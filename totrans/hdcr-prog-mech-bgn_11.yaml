- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DRAWING VECTOR IMAGES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: We’re about to start drawing images described by mathematical equations, a topic
    as fascinating as it is entertaining. We call images consisting of geometric primitives
    *vector images*, as opposed to *bitmap images*, which are sometimes also called
    *raster images*. Vector images are perfect for plotting the results of engineering
    problems that often come in the form of diagrams and simplified problem geometries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll create our own Python package capable of creating SVG
    images out of the geometric primitives we created in [Part II](part02.xhtml#part02)
    of the book: points, segments, circles, polygons, and so on. In later chapters,
    when we use code to solve actual mechanics problems, this package will help us
    produce graphical results.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: There are good SVG packages out there (such as *svgwrite*, for instance), and
    we could just import them, but this book is about learning by doing, so we won’t
    be using anything besides the Python Standard Library and our own code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, we won’t be writing unit tests in this chapter, but
    if you download the code, you’ll see I wrote them to make sure everything works
    as it should. I encourage you to try to write your own unit tests for functions
    in this chapter and then compare them to the code I provided.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce a powerful concept: *templating*. When templating,
    we have a piece of text, the *template*, that can be customized by filling in
    different placeholders. This technique is widely used in web development to produce
    the HTML document that gets rendered in your browser. Here again, there are many
    good templating libraries (such as *jinja2* or *mako*), but we want to learn how
    they work behind the scenes, so instead of using any of them, we’ll write our
    own templating logic.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitmaps and Vector Images**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of images: *bitmaps* and *vectors*. You’ve likely seen
    bitmap images before: *.jpeg*, *.gif*, and *.png* are all examples of bitmap image
    formats. A bitmap is an image defined over a grid of pixels where each individual
    pixel is assigned a particular color. These images look nice in their original
    size, but if you zoom in, you may start to distinguish those squares, the pixels.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Vector images, on the other hand, define their content by means of mathematical
    equations. This has the advantage of scaling smoothly without losing any quality.
    Let’s explore *.svg*, the most widely used vector image format and the one we’ll
    be using in this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**The SVG Format**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SVG stands for Scalable Vector Graphics. Its specification was developed by
    the *World Wide Web Consortium (W3C)* and is an open standard. I recommend that
    you open [*https://developer.mozilla.org/en-US/docs/Web/SVG*](https://developer.mozilla.org/en-US/docs/Web/SVG)
    and have it with you as a reference to look at; it’ll provide more complete descriptions
    and examples that can complement the ones in this book. If you ever need to add
    something new to your SVG package, this page will be your ally.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following definition from the Mozilla website mentioned above
    for a quick reference on how these kinds of images are defined, as it beautifully
    describes the process:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: SVG images and their related behaviors are defined in XML text files, which
    means they can be searched, indexed, scripted, and compressed. Additionally, this
    means they can be created and edited with any text editor and with drawing software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Note that SVG images are defined as plaintext, whereas most other image formats
    are binary encoded. This means we can readily automate the creation of SVG images
    and even inspect the contents of an existing image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter assumes you have a basic understanding of XML format, but if
    you don’t, don’t worry; it’s quite simple to learn. Check the following resources
    to get started with it:* [https://www.w3schools.com/xml](https://www.w3schools.com/xml)
    *and* [https://www.xmlfiles.com/xml](https://www.xmlfiles.com/xml).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to create our first SVG image. Open your favorite plaintext editor
    such as Sublime Text, Visual Studio Code, Atom, or even PyCharm if you want, and
    write [Listing 8-1](ch08.xhtml#ch8lis1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: SVG description of several circles*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Note that you shouldn’t create SVG files using a rich-text editor such as Word.
    These rich-text editors add their own markings into the raw file and break the
    SVG format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve copied what’s in [Listing 8-1](ch08.xhtml#ch8lis1), save the file
    as *circles.svg*, and open it using either Chrome or Firefox. Believe it or not,
    browsers are some of the best SVG image viewers. Using their *developer tools*,
    we can inspect the different parts that make up an image, something that will
    prove useful later when we build more complex images. You should see something
    like [Figure 8-1](ch08.xhtml#ch8fig1) (there’ll be colors on your screen, but
    the print version of the book is in grayscale). Zoom in on the image, and you’ll
    see how it retains its crispness.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Examples of SVG circles*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down the code in [Listing 8-1](ch08.xhtml#ch8lis1). The first and
    most cryptic line contains the *XML namespace* (xmln) attribute.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to include this namespace definition in every svg opening tag. The width
    and height attributes determine the size of the image in pixels. SVG *attributes*
    are modifiers that affect how a particular element is rendered. The width and
    height attributes, for example, determine the size of the drawing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, between the svg open and close tags is the actual definition of what
    is drawn, in this case three circles:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 svg 开始和结束标签之间是实际的绘制定义，在这种情况下是三个圆形：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you may have guessed, cx and cy correspond to the coordinates of the center
    point; r is the radius of the circle. The attribute fill determines the fill color
    for the circles in hexadecimal format: #rrggbbaa, where rr is the red value, gg
    is the green value, bb is the blue value, and aa is the alpha or opacity value
    (see [Figure 8-2](ch08.xhtml#ch8fig2)).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，cx 和 cy 对应的是圆心的坐标；r 是圆的半径。属性 fill 确定圆形的填充颜色，采用十六进制格式：#rrggbbaa，其中
    rr 是红色值，gg 是绿色值，bb 是蓝色值，aa 是 alpha 或透明度值（参见 [图 8-2](ch08.xhtml#ch8fig2)）。
- en: '![Image](../images/08fig02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig02.jpg)'
- en: '*Figure 8-2: Hexadecimal color components*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：十六进制颜色组件*'
- en: 'For example, the color #ff000077 has the following components:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，颜色 #ff000077 具有以下组成部分：'
- en: '**red**    ff, the maximum value (255 in base 10)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**红色**    ff，最大值（十进制中的 255）'
- en: '**green**    00, the minimum value (0 in base 10)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**绿色**    00，最小值（十进制中的 0）'
- en: '**blue**    00, the minimum value (0 in base 10)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝色**    00，最小值（十进制中的 0）'
- en: '**alpha**    77, a value of 119 out of 255, which equals an alpha percentage
    of around 47%'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**透明度**    77，255 中的 119，相当于约 47% 的透明度'
- en: This color is a perfect red with some transparency added to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种颜色是纯正的红色，并加入了一些透明度。
- en: 'You may not have realized, but the origin of coordinates for SVG images is
    located in the upper-left corner, with its y-axis pointing down. You may not be
    used to this orientation of the vertical axis, but don’t worry: by using one of
    our affine transformations, we can easily transform space so that the y-axis points
    upward, as you’ll see later in the chapter. [Figure 8-3](ch08.xhtml#ch8fig3) shows
    the geometry and arrangement of coordinates for the image we created.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有意识到，但 SVG 图像的坐标原点位于左上角，y 轴指向下方。你可能不习惯这种垂直轴的方向，但别担心：通过使用我们的仿射变换之一，我们可以轻松地将空间变换，使
    y 轴指向上方，正如你将在本章后面看到的那样。[图 8-3](ch08.xhtml#ch8fig3) 展示了我们创建的图像的几何形状和坐标布局。
- en: '![Image](../images/08fig03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig03.jpg)'
- en: '*Figure 8-3: The geometry of our first SVG image*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：我们第一个 SVG 图像的几何形状*'
- en: '***The viewBox***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***viewBox***'
- en: A useful attribute that we can define for the svg tag is the viewBox. The viewBox
    is the rectangular portion of the image the user sees. It’s defined using four
    numbers,
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 svg 标签定义的一个有用属性是 viewBox。viewBox 是用户看到的图像的矩形部分。它由四个数字定义，
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where x and y are the coordinates of the rectangle’s origin, and w and h are
    the width and height of the rectangle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 x 和 y 是矩形原点的坐标，w 和 h 是矩形的宽度和高度。
- en: Let’s add a viewBox to our circles image to see its effect (see [Listing 8-2](ch08.xhtml#ch8lis2)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给圆形图像添加一个 viewBox 来查看其效果（参见 [列表 8-2](ch08.xhtml#ch8lis2)）。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-2: SVG viewBox*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：SVG viewBox*'
- en: Save the changes we made in [Listing 8-2](ch08.xhtml#ch8lis2) and reload the
    image in the browser to see the change. To understand what’s happened, take a
    look at [Figure 8-4](ch08.xhtml#ch8fig4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们在 [列表 8-2](ch08.xhtml#ch8lis2) 中所做的更改，并在浏览器中重新加载图像以查看变化。要理解发生了什么，查看 [图 8-4](ch08.xhtml#ch8fig4)。
- en: 'We’ve defined a rectangle whose origin is at (100, 100), with a width of 300
    and a height of 300: a rectangle that contains all three circles without any margin.
    Notice the image retains its size of 500 by 500 pixels, as defined by the width
    and height attributes. If the size of the viewBox is not the same as the size
    of the SVG itself, the content is scaled.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个矩形，其原点在 (100, 100)，宽度为 300，高度为 300：一个包含所有三个圆形且没有任何边距的矩形。注意，图像保持其 500x500
    像素的大小，这是由 width 和 height 属性定义的。如果 viewBox 的大小与 SVG 本身的大小不同，内容会被缩放。
- en: '![Image](../images/08fig04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig04.jpg)'
- en: '*Figure 8-4: The *viewBox* of an SVG image*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：SVG 图像的 *viewBox*'
- en: The viewBox is therefore the rectangular portion from the infinite canvas that’s
    displayed to the user. It’s optional, and it defaults to the rectangle with the
    size defined by width and height, with its origin at (0, 0).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，viewBox 是从无限画布中显示给用户的矩形部分。它是可选的，默认为由宽度和高度定义的矩形，原点在 (0, 0)。
- en: '***Space Transformation***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***空间变换***'
- en: 'Remember the concept of affine transformations from [Chapter 7](ch07.xhtml#ch07)?
    SVG images use them to transform their content. The attribute transform can be
    used to define the affine transformation matrix as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The confusing order of the matrix terms may seem surprising at first, but it
    actually makes sense, at least for the people behind the SVG standard. The SVG
    documentation defines the affine transformation matrix as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0208-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'So these are the terms of the transform attribute:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Translated to our less cryptic language, the terms are *a* = *s*[*x*], *b*
    = *sh*[*y*], *c* = *sh*[*x*], *d* = *s*[*y*], *e* = *t*[*x*], and *f* = *t*[*y*]:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0208-02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Let’s see it in action. We’ll apply a shear in the x direction by setting *sh*[*x*]
    to be 1\. Remember that both *s*[*x*] and *s*[*y*] have to be 1; otherwise, if
    set as zero, the image would collapse in a line or point, and we wouldn’t see
    anything. [Listing 8-3](ch08.xhtml#ch8lis3) has the added transform attribute.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8-3: Shear transformation in circles image*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Remember to remove the viewBox attribute so the resulting geometry doesn’t get
    cropped. You should see something like [Figure 8-5](ch08.xhtml#ch8fig5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: Our circles once transformed*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'What about inverting the y-axis so that it points upward, like we’re used to?
    Easy! Edit the transform matrix to the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The resulting geometry you should see is outlined in [Figure 8-6](ch08.xhtml#ch8fig6).
    Compare it with [Figure 8-1](ch08.xhtml#ch8fig1). See what happened? The picture
    flipped vertically.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: Transformed circles, with the y-axis inverted*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of how to create SVG images, let’s do
    some Python coding. We’ll create a package in our project to draw SVG images.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**The svg Package**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s create a new package for graphics in our project, which will contain a
    subpackage to produce SVG images. Later in the book we’ll add other subpackages
    for other kinds of graphical operations. Right-click the project name in the **Project
    Tool** window and choose **New** ▸ **Python Package**. Name it *graphic*. You
    can also create a new folder yourself, but don’t forget to add the *__init__.py*
    file to instruct Python this is a package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have the package at the same level as *geom2d*, and it should contain
    only an *__init__.py* file. Your project’s directory structure should look like
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '|- graphic'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '|- utils'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s add the *svg* subpackage: right-click the package you just created
    and choose **New** ▸ **Python Package** again, but this time name it *svg*. Now
    we’re ready to start adding our code.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '***Templates***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A template is a document with some placeholders in it. By assigning values to
    these placeholders we can produce a complete version of the document. Think, for
    instance, about those email campaigns that greet you by your name. The company
    sending them probably has a template like
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一个包含占位符的文档。通过为这些占位符赋值，我们可以生成文档的完整版本。例如，想想那些通过你名字来问候你的邮件营销活动。发送这些邮件的公司可能有一个像这样的模板。
- en: Hello, {{name}}!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，{{name}}！
- en: Here are some book recommendations we think you may like.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们认为你可能喜欢的书籍推荐。
- en: '...'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: and an automatic process that substitutes the {{name}} placeholder with each
    of their clients’ names and then sends the final composed email.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 并且通过一个自动化过程，将 {{name}} 占位符替换为每个客户的名字，然后发送最终生成的邮件。
- en: The placeholders in a template may also be called *variables*. Variables are
    given values in the process of rendering the template, which produces the final
    document with everything defined in it. [Figure 8-7](ch08.xhtml#ch8fig7) illustrates
    the process of rendering the same template with two different sets of values.
    The template has the variables place-from, place-to, distance, and units, which
    we assign different values to produce different versions of the same template.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的占位符也可以称为 *变量*。在渲染模板的过程中，变量会被赋值，从而生成最终的文档，文档中包含了所有已定义的内容。[图 8-7](ch08.xhtml#ch8fig7)
    演示了使用两组不同值渲染相同模板的过程。模板中有变量 place-from、place-to、distance 和 units，我们为这些变量赋不同的值，生成相同模板的不同版本。
- en: '![Image](../images/08fig07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig07.jpg)'
- en: '*Figure 8-7: Template rendering process*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：模板渲染过程*'
- en: Using templates is a powerful technique that solves a variety of problems where
    text of any shape and format needs to be generated. Most web frameworks, for instance,
    use some kind of templating to produce the rendered HTML document. We’ll employ
    a template to generate our SVG images.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板是一种强大的技术，解决了需要生成任何形状和格式的文本的各种问题。例如，大多数 web 框架使用某种形式的模板来生成渲染后的 HTML 文档。我们将使用模板来生成我们的
    SVG 图像。
- en: '**An Example Using Python’s String Replacement**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Python 字符串替换的示例**'
- en: 'Let’s work on a template example in code. Open Python’s shell and enter the
    following template string:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中做一个模板示例。打开 Python 的 shell，并输入以下模板字符串：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s create a greeting by substituting the {{name}} variable with a real
    name:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过将 {{name}} 变量替换为真实名字来创建一个问候语：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we can use Python’s replace string method to create a new string
    where {{name}} has been replaced by ’Angel’. Since replace returns a new instance,
    we can chain the calls like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以使用 Python 的 replace 字符串方法来创建一个新的字符串，其中 {{name}} 已被 'Angel' 替换。由于 replace
    返回一个新的实例，我们可以像这样链式调用：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we first replaced the {{name}} variable with the string ’Angel’.
    Then, we called the replace method on the resulting string to substitute the word
    ’Hello’ with ’Hi there’.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先将 {{name}} 变量替换为字符串 'Angel'。然后，我们在结果字符串上调用 replace 方法，将单词 'Hello'
    替换为 'Hi there'。
- en: 'Note that we can substitute whatever sequence of characters we want using the
    replace method; there’s no need for our replacement targets to appear between
    braces, like for instance we did with {{name}}. Using the double braces is a convention
    for us to quickly identify a variable inside a template. This convention also
    serves the purpose of preventing unwanted replacements: it’s unlikely that our
    templates include anything inside two levels of braces, except for our variables.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以使用 replace 方法替换任何我们想要的字符序列；无需让我们的替换目标出现在大括号中，就像我们之前用 {{name}} 那样。使用双大括号是一种约定，用于帮助我们快速识别模板中的变量。这个约定也有助于防止不必要的替换：我们的模板中不太可能包含两个大括号之间的任何内容，除非是我们的变量。
- en: Now that we know how to work with template strings in Python, let’s see how
    we can define templates in separate files and load them into strings in our code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 Python 中使用模板字符串，让我们看看如何在单独的文件中定义模板，并将其加载到代码中的字符串中。
- en: '***Loading Templates***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载模板***'
- en: 'To avoid mixing XML and Python code, we want to separate the definitions of
    SVG tags into their own files. The files containing the XML need to have placeholders
    where the actual data will be inserted. For example, our circle definition file
    could look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混合 XML 和 Python 代码，我们希望将 SVG 标签的定义分离到各自的文件中。包含 XML 的文件需要有占位符，以便插入实际数据。例如，我们的圆形定义文件可能如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we’ve put placeholders using double braces. We’ll use code to load this
    definition into a string and replace the placeholders with the actual coordinates
    of the center and the radius of the circle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了双大括号来放置占位符。我们将使用代码将此定义加载到一个字符串中，并将占位符替换为圆心的实际坐标和半径。
- en: We’ll be creating a few templates, so let’s create a folder named *templates*
    inside the *svg* package by right-clicking the package name and choosing **New**
    ▸ **Directory**. We need a function that reads the templates inside this folder
    by their name and returns their content as a string. In the *svg* package, but
    not in the *templates* folder, create a new file named *read.py* and add the code
    in [Listing 8-4](ch08.xhtml#ch8lis4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建几个模板，因此让我们在*svg*包内创建一个名为*templates*的文件夹，通过右键单击包名并选择**新建** ▸ **目录**。我们需要一个函数，它可以根据名称读取此文件夹中的模板并将其内容作为字符串返回。在*svg*包中，但不在*templates*文件夹内，创建一个名为*read.py*的新文件，并添加[列表
    8-4](ch08.xhtml#ch8lis4)中的代码。
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-4: Reading the content of a template file*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-4：读取模板文件的内容*'
- en: Let’s break [Listing 8-4](ch08.xhtml#ch8lis4) down. The first thing we do in
    the function is obtain the path inside *templates* where the file lives. We do
    this using the os.path module’s join function. This function computes the path
    by joining the parts passed as arguments and using the correct separator for your
    operating system. For instance, Unix-based operating systems use the / character.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下[列表 8-4](ch08.xhtml#ch8lis4)。函数中首先要做的事情是获取*templates*文件夹内文件的路径。我们通过使用os.path模块的join函数来实现这一点。此函数通过连接作为参数传递的各部分并使用适合操作系统的分隔符来计算路径。例如，基于Unix的操作系统使用/字符。
- en: Then, using resource_string from the *pkg_resources* module, we read the file
    as a *byte string*. A file is stored to disk as a sequence of bytes, so when we
    read it using the resource_string function, we get this byte string. To convert
    it to a Unicode character string, we need to *decode* it. For this, byte strings
    have the method decode, which accepts the encoding as an argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用*pkg_resources*模块中的resource_string，我们将文件作为*字节字符串*读取。文件以字节序列存储到磁盘中，因此当我们使用resource_string函数读取它时，得到的是字节字符串。为了将其转换为Unicode字符字符串，我们需要对其进行*解码*。为此，字节字符串具有decode方法，该方法接受编码作为参数。
- en: We return the result of decoding the string of bytes using UTF-8 encoding. This
    will give us a string version of the template we can easily work with.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回使用UTF-8编码解码字节字符串的结果。这将给我们一个字符串版本的模板，便于操作。
- en: '***Image Templates***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***图像模板***'
- en: The most important template we want to define is the template for the SVG image.
    Create a new text file named *img* (without an extension; we don’t need one) in
    the *templates* folder and include the definition in [Listing 8-5](ch08.xhtml#ch8lis5).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要定义的最重要的模板是SVG图像的模板。在*templates*文件夹中创建一个新的文本文件，命名为*img*（不带扩展名；我们不需要扩展名），并在其中包含[列表
    8-5](ch08.xhtml#ch8lis5)中的定义。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 8-5: SVG image template*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：SVG 图像模板*'
- en: 'This template includes five placeholders that need to be replaced with the
    actual values from the resulting image. We can try to load the template in Python’s
    shell using the read_template function we defined earlier:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板包括五个占位符，需要用实际的图像值进行替换。我们可以尝试使用之前定义的read_template函数，在Python的shell中加载模板：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s create a new file *image.py* in the *svg* directory (but outside the *templates*
    folder!) and define a function that reads in the file and does the replacement.
    In your *image.py* file, enter the code in [Listing 8-6](ch08.xhtml#ch8lis6).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*svg*目录中（但在*templates*文件夹外）创建一个新的文件*image.py*，并定义一个函数，该函数读取文件并进行替换。在你的*image.py*文件中，输入[列表
    8-6](ch08.xhtml#ch8lis6)中的代码。
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-6: SVG image*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6：SVG 图像*'
- en: The svg_content function takes four parameters; the last two, viewbox_rect and
    transform, are given a default value of None. We can use or so that viewbox _rect
    keeps its value if it’s not None and otherwise gets a default instance created
    by __default_viewbox_rect ➊ (we’ll write this function next). We do the same with
    transform ➋, using an affine transformation constructed with the default values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: svg_content函数有四个参数；最后两个参数viewbox_rect和transform的默认值为None。我们可以使用“或”操作符，这样当viewbox_rect不是None时，它保持其值，否则将由__default_viewbox_rect
    ➊（我们接下来将编写此函数）创建一个默认实例。我们对transform ➋做同样的处理，使用默认值构造一个仿射变换。
- en: Then, using the function we prepared in the previous section, we load the template
    stored in *templates/img* ➌.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们在前一节准备的函数，我们加载存储在*templates/img*中的模板 ➌。
- en: The last and most important step is to replace all placeholders in the loaded
    template string with the values we’ve been passed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个也是最重要的步骤是将加载的模板字符串中的所有占位符替换为我们传入的值。
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One nice property of strings in Python, as in most programming languages,
    is that they’re immutable; you can’t take a string and change a character in it.
    What you do instead is create a new string with the desired change. This is how
    the* replace *string method works: it replaces a given sequence of characters
    with another and returns a new string with the result. Thanks to this nice property,
    we can beautifully chain several* replace *calls to the result of the call to*
    read_template.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 中字符串的一个优点，与大多数编程语言类似，是它们是不可变的；你不能直接修改字符串中的某个字符。相反，你需要创建一个包含所需更改的新字符串。这就是*
    replace *字符串方法的工作原理：它将给定的字符序列替换为另一个序列，并返回一个新的字符串作为结果。得益于这个特性，我们可以漂亮地链式调用多个* replace
    *来处理对* read_template* 方法的结果。*'
- en: The replacements for the {{width}} and {{height}} placeholders are straightforward;
    just keep in mind that the passed-in size.width and size.height properties are
    numbers, so we need to convert them to their string representation using str.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '{{width}} 和 {{height}} 占位符的替换非常直接；只需记住，传入的 size.width 和 size.height 属性是数字，因此我们需要使用
    str 将它们转换为字符串表示。'
- en: The primitives parameter contains a sequence of strings representing the content
    of the image. We need to collect these strings in a single string. The join string
    method joins all the elements in a list together into a single string using the
    string it was called on as a separator. To obtain a string including all the primitives,
    we’ll use join ➍ on the list, with a new line and a tab character (\n\t) as the
    separator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: primitives 参数包含了一系列字符串，这些字符串代表了图像的内容。我们需要将这些字符串收集到一个单独的字符串中。join 字符串方法将列表中的所有元素连接成一个单一的字符串，并以它被调用时的字符串作为分隔符。为了获取包含所有
    primitives 的字符串，我们将使用 join ➍ 方法对列表进行操作，并以换行符和制表符（\n\t）作为分隔符。
- en: For viewBox we need to convert the Rect instance into the four numbers that
    define it ➎; this is done with __viewbox_from_rect, which we’ll define in a minute.
    The same goes for transf ➏.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 viewBox，我们需要将 Rect 实例转换为定义它的四个数字 ➎；这通过 __viewbox_from_rect 实现，我们稍后将定义它。transf
    ➏ 的处理方式也是如此。
- en: Let’s write the missing helping functions after svg_content. The code is in
    [Listing 8-7](ch08.xhtml#ch8lis7).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 svg_content 后编写缺失的辅助函数。代码见 [列表 8-7](ch08.xhtml#ch8lis7)。
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 8-7: SVG image helper functions*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：SVG 图像辅助函数*'
- en: The first function (__default_viewbox_rect) creates a rectangle for the viewBox
    using the point (0, 0) as the origin and the provided size. This function, as
    its name indicates, is used to provide a default value for the viewbox _rect parameter
    in case it wasn’t given by the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 (__default_viewbox_rect) 使用点 (0, 0) 作为原点和提供的尺寸来创建一个矩形用于 viewBox。正如它的名字所示，这个函数用于提供
    viewbox _rect 参数的默认值，以防用户没有提供。
- en: 'The __viewbox_from_rect function returns a string formatted to be used as viewBox
    inside the SVG definition. The last function, __transf_matrix_vals, does something
    similar: it converts an affine transformation into a string with the format expected
    by SVG.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: __viewbox_from_rect 函数返回一个格式化字符串，可以用作 SVG 定义中的 viewBox。最后一个函数 __transf_matrix_vals
    做的事情类似：它将一个仿射变换转换为 SVG 期望的字符串格式。
- en: Great! We now have a function that renders the SVG template into a string. Let’s
    take a look at some attributes we’ll add to almost all primitives.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！我们现在有了一个函数，可以将 SVG 模板渲染为一个字符串。接下来，让我们看一下我们将添加到几乎所有图形元素中的一些属性。
- en: '***Attributes***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***属性***'
- en: 'The appearance of SVG elements can be modified using *attributes*. SVG attributes
    are defined following the XML attribute syntax (don’t forget that SVG images are
    defined following the XML format):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 *属性* 来修改 SVG 元素的外观。SVG 属性是按照 XML 属性语法定义的（别忘了 SVG 图像是按照 XML 格式定义的）：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, we can use the stroke attribute to set a primitive’s stroke color:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 stroke 属性来设置图形的描边颜色：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that, in the previous example, the circle’s center coordinates (cx and
    cy) and radius (r) are also defined as attributes in the circle SVG element.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，圆形的中心坐标（cx 和 cy）以及半径（r）也作为属性定义在圆形的 SVG 元素中。
- en: As we’re about to see, many SVG geometry primitives have shared attributes to
    define things such as the color of their stroke, the stroke’s width, the fill
    color, etc. To reuse this logic, we’ll place it in a file that all primitive generation
    functions will use. As these attribute definitions are short, we won’t include
    them in templates that need to be loaded; instead, we’ll define them inside the
    function that replaces the placeholders.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named *attributes.py* inside the *svg* directory. Your *graphic/svg*
    folder should look like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: svg
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '|- templates'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- img'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '|- attributes.py'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '|- image.py'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '|- read.py'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Enter the functions in [Listing 8-8](ch08.xhtml#ch8lis8).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-8: SVG attributes*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: All the functions are quite straightforward; they receive a value and return
    a string with the definition of an SVG attribute. We use single quotes around
    the returned strings, and this allows us to use double quotes inside without the
    need of escaping them. The SVG attributes are defined using double quotes, like,
    for example, stroke="blue".
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function takes some attributes and joins them into a string separating
    them with spaces. We achieve this using a single space (’ ’) as a separator for
    the join function. To fully understand how this works, give this a try in the
    shell:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**The SVG Primitives**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve written the foundations of our *svg* package; we can now produce empty
    images, a process that involves reading the *img* template and replacing its variables.
    If we called our svg_content function from Python’s shell,
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'we’d get the following SVG content:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s a great beginning, but who wants blank images?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next sections, we’ll create a couple basic SVG primitives to add between
    the <svg></svg> tags: lines, rectangles, circles, polygons, and text labels, to
    name a few. As we’ll see throughout the book, we don’t need a lot of primitives
    to draw our engineering drawings; we can get pretty far with only straight lines,
    circles, and rectangles.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy we’ll follow to produce these SVG primitives is the same we used
    for the SVG content: we’ll use a template to define the SVG code with variables
    that we’ll replace inside a function.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***Lines***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first primitive we’ll implement in our *svg* package is the line segment,
    or line in SVG parlance. This may be a little unfortunate, as segments and lines
    are different concepts. (Recall that lines are infinite, but segments are not;
    they have a finite length.) At any rate, we’ll use the SVG terminology here, so
    let’s create a new template file named *line* inside the *templates* folder and
    add the code in [Listing 8-9](ch08.xhtml#ch8lis9):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-9: Line template*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The template for a line is simple. The placeholders define the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: x1 and y1, the coordinates of the start point
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x2 and y2, the coordinates of the end point
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: attrs, where the attributes will be inserted
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 8-8](ch08.xhtml#ch8fig8) depicts the line with its attributes using
    the default coordinate system for SVG images.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig08.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: An example of an SVG line*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now create a function that reads the template and inserts the values of
    a segment. We need a new file; let’s create it inside *svg* with the name *primitives.py*.
    Enter the function in [Listing 8-10](ch08.xhtml#ch8lis10).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-10: SVG line*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note is that the parameter attributes has a default value of (),
    that is, an empty tuple. We could have also used an empty list [] as the default
    for the parameter, but there’s an important difference between those two options:
    tuples are immutable, and lists are mutable. Function default arguments are evaluated
    only once when the file is loaded into the interpreter, so if a mutable default
    parameter is mutated, all subsequent calls to the same function would get the
    mutated value as the default, and that’s something we want to avoid.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the shell, try the code below to create an SVG line in order to see the result
    and make sure that all placeholders are properly replaced.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This line inside an SVG file would be drawn as in [Figure 8-9](ch08.xhtml#ch8fig9).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig09.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: SVG line*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind the arrows and position captions are added in this figure for clarity
    but won’t appear in the image itself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '***Rectangles***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our next primitive is the rectangle, so inside *templates* create a new file
    named *rect* (remember, we’re not using any extension in our template files) with
    the definition shown in [Listing 8-11](ch08.xhtml#ch8lis11):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-11: The rectangle template*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: You can write the template in a single line; here we used several lines because
    in the print version, the code didn’t fit in just one. The attributes that define
    a rectangle are, as expected, the coordinates of the origin x and y and its size
    given by width and height. In *primitives.py*, add the function in [Listing 8-12](ch08.xhtml#ch8lis12).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-12: SVG rectangle*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'To gain a better understanding of the attributes that define a rectangle in
    the SVG format, take a look at [Figure 8-10](ch08.xhtml#ch8fig10). The figure
    uses the default coordinate system from SVG: the y-axis pointing downward. This
    is why the origin of the rectangle is the upper-left corner. If we were using
    a coordinate system whose y-axis pointed upward, the origin would be the lower-left
    corner.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: An example of an SVG rectangle*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Give it a try in the shell, as we did with the segment, to check that all placeholders
    are properly replaced:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It’s a good idea to check that everything works as expected, since later in
    the book we’ll be creating lots of diagrams using these simple primitives. Unit
    testing is the best option, much better than testing manually in the shell. If
    you downloaded the code for the book, you’ll see all these primitive rendering
    functions are covered by tests. Try to write them yourself so you get used to
    writing unit tests and then compare them to the ones that I’ve provided you.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '***Circles***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll take a similar approach to rectangles to create circles. Create the template
    in a file named *circle* (see [Listing 8-13](ch08.xhtml#ch8lis13)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-13: The circle template*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Then add the function to render the circle inside *primitives.py* (see [Listing
    8-14](ch08.xhtml#ch8lis14)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-14: SVG circle*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Nothing unexpected here! You can take a look at [Figure 8-11](ch08.xhtml#ch8fig11)
    to see the attributes we used to define the circle in the SVG format.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig11.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: An example of an SVG circle*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a try in the shell:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***Polygons***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Polygons are simple to define; we simply need to provide the list of vertex
    coordinates formatted in a specific way. Create the template file *polygon* in
    *templates* (see [Listing 8-15](ch08.xhtml#ch8lis15)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 8-15: The polygon template*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Then inside *primitives.py* include the function in [Listing 8-16](ch08.xhtml#ch8lis16).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 8-16: SVG polygon*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The placeholder {{points}} is replaced with the result of applying __format_points
    to the list of vertices. Let’s write that function here, inside the *primitives.py*
    file (see [Listing 8-16](ch08.xhtml#ch8lis16)):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 8-17: Format points*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the list of vertices is converted into a string where each vertex
    is separated by a space,
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'and the two coordinates, x and y, are separated with a comma:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For example, a polygon with vertices (1, 2), (5, 6), and (8, 9) would result
    in the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***Polylines***'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Polylines* are defined the same way as polygons—the only difference is that
    the last vertex isn’t connected with the first one. Create the template in a file
    named *polyline* in *templates* (see [Listing 8-18](ch08.xhtml#ch8lis18)).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 8-18: The polyline template*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Include the rendering function inside file *primitives.py* (see [Listing 8-19](ch08.xhtml#ch8lis19)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 8-19: SVG polyline*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Again, no surprises here. [Figure 8-12](ch08.xhtml#ch8fig12) shows the difference
    between a polygon and a polyline. The definition for both is the same; the only
    difference is that last segment connecting vertex (*x*[4], *y*[4]) back to (*x*[1],
    *y*[1]) appears only in the case of a polygon.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig12.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-12: An SVG polygon and polyline*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a polygon and a polyline in the shell to see the results:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Both the polygon and the polyline have the same sequence of points, but in an
    SVG image, the polygon will have a segment connecting the first and last vertices,
    whereas the polyline will remain open.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '***Text***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our diagrams will contain captions (like the structural analysis result diagrams
    in [Chapter 18](ch18.xhtml#ch18)), so we need to be able to include text in our
    images. Create a new template file named *text* in folder *templates* with the
    code in [Listing 8-20](ch08.xhtml#ch8lis20).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 8-20: The text template*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The placeholder {{text}} has to be between the open and close tags <text> and
    </text>; this is where the actual text will be inserted. The attributes x and
    y define the position where the text will be located; then dx and dy displace
    that original position. We’ll find this displacement handy when, for instance,
    we want to add the coordinates of a point next to it. We can choose the position
    of the point itself as the base, which we then displace a given amount so that
    the text and the drawing of the point don’t overlap.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'In *primitives.py* add the function shown in [Listing 8-21](ch08.xhtml#ch8lis21)
    to render text:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 8-21: SVG text*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a try in the shell:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we format the result string, the result is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***Groups***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Oftentimes we want to group a bunch of elements so we can add a common attribute
    to all of them, such as an affine transformation or fill color. This is what groups
    are for. They’re nothing to be rendered by themselves, but they group a bunch
    of primitives in a neat way. Create the file *group* inside the *templates* folder
    (see [Listing 8-22](ch08.xhtml#ch8lis22)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 8-22: The group template*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: To render the group, we’ll add the function shown in [Listing 8-23](ch08.xhtml#ch8lis23)
    to file *primitives.py*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 8-23: SVG group*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: This time, all primitives passed as a sequence are joined into a string separated
    by line breaks (\n). This is so that each primitive is inserted in a new line,
    which will make the file easier to read.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '***Arrows***'
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we’re going to add a different primitive, one that’s built
    not by loading and rendering a template but by using other primitives: an arrow.
    In [Chapter 18](ch18.xhtml#ch18), when we draw structure diagrams, we’ll use arrows
    to represent forces, so this is a good moment to implement them.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The arrow consists of a line segment with a small triangle at one of its ends,
    the arrow’s head (see [Figure 8-13](ch08.xhtml#ch8fig13)).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig13.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-13: An SVG arrow*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing the arrow’s segment is simple: we just need a line segment. Drawing
    the head is a bit more involved, because it needs to always be aligned with the
    segment. Using a bit of elementary geometry we can figure out the points that
    define the arrow’s head. Take a look at [Figure 8-14](ch08.xhtml#ch8fig14).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig14.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-14: Key points in an arrow*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Our arrow’s head is a triangle defined between points *C*[1], *E* (the segment’s
    end point), and *C*[2]. The size of the arrow is given by a length and a height,
    sizes that we’ll use to locate the *C*[1] and *C*[2] points.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The figure uses three vectors to position these two points.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/vlvictorit.jpg)    This is a vector in the direction opposite
    to the segment’s direction vector and is the same length as the arrow.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/vh1victorit.jpg)    This is a vector perpendicular to the
    segment, and the length is half the arrow’s head height.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/vh2victorit.jpg)    This is similar to ![Image](../images/vh1victorit.jpg),
    but in the opposite direction.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these vectors, we can now compute the points as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00227-p1.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: and
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00227-p2.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: Without further ado, let’s write the code to draw arrows. Inside *primitives.py*,
    enter the code in [Listing 8-24](ch08.xhtml#ch8lis24).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 8-24: SVG arrow*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We’ve defined the arrow function that accepts as parameters a segment, the length
    and height of the arrow, and the SVG attributes. Note that the _segment parameter
    starts with an underscore. This is to avoid a clash with the file’s segment function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In this function we first store the segment’s director vector in the variable
    director. We then compute the ![Image](../images/vlvictorit.jpg) vector taking
    director’s opposite vector scaled to the passed-in length ➊. The ![Image](../images/vh1victorit.jpg)
    vector is obtained by taking director’s perpendicular vector scaled to the arrow’s
    half-height ➋. Then, ![Image](../images/vh2victorit.jpg) is simply the opposite
    of it ➌.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The function returns an SVG group including the arrow’s segment ➍ and a polyline
    ➎. This polyline defines the arrow’s head using the three points we discussed
    earlier.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The first point, *C*[1], is computed by displacing the segment’s end point by
    the result of adding vectors ![Image](../images/vlvictorit.jpg) and ![Image](../images/vh1victorit.jpg).
    Then comes the segment’s end point. Lastly comes *C*[2], resulting from the displacement
    of the segment’s end point by a vector that’s the result of adding ![Image](../images/vlvictorit.jpg)
    and ![Image](../images/vh2victorit.jpg).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitives Result**'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve added a few functions to our *primitives.py* file. If you followed along,
    your file should look similar to [Listing 8-25](ch08.xhtml#ch8lis25).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 8-25: SVG primitives result*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: We have everything we need to start drawing images. In the next chapter, we’ll
    use our *svg* package to plot the result of a geometrical problem. But first,
    let’s provide a convenient way of importing the contents of this package.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Imports**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to what we did with the *geom2d* package, we want to give the option
    of importing everything from *svg* with a single import line:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The only thing we have to do is import all relevant modules inside the *svg*
    package’s *__init__.py* file file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Summary**'
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graphics are key to engineering applications. Many involve creating diagrams
    made of simple geometric primitives such as segments and rectangles. We created
    a geometry package in [Part II](part02.xhtml#part02) of this book; in this chapter,
    we learned how to turn those primitives into vector images.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We started with a quick introduction to the SVG format and saw how easy it is
    to create SVG images using just a few lines of XML data. We then learned about
    templates, extensionless plaintext files that define the SVG structure using placeholders.
    The placeholders, which have the form of {{name}}, are replaced by concrete data
    using code. Templates are widely used, and there are some complex packages for
    rendering templates. Our use case was pretty simple, so we did the replacement
    using the replace method from Python strings.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we created functions to obtain the SVG representation for our geometric
    primitives: line segments, circles, rectangles, and polygons. From now on, creating
    vector diagrams should be straightforward, something that we’ll prove in the next
    chapter.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
