<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_285"/><strong><span class="big">14</span><br/>MAPPING MARS WITH THE MARS ORBITER</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">The <em>Mars Orbiter</em> space probe has been successfully injected into Martian orbit, but all is not well. The orbit is highly elliptical, and the project’s mapping objectives require a low-altitude circular orbit. Fortunately, there’s just enough propellant on board to correct things, assuming the eggheads at Mission Control have the patience and skill to pull it off!</p>
<p class="indent">In this chapter, you’ll design and build a game based on this scenario. You’ll use <code>pygame</code> again (for an overview of <code>pygame</code>, see “<a href="ch13.xhtml#lev296">A Slice of <code>pygame</code></a>” on <a href="ch13.xhtml#page_267">page 267</a>), and you’ll do your part to advance STEM (science, technology, engineering, and mathematics) education by making the game real enough to teach players the fundamentals of orbital mechanics.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_286"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Although they share the same name, the</em> Mars Orbiter <em>space probe in the game bears no direct relationship to the</em> Mars Orbiter Mission <em>launched by the</em> Indian Space Research Organization (ISRO) <em>in 2014. The game probe is patterned after the</em> Mars Global Surveyor<em>, launched by NASA in 1996.</em></p>
</div>
<h3 class="h3" id="lev315"><strong>Astrodynamics for Gamers</strong></h3>
<p class="noindent">Because you’ll want your game to be as realistic as possible, a quick review of some of the basic science underlying spaceflight is in order. This will be short, sweet, and tailored to game development and play.</p>
<h4 class="h4" id="lev316"><strong><em>The Law of Universal Gravity</em></strong></h4>
<p class="noindent">The theory of gravity states that massive objects—like stars and planets—warp both space and time around them, similar to how a heavy bowling ball placed on a mattress causes a depression that is sudden and sharp near the ball but quickly levels off. This behavior is captured mathematically by Isaac Newton’s law of universal gravitation:</p>
<div class="imagec"><img src="../images/f0286-01.jpg" alt="image"/></div>
<p class="noindent">where <em>F</em> is the force of gravity, <em>m</em><sub>1</sub> is the mass of object 1, <em>m</em><sub>2</sub> is the mass of object 2, <em>d</em> is the distance between objects, and <em>G</em> is the gravitational constant (6.674 × 10<sup>–11</sup> <em>N</em> · <em>m</em><sup>2</sup> · kg<sup>–2</sup>).</p>
<p class="indent">Two objects pull on each other according to the product of their masses divided by the square of the distance between them. So, gravity is much stronger when objects are close together, like the deep bowing of the mattress just beneath the bowling ball. To illustrate, a 220-pound (100 kg) man would weigh over half a pound less on top of Mt. Everest than he would at sea level, where he would be 8,848 m closer to the center of Earth. (This assumes the mass of the planet is 5.98 × 10<sup>24</sup> kg and sea level is 6.37 × 10<sup>6</sup> m from the center.)</p>
<p class="indent">Today, we generally think of gravity as a <em>field</em>—like the mattress in the bowling ball analogy—rather than as Newton’s point of attraction. This field is still defined with Newton’s law and results in <em>acceleration</em>, usually expressed in m/sec<sup>2</sup>.</p>
<p class="indent">According to Newton’s second law of motion, force is equal to mass × acceleration. You can calculate the force exerted by object 1 (<em>m</em><sub>1</sub>) on object 2 (<em>m</em><sub>2</sub>) by rewriting the gravitational equation as:</p>
<div class="imagec"><img src="../images/f0286-02.jpg" alt="image"/></div>
<p class="noindent">where <em>a</em> = acceleration, <em>G</em> is the gravitational constant, <em>m</em><sub>1</sub> is the mass of one of the objects, and <em>d</em> is the distance between objects. The direction of force is from object 2 toward the center of mass of object 1 (<em>m</em><sub>1</sub>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_287"/>The pull of very small objects on large ones is generally ignored. For example, the force exerted by a 1,000 kg satellite on Mars is about 1.6 × 10<sup>–21</sup> times smaller than the force exerted by Mars on the satellite! Thus, you can safely ignore the satellite’s mass in your simulation.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>As a simplification in this project, distance is calculated from the center points of objects. In real life, an orbiting satellite would experience subtle changes in gravitational acceleration due to changes in a planet’s shape, topography, crustal density, and so on. According to the</em> Encyclopedia Britannica<em>, these changes cause gravitational acceleration at Earth’s surface to vary by about 0.5 percent.</em></p>
</div>
<h4 class="h4" id="lev317"><strong><em>Kepler’s Laws of Planetary Motion</em></strong></h4>
<p class="noindent">In 1609, astronomer Johann Kepler discovered that planetary orbits are ellipses, allowing him to explain and predict the motion of the planets. He also found that a line segment drawn between the sun and an orbiting planet sweeps out equal areas in equal time intervals. This idea, known as Kepler’s second law of planetary motion, is demonstrated in <a href="ch14.xhtml#ch14fig1">Figure 14-1</a>, where a planet is shown at different points in its orbit.</p>
<div class="image"><a id="ch14fig1"/><img src="../images/f0287-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-1: Kepler’s second law of planetary motion: orbital speed increases as planets near the sun.</em></p>
<p class="indent">This law applies to all celestial bodies, and it means that an orbiting object speeds up as it gets close to the body it is orbiting and slows down as it travels farther away.</p>
<h4 class="h4" id="lev318"><span epub:type="pagebreak" id="page_288"/><strong><em>Orbital Mechanics</em></strong></h4>
<p class="noindent">Orbiting is basically free-falling forever. You’re falling into the core of a planet’s gravity well—located at its literal core—but your tangential velocity is fast enough that you keep missing the planet (see <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>). As long as you balance your momentum with the force of gravity, the orbit will never end.</p>
<div class="image"><a id="ch14fig2"/><img src="../images/f0288-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-2: Orbit is achieved when a spacecraft’s velocity keeps it “free-falling” around a celestial body.</em></p>
<p class="indent">Some counterintuitive things can happen when you orbit a planet in the vacuum of space. With no friction or wind resistance, spacecraft can behave in unexpected ways.</p>
<h5 class="h5" id="lev319"><strong>Flying Backward</strong></h5>
<p class="noindent">If you’ve ever watched an episode of <em>Star Trek</em>, you’ve probably noticed how the orbiting <em>Enterprise</em> seems to steer its way around planets, like a car going around a track. This is certainly possible to do—and definitely looks cool—but it requires the expenditure of precious fuel. If there’s no need to continuously point a specific part of a spacecraft at a planet, then the nose of the spacecraft will always point in the same direction throughout its orbit. As a result, there will be times in each orbit when it appears to fly backward (see <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>).</p>
<div class="image"><a id="ch14fig3"/><img src="../images/f0288-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-3: Spacecraft retain the same attitude in orbit unless forced to do otherwise.</em></p>
<p class="indent">You can blame this on Newton and his law of inertia, which states that an object at rest stays at rest and an object in motion stays in motion with the same speed and in the same direction unless acted upon by an unbalanced force.</p>
<h5 class="h5" id="lev320"><strong>Raising and Lowering Orbits</strong></h5>
<p class="noindent">Brakes don’t work in space, there’s no friction, and inertia takes itself very seriously. To lower a spacecraft’s orbit, you have to fire thrusters to reduce its velocity so that it falls farther into a planet’s gravity well. To accomplish this, you have to <em>retrograde</em> your spacecraft so that its nose faces away from the present velocity vector—a fancy way of saying you have to fly tail-first. This assumes, of course, that the main thrusters are at the back of the spacecraft. Conversely, if you want to raise the orbit, you have to <em>prograde</em> the spacecraft, so that its nose will be pointed in the direction you are traveling. These two concepts are shown in <a href="ch14.xhtml#ch14fig4">Figure 14-4</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_289"/><a id="ch14fig4"/><img src="../images/f0289-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-4: Prograde and retrograde are defined by the orientation of a spacecraft’s nose with respect to the direction it is traveling around the body it is orbiting.</em></p>
<h5 class="h5" id="lev321"><strong>Taking the Inside Track</strong></h5>
<p class="noindent">If you’re chasing another spacecraft in orbit, do you speed up or slow down to catch it? According to Kepler’s second law, you slow down. This will lower your orbit, resulting in a faster orbital velocity. Just as in horse racing, you want to take the inside track.</p>
<p class="indent">On the left side of <a href="ch14.xhtml#ch14fig5">Figure 14-5</a>, two space shuttles are side by side in essentially the same orbit, traveling at the same velocity.</p>
<div class="image"><a id="ch14fig5"/><img src="../images/f0289-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-5: The orbital paradox: slow down to speed up!</em></p>
<p class="indent">The shuttle closest to the planet rotates 180 degrees and does a retrograde thrust to slow its immediate velocity. The outer shuttle performs a prograde thrust that increases its immediate velocity. They simultaneously stop thrusting, and the inner shuttle drops to a lower orbit while the outer shuttle transfers to a higher orbit. After an hour or so, the inner shuttle is traveling much faster, due to its closer proximity to the planet, and is well on its way to catch and lap the outer shuttle.</p>
<h5 class="h5" id="lev322"><span epub:type="pagebreak" id="page_290"/><strong>Circularizing an Elliptical Orbit</strong></h5>
<p class="noindent">You can make highly elliptical orbits circular by applying engine impulses at either the <em>apoapsis</em> or <em>periapsis</em>, depending on the situation. The apoapsis (called the <em>apogee</em> if the object is orbiting Earth) is the highest point in an elliptical orbit—the point where the object is the farthest away from the body it is orbiting (<a href="ch14.xhtml#ch14fig6">Figure 14-6</a>). The periapsis (<em>perigee</em> if the object’s orbiting Earth) is the point lowest in an orbit.</p>
<div class="image"><a id="ch14fig6"/><img src="../images/f0290-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-6: Location of the apoapsis and periapsis in an elliptical orbit</em></p>
<p class="indent">To raise the periapsis, the spacecraft performs a prograde thrust at the apoapsis (see the left-hand side of <a href="ch14.xhtml#ch14fig7">Figure 14-7</a>). To lower the orbit while circularizing, the spacecraft must perform a retrograde thrust at the periapsis (see the right-hand side of <a href="ch14.xhtml#ch14fig7">Figure 14-7</a>).</p>
<p class="indent">A somewhat counterintuitive part of this maneuver is that the initial orbit—that’s the orbit that would have been—and the final, or actual, orbit will coincide at the point the engine impulse was applied.</p>
<div class="image"><a id="ch14fig7"/><img src="../images/f0290-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-7: Circularizing and raising an orbit at apoapsis (left) and circularizing and lowering an orbit at periapsis (right)</em></p>
<h5 class="h5" id="lev323"><span epub:type="pagebreak" id="page_291"/><strong>Raising and Lowering Orbits with the Hohmann Transfer</strong></h5>
<p class="noindent">A <em>Hohmann transfer orbit</em> uses an elliptical orbit to switch between two circular orbits in the same plane (see <a href="ch14.xhtml#ch14fig8">Figure 14-8</a>). The orbit can be either raised or lowered. The maneuver is relatively slow, but it consumes the least possible amount of fuel.</p>
<p class="indent">To change to an orbit with both a different periapsis <em>and</em> apoapsis, a spacecraft requires two engine impulses. One impulse moves the spacecraft onto the transfer orbit, and another moves it onto the final, destination orbit. When raising an orbit, the spacecraft applies the change in velocity in the direction of motion, and when lowering an orbit, it applies the change of velocity opposite to the direction of motion. The velocity changes have to occur at opposite sides of the orbit, as shown in <a href="ch14.xhtml#ch14fig8">Figure 14-8</a>. Without the second thrust, the orbits will still intersect at the point of the first thrust, as shown on the right side of <a href="ch14.xhtml#ch14fig7">Figure 14-7</a>.</p>
<div class="image"><a id="ch14fig8"/><img src="../images/f0291-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-8: Transferring to a lower circular orbit with the Hohmann transfer technique</em></p>
<h5 class="h5" id="lev324"><strong>Raising and Lowering Orbits with the One-Tangent Burn</strong></h5>
<p class="noindent">The <em>One-Tangent Burn</em> technique transfers a spacecraft between orbits faster but less efficiently than a Hohmann transfer. A <em>burn</em> is just another term for thrust or impulse. As with the Hohmann transfer, orbits can be either raised or lowered.</p>
<p class="indent">The maneuver requires two engine impulses, the first tangential to the orbit and the second nontangential (see <a href="ch14.xhtml#ch14fig9">Figure 14-9</a>). If the initial orbit is circular, as in the figure, then all points along it represent both the apoapsis and the periapsis, and the spacecraft can apply its first burn at any time.</p>
<div class="image"><a id="ch14fig9"/><img src="../images/f0291-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-9: Transferring to a higher circular orbit with the One-Tangent Burn</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_292"/>Just as with the Hohmann transfer, a prograde burn raises the orbit, and a retrograde burn lowers it. If the orbit is elliptical, the first burn would be a prograde burn at the apoapsis to raise the orbit, or a retrograde burn at periapsis to lower it.</p>
<h5 class="h5" id="lev325"><strong>Executing a Spiral Orbit with the Spiral Transfer</strong></h5>
<p class="noindent">A <em>spiral transfer</em> uses a continuous, low-thrust burn to change the size of an orbit. In gameplay, you can simulate this using retrograde or prograde burns that are short and regularly spaced, like those shown in <a href="ch14.xhtml#ch14fig10">Figure 14-10</a>.</p>
<div class="image"><a id="ch14fig10"/><img src="../images/f0292-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-10: Executing a spiral orbit using short retrograde burns at regular intervals</em></p>
<p class="indent">To lower an orbit, all the burns must be retrograde; to raise an orbit, the spacecraft uses prograde burns.</p>
<h5 class="h5" id="lev326"><strong>Executing Synchronous Orbits</strong></h5>
<p class="noindent">In a <em>synchronous orbit</em>, a spacecraft takes the same amount of time to make one revolution around a planet as it takes the planet to make one rotation around its axis. If a synchronous orbit is parallel to the equator, with no orbital inclination, it is a <em>stationary</em> orbit; to an observer on the orbited body, the satellite appears motionless in a fixed position in the sky. Communications satellites commonly use <em>geostationary</em> orbits, which have an altitude of 22,236 miles around Earth. A similar orbit would be called <em>aerostationary</em> around Mars and <em>selenostationary</em> around the moon.</p>
<h3 class="h3a" id="lev327"><span epub:type="pagebreak" id="page_293"/><strong>Project #22: The Mars Orbiter Game</strong></h3>
<p class="noindent">In real life, a series of equations is used to precisely execute orbital maneuvers. In gameplay, you’ll use your intuition, patience, and reflexes! You’ll also need to fly by instruments to a certain extent, using mainly the spacecraft’s altitude readout and a measure of the orbit’s circularity.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Use <code>pygame</code> to build an arcade game that teaches the fundamentals of orbital mechanics. The game’s goal is to nudge a satellite into a circular mapping orbit without running out of fuel or burning up in the atmosphere.</p>
</div>
<h3 class="h3" id="lev328"><strong>The Strategy</strong></h3>
<p class="noindent">Start the design phase with a game sketch, as you did in <a href="ch13.xhtml#ch13">Chapter 13</a>. This sketch should capture all of the salient points of the game, like how it will look, how it will sound, how things will move, and how the game will communicate with the player (<a href="ch14.xhtml#ch14fig11">Figure 14-11</a>).</p>
<div class="image"><a id="ch14fig11"/><img src="../images/f0293-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-11: Sketch of the main gameplay of the Mars Orbiter game</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_294"/>The sketch in <a href="ch14.xhtml#ch14fig11">Figure 14-11</a> describes the main gameplay. You’ll need a separate sketch to describe the win-lose conditions. For the main gameplay, the key points are:</p>
<ul>
<li class="noindent"><strong>The viewpoint is Mission Control.</strong> The game screen should resemble a monitor at Mission Control from which the player can operate the errant space probe.</li>
<li class="noindent"><strong>Mars is at front and center.</strong> Everybody loves the Red Planet, so it will occupy the center of the jet-black screen.</li>
<li class="noindent"><strong>Mars is animated.</strong> The Martian globe will slowly rotate around its axis and cast a shadow. The satellite will dim appreciably when it passes through this shadow.</li>
<li class="noindent"><strong>The satellite’s initial orbit is chosen at random.</strong> The satellite will appear at startup with a randomized—but constrained—orientation and velocity. On rare occasions, this may result in an instant game loss. That’s still better than real missions, which fail 47 percent of the time!</li>
<li class="noindent"><strong>There’s no need to prograde or retrograde the satellite.</strong> Constantly rotating the space probe before firing its thrusters greatly diminishes gameplay. Assume that attitudinal thrusters are arrayed around the fuselage and use the arrow keys to choose which thrusters to fire.</li>
<li class="noindent"><strong>Firing thrusters causes an audible hiss.</strong> Despite the fact that there’s no sound in space, give the player the satisfaction of hearing a nice hiss whenever they fire the thrusters.</li>
<li class="noindent"><strong>The satellite dish always points toward Mars.</strong> The satellite will slowly and automatically rotate so that its remote-sensing dish is always aimed at Mars.</li>
<li class="noindent"><strong>The satellite’s orbital path is visible.</strong> A thin white line will trail out from behind the satellite and persist until the player clears it by pressing the space bar.</li>
<li class="noindent"><strong>The data readouts are placed at the top of the screen.</strong> You will display information useful for gameplay in boxes at the top of the window. Key data are the space probe’s velocity, altitude, fuel, and orbital eccentricity (a measure of the orbit’s circularity).</li>
<li class="noindent"><strong>A short introduction is shown at startup.</strong> Text introducing the game will appear at the center of the screen when the game starts and stay up for about 15 seconds. The text will not disrupt gameplay, so the player can start manipulating the satellite immediately.</li>
<li class="noindent"><strong>Win conditions and key controls are shown in permanent legends.</strong> Critical information, like mission objectives and control keys, will be displayed permanently in the lower-left and -right corners of the screen.</li>
</ul>
<p class="indent">The game sketch in <a href="ch14.xhtml#ch14fig12">Figure 14-12</a> describes what happens in success and failure cases. The player needs a reward when they win and an interesting outcome when they lose.</p>
<div class="image"><span epub:type="pagebreak" id="page_295"/><a id="ch14fig12"/><img src="../images/f0295-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-12: Game sketch of winning versus losing outcomes in the Mars Orbiter game</em></p>
<p class="indent">For winning and losing outcomes, the key points are:</p>
<ul>
<li class="noindent"><strong>Change the satellite image for crash and burn.</strong> If the satellite’s altitude drops below 68 miles, it burns up in the atmosphere. The moving satellite image will be replaced with a glowing red version that sticks to the side of Mars; this is similar to something you might see on a real Mission Control display.</li>
<li class="noindent"><strong>The satellite is lost in space if it runs out of fuel.</strong> Although unrealistic, have the satellite fly off the screen and into the depths of space if it runs out of fuel. This really rubs the player’s nose in it!</li>
<li class="noindent"><strong>Win conditions unlock a prize.</strong> If the satellite achieves a circular orbit within the target altitude range, new text will urge the player to press the M key.</li>
<li class="noindent"><strong>Pressing M changes the Mars image.</strong> When the M key is unlocked, pressing it causes the Mars image to change to a rainbow image where cool colors represent areas of high soil moisture and warm colors represent drier areas.</li>
</ul>
<p class="indent">For gameplay, the size of the satellite and its orbital speed won’t be realistic, but the overall behavior will be correct. You should be able to correctly execute all of the orbital maneuvers described in “<a href="ch14.xhtml#lev315">Astrodynamics for Gamers</a>” on <a href="ch14.xhtml#page_286">page 286</a>.</p>
<h3 class="h3" id="lev329"><span epub:type="pagebreak" id="page_296"/><strong>Game Assets</strong></h3>
<p class="noindent">The assets you’ll need for the Mars Orbiter game are two satellite images, two planet images, and a sound file. You can prepare these together at the start of the process or build them when you need them. The latter approach lets you take episodic breaks from coding, which some people prefer.</p>
<p class="indent">Finding good, copyright-free graphics and sound files can be a challenge. You can find suitable assets online—either for free or for a fee—but it’s best to make your own whenever possible. This lets you avoid any legal issues down the road.</p>
<p class="indent">The sprites (2D icons or images) I used for this project are shown in <a href="ch14.xhtml#ch14fig13">Figure 14-13</a>. You need a satellite, a red “burned” version of the satellite, a view of Mars with a polar cap centered, and the same view with a colorful overlay that will represent mapped soil-moisture gradations. I found the satellite sprite at the free icon site AHA-SOFT (<em><a href="http://www.aha-soft.com/">http://www.aha-soft.com/</a></em>) and then copied and recolored it to make the crashed version. Both of the Mars sprites are NASA images modified for the game.</p>
<div class="image"><a id="ch14fig13"/><img src="../images/f0296-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-13: The satellite, crashed satellite, Mars, and Mars overlay images used as game sprites</em></p>
<p class="indent">I made a sound file for when the satellite is firing its thrusters using the white noise generator in the open source program Audacity. You can download a free copy of Audacity at <em><a href="https://www.audacityteam.org/">https://www.audacityteam.org/</a></em>. I saved the file in <em>Ogg Vorbis</em> format, an open source standard audio compression format that is free and works well with Python and <code>pygame</code>. You can use other formats, like MP3 and WAV, with <code>pygame</code>, but some have documented problems or have proprietary components that can raise legal issues if you try to commercialize your game.</p>
<p class="indent">You can download these files from this book’s website at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em> as <em>satellite.png</em>, <em>satellite_crash_40x33.png</em>, <em>mars.png</em>, <em>mars_water.png</em>, and <em>thrust_audio.ogg</em>. Download them, preserving the filenames, into the same folder as the code.</p>
<h3 class="h3" id="lev330"><span epub:type="pagebreak" id="page_297"/><strong>The Code</strong></h3>
<p class="noindent"><a href="ch14.xhtml#ch14fig14">Figure 14-14</a> is an example of the final game screen you’ll be building. You can refer back to this figure to get an idea of what the code is doing.</p>
<div class="image"><a id="ch14fig14"/><img src="../images/f0297-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-14: Example startup game screen for the final version of</em> mars_orbiter.py</p>
<p class="indent">You can download the complete program (<em>mars_orbiter.py</em>) at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h4 class="h4" id="lev331"><strong><em>Importing and Building a Color Table</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list1">Listing 14-1</a> imports the required modules and builds a color table.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 1</p>
<pre><span class="ent">➊</span> import os<br/>   import math<br/>   import random<br/>   import pygame as pg<br/><br/><span class="ent">➋</span> WHITE = (255, 255, 255)<br/>   BLACK = (0, 0, 0)<br/>   RED = (255, 0, 0)<br/>   GREEN = (0, 255, 0)<br/>   LT_BLUE = (173, 216, 230)</pre>
<p class="listing" id="ch14list1"><em>Listing 14-1: Imports modules and builds a color table</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_298"/>First, import the operating system, designated by <code>os</code> <span class="ent">➊</span>. The game will launch in full-screen mode, but the player will have the option of escaping out of full screen. This module will let you control the location of the game window after the player presses <small>ESC</small>.</p>
<p class="indent">You’ll use the <code>math</code> module for gravity and trigonometric calculations and <code>random</code> to start the satellite off with a random position and velocity. Import <code>pygame</code> as you did in <a href="ch13.xhtml#ch13">Chapter 13</a>, using <code>pg</code>, rather than <code>pygame</code>, to reduce typing.</p>
<p class="indent">Finish by building an RGB color table <span class="ent">➋</span> as you did in <a href="ch13.xhtml#ch13">Chapter 13</a>. This lets you type in color names, rather than RGB-value tuples, when you need to assign one of these colors.</p>
<h4 class="h4" id="lev332"><strong><em>Defining the Satellite Class Initialization Method</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list2">Listing 14-2</a> defines the <code>Satellite</code> class and its initialization method, which you’ll use to instantiate a satellite object in the game. Since this method definition is long, it’s split over two listings.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 2</p>
<pre><span class="ent">➊</span> class Satellite(pg.sprite.Sprite):<br/>       """Satellite object that rotates to face planet &amp; crashes &amp; burns."""<br/><br/>    <span class="ent">➋</span> def __init__(self, background):<br/>        <span class="ent">➌</span> super().__init__()<br/>        <span class="ent">➍</span> self.background = background<br/>        <span class="ent">➎</span> self.image_sat = pg.image.load("satellite.png").convert()<br/>           self.image_crash = pg.image.load("satellite_crash_40x33.png").convert()<br/>        <span class="ent">➏</span> self.image = self.image_sat<br/>        <span class="ent">➐</span> self.rect = self.image.get_rect()<br/>        <span class="ent">➑</span> self.image.set_colorkey(BLACK)  # sets transparent color</pre>
<p class="listing" id="ch14list2"><em>Listing 14-2: Defines the first part of the</em> <span class="codeitalic">Satellite</span> <em>class initialization method</em></p>
<p class="indent">Define a class for a <code>Satellite</code> object <span class="ent">➊</span>; if you need a refresher on object-oriented programming, read <a href="ch11.xhtml#ch11">Chapter 11</a>. Pass it the <code>pygame</code> <code>Sprite</code> class, as objects instantiated from the <code>Satellite</code> class will be sprites. As described in <a href="ch13.xhtml#ch13">Chapter 13</a>, <code>Sprite</code> is a built-in class that serves as a template for making sprites. Your new class will inherit features that your sprites will need from this base class. These include important attributes like <code>rect</code> and <code>image</code>, which you’ll deal with shortly.</p>
<p class="indent">Next, define the <code>__init__()</code> method for the <code>Satellite</code> object <span class="ent">➋</span> and pass it <code>self</code>, which—by convention—is a special name within a class definition that refers to the current object. You also need to pass the method a <code>background</code> object. The satellite’s path will be drawn on this object.</p>
<p class="indent">Inside the <code>__init_()</code> method, immediately invoke the initialization method for the built-in <code>Sprite</code> class using <code>super</code> <span class="ent">➌</span>. This will initialize the sprite and establish the <code>rect</code> and <code>image</code> attributes it needs. With <code>super</code>, you don’t need to refer to the base class (<code>Sprite</code>) explicitly. For more on <code>super</code>, see <a href="ch11.xhtml#ch11list5">Listing 11-5</a> on <a href="ch11.xhtml#page_229">page 229</a> or visit the docs at <em><a href="https://docs.python.org/3/library/functions.html?highlight=super#super">https://docs.python.org/3/library/functions.html?highlight=super#super</a></em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_299"/>Next, assign the <code>background</code> to <code>self</code> as an object attribute <span class="ent">➍</span>. Then use <code>pygame</code>’s <code>image.load()</code> method to load your two satellite images—one operational and one crashed—and in the same step, run the <code>convert()</code> method on them <span class="ent">➎</span>. This converts the object into a graphic format that <code>pygame</code> can use efficiently once the game loop starts. Without this step, the game may slow noticeably as the <code>png</code> format is converted, on the fly, 30 or more times per second.</p>
<p class="indent">You’ll use only one of the satellite images at a time, depending on whether or not the player burned up in the atmosphere, so use a generic <code>self.image</code> attribute to hold the loaded and converted image <span class="ent">➏</span>. The unburned satellite image will be the default image; it will be replaced with the red crashed image if the satellite object gets too close to Mars.</p>
<p class="indent">Now, get the rectangle information for the image <span class="ent">➐</span>. Remember that <code>pygame</code> places the sprites on rectangular surface objects, and it needs to know the dimensions and location of these rectangles as the game runs.</p>
<p class="indent">Finally, make the black parts of the satellite image invisible <span class="ent">➑</span>. The satellite icon is on a field of black (see <a href="ch14.xhtml#ch14fig13">Figure 14-13</a>), and you want the crashed-and-burned image to plot partially over Mars, so use the <code>BLACK</code> constant with the image object’s <code>colorkey()</code> method in order to make the icon’s background transparent. Otherwise, you’ll see a black box with a red satellite overlapping the Red Planet. Note that if you want to type in the RGB equivalent for black, you need to enter it as a tuple: <code>(0, 0, 0)</code>.</p>
<h4 class="h4" id="lev333"><strong><em>Setting the Satellite’s Initial Position, Speed, Fuel, and Sound</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list3">Listing 14-3</a> completes the definition of the <code>Satellite</code> class initialization method. The satellite object’s initial position and velocity are chosen at random from a limited range of choices; the orientation of the remote-sensing dish is initialized, the fuel tank topped off, and sound effects added.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 3</p>
<pre>        <span class="ent">➊</span> self.x = random.randrange(315, 425)<br/>           self.y = random.randrange(70, 180)<br/>        <span class="ent">➋</span> self.dx = random.choice([-3, 3])<br/>        <span class="ent">➌</span> self.dy = 0<br/>        <span class="ent">➍</span> self.heading = 0  # initializes dish orientation<br/>        <span class="ent">➎</span> self.fuel = 100<br/>           self.mass = 1<br/>           self.distance = 0  # initializes distance between satellite &amp; planet<br/>        <span class="ent">➏</span> self.thrust = pg.mixer.Sound('thrust_audio.ogg')<br/>        <span class="ent">➐</span> self.thrust.set_volume(0.07)  # valid values are 0-1</pre>
<p class="listing" id="ch14list3"><em>Listing 14-3: Completes the</em> <span class="codeitalic">Satellite</span> <em>class initialization method by initializing parameters</em></p>
<p class="indent">When the game starts, the satellite will appear at a random point near the top of the screen. You’ll choose the exact location from a range of x- and y-values <span class="ent">➊</span>.</p>
<p class="indent">You’ll also choose the satellite’s velocity at random, but it will be slow enough that the satellite can’t escape from orbit. Randomly set the velocity to either –3 or 3. Negative values result in a counterclockwise orbit, and vice versa. Use the delta-x (<code>dx</code>) attribute only <span class="ent">➋</span> and let gravity take care of <code>dy</code>. As <span epub:type="pagebreak" id="page_300"/>discussed in <a href="ch13.xhtml#ch13">Chapter 13</a>, <code>pygame</code> moves sprites around the screen using incremental changes in the x-location (called delta-x or <em>dx</em>) and incremental changes in the y-location (called delta-y or <em>dy</em>). These vector components are calculated and added to the sprite’s current position (<code>self.x</code>, <code>self.y</code>) with each game loop.</p>
<p class="indent">Next, set the <code>dy</code> attribute to <code>0</code> <span class="ent">➌</span>. Later, the <code>gravity()</code> method will establish an initial <code>dy</code> value when it accelerates the newly instantiated satellite downscreen toward the planet.</p>
<p class="indent">Assign an attribute for the satellite’s heading <span class="ent">➍</span>. The remote-sensing dish, which will read soil moisture on the planet’s surface, should always point toward Mars, and if you remember from <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>, this won’t occur unless you overcome inertia. You’ll use a method to actually rotate the satellite, so for now, just initialize the <code>heading</code> attribute with <code>0</code>.</p>
<p class="indent">Now, top off the fuel tank with 100 units of fuel <span class="ent">➎</span>. If you want to relate this to real life, it would probably represent 100 kilograms of hydrazine, similar to what was used in the <em>Magellan</em> probe that mapped Venus.</p>
<p class="indent">Next, set the object’s mass to <code>1</code>. This basically means you’ll just use the mass of Mars in the gravity equation, because you multiply the masses of two objects together. As stated earlier, the pull of the satellite on Mars is inconsequential, so you don’t need to calculate it. The satellite’s <code>mass</code> attribute is included for completeness and as a placeholder in case you want to experiment with different values later.</p>
<p class="indent">The following <code>distance</code> attribute stores the distance between the satellite and the body it is orbiting. The actual value will be calculated by a method you’ll define later.</p>
<p class="indent">It’s time to add sound effects. You’ll initialize <code>pygame</code>’s sound mixer in the <code>main()</code> function, but for now, name a <code>thrust</code> attribute for the thrusting sound effect <span class="ent">➏</span>. Pass the mixer’s <code>Sound</code> class the short clip of white noise in Ogg Vorbis format (<em>.ogg</em>). Finally, set the playback volume, using values between 0 and 1 <span class="ent">➐</span>. You may need to calibrate this to your PC. Ideally, you want a value that every player will be able to at least <em>hear</em> and then fine-tune with their own computer’s volume control.</p>
<h4 class="h4" id="lev334"><strong><em>Firing Thrusters and Checking for Player Input</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list4">Listing 14-4</a> defines the <code>thruster()</code> and <code>check_keys()</code> methods of the <code>Satellite</code> class. The first determines the actions taken if one of the satellite’s thrusters is fired. The second checks whether a player has interacted with the thrusters by pressing an arrow key.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 4</p>
<pre>    <span class="ent">➊</span> def thruster(self, dx, dy):<br/>           """Execute actions associated with firing thrusters."""<br/>        <span class="ent">➋</span> self.dx += dx<br/>           self.dy += dy<br/>        <span class="ent">➌</span> self.fuel -= 2<br/>        <span class="ent">➍</span> self.thrust.play()<br/><br/>    <span class="ent">➎</span> def check_keys(self):<br/>           """Check if user presses arrow keys &amp; call thruster() method."""<br/>        <span class="ent">➏</span> keys = pg.key.get_pressed()<br/><span epub:type="pagebreak" id="page_301"/>           # fire thrusters<br/>        <span class="ent">➐</span> if keys[pg.K_RIGHT]:<br/>            <span class="ent">➑</span> self.thruster(dx=0.05, dy=0)<br/>           elif keys[pg.K_LEFT]:<br/>               self.thruster(dx=-0.05, dy=0)<br/>           elif keys[pg.K_UP]:<br/>               self.thruster(dx=0, dy=-0.05)<br/>           elif keys[pg.K_DOWN]:<br/>               self.thruster(dx=0, dy=0.05)</pre>
<p class="listing" id="ch14list4"><em>Listing 14-4: Defines the</em> <span class="codeitalic">thruster()</span> <em>and</em> <span class="codeitalic">check_keys()</span> <em>methods for the</em> <span class="codeitalic">Satellite</span> <em>class</em></p>
<p class="indent">The <code>thruster()</code> method takes <code>self</code>, <code>dx</code>, and <code>dy</code> as arguments <span class="ent">➊</span>. The last two arguments, which can be positive or negative, are immediately added to the satellite’s <code>self.dx</code> and <code>self.dy</code> velocity components <span class="ent">➋</span>. Next, the fuel level is decreased by two units <span class="ent">➌</span>. Altering this value is one way to make the game either harder or easier. Finish by calling the <code>play()</code> method on the <code>thrust</code> audio attribute to make the hissing sound <span class="ent">➍</span>. Note that, instead of <em>returning</em> values, OOP methods <em>update</em> existing object attributes.</p>
<p class="indent">The <code>check_keys()</code> method takes <code>self</code> as an argument <span class="ent">➎</span>. First you use the <code>pygame</code> <code>key</code> module to determine whether the player has pressed a key <span class="ent">➏</span>. The <code>get_pressed()</code> method returns a tuple of Boolean values—<code>1</code> for <code>True</code> and <code>0</code> for <code>False</code>—that represent the current state of each key on the keyboard. <code>True</code> means a key has been pressed. You can index this tuple by using the key constants. You can find a list of all the keyboard constants at <em><a href="https://www.pygame.org/docs/ref/key.html">https://www.pygame.org/docs/ref/key.html</a></em>.</p>
<p class="indent">For example, the right arrow key is <code>K_RIGHT</code>. If this key has been pressed <span class="ent">➐</span>, call the <code>thruster()</code> method and pass it <code>dx</code> and <code>dy</code> values <span class="ent">➑</span>. In <code>pygame</code>, x-values increase toward the right of the screen, and y-values increase toward the bottom of the screen. So, if the user presses the left arrow key, subtract from <code>dx</code>; likewise, if the up arrow is pressed, decrement the <code>dy</code> value. The right arrow will increase <code>dx</code>, and the down arrow will increase <code>dy</code>. Readouts at the top of the screen will help the player relate the satellite’s movements to the underlying <code>dx</code> and <code>dy</code> values (see <a href="ch14.xhtml#ch14fig14">Figure 14-14</a>).</p>
<h4 class="h4" id="lev335"><strong><em>Locating the Satellite</em></strong></h4>
<p class="noindent">Still in the <code>Satellite</code> class, <a href="ch14.xhtml#ch14list5">Listing 14-5</a> defines the <code>locate()</code> method. This method calculates the distance of the satellite from the planet and determines the heading for pointing the dish at the planet. You’ll use the distance attribute later when calculating the force of gravity and the <em>eccentricity</em> of the orbit. Eccentricity is a measurement of the deviation of an orbit from a perfect circle.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 5</p>
<pre>    <span class="ent">➊</span> def locate(self, planet):<br/>           """Calculate distance &amp; heading to planet."""<br/>        <span class="ent">➋</span> px, py = planet.x, planet.y<br/>        <span class="ent">➌</span> dist_x = self.x - px<br/>           dist_y = self.y - py<br/>           # get direction to planet to point dish<br/>        <span class="ent">➍</span> planet_dir_radians = math.atan2(dist_x, dist_y)<br/><span epub:type="pagebreak" id="page_302"/>        <span class="ent">➎</span> self.heading = planet_dir_radians * 180 / math.pi<br/>        <span class="ent">➏</span> self.heading -= 90  # sprite is traveling tail-first<br/>        <span class="ent">➐</span> self.distance = math.hypot(dist_x, dist_y)</pre>
<p class="listing" id="ch14list5"><em>Listing 14-5: Defines the</em> <span class="codeitalic">locate()</span> <em>method for the</em> <span class="codeitalic">Satellite</span> <em>class</em></p>
<p class="indent">To locate the satellite, you need to pass the <code>locate()</code> method the <code>satellite</code> (<code>self</code>) and <code>planet</code> objects <span class="ent">➊</span>. First, determine the distance between the objects in x-y space. Get the planet’s x- and y-attributes <span class="ent">➋</span>; then subtract them from the satellite’s x- and y-attributes <span class="ent">➌</span>.</p>
<p class="indent">Now, use these new distance variables to calculate the angle between the satellite’s heading and the planet so you can rotate the satellite dish toward the planet. The <code>math</code> module uses radians, so assign a local variable called <code>planet_dir_radians</code> to hold the direction in radians and pass <code>dist_x</code> and <code>dist_y</code> to the <code>math.atan2()</code> function to calculate the arc tangent <span class="ent">➍</span>. Since <code>pygame</code> uses degrees (sigh), convert the angle from radians to degrees using the standard formula; alternatively, you could use <code>math</code> to do this, but sometimes it’s good to see the man behind the curtain <span class="ent">➎</span>. This should be a sharable attribute of the satellite object, so name it <code>self.heading</code>.</p>
<p class="indent">In <code>pygame</code>, the front of a sprite is to the east by default, which means the satellite sprite is orbiting tail-first (see the satellite icon in <a href="ch14.xhtml#ch14fig13">Figure 14-13</a>). To get the dish to point toward Mars, you need to subtract 90 degrees from the heading, because negative angles result in <em>clockwise</em> rotation in <code>pygame</code> <span class="ent">➏</span>. This maneuver will use none of the player’s fuel allotment.</p>
<p class="indent">Finally, get the Euclidian distance between the satellite and Mars by using the <code>math</code> module to calculate the hypotenuse from the x- and y-components <span class="ent">➐</span>. You should make this an attribute of the satellite object since you will use it later in other functions.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In real life, there are multiple ways to keep the dish of a satellite pointed toward a planet without expending large amounts of fuel. Techniques include slowly tumbling or spinning the satellite, making the dish end heavier than the opposite end, using magnetic torque, or using internal flywheels—also known as reaction wheels or momentum wheels. Flywheels use electric motors that can be powered by solar panels, eliminating the need for heavy and toxic liquid propellant.</em></p>
</div>
<h4 class="h4" id="lev336"><strong><em>Rotating the Satellite and Drawing Its Orbit</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list6">Listing 14-6</a> continues the <code>Satellite</code> class by defining methods for rotating the satellite dish toward the planet and drawing a path behind it. Later, in the <code>main()</code> function, you’ll add code that lets the player erase and restart the path by pressing the space bar.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 6</p>
<pre>    <span class="ent">➊</span> def rotate(self):<br/>           """Rotate satellite using degrees so dish faces planet."""<br/>        <span class="ent">➋</span> self.image = pg.transform.rotate(self.image_sat, self.heading)<br/>        <span class="ent">➌</span> self.rect = self.image.get_rect()<br/><br/>    <span class="ent">➍</span> def path(self):<br/><span epub:type="pagebreak" id="page_303"/>           """Update satellite’s position &amp; draw line to trace orbital path."""<br/>        <span class="ent">➎</span> last_center = (self.x, self.y)<br/>        <span class="ent">➏</span> self.x += self.dx<br/>           self.y += self.dy<br/>        <span class="ent">➐</span> pg.draw.line(self.background, WHITE, last_center, (self.x, self.y))</pre>
<p class="listing" id="ch14list6"><em>Listing 14-6: Defines the</em> <span class="codeitalic">rotate()</span> <em>and</em> <span class="codeitalic">path()</span> <em>methods of the</em> <span class="codeitalic">Satellite</span> <em>class</em></p>
<p class="indent">The <code>rotate()</code> method will use the <code>heading</code> attribute, which you calculate in the <code>locate()</code> method, to turn the satellite dish toward Mars. Pass <code>self</code> to <code>rotate()</code> <span class="ent">➊</span>, which means <code>rotate()</code> will automatically take the name of the satellite object as an argument when it is called later.</p>
<p class="indent">Now, rotate the satellite image using <code>pygame</code>’s <code>transform.rotate()</code> method <span class="ent">➋</span>. Pass it the original image followed by the <code>heading</code> attribute; assign these to the <code>self.image</code> attribute so you don’t degrade the original master image. You’ll need to transform the image with each game loop, and transforming an image rapidly degrades it. So always keep a master image and work off a new copy every time you do a transformation.</p>
<p class="indent">End the function by getting the transformed image’s <code>rect</code> object <span class="ent">➌</span>.</p>
<p class="indent">Next, define a method called <code>path()</code> and pass it <code>self</code> <span class="ent">➍</span>. This will draw a line marking the satellite’s path, and since you need two points to draw a line, assign a variable to record the satellite’s center location as a tuple prior to moving it <span class="ent">➎</span>. Then increment the x- and y-locations with the <code>dx</code> and <code>dy</code> attributes <span class="ent">➏</span>. Finish by using <code>pygame</code>’s <code>draw.line()</code> method to define the line <span class="ent">➐</span>. This method needs a drawing object, so pass it the <code>background</code> attribute, followed by the line color and the previous and current x-y location tuples.</p>
<h4 class="h4" id="lev337"><strong><em>Updating the Satellite Object</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list7">Listing 14-7</a> updates the satellite object and completes the class definition. Sprite objects almost always have an <code>update()</code> method that is called once per frame as the game runs. Anything that happens to the sprite, such as movement, color changes, user interactions, and so on, is included in this method. To keep them from becoming too cluttered, <code>update()</code> methods mostly call other methods.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 7</p>
<pre>    <span class="ent">➊</span> def update(self):<br/>           """Update satellite object during game."""<br/>        <span class="ent">➋</span> self.check_keys()<br/>        <span class="ent">➌</span> self.rotate()<br/>        <span class="ent">➍</span> self.path()<br/>        <span class="ent">➎</span> self.rect.center = (self.x, self.y)<br/>           # change image to fiery red if in atmosphere<br/>        <span class="ent">➏</span> if self.dx == 0 and self.dy == 0:<br/>               self.image = self.image_crash<br/>               self.image.set_colorkey(BLACK)</pre>
<p class="listing" id="ch14list7"><em>Listing 14-7: Defines the</em> <span class="codeitalic">update()</span> <em>method for the</em> <span class="codeitalic">Satellite</span> <em>class</em></p>
<p class="indent">Start by defining the <code>update()</code> method and passing it the object, or <code>self</code> <span class="ent">➊</span>. Next, call the methods that you defined earlier. The first of these checks <span epub:type="pagebreak" id="page_304"/>for player interactions made through the keyboard <span class="ent">➋</span>. The second rotates the satellite object so that the dish keeps pointing toward the planet <span class="ent">➌</span>. The final method updates the satellite’s x-y location and draws a path behind it so you can visualize the orbit <span class="ent">➍</span>.</p>
<p class="indent">The program needs to keep track of the satellite sprite’s location as it orbits Mars, so assign a <code>rect.center</code> attribute and set it to the satellite’s current x-y location <span class="ent">➎</span>.</p>
<p class="indent">The final bit of code changes the satellite image in the event the player crashes and burns in the atmosphere <span class="ent">➏</span>. The top of the Martian atmosphere is about 68 miles above its <em>surface</em>. For reasons I’ll explain later, assume that an altitude value of 68—which is measured in pixels from the <em>center</em> of the planet—equates to the top of the atmosphere. If the satellite dips below this altitude during gameplay, the <code>main()</code> function will set its velocity—represented by <code>dx</code> and <code>dy</code>—to <code>0</code>. Check that these values are both <code>0</code>, and if so, change the image to <code>image_crash</code> and set its background to transparent (as you did previously for the main satellite image).</p>
<h4 class="h4" id="lev338"><strong><em>Defining the Planet Class Initialization Method</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list8">Listing 14-8</a> defines the <code>Planet</code> class, which you’ll use to instantiate a <code>planet</code> object.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 8</p>
<pre><span class="ent">➊</span> class Planet(pg.sprite.Sprite):<br/>       """Planet object that rotates &amp; projects gravity field."""<br/><br/>    <span class="ent">➋</span> def __init__(self):<br/>           super().__init__()<br/>        <span class="ent">➌</span> self.image_mars = pg.image.load("mars.png").convert()<br/>           self.image_water = pg.image.load("mars_water.png").convert()<br/>        <span class="ent">➍</span> self.image_copy = pg.transform.scale(self.image_mars, (100, 100))<br/>        <span class="ent">➎</span> self.image_copy.set_colorkey(BLACK)<br/>        <span class="ent">➏</span> self.rect = self.image_copy.get_rect()<br/>           self.image = self.image_copy<br/>        <span class="ent">➐</span> self.mass = 2000<br/>        <span class="ent">➑</span> self.x = 400<br/>           self.y = 320<br/>           self.rect.center = (self.x, self.y)<br/>        <span class="ent">➒</span> self.angle = math.degrees(0)<br/>           self.rotate_by = math.degrees(0.01)</pre>
<p class="listing" id="ch14list8"><em>Listing 14-8: Begins definition of the</em> <span class="codeitalic">Planet</span> <em>class</em></p>
<p class="indent">You are probably very familiar with the initial steps to creating the <code>Planet</code> class by now. First, you name the class with a capital letter, then pass it the <code>Sprite</code> class so it will conveniently inherit features from this built-in <code>pygame</code> class <span class="ent">➊</span>. Next, you define an <code>__init__()</code>, or initialization, method for your <code>planet</code> object <span class="ent">➋</span>. Then you call the <code>super()</code> initialization method, as you did for the <code>Satellite</code> class.</p>
<p class="indent">Load the images as attributes and convert them to <code>pygame</code>’s graphic format at the same time <span class="ent">➌</span>. You need both the normal Mars image and the <span epub:type="pagebreak" id="page_305"/>one for mapped soil moisture. You were able to use the satellite sprite at its native size, but the Mars image is too large. Scale the image to 100 pixels × 100 pixels <span class="ent">➍</span> and assign the scaled image to a new attribute so repeated transformations won’t degrade the master image.</p>
<p class="indent">Now, set the transformed image’s transparent color to black, as you did earlier with the satellite image <span class="ent">➎</span>. Sprites in <code>pygame</code> are all “mounted” on rectangular surfaces, and if you don’t make black invisible, the corners of the planet surface may overlap and cover the white-colored orbital path drawn by the satellite (see <a href="ch14.xhtml#ch14fig15">Figure 14-15</a>).</p>
<div class="image"><a id="ch14fig15"/><img src="../images/f0305-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-15: Corners of Mars</em> <span class="codeitalic">rect</span> <em>covering orbital path</em></p>
<p class="indent">As always, get the sprite’s <code>rect</code> object <span class="ent">➏</span>. There’s another transformation to come, so copy the image attribute again and assign it the logical name of <code>self.image</code>.</p>
<p class="indent">To apply the force of gravity, the planet needs mass, so name a <code>mass</code> attribute and assign it a value of <code>2000</code> <span class="ent">➐</span>. Earlier, you assigned the satellite a mass of <code>1</code>; this means that Mars is only 2,000 times as massive as a satellite! That’s okay, because you aren’t working in real-world units, and the time and distance scales differ from reality. If you scale distances so that the satellite is only a few hundred pixels from Mars, you have to scale gravity as well. Despite this, the satellite will still behave realistically with respect to gravity.</p>
<p class="indent">The planet’s mass value was determined through experimentation. To scale the force of gravity, you can either change this mass value or use the gravitational constant (<code>G</code>) variable later.</p>
<p class="indent">Set the <code>planet</code> object’s <code>x</code> and <code>y</code> attributes to the center point of the screen—you’ll use a screen size of 800 × 645 in the <code>main()</code> function—and assign these values to the <code>rect</code> object’s center <span class="ent">➑</span>.</p>
<p class="indent">Finally, assign the attributes you’ll need to slowly rotate Mars about its axis <span class="ent">➒</span>. You’ll use the same <code>transform.rotate()</code> method you used to turn the satellite, so you need to create an <code>angle</code> attribute. Then, use a <code>rotate_by</code> attribute to assign the increment—in degrees—by which this rotation angle changes with each game loop.</p>
<h4 class="h4" id="lev339"><span epub:type="pagebreak" id="page_306"/><strong><em>Rotating the Planet</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list9">Listing 14-9</a> continues the <code>Planet</code> class by defining its <code>rotate()</code> method. This method rotates the planet around its axis, making small changes with each game loop.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 9</p>
<pre>    <span class="ent">➊</span> def rotate(self):<br/>           """Rotate the planet image with each game loop."""<br/>        <span class="ent">➋</span> last_center = self.rect.center<br/>        <span class="ent">➌</span> self.image = pg.transform.rotate(self.image_copy, self.angle)<br/>           self.rect = self.image.get_rect()<br/>        <span class="ent">➍</span> self.rect.center = last_center<br/>        <span class="ent">➎</span> self.angle += self.rotate_by</pre>
<p class="listing" id="ch14list9"><em>Listing 14-9: Defines a method to rotate the planet around its axis</em></p>
<p class="indent">The <code>rotate()</code> method also takes the object as an argument <span class="ent">➊</span>. As the square Mars image is rotating, the bounding rectangle object (<code>rect</code>) remains stationary and must expand to accommodate the new configuration (see <a href="ch14.xhtml#ch14fig16">Figure 14-16</a>). This change in size can affect the center point of the <code>rect</code>, so assign a <code>last_center</code> variable and set it to the planet’s current center point <span class="ent">➋</span>. If you don’t do this, Mars will wobble around its axis as the game runs.</p>
<div class="image"><a id="ch14fig16"/><img src="../images/f0306-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-16: The bounding rectangle changes size to accommodate rotating images.</em></p>
<p class="indent">Next, rotate the copied image using <code>pygame</code>’s <code>transform.rotate()</code> method and assign it to the <code>self.image</code> attribute <span class="ent">➌</span>; you need to pass the method the copied image and the <code>angle</code> attribute. Immediately after rotating, reset the image’s <code>rect</code> attribute and move its center location back to <code>last_center</code> in order to mitigate any shifting of <code>rect</code> that occurred during rotation <span class="ent">➍</span>.</p>
<p class="indent">When the <code>planet</code> object is instantiated, the angle attribute will start at 0 degrees, then increase by 0.1—assigned in the <code>rotate_by</code> attribute—with each frame <span class="ent">➎</span>.</p>
<h4 class="h4" id="lev340"><span epub:type="pagebreak" id="page_307"/><strong><em>Defining the gravity() and update() Methods</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list10">Listing 14-10</a> completes the <code>Planet</code> class by defining the <code>gravity()</code> and <code>update()</code> methods. In <a href="ch13.xhtml#ch13">Chapter 13</a>, you treated gravity as a constant applied in the y-direction. The method applied here is slightly more sophisticated, because it takes into account the distance between two objects.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 10</p>
<pre>    <span class="ent">➊</span> def gravity(self, satellite):<br/>
           """Calculate impact of gravity on satellite."""<br/>
        <span class="ent">➋</span> G = 1.0  # gravitational constant for game<br/>
        <span class="ent">➌</span> dist_x = self.x - satellite.x<br/>
           dist_y = self.y - satellite.y<br/>
           distance = math.hypot(dist_x, dist_y)<br/>
           # normalize to a unit vector<br/>
        <span class="ent">➍</span> dist_x /= distance<br/>
           dist_y /= distance<br/>
           # apply gravity (dx &amp; dy represent pixels/frame)<br/>
        <span class="ent">➎</span> force = G * (satellite.mass * self.mass) / (math.pow(distance, 2))<br/>
        <span class="ent">➏</span> satellite.dx += (dist_x * force)<br/>
           satellite.dy += (dist_y * force)<br/>
<br/>
    <span class="ent">➐</span> def update(self):<br/>
           """Call the rotate method."""<br/>
           self.rotate()</pre>
<p class="listing" id="ch14list10"><em>Listing 14-10: Defines the</em> <span class="codeitalic">gravity()</span> <em>and</em> <span class="codeitalic">update()</span> <em>methods of the</em> <span class="codeitalic">Planet</span> <em>class</em></p>
<p class="indent">Define the <code>gravity()</code> method and pass it <code>self</code> and the satellite object <span class="ent">➊</span>. You’re still in the <code>Planet</code> class, so <code>self</code> here represents Mars.</p>
<p class="indent">Start by naming a local variable <code>G</code>; an uppercase G is the <em>universal gravitational constant</em>, also known as the <em>constant of proportionality</em> <span class="ent">➋</span>. In real life, this is a very small, empirically derived number, which is basically a conversion number to get all the units to work out correctly. You’re not using real-world units in the game, so set this to <code>1</code>; this way, it won’t have an impact on the gravity equation. During game development, you can tweak this constant up or down to fine-tune the force of gravity and its effect on orbiting objects.</p>
<p class="indent">You need to know how far apart the two objects are, so get their distance in the x-direction and the y-direction <span class="ent">➌</span>. Then, use the <code>math</code> module’s <code>hypot()</code> method to get the Euclidian distance. This will represent the <em>r</em> in the gravity equation.</p>
<p class="indent">Since you’re going to directly address the <em>magnitude</em> of the distance between the satellite and Mars in the gravity equation, all you need from the distance vector is <em>direction</em>. So, divide <code>dist_x</code> and <code>dist_y</code> by <code>distance</code> to “normalize” the vector to a unit vector with a magnitude of <code>1</code> <span class="ent">➍</span>. You are basically dividing the length of each side of a right triangle by its hypotenuse. This preserves the vector’s direction, represented by the relative differences in <code>dist_x</code> and <code>dist_y</code>, but sets its magnitude to <code>1</code>. Note that if you don’t perform this normalization step, the results will be unrealistic but interesting (see <a href="ch14.xhtml#ch14fig17">Figure 14-17</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_308"/><a id="ch14fig17"/><img src="../images/f0308-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-17: “Spirograph” orbit resulting from use of an unnormalized distance vector</em></p>
<p class="indent">Calculate the force of gravity using Newton’s equation, which I described in “<a href="ch14.xhtml#lev316">The Law of Universal Gravity</a>” on <a href="ch14.xhtml#page_286">page 286</a> <span class="ent">➎</span>. Finish by multiplying the normalized distances by <code>force</code>—to calculate by how much acceleration changes velocity in each step—and add these amounts to the satellite object’s <code>dx</code> and <code>dy</code> attributes <span class="ent">➏</span>.</p>
<p class="indent">Note that you don’t assign most of these variables as attributes of <code>self</code>. These just represent intermediate steps within a method that don’t need to be shared with other methods, and you can treat them as you would local variables in procedural programming.</p>
<p class="indent">Finally, define a method that will be called every game loop to update the <code>planet</code> object <span class="ent">➐</span>. Use it to call the <code>rotate()</code> method.</p>
<h4 class="h4" id="lev341"><strong><em>Calculating Eccentricity</em></strong></h4>
<p class="noindent">You’re through defining classes. Now it’s time to define some functions that will help with running the game. <a href="ch14.xhtml#ch14list11">Listing 14-11</a> defines a function to calculate the eccentricity of the satellite’s orbit. The player will need to achieve a circular orbit within a certain altitude range, and this function will provide the measurement of circularity.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 11</p>
<pre><span class="ent">➊</span> def calc_eccentricity(dist_list):<br/>       """Calculate &amp; return eccentricity from list of radii."""<br/>    <span class="ent">➋</span> apoapsis = max(dist_list)<br/>       periapsis = min(dist_list)<br/>    <span class="ent">➌</span> eccentricity = (apoapsis - periapsis) / (apoapsis + periapsis)<br/>       return eccentricity</pre>
<p class="listing" id="ch14list11"><em><a href="ch14.xhtml#ch14list11">Listing 14-11</a>: Defines a function to measure orbital eccentricity</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_309"/>Define the <code>calc_eccentricity()</code> function and pass it a list of distances <span class="ent">➊</span>. In the <code>main()</code> function, you’ll append the <code>sat.distance</code> attribute—which records the satellite’s altitude—to this list during every game loop. To calculate eccentricity, you need to know both the apoapsis and periapsis of the orbit. Get these by finding the maximum and minimum values in this list <span class="ent">➋</span>. Then, calculate <code>eccentricity</code> <span class="ent">➌</span>. Later, in the <code>main()</code> function, you’ll display this number to eight decimal places, just to look cool and precise in the readout.</p>
<p class="indent">Note that circular orbits will have the same value for both apoapsis and periapsis, and so the calculation will yield <code>0</code> for a perfect circle. End the function by returning the <code>eccentricity</code> variable.</p>
<h4 class="h4" id="lev342"><strong><em>Defining Functions to Make Labels</em></strong></h4>
<p class="noindent">The game will need a fair amount of text for instructions and telemetry readouts. Displaying this text one string at a time can result in a lot of code redundancy, so <a href="ch14.xhtml#ch14list12">Listing 14-12</a> will define two functions—one to post instructions and another for the streams of velocity, altitude, fuel, and eccentricity data you’ll need to share with the player.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 12</p>
<pre><span class="ent">➊</span> def instruct_label(screen, text, color, x, y):<br/>       """Take screen, list of strings, color, &amp; origin &amp; render text to screen."""<br/>    <span class="ent">➋</span> instruct_font = pg.font.SysFont(None, 25)<br/>    <span class="ent">➌</span> line_spacing = 22<br/>    <span class="ent">➍</span> for index, line in enumerate(text):<br/>           label = instruct_font.render(line, True, color, BLACK)<br/>           screen.blit(label, (x, y + index * line_spacing))<br/><br/><span class="ent">➎</span> def box_label(screen, text, dimensions):<br/>       """Make fixed-size label from screen, text &amp; left, top, width, height."""<br/>       readout_font = pg.font.SysFont(None, 27)<br/>    <span class="ent">➏</span> base = pg.Rect(dimensions)<br/>    <span class="ent">➐</span> pg.draw.rect(screen, WHITE, base, 0)<br/>    <span class="ent">➑</span> label = readout_font.render(text, True, BLACK)<br/>    <span class="ent">➒</span> label_rect = label.get_rect(center=base.center)<br/>    <span class="ent">➓</span> screen.blit(label, label_rect)</pre>
<p class="listing" id="ch14list12"><em>Listing 14-12: Defines functions to make instruction and readout labels</em></p>
<p class="indent">Define a function called <code>instruct_label()</code> for displaying instructions on the game screen <span class="ent">➊</span>. Pass it the screen, a list containing the text, a text color, and the coordinates for the upper-left corner of the <code>pygame</code> <code>surface</code> object that will hold the text.</p>
<p class="indent">Next, tell <code>pygame</code> which font to use <span class="ent">➋</span>. The arguments for the <code>font.SysFont()</code> method are the typeface and size. Using <code>None</code> for the typeface invokes <code>pygame</code>’s built-in default font, which should work on multiple platforms. Note that the method accepts both <code>None</code> and <code>'None'</code>.</p>
<p class="indent">The introduction and instruction text will take up multiple lines (see the example in <a href="ch14.xhtml#ch14fig14">Figure 14-14</a>). You’ll need to specify the line spacing, in pixels, between the text strings, so assign a variable for this and set it to <code>22</code> <span class="ent">➌</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_310"/>Now, start looping through the list of text strings <span class="ent">➍</span>. Use <code>enumerate()</code> to get an index, which you’ll use with the <code>line_spacing</code> variable to post the strings in the correct locations. The text will need to be placed on a surface. Name this surface <code>label</code>, pass the <code>font.render()</code> method the line of text you want to display, set antialiasing to <code>True</code> for smoother text, color the text, and set the background color to black. Finish by blitting the surface to the screen. Pass the method the <code>label</code> variable and the upper-left-corner coordinates, with <code>y</code> defined as <code>y + index * line_spacing</code>.</p>
<p class="indent">Next, define a function called <code>box_label()</code> for the data readout labels that will appear as gauges at the top of the screen (see <a href="ch14.xhtml#ch14fig18">Figure 14-18</a>) <span class="ent">➎</span>. Parameters for this function are the screen, some text, and a tuple containing the dimensions of the rectangular surface that will form the gauge.</p>
<div class="image"><a id="ch14fig18"/><img src="../images/f0310-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-18: Readout labels at the top of the game window (header label above and data label below)</em></p>
<p class="indent">The surfaces made by the <code>instruct_label()</code> function will automatically change size to accommodate the amount of text being displayed. This works fine for static displays, but the readout data will change constantly, causing your gauges to expand and shrink as they adjust to fit the text inside them. To mitigate this, you’ll use a stand-alone <code>rect</code> object of a specified size to form a base for your text object.</p>
<p class="indent">Start the function by setting the font, as you did in <span class="ent">➋</span>. Assign a variable called <code>base</code> to a <code>pygame</code> <code>rect</code> object; use the <code>dimensions</code> argument for the size <span class="ent">➏</span>. This argument lets you precisely place the position of the box by specifying the left and top coordinates of the rectangle, followed by its width and height. The resulting rectangle should be wide enough to handle the longest possible readout the game will produce for the data type being displayed.</p>
<p class="indent">Now, draw the <code>base</code> using the <code>draw_rect()</code> method <span class="ent">➐</span>. The arguments are the drawing surface, a fill color, the name of the <code>rect</code>, and a width of <code>0</code>, which fills the rectangle rather than drawing a border. You’ll post your text object on top of this white rectangle.</p>
<p class="indent">Repeat the code that renders the text <span class="ent">➑</span>, then get the <code>rect</code> for the <code>label</code> <span class="ent">➒</span>. Note that in the <code>get_rect()</code> method there’s a parameter that sets the center equal to the center of <code>base</code>. This lets you place the text label on top of the white base rectangle. Finally, blit to the screen, specifying the source and destination rects <span class="ent">➓</span>.</p>
<h4 class="h4" id="lev343"><span epub:type="pagebreak" id="page_311"/><strong><em>Mapping Soil Moisture</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list13">Listing 14-13</a> defines functions that allow the player to “map” Mars if the game’s winning conditions have been met. When the player presses the M key, these functions will be called by the <code>main()</code> function, and the planet’s image will be replaced with a colorful overlay we’ll pretend represents soil moisture content. When the player releases the key, the normal view of Mars will return. The key checks will also be performed in the <code>main()</code> function.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 13</p>
<pre><span class="ent">➊</span> def mapping_on(planet):<br/>       """Show soil moisture image of planet."""<br/>    <span class="ent">➋</span> last_center = planet.rect.center<br/>    <span class="ent">➌</span> planet.image_copy = pg.transform.scale(planet.image_water, (100, 100))<br/>    <span class="ent">➍</span> planet.image_copy.set_colorkey(BLACK)<br/>       planet.rect = planet.image_copy.get_rect()<br/>       planet.rect.center = last_center<br/><br/><span class="ent">➎</span> def mapping_off(planet):<br/>       """Restore normal planet image."""<br/>    <span class="ent">➏</span> planet.image_copy = pg.transform.scale(planet.image_mars, (100, 100))<br/>       planet.image_copy.set_colorkey(BLACK)</pre>
<p class="listing" id="ch14list13"><em>Listing 14-13: Defines functions to let the player make a soil moisture map of Mars</em></p>
<p class="indent">Start by defining a function that takes as an argument the <code>planet</code> object <span class="ent">➊</span>. Start by assigning a <code>last_center</code> variable as you did in <a href="ch14.xhtml#ch14list9">Listing 14-9</a>; this will be used to keep the planet from wobbling on its axis <span class="ent">➋</span>.</p>
<p class="indent">Next, scale the water image of Mars to the same size as the normal image and assign this to the planet’s <code>image_copy</code> attribute, because transformations degrade an image if used repeatedly <span class="ent">➌</span>. Set the image’s background to transparent <span class="ent">➍</span>, get its <code>rect</code>, and set the center of the <code>rect</code> equal to the <code>last_center</code> variable; that way Mars will stay put at the center of the screen.</p>
<p class="indent">Now, define another function for when the player stops actively mapping Mars <span class="ent">➎</span>. It also takes the <code>planet</code> object as an argument. All you need to do is reset the planet image to the original version <span class="ent">➏</span>. Because you’re still using the <code>image_copy</code> attribute, you don’t need to get the <code>rect</code> again, but you do need to set the transparent color.</p>
<h4 class="h4" id="lev344"><strong><em>Casting a Shadow</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list14">Listing 14-14</a> defines a function that gives Mars a “dark side” and casts a shadow behind the planet. The shadow will be a black, semitransparent rectangle with its right edge coincident with the center of the planet sprite (see <a href="ch14.xhtml#ch14fig19">Figure 14-19</a>). This assumes the sun is to the right of the screen and that it is either the vernal or autumnal equinox on Mars.</p>
<div class="image"><span epub:type="pagebreak" id="page_312"/><a id="ch14fig19"/><img src="../images/f0312-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-19: Shadow rectangle in semitransparent white (left) and final semitransparent black (right)</em></p>
<p class="margin"><em>mars_orbiter.py,</em> part 14</p>
<pre><span class="ent">➊</span> def cast_shadow(screen):<br/>       """Add optional terminator &amp; shadow behind planet to screen."""<br/>    <span class="ent">➋</span> shadow = pg.Surface((400, 100), flags=pg.SRCALPHA)  # tuple is w,h<br/>    <span class="ent">➌</span> shadow.fill((0, 0, 0, 210))  # last number sets transparency<br/>       screen.blit(shadow, (0, 270))  # tuple is top left coordinates</pre>
<p class="listing" id="ch14list14"><em>Listing 14-14: Defines a function to give Mars a dark side and let it cast a shadow</em></p>
<p class="indent">The <code>cast_shadow()</code> function takes the <code>screen</code> object as an argument <span class="ent">➊</span>. Assign a 400 pixel × 100 pixel <code>pygame</code> surface to an object named <code>shadow</code> <span class="ent">➋</span>. Use <code>pygame</code>’s <code>SRCALPHA</code> flag—for “source alpha”—to indicate you will use per pixel alpha (transparency). Fill the object with black and set alpha—represented by the last number—to <code>210</code> <span class="ent">➌</span>. Alpha is part of the RGBA color system and has valid values of 0 through 255, so this is very dark but not completely opaque. Finally, blit the surface to the screen, along with the coordinates for its top-left corner. To turn off the shadow, just comment out the function call in <code>main()</code> or set the alpha value to <code>0</code>.</p>
<h4 class="h4" id="lev345"><strong><em>Defining the main() Function</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list15">Listing 14-15</a> begins the definition of the <code>main()</code> function that runs the game. The <code>pygame</code> package and the sound mixer are initialized, the game screen is set up, and instructions for the player are stored as lists.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 15</p>
<pre>def main():<br/>       """Set up labels &amp; instructions, create objects &amp; run the game loop."""<br/>    <span class="ent">➊</span> pg.init()  # initialize pygame<br/><br/>       # set up display:<br/>    <span class="ent">➋</span> os.environ['SDL_VIDEO_WINDOW_POS'] = '700, 100'  # set game window origin<br/>    <span class="ent">➌</span> screen = pg.display.set_mode((800, 645), pg.FULLSCREEN)<br/>   <span epub:type="pagebreak" id="page_313"/> <span class="ent">➍</span> pg.display.set_caption("Mars Orbiter")<br/>    <span class="ent">➎</span> background = pg.Surface(screen.get_size())<br/><br/>    <span class="ent">➏</span> pg.mixer.init()  # for sound effects<br/><br/>    <span class="ent">➐</span> intro_text = [<br/>           ' The Mars Orbiter experienced an error during Orbit insertion.',<br/>           ' Use thrusters to correct to a circular mapping orbit without',<br/>           ' running out of propellant or burning up in the atmosphere.'<br/>           ]<br/><br/>       instruct_text1 = [<br/>           'Orbital altitude must be within 69-120 miles',<br/>           'Orbital Eccentricity must be &lt; 0.05',<br/>           'Avoid top of atmosphere at 68 miles'<br/>           ]<br/><br/>       instruct_text2 = [<br/>           'Left Arrow = Decrease Dx',<br/>           'Right Arrow = Increase Dx',<br/>           'Up Arrow = Decrease Dy',<br/>           'Down Arrow = Increase Dy',<br/>           'Space Bar = Clear Path',<br/>           'Escape = Exit Full Screen'<br/>           ]</pre>
<p class="listing" id="ch14list15"><em>Listing 14-15: Starts the</em> <span class="codeitalic">main()</span> <em>function by initializing</em> <span class="codeitalic">pygame</span> <em>and the sound mixer and by setting up the game screen and instructions</em></p>
<p class="indent">Start the <code>main()</code> function by initializing <code>pygame</code> <span class="ent">➊</span>. Then, use the <code>os</code> module’s <code>environ()</code> method to assign the coordinates of the upper-left corner of the game window <span class="ent">➋</span>. This step is not strictly necessary, but I wanted to demonstrate that you have control over where windows appear on the desktop.</p>
<p class="indent">Next, assign a variable to hold the <code>screen</code> object and set the display mode to full screen <span class="ent">➌</span>. Use the tuple <code>(800, 645)</code> to specify the screen size to use if the player escapes from full-screen mode.</p>
<p class="indent">Now use <code>pygame</code>’s <code>display.set_caption()</code> method to name the game window “Mars Orbiter” <span class="ent">➍</span>. Then, use <code>pygame</code>’s <code>Surface</code> class to create a background object for the game that’s the same size as the screen <span class="ent">➎</span>.</p>
<p class="indent">Initialize <code>pygame</code>’s sound mixer so you can play the thruster sound effect <span class="ent">➏</span>. You defined this sound earlier in the satellite’s initialization method.</p>
<p class="indent">The game will start with a short introduction that will vanish after 15 seconds. Permanent legends describing keyboard controls and win conditions occupy the bottom corners of the screen. Enter the text for these as lists <span class="ent">➐</span>. Later, you will pass these lists to the <code>instruct_label()</code> function you wrote in <a href="ch14.xhtml#ch14list12">Listing 14-12</a>. Each item in the list, delineated by a comma, will appear as a separate line in the game window (see <a href="ch14.xhtml#ch14fig19">Figure 14-19</a>).</p>
<h4 class="h4" id="lev346"><span epub:type="pagebreak" id="page_314"/><strong><em>Instantiating Objects, Setting Up Orbit Verification, Mapping, and Timekeeping</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list16">Listing 14-16</a>, still in the <code>main()</code> function, instantiates the <code>planet</code> and <code>satellite</code> objects, assigns some useful variables for determining orbital eccentricity, prepares the game clock within the function, and assigns a variable to track the state of the mapping functionality.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 16</p>
<pre>       # instantiate planet and satellite objects<br/>    <span class="ent">➊</span> planet = Planet()<br/>    <span class="ent">➋</span> planet_sprite = pg.sprite.Group(planet)<br/>    <span class="ent">➌</span> sat = Satellite(background)<br/>    <span class="ent">➍</span> sat_sprite = pg.sprite.Group(sat)<br/><br/>       # for circular orbit verification<br/>    <span class="ent">➎</span> dist_list = []<br/>    <span class="ent">➏</span> eccentricity = 1<br/>    <span class="ent">➐</span> eccentricity_calc_interval = 5  # optimized for 120 mile altitude<br/><br/>       # time keeping<br/>    <span class="ent">➑</span> clock = pg.time.Clock()<br/>       fps = 30<br/>       tick_count = 0<br/><br/>       # for soil moisture mapping functionality<br/>    <span class="ent">➒</span> mapping_enabled = False</pre>
<p class="listing" id="ch14list16"><em>Listing 14-16: Instantiates objects and assigns useful variables in</em> <span class="codeitalic">main()</span></p>
<p class="indent">Continue the <code>main()</code> function by creating a <code>planet</code> object from the <code>Planet</code> class <span class="ent">➊</span>, then place it in a sprite group <span class="ent">➋</span>. Remember from <a href="ch13.xhtml#ch13">Chapter 13</a> that <code>pygame</code> manages sprites using containers called <em>groups</em>.</p>
<p class="indent">Next, instantiate a satellite object, passing the <code>Satellite</code> class’s initialization method the <code>background</code> object <span class="ent">➌</span>. The satellite needs the <code>background</code> for drawing its path.</p>
<p class="indent">After creating the satellite, put it in its own sprite group <span class="ent">➍</span>. You should generally keep radically different sprite types in their own containers. This makes it easy to manage things like display order and collision handling.</p>
<p class="indent">Now, assign some variables to help with calculating eccentricity. Start an empty list to hold the distance values calculated in each game loop <span class="ent">➎</span>, then assign an <code>eccentricity</code> variable a placeholder value of <code>1</code> <span class="ent">➏</span>, indicating a noncircular starting orbit.</p>
<p class="indent">You’ll want to update the <code>eccentricity</code> variable regularly to evaluate any changes the player makes to the orbit. Remember, you need the orbit’s apoapsis and periapsis to calculate eccentricity, and for large, elliptical orbits, it may take a while to actually sample these. The good news is that you only need to consider “winning” orbits between 69 and 120 miles. So, you can optimize the sampling rate for orbits below 120 miles, which generally take the satellite sprite less than 6 seconds to complete. Use 5 seconds and assign this value to an <code>eccentricity_calc_interval</code> variable <span class="ent">➐</span>. This means that, <span epub:type="pagebreak" id="page_315"/>for orbits with altitudes above 120 miles, the calculated eccentricity may not be technically correct, but it will be good enough considering the orbit doesn’t satisfy the winning conditions at that altitude.</p>
<p class="indent">Address timekeeping next. Use a <code>clock</code> variable to hold <code>pygame</code>’s game clock, which will control the speed of the game in frames per second <span class="ent">➑</span>. Each frame will represent one tick of the clock. Assign a variable named <code>fps</code> a value of <code>30</code>, which means the game will update 30 times per second. Next, assign a <code>tick_count</code> variable that you’ll use to determine when to clear the introduction text and when to call the <code>calc_eccentricity()</code> function.</p>
<p class="indent">Finish the section by naming a variable to enable the mapping functionality and set it to <code>False</code> <span class="ent">➒</span>. If the player achieves the winning conditions, you’ll change this to <code>True</code>.</p>
<h4 class="h4" id="lev347"><strong><em>Starting the Game Loop and Playing Sounds</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list17">Listing 14-17</a>, still in the <code>main()</code> function, starts the game clock and <code>while</code> loop, also referred to as the <em>game loop</em>. It also receives events, such as a player firing thrusters using the arrow keys. If the player fires the thrusters, the Ogg Vorbis audio file plays, and the player hears a satisfying hiss.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 17</p>
<pre>    <span class="ent">➊</span> running = True<br/>       while running:<br/>        <span class="ent">➋</span> clock.tick(fps)<br/>           tick_count += 1<br/>        <span class="ent">➌</span> dist_list.append(sat.distance)<br/><br/>           # get keyboard input<br/>        <span class="ent">➍</span> for event in pg.event.get():<br/>            <span class="ent">➎</span> if event.type == pg.QUIT:  # close window<br/>                   running = False<br/>            <span class="ent">➏</span> elif event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE:<br/>                   screen = pg.display.set_mode((800, 645))  # exit full screen<br/>            <span class="ent">➐</span> elif event.type == pg.KEYDOWN and event.key == pg.K_SPACE:<br/>                   background.fill(BLACK)  # clear path<br/>            <span class="ent">➑</span> elif event.type == pg.KEYUP:<br/>                <span class="ent">➒</span> sat.thrust.stop()  # stop sound<br/>                   mapping_off(planet)  # turn off moisture map view<br/>            <span class="ent">➓</span> elif mapping_enabled:<br/>                   if event.type == pg.KEYDOWN and event.key == pg.K_m:<br/>                       mapping_on(planet)</pre>
<p class="listing" id="ch14list17"><em>Listing 14-17: Starts the game loop, gets events, and plays sounds in</em> <span class="codeitalic">main()</span></p>
<p class="indent">First assign a <code>running</code> variable for use with the <code>while</code> loop that runs the game <span class="ent">➊</span>, then start the loop. Set the game speed using the clock’s <code>tick()</code> method and pass it the <code>fps</code> variable you named in the previous listing <span class="ent">➋</span>. If the game feels slow to you, set the speed to 40 fps. For each loop—or frame—increment the clock-based counter by 1.</p>
<p class="indent">Next, append the satellite object’s <code>sat.distance</code> value to <code>dist_list</code> <span class="ent">➌</span>. This is the distance between the satellite and the planet, calculated each game loop by the satellite’s <code>locate()</code> method.</p>
<p class="indent"><span epub:type="pagebreak" id="page_316"/>Now, gather player input made through the keyboard <span class="ent">➍</span>. As described in the previous chapter, <code>pygame</code> records every user interaction—called an <em>event</em>—in an event buffer. The <code>event.get()</code> method creates a list of these events that you can evaluate, in this case, with <code>if</code> statements. Start by checking if the player closed the window to quit the game <span class="ent">➎</span>. If this is <code>True</code>, set running to <code>False</code> to end the game loop.</p>
<p class="indent">If the player presses <small>ESC</small>, they are exiting full-screen mode, so reset the screen size to 800 × 645 pixels using the <code>display.set_mode()</code> method that you called at the start of <code>main()</code> <span class="ent">➏</span>. If the player presses the space bar, fill the background with black, which will erase the white orbital path of the satellite <span class="ent">➐</span>.</p>
<p class="indent">When the player presses an arrow key, the satellite object plays the hissing sound, but nothing in its <code>check_keys()</code> method tells it to stop. So, pass <code>pygame</code> any <code>KEYUP</code> events <span class="ent">➑</span>; when <code>pygame</code> reads that the player has released the arrow key, call the <code>stop()</code> method on <code>thrust</code> to stop the sound from playing <span class="ent">➒</span>.</p>
<p class="indent">To map Mars, the player will have to hold down the M key, so use the same <code>KEYUP</code> event to call the <code>mapping_off()</code> function. This will reset the planet image to its normal, nonmapped state.</p>
<p class="indent">Finally, check whether the <code>mapping_enabled</code> variable is <code>True</code>, meaning the player has achieved the winning conditions and is ready to map Mars <span class="ent">➓</span>. If they press the M key, call the <code>mapping_on()</code> function to show the soil moisture overlay in place of the normal view of the planet.</p>
<h4 class="h4" id="lev348"><strong><em>Applying Gravity, Calculating Eccentricity, and Handling Failure</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list18">Listing 14-18</a> continues the <code>while</code> loop of the <code>main()</code> function by exerting a gravity force on the satellite and then calculating the eccentricity of its orbit. The eccentricity value will determine whether the orbit is circular or not, one of the game’s winning conditions. The listing also blits the background and responds to the fail conditions of running out of fuel or burning up in the atmosphere.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 18</p>
<pre>           # get heading &amp; distance to planet &amp; apply gravity<br/>        <span class="ent">➊</span> sat.locate(planet)<br/>           planet.gravity(sat)<br/><br/>           # calculate orbital eccentricity<br/>        <span class="ent">➋</span> if tick_count % (eccentricity_calc_interval * fps) == 0:<br/>               eccentricity = calc_eccentricity(dist_list)<br/>            <span class="ent">➌</span> dist_list = []<br/><br/>           # re-blit background for drawing command - prevents clearing path<br/>        <span class="ent">➍</span> screen.blit(background, (0, 0))<br/><br/>           # Fuel/Altitude fail conditions<br/>        <span class="ent">➎</span> if sat.fuel &lt;= 0:<br/>            <span class="ent">➏</span> instruct_label(screen, ['Fuel Depleted!'], RED, 340, 195)<br/>               sat.fuel = 0<br/>               sat.dx = 2<br/>        <span class="ent">➐</span> elif sat.distance &lt;= 68:<br/>               instruct_label(screen, ['Atmospheric Entry!'], RED, 320, 195)<br/>   <span epub:type="pagebreak" id="page_317"/>            sat.dx = 0<br/>               sat.dy = 0</pre>
<p class="listing" id="ch14list18"><em>Listing 14-18: Applies gravity, calculates eccentricity, and addresses fail conditions</em></p>
<p class="indent">Call the satellite’s <code>locate()</code> method and pass it the <code>planet</code> object as an argument <span class="ent">➊</span>. This method computes the heading and distance to Mars, which you use to point the dish, calculate orbital eccentricity, and apply gravity. Then, to apply the force of gravity, call the planet’s <code>gravity()</code> method and pass it the satellite object.</p>
<p class="indent">If the modulus of the <code>tick_count</code> and the <code>eccentricity_calc_interval</code> <code>*</code> <code>fps</code> is <code>0</code> <span class="ent">➋</span>, call the function that calculates eccentricity and pass it the <code>dist_list</code> variable. Then, reset the <code>dist_list</code> variable to <code>0</code> to restart the distance sampling <span class="ent">➌</span>.</p>
<p class="indent">Next, call the screen’s <code>blit()</code> method and pass it the background and coordinates for the upper-left corner <span class="ent">➍</span>. The placement of this statement matters. For example, if you move it after the code that updates the sprites, you won’t see the satellite or Mars on the game screen.</p>
<p class="indent">Now, handle the case where the player runs out of fuel before achieving a circular orbit. First, get the current fuel level from the satellite object’s <code>fuel</code> attribute <span class="ent">➎</span>. If the level is at or below <code>0</code>, use the <code>instruct_label()</code> function to announce that the fuel is spent <span class="ent">➏</span>, then set the satellite’s <code>dx</code> attribute to <code>2</code>. This will cause the satellite sprite to quickly fly off the screen and into the depths of space, with the altitude readout getting larger and larger. Though unrealistic, this ensures the player knows they have failed!</p>
<p class="indent">The last failure case is when the player burns up in the atmosphere. If the satellite’s <code>distance</code> attribute is less than or equal to <code>68</code> <span class="ent">➐</span>, make a label near the center of the screen that lets the player know they have entered the atmosphere and then set the satellite’s velocity attributes equal to <code>0</code>. This will cause gravity to lock the sprite against the planet (<a href="ch14.xhtml#ch14fig20">Figure 14-20</a>). Also, when <code>dx</code> and <code>dy</code> are <code>0</code>, the satellite’s <code>update()</code> method (<a href="ch14.xhtml#ch14list7">Listing 14-7</a>) will switch the satellite’s image to the red “crashed” version.</p>
<div class="image"><a id="ch14fig20"/><img src="../images/f0317-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-20: Satellite in crash configuration</em></p>
<p class="indent">The altitude parameter is a bit of a cheat, as altitude equates to the <code>distance</code> attribute, which is measured from the <em>centers</em> of the planet and <span epub:type="pagebreak" id="page_318"/>satellite sprites, rather than from the <em>surface</em> of the planet to the satellite. It all comes down to scale. Planetary atmospheres are very thin veneers—at the scale of the game, the Martian atmosphere would be less than 2 pixels thick! As the game is designed, when the tip of the satellite dish scrapes the planet, the satellite will burn up, but since the size of the satellite sprite is unrealistically large, the sprite’s 68-mile center point must be pushed farther out.</p>
<h4 class="h4" id="lev349"><strong><em>Rewarding Success and Updating and Drawing Sprites</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list19">Listing 14-19</a>, still in the <code>while</code> loop of the <code>main()</code> function, rewards the winning player by enabling functionality that lets them map the moisture content in the Martian soil. In real life, this might be accomplished with radar or microwave resonators, which can remotely measure moisture in bare soil down to a depth of a few inches. The listing also updates the planet and satellite sprites and draws them to the screen.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 19</p>
<pre>           # enable mapping functionality<br/>        <span class="ent">➊</span> if eccentricity &lt; 0.05 and sat.distance &gt;= 69 and sat.distance &lt;= 120:<br/>            <span class="ent">➋</span> map_instruct = ['Press &amp; hold M to map soil moisture']<br/>               instruct_label(screen, map_instruct, LT_BLUE, 250, 175)<br/>            <span class="ent">➌</span> mapping_enabled = True<br/>           else:<br/>               mapping_enabled = False<br/><br/>        <span class="ent">➍</span> planet_sprite.update()<br/>        <span class="ent">➎</span> planet_sprite.draw(screen)<br/>           sat_sprite.update()<br/>           sat_sprite.draw(screen)</pre>
<p class="listing" id="ch14list19"><em>Listing 14-19: Enables mapping functionality and updates sprites in the game loop</em></p>
<p class="indent">If the orbit is circular and meets the altitude requirements <span class="ent">➊</span>, display a message instructing the player to press the M key to map soil moisture <span class="ent">➋</span>. Put the text in brackets, as the <code>instruct_label()</code> function expects a list. Make the text color light blue and place it near the center of the screen.</p>
<p class="indent">Next, set the <code>mapping_enabled</code> variable to <code>True</code> <span class="ent">➌</span>; otherwise, if the orbit strays outside of the target parameters, set it to <code>False</code>.</p>
<p class="indent">Finish by calling the planet sprite’s <code>update()</code> method, through the sprite group <span class="ent">➍</span>, then actually draw it to the screen <span class="ent">➎</span>. The argument for the <code>draw()</code> method is the <code>screen</code>, the object on which to draw the sprites. Repeat these steps for the satellite sprite.</p>
<h4 class="h4" id="lev350"><strong><em>Displaying Instructions and Telemetry and Casting a Shadow</em></strong></h4>
<p class="noindent"><a href="ch14.xhtml#ch14list20">Listing 14-20</a> completes the <code>while</code> loop and the <code>main()</code> function by displaying instructions, data readouts, and the planet’s shadow. The game introduction text will be shown only for a short time at startup.</p>
<p class="margin"><em>mars_orbiter.py,</em> part 20</p>
<pre>           # display intro text for 15 seconds<br/>        <span class="ent">➊</span> if pg.time.get_ticks() &lt;= 15000:  # time in milliseconds<br/>   <span epub:type="pagebreak" id="page_319"/>            instruct_label(screen, intro_text, GREEN, 145, 100)<br/><br/>           # display telemetry and instructions<br/>        <span class="ent">➋</span> box_label(screen, 'Dx', (70, 20, 75, 20))<br/>           box_label(screen, 'Dy', (150, 20, 80, 20))<br/>           box_label(screen, 'Altitude', (240, 20, 160, 20))<br/>           box_label(screen, 'Fuel', (410, 20, 160, 20))<br/>           box_label(screen, 'Eccentricity', (580, 20, 150, 20))<br/><br/>        <span class="ent">➌</span> box_label(screen, '{:.1f}'.format(sat.dx), (70, 50, 75, 20))<br/>           box_label(screen, '{:.1f}'.format(sat.dy), (150, 50, 80, 20))<br/>           box_label(screen, '{:.1f}'.format(sat.distance), (240, 50, 160, 20))<br/>           box_label(screen, '{}'.format(sat.fuel), (410, 50, 160, 20))<br/>           box_label(screen, '{:.8f}'.format(eccentricity), (580, 50, 150, 20))<br/><br/>        <span class="ent">➍</span> instruct_label(screen, instruct_text1, WHITE, 10, 575)<br/>           instruct_label(screen, instruct_text2, WHITE, 570, 510)<br/><br/>           # add terminator &amp; border<br/>        <span class="ent">➎</span> cast_shadow(screen)<br/>        <span class="ent">➏</span> pg.draw.rect(screen, WHITE, (1, 1, 798, 643), 1)<br/><br/>        <span class="ent">➐</span> pg.display.flip()<br/><br/><span class="ent">➑</span> if __name__ == "__main__":<br/>       main()</pre>
<p class="listing" id="ch14list20"><em>Listing 14-20: Displays text and planet’s shadow and calls the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">The text summarizing the game should hover near the middle of the screen just long enough to be read, then vanish. Control this using an <code>if</code> statement and the <code>pygame</code> <code>tick.get_ticks()</code> method, which returns the number of milliseconds that have elapsed since the game started. If fewer than 15 seconds have passed, use the <code>instruct_label()</code> function to display the list of text strings from <a href="ch14.xhtml#ch14list15">Listing 14-15</a> in green.</p>
<p class="indent">Next, make the gauges for the data readouts, starting with the header boxes. Use the <code>box_label()</code> function and call it for each of the five readout gauges <span class="ent">➋</span>. Repeat this for the data readouts <span class="ent">➌</span>. Note that you can use the string format method when you pass the function the text.</p>
<p class="indent">Use the <code>instruct_label()</code> function to place the instructions made in <a href="ch14.xhtml#ch14list15">Listing 14-15</a> in the bottom corners of the screen <span class="ent">➍</span>. Feel free to change the text color if you want to distinguish between those that describe the winning conditions and those that define the key functions.</p>
<p class="indent">Now, call the function that displays the planet’s shadow <span class="ent">➎</span> and then, as a finishing touch, add a border using <code>pygame</code>’s <code>draw.rect()</code> method <span class="ent">➏</span>. Pass it the <code>screen</code> object, the border color, the corner coordinates, and a line width.</p>
<p class="indent">Finish the <code>main()</code> function and its game loop by flipping the display <span class="ent">➐</span>. As described in the preceding chapter, the <code>flip()</code> method blits everything from the screen object to the visual display.</p>
<p class="indent">Finally, call <code>main()</code> in the global space, using the standard syntax for running it stand-alone or as a module <span class="ent">➑</span>.</p>
<h3 class="h3" id="lev351"><span epub:type="pagebreak" id="page_320"/><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you used <code>pygame</code> to build a 2D, arcade-style game with image sprites, sound effects, and keyboard game controls. You also created a fun, heuristic method for learning orbital mechanics. All of the techniques shown in “<a href="ch14.xhtml#lev315">Astrodynamics for Gamers</a>” on <a href="ch14.xhtml#page_286">page 286</a> should work in the game. In the following section, “Challenge Projects,” you can continue to improve both the game and the player experience.</p>
<h3 class="h3" id="lev352"><strong>Challenge Projects</strong></h3>
<p class="noindent">Make the Mars Orbiter game your own by improving it and adding new challenges based on the following suggestions. As always, no solutions are provided to challenge projects.</p>
<h4 class="h4" id="lev353"><strong><em>Game Title Screen</em></strong></h4>
<p class="noindent">Copy and edit the <em>mars_orbiter.py</em> program so that a title screen appears for a short time before the main game screen. Have the title screen display a NASA-type mission patch, like the one for the <em>Mars Global Surveyor</em> (<a href="ch14.xhtml#ch14fig21">Figure 14-21</a>), but make it unique to the Mars Orbiter in the game. You can see some other NASA patches, in color, at <em><a href="https://space.jpl.nasa.gov/art/patches.html">https://space.jpl.nasa.gov/art/patches.html</a></em>.</p>
<div class="image"><a id="ch14fig21"/><img src="../images/f0320-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-21:</em> Mars Global Surveyor <em>mission patch</em></p>
<h4 class="h4" id="lev354"><strong><em>Smart Gauges</em></strong></h4>
<p class="noindent">Copy and edit the <em>mars_orbiter.py</em> program so that the altitude and eccentricity readouts use either a red background or red text color when their values are outside of the target ranges. But be careful: a circular eccentricity value should stay red until the altitude value is in range!</p>
<h4 class="h4" id="lev355"><strong><em>Radio Blackout</em></strong></h4>
<p class="noindent">Copy and edit the <em>mars_orbiter.py</em> program so that keyboard controls are locked when the satellite is within the <code>shadow</code> rectangle.</p>
<h4 class="h4" id="lev356"><strong><em>Scoring</em></strong></h4>
<p class="noindent">Copy and edit the <em>mars_orbiter.py</em> program so that it scores the player and keeps the best results in a displayable high-scores list. Highest scores go to those achieving the lowest allowable orbit while using the least amount of fuel in the least amount of time. For example, the fuel component of the score could be the amount of remaining fuel; for the orbit component, the maximum allowable altitude (120) minus the altitude of the circular orbit; <span epub:type="pagebreak" id="page_321"/>and for the time component, the inverse of the time taken to achieve the circular orbit multiplied by 1,000. Add the three components together for the final score.</p>
<h4 class="h4" id="lev357"><strong><em>Strategy Guide</em></strong></h4>
<p class="noindent">Copy and edit the <em>mars_orbiter.py</em> program so it includes a pop-up strategy guide, or help file, by incorporating some of the figures in “<a href="ch14.xhtml#lev315">Astrodynamics for Gamers</a>” on <a href="ch14.xhtml#page_286">page 286</a>. For example, add a line to the instructions telling the player to press and hold the H key for help. This could bring up and cycle through the images of different orbital maneuvers, such as the Hohmann transfer or the One-Tangent Burn. Be sure to include comments on the strengths and weaknesses of each technique and pause the game while the guide is open.</p>
<h4 class="h4" id="lev358"><strong><em>Aerobraking</em></strong></h4>
<p class="noindent">Aerobraking is a fuel-saving technique that uses atmospheric friction to slow down a spacecraft (<a href="ch14.xhtml#ch14fig22">Figure 14-22</a>). Copy and edit the <em>mars_orbiter.py</em> program to include aerobraking. In the <code>main()</code> function, set the lowest winning altitude to 70 miles and the lowest safe altitude to 60 miles. If the satellite’s altitude is between 60 and 70 miles, reduce its velocity by a small amount.</p>
<div class="image"><a id="ch14fig22"/><img src="../images/f0321-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-22: Circularizing an orbit using the atmosphere in place of a retrograde burn</em></p>
<p class="indent"><a href="ch14.xhtml#ch14fig23">Figure 14-23</a> is an example of using aerobraking in the game to circularize an elliptical orbit. The top of the atmosphere was set at 80 miles. Aerobraking serves the same purpose as a retrograde burn at periapsis, but you have to be cautious and patient and raise the orbit out of the atmosphere before it becomes circular.</p>
<div class="image"><span epub:type="pagebreak" id="page_322"/><a id="ch14fig23"/><img src="../images/f0322-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-23: Circularizing an orbit using aerobraking. Note the low fuel consumption.</em></p>
<p class="indent">NASA used a similar technique to move the <em>Mars Global Surveyor</em> from its elliptical capture orbit to its final mapping orbit. This process took many months to accomplish, because they needed to protect the spacecraft from overheating in the atmosphere.</p>
<h4 class="h4" id="lev359"><strong><em>Intruder Alert!</em></strong></h4>
<p class="noindent">Copy and edit the <em>mars_orbiter.py</em> program so that a new <code>planet</code> object is instantiated and flies across the screen, disrupting the satellite’s orbit with its gravity. Make a new sprite to represent a comet or asteroid and launch it at random intervals (but not <em>too</em> often!). Don’t apply Mars’s <code>gravity()</code> method to the object so that it doesn’t enter Martian orbit, but apply the new object’s <code>gravity()</code> method to the satellite. Play with the new object’s mass so that it noticeably perturbs the satellite’s orbit from 100 or so pixels away. Allow the object to pass Mars or the satellite without colliding.</p>
<h4 class="h4" id="lev360"><strong><em>Over the Top</em></strong></h4>
<p class="noindent">The Mars Orbiter currently uses an <em>equatorial</em> orbit. This is for easy coding, since you only need to rotate a single Mars image. But true mapping orbits use polar orbits—oriented perpendicular to equatorial orbits—and pass over the planet’s poles (<a href="ch14.xhtml#ch14fig24">Figure 14-24</a>). As the planet rotates beneath the orbit, the satellite can map its entire surface. With equatorial orbits, high latitudes are essentially unmappable due to curvature of the planet’s surface (see the dashed line in <a href="ch14.xhtml#ch14fig24">Figure 14-24</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_323"/><a id="ch14fig24"/><img src="../images/f0323-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-24: Polar versus equatorial orbits; notional north and south mapping limits for an equatorial orbit are represented by the dashed line.</em></p>
<p class="indent">Copy and edit the <em>mars_orbiter.py</em> program so that the satellite follows a polar orbit. All this involves is changing the Mars image. But you can’t use a single top-down image anymore; the view will need to be perpendicular to the planet’s axis of rotation. For a video example, see <em><a href="https://youtu.be/IP2SDbhFbXk">https://youtu.be/IP2SDbhFbXk</a></em>; for an animated gif of Mars, see <em><a href="http://gph.is/2caBKKS">http://gph.is/2caBKKS</a></em>. You can’t use animated gifs directly in <code>pygame</code>, but you can split out and use the individual frames. Tools for splitting out frames can be found online, and in the next chapter, you’ll use one of these products to extract images from a video.<span epub:type="pagebreak" id="page_324"/></p>
</body></html>