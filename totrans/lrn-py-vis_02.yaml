- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing More Complicated Shapes
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In Chapter 1, you learned about 2D primitives, including arcs, ellipses, lines,
    points, quads, rectangles, and triangles. However, some shapes, like hearts, stars,
    octagons, and Pikachu silhouettes, don’t fit into any such category and require
    more than shape functions to create.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to draw more complicated shapes with points
    and curves, as well as vertex functions for laying points. Using these techniques,
    you’ll draw shapes that blend straight and curved lines, and you’ll create *negative*
    shapes by subtracting one shape from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also learn how to work with two types of curves: *Catmull-Rom splines*
    and *Bézier curves*. Although both involve complicated math, Processing’s curve
    functions handle the underlying calculus, allowing you to create curves with just
    the coordinates of a few control points.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to understand how curves work in Processing is to draw a few and
    then manipulate them. It’s easier to plot points and curves by using a grid background
    for reference, so you’ll add one by using a ready-made graphic. Create a new sketch
    and save it as *curves*, and then follow these instructions to download the grid
    graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your web browser and go to [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to *chapter-02-drawing_more_complicated_shapes*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the *grid.png* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional sketch assets (images, fonts, and other media) belong in a subfolder
    named *data*, so create a new *data* subfolder within your *curves* sketch folder
    and place the *grid.png* file within it ([Figure 2-1](#figure2-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02001](image_fi/500969c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: Place the grid graphic within your *data* subfolder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This grid graphic will lie beneath everything you draw ([Figure 2-2](#figure2-2)),
    assisting you in gauging x-y coordinates. Set up your sketch by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `loadImage()` function loads the graphic file and assigns it to a variable
    named `grid` 1. The `image()` function 2 draws the image to the display window.
    The three arguments (`grid`, `0`, `0`) represent the loaded image file, x-coordinate,
    and y-coordinate, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The image is drawn at its original dimensions unless it’s resized using an additional
    fourth (width) and fifth (height) `image()` function argument.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02002](image_fi/500969c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Displaying the grid image'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Curves Using Catmull-Rom Splines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw a curved line in Processing, you can use the `curve()` function. This
    function accepts eight arguments, which represent four pairs of x-y coordinates;
    these are the starting control point, start of the curve, end of the curve, and
    ending control point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with a standard line and then adapt it into a curve. This way,
    you can visualize how the `curve()` function operates by comparing it with the
    simpler and more familiar `line()` function. Add a diagonal line to your *curves*
    sketch ([Figure 2-3](#figure2-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![f02003](image_fi/500969c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A straight line to adapt into a curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing draws a line between the specified pairs of x-y coordinates: (100,
    100) and (400, 400). Note that the line’s coordinates correspond to the grid beneath.'
  prefs: []
  type: TYPE_NORMAL
- en: Curving Lines with curve()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use the `curve()` function to draw the same line, comment out the `line()`
    function in the *curves* sketch and replace it with a `curve()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you run the sketch, the visual result should be exactly the same, as shown
    previously in [Figure 2-3](#figure2-3). The four middle values within the `curve()`
    function’s parentheses match those of the `line()` function, and they also indicate
    the starting and ending x-y coordinates of the curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the `curve()` function takes four additional outer arguments (in this example,
    `0,0` and `500,500`), which represent two pairs of *control-point* coordinates.
    The positions of these control points determine the direction and amount of curvature
    you apply to the line. Before exploring this in detail, add the following new
    lines to the end of your code to draw a yellow line of the same length, at the
    same position, but with some curvature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, the four middle arguments remain the same, but the control-point
    coordinates have been changed to `0,250` and `500,250`. The result is a yellow
    curve with a slight S-bend ([Figure 2-4](#figure2-4)). By comparing the blue and
    yellow lines, you can visualize how changing the control points has manipulated
    the curve.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02004](image_fi/500969c02/f02004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: The yellow curve’s control points, circled in orange, would otherwise
    be invisible.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how the control points influence the curve, imagine that each
    end of the yellow curve extends to its neighboring control point. The closer you
    bring the control point to the center of the display window, the harder you are
    “flexing” this curve. Conversely, with control points 1 and 2 positioned at the
    upper left and lower left corners of the display window, respectively, the four
    points lie in a row, and the curve does not have to flex, resulting in a straight
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the control points work, add the following orange curves to serve
    as visual aids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first `curve()` function 1 draws an orange curve from control point 1 to
    the starting point of the yellow curve; the second `curve()` function 2 draws
    another orange curve from the end point of the yellow curve to control point 2\.
    The result ([Figure 2-5](#figure2-5)) is a three-part curve (orange-yellow-orange)
    that shows how the control points determine the curvature of the yellow part.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02005](image_fi/500969c02/f02005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: Your Processing curve (left) and a traditional spline (right).
    (Illustration: Pearson Scott Foresman, licensed under public domain.)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the orange curves extend the yellow curve and illustrate what
    the yellow curve would look like as a physically complete spline. To the right
    in [Figure 2-5](#figure2-5), you can see the flexible strip for drawing such a
    curve without the aid of a computer. As mentioned earlier, it’s this strip from
    which the spline takes its name. The two nails correspond to the starting and
    ending points of the `curve()` function, and the L-pieces at each end represent
    the control points.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Curves with curveTightness()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `curveTightness()` function determines how rigidly the curve conforms to
    the points that control it, as if you were replacing the draftsman’s spline with
    a strip of less or more pliable material, or feeding a shorter or longer length
    of spline into the same area. The function accepts values ranging from –5.0 to
    5.0, with 0 being the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To experiment, add a `curveTightness()` line above the yellow stroke:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Enter different values to affect the curves below it. [Figure 2-6](#figure2-6)
    shows curves with different `curveTightness()` values.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02006](image_fi/500969c02/f02006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: Clockwise from the top left: `curveTightness``(``-1)`, `curveTightness``(0)`,
    curveTightness`(1)`, and`curveTightness``(5)`'
  prefs: []
  type: TYPE_NORMAL
- en: The lower right curve in [Figure 2-6](#figure2-6), with its tightness argument
    set to `1`, fits so rigidly that the result is a straight yellow line. The more
    you adjust the tightness value away from `1`, the more the curve will deform.
    For curves that overshoot their starting and ending points, use values greater
    than 1\. For instance, at an upper tightness limit of `5` (bottom left), the spline
    loops as it passes through the starting and ending points. With a tightness argument
    of `-1` (top left), the lengthier spline is rerouted to better align with the
    points it passes through; hence, there is increased curvature but no looping.
  prefs: []
  type: TYPE_NORMAL
- en: The `curve()` function is intuitive and useful for generating curved lines quickly.
    However, you’re most likely to encounter Bézier curves in 3D modeling, animation,
    computer-aided design (CAD), and vector illustration software, so let’s look at
    those next.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Bézier Curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bézier curves* provide an intuitive and versatile means of modeling smooth
    curves using a series of anchor and control points. You may have encountered these
    curves in vector graphics drawing software, such as Adobe Illustrator or Inkscape.
    In this section, you’ll draw curves using the `bezier()` function. In graphics
    software, you have visual nodes to grab and manipulate; in Processing, you define
    the positions of your anchor and control points, using `bezier()` function arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the bezier() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `bezier()` function takes eight arguments, expanded across multiple lines
    here for easier readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first and last pair of arguments are the starting and ending points for
    your curve. When using Bézier curves, you typically refer to the points that your
    visible lines connect to as *anchor points*. The curvature of the line as it heads
    away from the first anchor point (`anchor_point_1_x, anchor_point_1_y`) is controlled
    by the position of its associated control point (`control_point_1_x, control_point_1_y`).
    The other control point (`control_point_2_x, control_point_2_y`) controls the
    curvature of the line as it heads toward the ending anchor point ([Figure 2-7](#figure2-7)).
    This is not spline-like behavior, though; instead, the control points behave more
    like magnets, causing the line to bulge toward them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a Bézier curve, create four variables to represent the x-y coordinate
    pairs of the two control points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![f02007](image_fi/500969c02/f02007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7: The anchor and control points manipulate the position and curvature
    of the Bézier curve.'
  prefs: []
  type: TYPE_NORMAL
- en: The first pair of `bezier()` coordinates positions anchor point 1 near the top
    right of the grid; the last pair of coordinates positions anchor point 2 near
    the bottom left. All of the control point variables (`cp1x,cp1y, cp2x,cp2y`) reference
    the center of the display window (250, 250). By placing the control points along
    the diagonal path formed between anchor points 1 and 2, you form a straight line.
    You’ll next shift these control points outward to observe how this curves the
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Run this sketch to render a pink line that represents a straightened Bézier
    curve ([Figure 2-8](#figure2-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02008](image_fi/500969c02/f02008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: The pink line represents a straightened Bézier curve.'
  prefs: []
  type: TYPE_NORMAL
- en: The pink line should cross the yellow curve at the center of the display window
    (250, 250).
  prefs: []
  type: TYPE_NORMAL
- en: Positioning Anchor and Control Points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To manipulate the pink line into a curve ([Figure 2-9](#figure2-9)), set the
    `cp1x` variable to `200`. In addition to this change, add two extra lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![f02009](image_fi/500969c02/f02009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: Curving the pink line by adjusting a control point'
  prefs: []
  type: TYPE_NORMAL
- en: The additional code creates a red line connecting anchor point 1 (`400, 100`)
    and its control point (`cp1x,cp1y`). This red line is useful because you can now
    visualize where the control point sits and which anchor point it controls. Moreover,
    sharing variables between the `bezier()` and red `line()` functions means that
    each time you adjust the values that position the curve’s control point (`cp1x,cp1y`),
    the red line adapts accordingly. Setting the value of `cp1x` to `200` applies
    curvature to the pink line because—as the control point moves away from the pink
    line—the pink line bulges toward it.
  prefs: []
  type: TYPE_NORMAL
- en: The top half of the curve is affected most by the control point that connects
    to its top anchor point (control point 1); this will become more apparent when
    you manipulate the control point for the lower anchor point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add another red line to connect (the lower) anchor point 2 and control
    point 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The new red line visually connects anchor point 2 (`100,400`) to its control
    point (`cp2x,cp2y`). Run the sketch to see the result ([Figure 2-10](#figure2-10)).
    Experiment with different control-point values to see how they affect the curve.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02010](image_fi/500969c02/f02010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10: Adjusting control point 2'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the lower part of the pink curve is “magnetically” pulled toward
    control point 2\. Knowing where to place the anchor and control points for your
    desired curve takes some skill. Try downloading and practicing in Inkscape (or
    Illustrator if you have it installed). Alternatively, try playing The Bézier Game
    in your web browser at [https://bezier.method.ac](https://bezier.method.ac)*/*.
  prefs: []
  type: TYPE_NORMAL
- en: You can now draw curved lines by using Catmull-Rom splines and Bézier curves.
    The `curve()` and `bezier()` functions are useful for standalone curves, but to
    form shapes composed of multiple curve segments, you’ll need vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Shapes Using Vertices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Processing, a *vertex* is a point used to connect lines in order to form
    a shape. *Vertices* is the plural of vertex. You can think of vertices as the
    dots in a connect-the-dots drawing puzzle. For example, a triangle requires 3
    vertices; a pentagon requires 5; and a five-pointed star () requires 10\. When
    using straight lines and curves to connect vertices, the shape possibilities become
    limitless. A vertex is not limited to 2D space—for instance, Blender’s Suzanne
    (a monkey head) has around 500 vertices positioned in 3D space ([Figure 2-13](#figure2-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02013](image_fi/500969c02/f02013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: Three of the 500 or so vertices circled in yellow'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll draw a square-type shape by using a series of `vertex()` functions. Create
    a new sketch and save it as *vertices*. Within the new *vertices* folder, add
    a *data* folder containing a copy of the *grid.png* file from your preceding sketch
    ([Figure 2-14](#figure2-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02014](image_fi/500969c02/f02014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14: The *vertices* sketch folder structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add code to set up the initial parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, you load and display the grid image to help you gauge coordinates in
    the display window. Each shape that you draw will have no fill and a white stroke
    of 3 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of using a `rect()` or `square()` function, use vertices to draw
    a square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `beginShape()` and `endShape()` functions are essential for separating groups
    of vertices into individual shapes. Without those two functions, Processing would
    have to assume that all the vertices in your sketch belong to the same shape.
    That said, Processing ignores any rogue `vertex()` lines placed outside the `beginShape()`
    and `endShape()` pair. As depicted in [Figure 2-15](#figure2-15), the code draws
    a square with no left side.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02015](image_fi/500969c02/f02015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-15: An open square drawn using vertices'
  prefs: []
  type: TYPE_NORMAL
- en: The shape will not close automatically unless you include an `endShape(CLOSE)`
    argument or add a final vertex that connects with the start. However, an active
    `fill()` will fill in color regardless ([Figure 2-16](#figure2-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02016](image_fi/500969c02/f02016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-16: Despite the open side, the shape is filled with color.'
  prefs: []
  type: TYPE_NORMAL
- en: You also can provide various parameters to the `beginShape()` function to determine
    how the enclosed vertices are connected, if at all ([Figure 2-17](#figure2-17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02017](image_fi/500969c02/f02017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-17: The functions `beginShape(POINTS)` (left), and `beginShape(LINES)`
    (right)'
  prefs: []
  type: TYPE_NORMAL
- en: For a shape composed of only dots, use `beginShape(POINTS)`. For a line between
    every other vertex, use `beginShape(LINES)`. Consult the reference for more details
    on `beginShape()` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Bézier Vertices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `bezierVertex()` function allows you to draw curved lines between vertices.
    A `curveVertex()` function is also available for Catmull-Rom-type curves, but
    this book focuses on the Bézier type, as it provides for greater control and more
    graceful curves.
  prefs: []
  type: TYPE_NORMAL
- en: The `bezierVertex()` function takes six arguments. To understand how those arguments
    operate, you’ll work toward completing the remaining shapes shown in [Figure 2-18](#figure2-18).
  prefs: []
  type: TYPE_NORMAL
- en: I have manually added the pale blue lines, the dotted tips of which provide
    a visual indication of the control points. Use these lines for reference purposes
    only; you don’t need to redraw them.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02018](image_fi/500969c02/f02018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-18: A Chinese coin (lower left), S-curve (middle), and heart (right)'
  prefs: []
  type: TYPE_NORMAL
- en: S-Curve
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *S-curve* is just a curved line that comprises two vertices, with each vertex
    attached to its own control point. You’ll draw it with a `bezierVertex()` function
    to keep this first example as simple as possible, but ordinarily, you would draw
    an S-curve by using `bezier()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `beginShape()` and `endShape()`, combine the `bezierVertex()` and `vertex()`
    functions however necessary. Your first point, however, is always created with
    `vertex()`. Begin a new shape and plot the first (in this case, upper) vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch. There is no second vertex with which to form a line, so the
    isolated vertex should appear as a point at (400, 200).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the second vertex by using `bezierVertex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last pair of `bezierVertex()` arguments (`400, 600`) denotes the position
    of the second (lower) vertex. The second vertex is attached to a control point
    positioned by the second pair of arguments (`500, 500`). The first pair of arguments
    (`300, 300`) represents the control point for the `vertex()` function that immediately
    precedes `bezierVertex()`. With the positions of the vertices presented for you
    in the reference image ([Figure 2-18](#figure2-18)), creating this shape ([Figure
    2-19](#figure2-19)) is really just a matter of typing in the correct sequence
    of coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02019](image_fi/500969c02/f02019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-19: The complete S-curve'
  prefs: []
  type: TYPE_NORMAL
- en: This is an open shape, so it would look odd if filled. Next, you’ll examine
    a closed shape, but feel free to experiment with different vertex and control-point
    values before moving along.
  prefs: []
  type: TYPE_NORMAL
- en: Heart
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can think of the heart shape as two curved lines connected to two vertices.
    To begin, draw one half of the heart ([Figure 2-20](#figure2-20)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![f02020](image_fi/500969c02/f02020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-20: Half a heart'
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left for you to do is complete the right half of the heart. Add
    a second `bezierVertex()` line and see if you can fill in the missing arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Refer back to [Figure 2-18](#figure2-18) to see where the control points lie.
    Remember that you can access all of the solutions to the challenges at [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  prefs: []
  type: TYPE_NORMAL
- en: Chinese Coin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Round metal coins with square holes in the center were first introduced in China
    many centuries ago, but replicating that shape makes for a good example to learn
    Processing. To create the purple coin shape in [Figure 2-18](#figure2-18), you’ll
    use the `beginContour()` and `endContour()` functions to subtract a square from
    a circle.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll create the outer shape by using the `beginShape()`, `endShape()`,
    and `vertex()` functions. You’ll then place the `beginContour()` and `endContour()`
    functions within the `beginShape()` and `endShape()` functions. Within this pair
    of contour functions, you’ll draw a second shape that’s also composed of `vertex()`
    and `bezierVertex()` functions; the contour functions subtract this shape from
    the outer shape.
  prefs: []
  type: TYPE_NORMAL
- en: The first challenge is creating the outer circle. The `beginContour()` and `endContour()`
    functions cannot subtract from predefined shape functions—like `rect()`, `ellipse()`,
    or `circle()`—so you need to construct the outer circle by using vertices. However,
    it is possible to draw circles by using Bézier curves, which you’ll do by creating
    a diamond and then using the control points to form it into something round.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by forming a diamond shape with `vertex()` functions (shown in [Figure
    2-21](#figure2-21)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![f02021](image_fi/500969c02/f02021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-21: The diamond shape that you’ll form into a circle'
  prefs: []
  type: TYPE_NORMAL
- en: With the vertices in the correct positions, you can proceed to add curvature
    to the diamond. Of course, this will require `bezierVertex()` functions, for which
    you’ll reference the coordinates of the vertices currently in place. For an idea
    of where to position the additional control-point coordinates, see [Figure 2-22](#figure2-22).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02022](image_fi/500969c02/f02022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-22: Positioning vertices and control points to form a circle'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-22](#figure2-22) indicates how the control points should be positioned
    to form the most circular shape. Now replace each `vertex()` with a `bezierVertex()`
    function. Remember, though, that the first point must remain a `vertex()` to form
    your circle ([Figure 2-23](#figure2-23)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![f02023](image_fi/500969c02/f02023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-23: A circle formed using `bezierVertex``(``)` functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the circle in place, you can go about removing a square from the middle.
    Once again, define this square by using vertices and not a predefined shape function,
    like `rect()` or `square()`. This is a relatively straightforward exercise, but
    be aware that you need to use *reverse winding* for the subtracted shape: you
    must lay the vertices of the square in a direction that’s opposite to the one
    you used to place the vertices of the exterior shape (the circle).'
  prefs: []
  type: TYPE_NORMAL
- en: Read through the circle code again and notice that the vertices are plotted
    in a clockwise sequence; this means that the square’s vertices must be plotted
    counterclockwise—that is, opposite to the winding of the shape from which it will
    subtract. If you fail to get this direction correct, no subtraction will take
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the square’s vertices within a `beginContour()` and `endContour()` function.
    Of course, you can’t observe the effect (shown in [Figure 2-24](#figure2-24))
    unless you add a fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![f02024](image_fi/500969c02/f02024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-24: The completed coin'
  prefs: []
  type: TYPE_NORMAL
- en: Without the fill 1, you would see only white outlines. The `beginContour()`
    function 2 starts recording the vertices that make up the negative shape. No `bezierVertex()`
    functions are necessary, because a square has no curves. The vertices follow a
    counterclockwise sequence, beginning at the upper left corner of the square (`180,
    580`), proceeding directly downward (to `180, 620`) and then farther around before
    the `endContour()` stops recording 3.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vector Graphics Software for Generating Shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use vector graphics drawing software to draw shapes, and then reference
    the positions of the vertices and control points for writing Processing code.
    This is how I mapped out the blue guidelines for the Python logo shown in [Figure
    2-25](#figure2-25).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02025](image_fi/500969c02/f02025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-25: Tracing a Python logo that includes the positions of the vertices
    and control points. (The Python Software Foundation logo trademark policy is available
    at [https://www.python.org/psf/trademarks/](https://www.python.org/psf/trademarks/).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re up for a challenge, clear out your *curves* sketch and try finishing
    the half of the Python logo I’ve begun in [Figure 2-25](#figure2-25). Here is
    some code to get the outline started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also export vector graphics as SVG files for use in Processing with
    the `loadShape()` and `shape()` functions, as opposed to the `loadImage()` and
    `image()` functions. But be warned: SVG support is not always dependable, and
    you may spend some time fiddling with your SVG export settings to get them to
    display properly in Processing.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve now learned most of Processing’s essential drawing features. Using a
    grid graphic as a reference for your coordinates, you learned to plot curves that
    mimic physical splines. In addition, you learned to draw Bézier curves—smooth,
    graceful curves that you can control with anchor and control points. You also
    saw how to draw shapes by using a series of vertices. When you connect vertices
    with straight lines and curves, the shape possibilities are limitless. You’ll
    be using curves, vertices, and the skills you learned in Chapter 1 in many of
    the tasks to come.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 3, you’ll move on to explore Processing’s text features. This includes
    drawing text to the display window, styling it, and loading fonts. You’ll also
    look at Python’s built-in features for manipulating string data. Later in this
    book, you’ll use text functions to label graphs and graphical interface elements,
    and to add speech bubbles to images.
  prefs: []
  type: TYPE_NORMAL
