<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_57"/><strong><span class="big">5</span></strong><br/><strong>DISTRIBUTING YOUR SOFTWARE</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">It’s safe to say that at some point, you will want to distribute your software. As tempted as you might be to just zip your code and upload it to the internet, Python provides tools to make it easier for your end users to get your software to work. You should already be familiar with using <em>setup.py</em> to install Python applications and libraries, but you have probably never delved into how it works behind the scenes or how to make a <em>setup.py</em> of your own.</p>&#13;
<p class="indent">In this chapter, you’ll learn the history of <em>setup.py</em>, how the file works, and how to create your own custom <em>setup.py</em>. We’ll also take a look at some of the less well-known capabilities of the package installation tool <code>pip</code> and how to make your software downloadable via <code>pip</code>. Finally, we’ll see how to use Python’s entry points to make functions easy to find between programs. With these skills, you can make your published software accessible for end users.</p>&#13;
<h3 class="h3" id="lev1sec23"><span epub:type="pagebreak" id="page_58"/><strong>A Bit of setup.py History</strong></h3>&#13;
<p class="noindent">The <code>distutils</code> library, originally created by software developer Greg Ward, has been part of the standard Python library since 1998. Ward sought to create an easy way for developers to automate the installation process for their end users. Packages provide the <em>setup.py</em> file as the standard Python script for their installation, and they can use <code>distutils</code> to install themselves, as shown in <a href="ch05.xhtml#ch5list1">Listing 5-1</a>.</p>&#13;
<pre>#!/usr/bin/python<br/>from distutils.core import setup<br/><br/>setup(name="rebuildd",<br/>      description="Debian packages rebuild tool",<br/>      author="Julien Danjou",<br/>      author_email="acid@debian.org",<br/>      url="http://julien.danjou.info/software/rebuildd.html",<br/>      packages=['rebuildd'])</pre>&#13;
<p class="listing1"><a id="ch5list1"/><em>Listing 5-1: Building a <span class="roman">setup.py</span> using <span class="codeitalic">distutils</span></em></p>&#13;
<p class="indent">With the <em>setup.py</em> file as the root of a project, all users have to do to build or install your software is run that file with the appropriate command as its argument. Even if your distribution includes C modules in addition to native Python ones, <code>distutils</code> can handle them automatically.</p>&#13;
<p class="indent">Development of <code>distutils</code> was abandoned in 2000; since then, other developers have picked up where it left off. One of the notable successors is the packaging library known as <code>setuptools</code>, which offers more frequent updates and advanced features, such as automatic dependency handling, the <code>Egg</code> distribution format, and the <code>easy_install</code> command. Since <code>distutils</code> was still the accepted means of packaging software included with the Python Standard Library at the time of development, <code>setuptools</code> provided a degree of backward compatibility with it. <a href="ch05.xhtml#ch5list2">Listing 5-2</a> shows how you’d use <code>setuptools</code> to build the same installation package as in <a href="ch05.xhtml#ch5list1">Listing 5-1</a>.</p>&#13;
<pre>#!/usr/bin/env python<br/>import setuptools<br/><br/>setuptools.setup(<br/>    name="rebuildd",<br/>    version="0.2",<br/>    author="Julien Danjou",<br/>    author_email="acid@debian.org",<br/>    description="Debian packages rebuild tool",<br/>    license="GPL",<br/>    url="http://julien.danjou.info/software/rebuildd/",<br/>    packages=['rebuildd'],<br/>    classifiers=[<br/>        "Development Status :: 2 - Pre-Alpha",<br/>        "Intended Audience :: Developers",<br/>        "Intended Audience :: Information Technology",<br/>        "License :: OSI Approved :: GNU General Public License (GPL)",<span epub:type="pagebreak" id="page_59"/><br/>        "Operating System :: OS Independent",<br/>        "Programming Language :: Python"<br/>    ],<br/>)</pre>&#13;
<p class="listing1"><a id="ch5list2"/><em>Listing 5-2: Building a <span class="roman">setup.py</span> using <span class="codeitalic">setuptools</span></em></p>&#13;
<p class="indent">Eventually, development on <code>setuptools</code> slowed down too, but it wasn’t long before another group of developers forked it to create a new library called <code>distribute</code>, which offered several advantages over <code>setuptools</code>, including fewer bugs and Python 3 support.</p>&#13;
<p class="indent">All the best stories have a twist ending, though: in March 2013, the teams behind <code>setuptools</code> and <code>distribute</code> decided to merge their codebases under the aegis of the original <code>setuptools</code> project. So <code>distribute</code> is now deprecated, and <code>setuptools</code> is once more the canonical way to handle advanced Python installations.</p>&#13;
<p class="indent">While all this was happening, another project, known as <code>distutils2</code>, was developed with the intention of completely replacing <code>distutils</code> in the Python Standard Library. Unlike both <code>distutils</code> and <code>setuptools</code>, it stored package metadata in a plaintext file, <em>setup.cfg</em>, which was easier both for developers to write and for external tools to read. However, <code>distutils2</code> retained some of the failings of <code>distutils</code>, such as its obtuse command-based design, and lacked support for entry points and native script execution on Windows—both features provided by <code>setuptools</code>. For these and other reasons, plans to include <code>distutils2</code>, renamed as <code>packaging</code>, in the Python 3.3 Standard Library fell through, and the project was abandoned in 2012.</p>&#13;
<p class="indent">There is still a chance for <code>packaging</code> to rise from the ashes through <code>distlib</code>, an up-and-coming effort to replace <code>distutils</code>. Before release, it was rumored that the <code>distlib</code> package would become part of the Standard Library in Python 3.4, but that never came to be. Including the best features from <code>packaging</code>, <code>distlib</code> implements the basic groundwork described in the packaging-related PEPs.</p>&#13;
<p class="indent">So, to recap:</p>&#13;
<ul>&#13;
<li><p class="noindent"><span class="codestrong">distutils</span> is part of the Python Standard Library and can handle simple package installations.</p></li>&#13;
<li><p class="noindent"><span class="codestrong">setuptools</span>, the standard for advanced package installations, was at first deprecated but is now back in active development and the de facto standard.</p></li>&#13;
<li><p class="noindent"><span class="codestrong">distribute</span> has been merged back into <code>setuptools</code> as of version 0.7; <span class="codestrong">distutils2</span> (aka <code>packaging</code>) has been abandoned.</p></li>&#13;
<li><p class="noindent"><span class="codestrong">distlib</span> <em>might</em> replace <code>distutils</code> in the future.</p></li>&#13;
</ul>&#13;
<p class="indent">There are other packaging libraries out there, but these are the five you’ll encounter the most. Be careful when researching these libraries on the internet: plenty of documentation is outdated due to the complicated history outlined above. The official documentation is up-to-date, however.</p>&#13;
<p class="indent">In short, <code>setuptools</code> is the distribution library to use for the time being, but keep an eye out for <code>distlib</code> in the future.</p>&#13;
<h3 class="h3" id="lev1sec24"><span epub:type="pagebreak" id="page_60"/><strong>Packaging with setup.cfg</strong></h3>&#13;
<p class="noindent">You’ve probably already tried to write a <em>setup.py</em> for a package at some point, either by copying one from another project or by skimming through the documentation and building it yourself. Building a <em>setup.py</em> is not an intuitive task. Choosing the right tool to use is just the first challenge. In this section, I want to introduce you to one of the recent improvements to <code>setuptools</code>: the <em>setup.cfg</em> file support.</p>&#13;
<p class="indent">This is what a <em>setup.py</em> using a <em>setup.cfg</em> file looks like:</p>&#13;
<pre>import setuptools<br/><br/>setuptools.setup()</pre>&#13;
<p class="indent">Two lines of code—it is that simple. The actual metadata the setup requires is stored in <em>setup.cfg</em>, as in <a href="ch05.xhtml#ch5list3">Listing 5-3</a>.</p>&#13;
<pre>[metadata]<br/>name = foobar<br/>author = Dave Null<br/>author-email = foobar@example.org<br/>license = MIT<br/>long_description = file: README.rst<br/>url = http://pypi.python.org/pypi/foobar<br/>requires-python = &gt;=2.6<br/>classifiers =<br/>    Development Status :: 4 - Beta<br/>    Environment :: Console<br/>    Intended Audience :: Developers<br/>    Intended Audience :: Information Technology<br/>    License :: OSI Approved :: Apache Software License<br/>    Operating System :: OS Independent<br/>    Programming Language :: Python</pre>&#13;
<p class="listing1"><a id="ch5list3"/><em>Listing 5-3: The <span class="roman">setup.cfg</span> metadata</em></p>&#13;
<p class="indent">As you can see, <em>setup.cfg</em> uses a format that’s easy to write and read, directly inspired by <code>distutils2</code>. Many other tools, such as <code>Sphinx</code> or <code>Wheel</code>, also read configuration from this <em>setup.cfg</em> file—that alone is a good argument to start using it.</p>&#13;
<p class="indent">In <a href="ch05.xhtml#ch5list3">Listing 5-3</a>, the description of the project is read from the <em>README.rst</em> file. It’s good practice to always have a README file—preferably in the RST format—so users can quickly understand what the project is about. With just these basic <em>setup.py</em> and <em>setup.cfg</em> files, your package is ready to be published and used by other developers and applications. The <code>setuptools</code> documentation provides more details if needed, for example, if you have some extra steps in your installation process or want to include extra files.</p>&#13;
<p class="indent">Another useful packaging tool is <code>pbr</code>, short for <em>Python Build Reasonableness</em>. The project was started in OpenStack as an extension of <code>setuptools</code> to <span epub:type="pagebreak" id="page_61"/>facilitate installation and deployment of packages. The <code>pbr</code> packaging tool, used alongside <code>setuptools</code>, implements features absent from <code>setuptools</code>, including these:</p>&#13;
<ul>&#13;
<li><p class="noindent">Automatic generation of Sphinx documentation</p></li>&#13;
<li><p class="noindent">Automatic generation of <em>AUTHORS</em> and <em>ChangeLog</em> files based on <code>git</code> history</p></li>&#13;
<li><p class="noindent">Automatic creation of file lists for <code>git</code></p></li>&#13;
<li><p class="noindent">Version management based on <code>git</code> tags using semantic versioning</p></li>&#13;
</ul>&#13;
<p class="indent">And all this with little to no effort on your part. To use <code>pbr</code>, you just need to enable it, as shown in <a href="ch05.xhtml#ch5list4">Listing 5-4</a>.</p>&#13;
<pre><span class="codestrong1">import setuptools</span><br/><br/><span class="codestrong1">setuptools.setup(setup_requires=['pbr'], pbr=True)</span></pre>&#13;
<p class="listing1"><a id="ch5list4"/><em>Listing 5-4: <span class="roman">setup.py</span> using pbr</em></p>&#13;
<p class="indent">The <code>setup_requires</code> parameter indicates to <code>setuptools</code> that <code>pbr</code> must be installed prior to using <code>setuptools</code>. The <code>pbr=True</code> argument makes sure that the <code>pbr</code> extension for <code>setuptools</code> is loaded and called.</p>&#13;
<p class="indent">Once enabled, the <code>python setup.py</code> command is enhanced with the <code>pbr</code> features. Calling <code>python setup.py –version</code> will, for example, return the version number of the project based on existing <code>git</code> tags. Running <code>python setup.py sdist</code> would create a source tarball with automatically generated <em>ChangeLog</em> and <em>AUTHORS</em> files.</p>&#13;
<h3 class="h3" id="lev1sec25"><strong>The Wheel Format Distribution Standard</strong></h3>&#13;
<p class="noindent">For most of Python’s existence, there’s been no official standard distribution format. While different distribution tools generally use some common archive format—even the <code>Egg</code> format introduced by <code>setuptools</code> is just a zip file with a different extension—their metadata and package structures are incompatible with each other. This problem was compounded when an official installation standard was finally defined in PEP 376 that was also incompatible with existing formats.</p>&#13;
<p class="indent">To solve these problems, PEP 427 was written to define a new standard for Python distribution packages called <code>Wheel</code>. The reference implementation of this format is available as a tool, also called <code>Wheel</code>.</p>&#13;
<p class="indent"><code>Wheel</code> is supported by <code>pip</code> starting with version 1.4. If you’re using <code>setuptools</code> and have the <code>Wheel</code> package installed, it automatically integrates itself as a <code>setuptools</code> command named <code>bdist_wheel</code>. If you don’t have <code>Wheel</code> installed, you can install it using the command <code>pip install wheel</code>. <a href="ch05.xhtml#ch5list5">Listing 5-5</a> shows some of the output when calling <code>bdist_wheel</code>, abridged for print.</p>&#13;
<pre><span epub:type="pagebreak" id="page_62"/>   $ <span class="codestrong1">python setup.py bdist_wheel</span><br/>   running bdist_wheel<br/>   running build<br/>   running build_py<br/>   creating build/lib<br/>   creating build/lib/daiquiri<br/>   creating build/lib/daiquiri/tests<br/>   copying daiquiri/tests/__init__.py -&gt; build/lib/daiquiri/tests<br/>   <span class="codeitalic1">--snip--</span><br/>   running egg_info<br/>   writing requirements to daiquiri.egg-info/requires.txt<br/>   writing daiquiri.egg-info/PKG-INFO<br/>   writing top-level names to daiquiri.egg-info/top_level.txt<br/>   writing dependency_links to daiquiri.egg-info/dependency_links.txt<br/>   writing pbr to daiquiri.egg-info/pbr.json<br/>   writing manifest file 'daiquiri.egg-info/SOURCES.txt'<br/>   installing to build/bdist.macosx-10.12-x86_64/wheel<br/>   running install<br/>   running install_lib<br/>   <span class="codeitalic1">--snip--</span><br/><br/>   running install_scripts<br/>   creating build/bdist.macosx-10.12-x86_64/wheel/daiquiri-1.3.0.dist-info/WHEEL<br/><span class="ent">➊</span> creating '/Users/jd/Source/daiquiri/dist/daiquiri-1.3.0-py2.py3-none-any.whl'<br/>   and adding '.' to it<br/>   adding 'daiquiri/__init__.py'<br/>   adding 'daiquiri/formatter.py'<br/>   adding 'daiquiri/handlers.py'<br/><br/>   <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="listing1"><a id="ch5list5"/><em>Listing 5-5: Calling <span class="codeitalic">setup.py bdist_wheel</span></em></p>&#13;
<p class="indent">The <code>bdist_wheel</code> command creates a <em>.whl</em> file in the <em>dist</em> directory <span class="ent">➊</span>. As with the <code>Egg</code> format, a <code>Wheel</code> archive is just a zip file with a different extension. However, <code>Wheel</code> archives do not require installation—you can load and run your code just by adding a slash followed by the name of your module:</p>&#13;
<pre>$ <span class="codestrong1">python wheel-0.21.0-py2.py3-none-any.whl/wheel -h</span><br/>usage: wheel [-h]<br/><br/>             {keygen,sign,unsign,verify,unpack,install,install-<br/>scripts,convert,help}<br/>             --<span class="codeitalic1">snip</span>--<br/><br/>positional arguments:<br/>--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">You might be surprised to learn this is not a feature introduced by the <code>Wheel</code> format itself. Python can also run regular zip files, just like with Java’s <em>.jar</em> files:</p>&#13;
<pre>python foobar.zip</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>This is equivalent to:</p>&#13;
<pre>PYTHONPATH=foobar.zip python -m __main__</pre>&#13;
<p class="indent">In other words, the <code>__main__</code> module for your program will be automatically imported from <code>__main__.py</code>. You can also import <code>__main__</code> from a module you specify by appending a slash followed by the module name, just as with <code>Wheel</code>:</p>&#13;
<pre>python foobar.zip/mymod</pre>&#13;
<p class="indent">This is equivalent to:</p>&#13;
<pre>PYTHONPATH=foobar.zip python -m mymod.__main__</pre>&#13;
<p class="indent">One of the advantages of <code>Wheel</code> is that its naming conventions allow you to specify whether your distribution is intended for a specific architecture and/or Python implementation (CPython, PyPy, Jython, and so on). This is particularly useful if you need to distribute modules written in C.</p>&#13;
<p class="indent">By default, <code>Wheel</code> packages are tied to the major version of Python that you used to build them. When called with <code>python2 setup.py bdist_wheel</code>, the pattern of a <code>Wheel</code> filename will be something like <em>library-version-py2-none-any.whl</em>.</p>&#13;
<p class="indent">If your code is compatible with all major Python versions (that is, Python 2 and Python 3), you can build a universal <code>Wheel</code>:</p>&#13;
<pre><span class="codestrong1">python setup.py bdist_wheel --universal</span></pre>&#13;
<p class="indent">The resulting filename will be different and contains both Python major versions—something like <em>library-version-py2.py3-none-any.whl</em>. Building a universal <code>Wheel</code> avoids ending up with two different <code>Wheel</code>s when only one would cover both Python major versions.</p>&#13;
<p class="indent">If you don’t want to pass the <code>--universal</code> flag each time you are building a <code>Wheel</code>, you can just add this to your <em>setup.cfg</em> file:</p>&#13;
<pre>[wheel]<br/>universal=1</pre>&#13;
<p class="indent">If the <code>Wheel</code> you build contains binary programs or libraries (like a Python extension written in C), the binary <code>Wheel</code> might not be as portable as you imagine. It will work by default on some platforms, such as Darwin (macOS) or Microsoft Windows, but it might not work on all Linux distributions. The PEP 513 (<em><a href="https://www.python.org/dev/peps/pep-0513">https://www.python.org/dev/peps/pep-0513</a></em>) targets this Linux problem by defining a new platform tag named <code>manylinux1</code> and a minimal set of libraries that are guaranteed to be available on that platform.</p>&#13;
<p class="indent"><code>Wheel</code> is a great format for distributing ready-to-install libraries and applications, so you are encouraged to build and upload them to PyPI as well.</p>&#13;
<h3 class="h3" id="lev1sec26"><span epub:type="pagebreak" id="page_64"/><strong>Sharing Your Work with the World</strong></h3>&#13;
<p class="noindent">Once you have a proper <em>setup.py</em> file, it is easy to build a source tarball that can be distributed. The <code>sdist setuptools</code> command does just that, as demonstrated in <a href="ch05.xhtml#ch5list6">Listing 5-6</a>.</p>&#13;
<pre>$ <span class="codestrong1">python setup.py sdist</span><br/>running sdist<br/><br/>[pbr] Generating AUTHORS<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Processing SOURCES.txt<br/>[pbr] In git context, generating filelist from git<br/>warning: no previously-included files matching '*.pyc' found anywhere in<br/>distribution<br/>writing manifest file 'ceilometer.egg-info/SOURCES.txt'<br/>running check<br/>copying setup.cfg -&gt; ceilometer-2014.1.a6-g772e1a7<br/>Writing ceilometer-2014.1.a6-g772e1a7/setup.cfg<br/><br/><span class="codeitalic1">--snip--</span><br/><br/>Creating tar archive<br/>removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)</pre>&#13;
<p class="listing1"><a id="ch5list6"/><em>Listing 5-6: Using <span class="codeitalic">setup.py sdist</span> to build a source tarball</em></p>&#13;
<p class="indent">The <code>sdist</code> command creates a tarball under the <em>dist</em> directory of the source tree. The tarball contains all the Python modules that are part of the source tree. As seen in the previous section, you can also build <code>Wheel</code> archives using the <code>bdist_wheel</code> command. <code>Wheel</code> archives are a bit faster to install as they’re already in the correct format for installation.</p>&#13;
<p class="indent">The final step to make that code accessible is to export your package somewhere users can install it via <code>pip</code>. That means publishing your project to PyPI.</p>&#13;
<p class="indent">If it’s your first time exporting to PyPI, it pays to test out the publishing process in a safe sandbox rather than on the production server. You can use the PyPI staging server for this purpose; it replicates all the functionality of the main index but is solely for testing purposes.</p>&#13;
<p class="indent">The first step is to register your project on the test server. Start by opening your <em>~/.pypirc</em> file and adding these lines:</p>&#13;
<pre>[distutils]<br/>index-servers =<br/>    testpypi<span epub:type="pagebreak" id="page_65"/><br/>[testpypi]<br/>username = &lt;your username&gt;<br/>password = &lt;your password&gt;<br/>repository = https://testpypi.python.org/pypi</pre>&#13;
<p class="indent">Save the file, and now you can register your project in the index:</p>&#13;
<pre><span class="codestrong1">$ python setup.py register -r testpypi</span><br/>running register<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Reusing existing SOURCES.txt<br/>running check<br/>Registering ceilometer to https://testpypi.python.org/pypi<br/>Server response (200): OK</pre>&#13;
<p class="indent">This connects to the test PyPI server instance and creates a new entry. Don’t forget to use the <code>-r</code> option; otherwise, the real production PyPI instance would be used!</p>&#13;
<p class="indent">Obviously, if a project with the same name is already registered there, the process will fail. Retry with a new name, and once you get your program registered and receive the <code>OK</code> response, you can upload a source distribution tarball, as shown in <a href="ch05.xhtml#ch5list7">Listing 5-7</a>.</p>&#13;
<pre>$ <span class="codestrong1">python setup.py sdist upload -r testpypi</span><br/>running sdist<br/>[pbr] Writing ChangeLog<br/>[pbr] Generating AUTHORS<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Processing SOURCES.txt<br/>[pbr] In git context, generating filelist from git<br/>warning: no previously-included files matching '*.pyc' found anywhere in<br/>distribution<br/>writing manifest file 'ceilometer.egg-info/SOURCES.txt'<br/>running check<br/>creating ceilometer-2014.1.a6.g772e1a7<br/><br/><span class="codeitalic1">--snip--</span><br/><br/>copying setup.cfg -&gt; ceilometer-2014.1.a6.g772e1a7<br/>Writing ceilometer-2014.1.a6.g772e1a7/setup.cfg<br/>Creating tar archive<br/>removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)<br/>running upload<span epub:type="pagebreak" id="page_66"/><br/>Submitting dist/ceilometer-2014.1.a6.g772e1a7.tar.gz to https://testpypi<br/>.python.org/pypi<br/>Server response (200): OK</pre>&#13;
<p class="listing1"><a id="ch5list7"/><em>Listing 5-7: Uploading your tarball to PyPI</em></p>&#13;
<p class="indent">Alternatively, you could upload a <code>Wheel</code> archive, as in <a href="ch05.xhtml#ch5list8">Listing 5-8</a>.</p>&#13;
<pre><span class="codestrong1">$ python setup.py bdist_wheel upload -r testpypi</span><br/>running bdist_wheel<br/>running build<br/>running build_py<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Reusing existing SOURCES.txt<br/>installing to build/bdist.linux-x86_64/wheel<br/>running install<br/>running install_lib<br/>creating build/bdist.linux-x86_64/wheel<br/><br/><span class="codeitalic1">--snip--</span><br/><br/>creating build/bdist.linux-x86_64/wheel/ceilometer-2014.1.a6.g772e1a7<br/>.dist-info/WHEEL<br/>running upload<br/>Submitting /home/jd/Source/ceilometer/dist/ceilometer-2014.1.a6<br/>.g772e1a7-py27-none-any.whl to https://testpypi.python.org/pypi<br/>Server response (200): OK</pre>&#13;
<p class="listing1"><a id="ch5list8"/><em>Listing 5-8: Uploading a <span class="codeitalic">Wheel</span> archive to PyPI</em></p>&#13;
<p class="indent">Once those operations are finished, you and other users can search for the uploaded packages on the PyPI staging server, and even install those packages using <code>pip</code>, by specifying the test server using the <code>-i</code> option:</p>&#13;
<pre><span class="codestrong1">$ pip install -i https://testpypi.python.org/pypi ceilometer</span></pre>&#13;
<p class="indent">If everything checks out, you can upload your project to the main PyPI server. Just make sure to add your credentials and the details for the server to your <code>~/.pypirc</code> file first, like so:</p>&#13;
<pre>[distutils]<br/>index-servers =<br/>    pypi<br/>    testpypi<br/><br/>[pypi]<br/>username = <span class="codeitalic1">&lt;your username&gt;</span><br/>password = <span class="codeitalic1">&lt;your password&gt;</span><span epub:type="pagebreak" id="page_67"/><br/>[testpypi]<br/>repository = https://testpypi.python.org/pypi<br/>username = <span class="codeitalic1">&lt;your username&gt;</span><br/>password = <span class="codeitalic1">&lt;your password&gt;</span></pre>&#13;
<p class="indent">Now if you run <code>register</code> and <code>upload</code> with the <code>-r pypi</code> switch, your package should be uploaded to PyPI.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>PyPI can keep several versions of your software in its index, allowing you to install specific and older versions, if you ever need to. Just pass the version number to the <span class="codeitalic">pip install</span> command; for example, <span class="codeitalic">pip install foobar==1.0.2</span>.</em></p>&#13;
</div>&#13;
<p class="indent">This process is straightforward to use and allows for any number of uploads. You can release your software as often as you want, and your users can install and update as often as they need.</p>&#13;
<h3 class="h3" id="lev1sec27"><strong>Entry Points</strong></h3>&#13;
<p class="noindent">You may have already used <code>setuptools</code> entry points without knowing anything about them. Software distributed using <code>setuptools</code> includes important metadata describing features such as its required dependencies and—more relevantly to this topic—a list of <em>entry points</em>. Entry points are methods by which other Python programs can discover the dynamic features a package provides.</p>&#13;
<p class="indent">The following example shows how to provide an entry point named <code>rebuildd</code> in the <code>console_scripts</code> entry point group:</p>&#13;
<pre>#!/usr/bin/python<br/>from distutils.core import setup<br/><br/>setup(name="rebuildd",<br/>    description="Debian packages rebuild tool",<br/>    author="Julien Danjou",<br/>    author_email="acid@debian.org",<br/>    url="http://julien.danjou.info/software/rebuildd.html",<br/>    entry_points={<br/>        'console_scripts': [<br/>            'rebuildd = rebuildd:main',<br/>        ],<br/>    },<br/>    packages=['rebuildd'])</pre>&#13;
<p class="indent">Any Python package can register entry points. Entry points are organized in groups: each group is made of a list of key and value pairs. Those pairs use the format <code><span class="codeitalic">path</code>.<span class="codeitalic">to</span>.<span class="codeitalic">module</span>:<span class="codeitalic">variable</span>_<span class="codeitalic">name</span></span>. In the previous example, the key is <code>rebuildd</code>, and the value is <code>rebuildd:main</code>.</p>&#13;
<p class="indent">The list of entry points can be manipulated using various tools, from <code>setuptools</code> to <code>epi</code>, as I’ll show here. In the following sections, we discuss how we can use entry points to add extensibility to our software.</p>&#13;
<h4 class="h4" id="lev2sec18"><span epub:type="pagebreak" id="page_68"/><strong><em>Visualizing Entry Points</em></strong></h4>&#13;
<p class="noindent">The easiest way to visualize the entry points available in a package is to use a package called <code>entry point inspector</code>. You can install it by running <code>pip install entry-point-inspector</code>. When installed, it provides the command <code>epi</code> that you can run from your terminal to interactively discover the entry points provided by installed packages. <a href="ch05.xhtml#ch5list9">Listing 5-9</a> shows an example of running <code>epi group list</code> on my system.</p>&#13;
<pre>$ <span class="codestrong1">epi group list</span><br/>---------------------------<br/>| Name                    |<br/>--------------------------<br/>| console_scripts |<br/>| distutils.commands |<br/>| distutils.setup_keywords |<br/>| egg_info.writers |<br/>| epi.commands |<br/>| flake8.extension |<br/>| setuptools.file_finders |<br/>| setuptools.installation |<br/>--------------------------</pre>&#13;
<p class="listing1"><a id="ch5list9"/><em>Listing 5-9: Getting a list of entry point groups</em></p>&#13;
<p class="indent">The output from <code>epi group list</code> in <a href="ch05.xhtml#ch5list9">Listing 5-9</a> shows the different packages on a system that provide entry points. Each item in this table is the name of an entry point group. Note that this list includes <code>console_scripts</code>, which we’ll discuss shortly. We can use the <code>epi</code> command with the <code>show</code> command to show details of a particular entry point group, as in <a href="ch05.xhtml#ch5list10">Listing 5-10</a>.</p>&#13;
<pre>$ <span class="codestrong1">epi group show console_scripts</span><br/>-------------------------------------------------<br/>| Name     | Module   | Member | Distribution | Error |<br/>-------------------------------------------------<br/>| coverage | coverage | main   | coverage 3.4 |       |</pre>&#13;
<p class="listing1"><a id="ch5list10"/><em>Listing 5-10: Showing details of an entry point group</em></p>&#13;
<p class="indent">We can see that in the group <code>console_scripts</code>, an entry point named <code>coverage</code> refers to the member <code>main</code> of the module <code>coverage</code>. This entry point in particular, provided by the package <code>coverage 3.4</code>, indicates which Python function to call when the command line script <code>coverage</code> is executed. Here, the function <code>coverage.main</code> is to be called.</p>&#13;
<p class="indent">The <code>epi</code> tool is just a thin layer on top of the complete Python library <code>pkg_resources</code>. This module allows us to discover entry points for any Python library or program. Entry points are valuable for various things, including console scripts and dynamic code discovery, as you’ll see in the next few sections.</p>&#13;
<h4 class="h4" id="lev2sec19"><span epub:type="pagebreak" id="page_69"/><strong><em>Using Console Scripts</em></strong></h4>&#13;
<p class="noindent">When writing a Python application, you almost always have to provide a launchable program—a Python script that the end user can run—that needs to be installed inside a directory somewhere in the system path.</p>&#13;
<p class="indent">Most projects have a launchable program similar to this:</p>&#13;
<pre>#!/usr/bin/python<br/>import sys<br/>import mysoftware<br/><br/>mysoftware.SomeClass(sys.argv).run()</pre>&#13;
<p class="indent">This kind of script is a best-case scenario: many projects have a much longer script installed in the system path. However, such scripts pose some major issues:</p>&#13;
<ul>&#13;
<li><p class="noindent">There’s no way the user can know where the Python interpreter is or which version it uses.</p></li>&#13;
<li><p class="noindent">This script leaks binary code that can’t be imported by software or unit tests.</p></li>&#13;
<li><p class="noindent">There’s no easy way to define where to install this script.</p></li>&#13;
<li><p class="noindent">It’s not obvious how to install this in a portable way (for example, on both Unix and Windows).</p></li>&#13;
</ul>&#13;
<p class="indent">Helping us circumvent these problems, <code>setuptools</code> offers the <code>console_scripts</code> feature. This entry point can be used to make <code>setuptools</code> install a tiny program in the system path that calls a specific function in one of your modules. With <code>setuptools</code>, you can specify a function call to start your program by setting up a key/value pair in the <code>console_scripts</code> entry point group: the key is the script name that will be installed, and the value is the Python path to your function (something like <code>my_module.main</code>).</p>&#13;
<p class="indent">Let’s imagine a <code>foobar</code> program that consists of a client and a server. Each part is written in its module—<code>foobar.client</code> and <code>foobar.server</code>, respectively, in <em>foobar/client.py</em>:</p>&#13;
<pre>def main():<br/>    print("Client started")</pre>&#13;
<p class="noindent">And in <em>foobar/server.py</em>:</p>&#13;
<pre>def main():<br/>    print("Server started")</pre>&#13;
<p class="indent">Of course, this program doesn’t do much of anything—our client and server don’t even talk to each other. For our example, though, they just need to print a message letting us know they have started successfully.</p>&#13;
<p class="indent">We can now write the following <em>setup.py</em> file in the root directory with entry points defined in <em>setup.py</em>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_70"/>from setuptools import setup<br/><br/>setup(<br/>    name="foobar",<br/>    version="1",<br/>    description="Foo!",<br/>    author="Julien Danjou",<br/>    author_email="julien@danjou.info",<br/>    packages=["foobar"],<br/>    entry_points={<br/>        "console_scripts": [<br/>         <span class="ent">➊</span> "foobard = foobar.server:main",<br/>            "foobar = foobar.client:main",<br/>        ],<br/>     },<br/>)</pre>&#13;
<p class="indent">We define entry points using the format <code>module.submodule:function</code>. You can see here that we’ve defined an entry point each for both <code>client</code> and <code>server</code> <span class="ent">➊</span>.</p>&#13;
<p class="indent">When <code>python setup.py install</code> is run, <code>setuptools</code> will create a script that will look like the one in <a href="ch05.xhtml#ch5list11">Listing 5-11</a>.</p>&#13;
<pre>#!/usr/bin/python<br/># EASY-INSTALL-ENTRY-SCRIPT: 'foobar==1','console_scripts','foobar'<br/>__requires__ = 'foobar==1'<br/>import sys<br/>from pkg_resources import load_entry_point<br/><br/>if __name__ == '__main__':<br/>    sys.exit(<br/>        load_entry_point('foobar==1', 'console_scripts', 'foobar')()<br/>    )</pre>&#13;
<p class="listing1"><a id="ch5list11"/><em>Listing 5-11: A console script generated by <span class="codeitalic">setuptools</span></em></p>&#13;
<p class="indent">This code scans the entry points of the <code>foobar</code> package and retrieves the <code>foobar</code> key from the <code>console_scripts</code> group, which is used to locate and run the corresponding function. The return value of the <code>load_entry_point</code> will then be a reference to the function <code>foobar.client.main</code>, which will be called without any arguments and whose return value will be used as an exit code.</p>&#13;
<p class="indent">Notice that this code uses <code>pkg_resources</code> to discover and load entry point files from within your Python programs.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re using <span class="codeitalic">pbr</span> on top of <span class="codeitalic">setuptools</span>, the generated script is simpler (and therefore faster) than the default one built by <span class="codeitalic">setuptools</span>, as it will call the function you wrote in the entry point without having to search the entry point list dynamically at runtime.</em></p>&#13;
</div>&#13;
<p class="indent">Using console scripts is a technique that removes the burden of writing portable scripts, while ensuring that your code stays in your Python package and can be imported (and tested) by other programs.</p>&#13;
<h4 class="h4" id="lev2sec20"><span epub:type="pagebreak" id="page_71"/><strong><em>Using Plugins and Drivers</em></strong></h4>&#13;
<p class="noindent">Entry points make it easy to discover and dynamically load code deployed by other packages, but this is not their only use. Any application can propose and register entry points and groups and then use them as it wishes.</p>&#13;
<p class="indent">In this section, we’re going to create a <code>cron</code>-style daemon <code>pycrond</code> that will allow any Python program to register a command to be run once every few seconds by registering an entry point in the group <code>pytimed</code>. The attribute indicated by this entry point should be an object that returns <code>number_of_seconds, callable</code>.</p>&#13;
<p class="indent">Here’s our implementation of <code>pycrond</code> using <code>pkg_resources</code> to discover entry points, in a program I’ve named <em>pytimed.py</em>:</p>&#13;
<pre>import pkg_resources<br/>import time<br/><br/>def main():<br/>    seconds_passed = 0<br/>    while True:<br/>        for entry_point in pkg_resources.iter_entry_points('pytimed'):<br/>            try:<br/>                seconds, callable = entry_point.load()()<br/>            except:<br/>                # Ignore failure<br/>                pass<br/>            else:<br/>                if seconds_passed % seconds == 0:<br/>                    callable()<br/>        time.sleep(1)<br/>        seconds_passed += 1</pre>&#13;
<p class="indent">This program consists of an infinite loop that iterates over each entry point of the <code>pytimed</code> group. Each entry point is loaded using the <code>load()</code> method. The program then calls the returned method, which needs to return the number of seconds to wait before calling the callable as well as the aforementioned callable.</p>&#13;
<p class="indent">The program in <em>pytimed.py</em> is a very simplistic and naive implementation, but it is sufficient for our example. Now we can write another Python program, named <em>hello.py</em>, that needs one of its functions called on a periodic basis:</p>&#13;
<pre>def print_hello():<br/>    print("Hello, world!")<br/><br/>def say_hello():<br/>    return 2, print_hello</pre>&#13;
<p class="indent">Once we have that function defined, we register it using the appropriate entry points in <em>setup.py</em>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_72"/>from setuptools import setup<br/><br/>setup(<br/>    name="hello",<br/>    version="1",<br/>    packages=["hello"],<br/>    entry_points={<br/>        "pytimed": [<br/>            "hello = hello:say_hello",<br/>        ],<br/>     },)</pre>&#13;
<p class="indent">The <em>setup.py</em> script registers an entry point in the group <code>pytimed</code> with the key <code>hello</code> and the value pointing to the function <code>hello.say_hello</code>. Once that package is installed using that <em>setup.py</em>—for example, using <code>pip install</code>—the <code>pytimed</code> script can detect the newly added entry point.</p>&#13;
<p class="indent">At startup, <code>pytimed</code> will scan the group <code>pytimed</code> and find the key <code>hello</code>. It will then call the <code>hello.say_hello</code> function, getting two values: the number of seconds to wait between each call and the function to call, 2 seconds and <code>print_hello</code> in this case. By running the program, as we do in <a href="ch05.xhtml#ch5list12">Listing 5-12</a>, you can see “Hello, world!” printed on the screen every 2 seconds.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import pytimed</span><br/>&gt;&gt;&gt; <span class="codestrong1">pytimed.main()</span><br/>Hello, world!<br/>Hello, world!<br/>Hello, world!</pre>&#13;
<p class="listing1"><a id="ch5list12"/><em>Listing 5-12: Running <span class="codeitalic">pytimed</span></em></p>&#13;
<p class="indent">The possibilities this mechanism offers are immense: you can build driver systems, hook systems, and extensions easily and generically. Implementing this mechanism by hand in every program you make would be tedious, but fortunately, there’s a Python library that can take care of the boring parts for us.</p>&#13;
<p class="indent">The <code>stevedore</code> library provides support for dynamic plugins based on the same mechanism demonstrated in our previous examples. The use case in this example is already simplistic, but we can still simplify it further in this script, <em>pytimed_stevedore.py</em>:</p>&#13;
<pre>from stevedore.extension import ExtensionManager<br/>import time<br/><br/>def main():<br/>    seconds_passed = 0<br/>    extensions = ExtensionManager('pytimed', invoke_on_load=True)<br/>    while True:<br/>        for extension in extensions:<br/>            try:<br/>                seconds, callable = extension.obj<span epub:type="pagebreak" id="page_73"/><br/>            except:<br/>                # Ignore failure<br/>                pass<br/>            else:<br/>                if seconds_passed % seconds == 0:<br/>                    callable()<br/>        time.sleep(1)<br/>        seconds_passed += 1</pre>&#13;
<p class="indent">The <code>ExtensionManager</code> class of <code>stevedore</code> provides a simple way to load all extensions of an entry point group. The name is passed as a first argument. The argument <code>invoke_on_load=True</code> makes sure that each function of the group is called once discovered. This makes the results accessible directly from the <code>obj</code> attribute of the extension.</p>&#13;
<p class="indent">If you look through the <code>stevedore</code> documentation, you will see that <code>ExtensionManager</code> has a variety of subclasses that can handle different situations, such as loading specific extensions based on their names or the result of a function. All of those are commonly used models you can apply to your program in order to implement those patterns directly.</p>&#13;
<p class="indent">For example, we might want to load and run only one extension from our entry point group. Leveraging the <code>stevedore.driver.DriverManager</code> class allows us to do that, as <a href="ch05.xhtml#ch5list13">Listing 5-13</a> shows.</p>&#13;
<pre>from stevedore.driver import DriverManager<br/>import time<br/><br/>def main(name):<br/>    seconds_passed = 0<br/>    seconds, callable = DriverManager('pytimed', name, invoke_on_load=True).<br/>driver<br/>    while True:<br/>        if seconds_passed % seconds == 0:<br/>            callable()<br/>        time.sleep(1)<br/>        seconds_passed += 1<br/><br/>main("hello")</pre>&#13;
<p class="listing1"><a id="ch5list13"/><em>Listing 5-13: Using <span class="codeitalic">stevedore</span> to run a single extension from an entry point</em></p>&#13;
<p class="indent">In this case, only one extension is loaded and selected by name. This allows us to quickly build a <em>driver system</em> in which only one extension is loaded and used by a program.</p>&#13;
<h3 class="h3" id="lev1sec28"><strong>Summary</strong></h3>&#13;
<p class="noindent">The packaging ecosystem in Python has a bumpy history; however, the situation is now settling. The <code>setuptools</code> library provides a complete solution to packaging, not only to transport your code in different formats and upload it to PyPI, but also to handle connection with other software and libraries via entry points.</p>&#13;
<h3 class="h3" id="lev1sec29"><span epub:type="pagebreak" id="page_74"/><strong>Nick Coghlan on Packaging</strong></h3>&#13;
<p class="noindent">Nick is a Python core developer working at Red Hat. He has written several PEP proposals, including PEP 426 (Metadata for Python Software Packages 2.0), and he is acting as delegate for our Benevolent Dictator for Life, Guido van Rossum, author of Python.</p>&#13;
<p class="noindentt"><strong>The number of packaging solutions (<span class="codestrong">distutils, setuptools, distutils2, distlib, bento, pbr</span>, and so on) for Python is quite extensive. In your opinion, what are the reasons for such fragmentation and divergence?</strong></p>&#13;
<p class="noindent">The short answer is that software publication, distribution, and integration is a complex problem with plenty of room for multiple solutions tailored for different use cases. In my recent talks on this, I have noted that the problem is mainly one of age, with the different packaging tools being born into different eras of software distribution.</p>&#13;
<p class="noindentt"><strong>PEP 426, which defines a new metadata format for Python packages, is still fairly recent and not yet approved. How do you think it will tackle current packaging problems?</strong></p>&#13;
<p class="noindent">PEP 426 originally started as part of the <code>Wheel</code> format definition, but Daniel Holth realized that <code>Wheel</code> could work with the existing metadata format defined by <code>setuptools</code>. PEP 426 is thus a consolidation of the existing <code>setuptools</code> metadata with some of the ideas from <code>distutils2</code> and other packaging systems (such as <code>RPM</code> and <code>npm</code>). It addresses some of the frustrations encountered with existing tools (for example, with cleanly separating different kinds of dependencies).</p>&#13;
<p class="indent">The main gains will be a REST API on PyPI offering full metadata access, as well as (hopefully) the ability to automatically generate distribution policy–compliant packages from upstream metadata.</p>&#13;
<p class="noindentt"><strong>The <code>Wheel</code> format is somewhat recent and not widely used yet, but it seems promising. Why is it not part of the Standard Library?</strong></p>&#13;
<p class="noindent">It turns out the Standard Library is not really a suitable place for packaging standards: it evolves too slowly, and an addition to a later version of the Standard Library cannot be used with earlier versions of Python. So, at the Python language summit earlier this year, we tweaked the PEP process to allow <code>distutils-sig</code> to manage the full approval cycle for packaging-related PEPs, and <code>python-dev</code> will only be involved for proposals that involve changing CPython directly (such as <code>pip</code> bootstrapping).</p>&#13;
<p class="noindentt"><strong>What is the future for <strong>Wheel</strong> packages?</strong></p>&#13;
<p class="noindent">We still have some tweaks to make before <code>Wheel</code> is suitable for use on Linux. However, <code>pip</code> is adopting <code>Wheel</code> as an alternative to the <code>Egg</code> format, allowing local caching of builds for fast virtual environment creation, and PyPI allows uploads of <code>Wheel</code> archives for Windows and macOS.</p>&#13;
</body></html>