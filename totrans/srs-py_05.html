<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_57"/><strong><span class="big">5</span></strong><br/><strong>DISTRIBUTING YOUR SOFTWARE</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">It’s safe to say that at some point, you will want to distribute your software. As tempted as you might be to just zip your code and upload it to the internet, Python provides tools to make it easier for your end users to get your software to work. You should already be familiar with using <em>setup.py</em> to install Python applications and libraries, but you have probably never delved into how it works behind the scenes or how to make a <em>setup.py</em> of your own.</p>&#13;
<p class="indent">In this chapter, you’ll learn the history of <em>setup.py</em>, how the file works, and how to create your own custom <em>setup.py</em>. We’ll also take a look at some of the less well-known capabilities of the package installation tool <span class="literal">pip</span> and how to make your software downloadable via <span class="literal">pip</span>. Finally, we’ll see how to use Python’s entry points to make functions easy to find between programs. With these skills, you can make your published software accessible for end users.</p>&#13;
<h3 class="h3" id="lev1sec23"><span epub:type="pagebreak" id="page_58"/><strong>A Bit of setup.py History</strong></h3>&#13;
<p class="noindent">The <span class="literal">distutils</span> library, originally created by software developer Greg Ward, has been part of the standard Python library since 1998. Ward sought to create an easy way for developers to automate the installation process for their end users. Packages provide the <em>setup.py</em> file as the standard Python script for their installation, and they can use <span class="literal">distutils</span> to install themselves, as shown in <a href="ch05.xhtml#ch5list1">Listing 5-1</a>.</p>&#13;
<p class="programs">#!/usr/bin/python<br/>from distutils.core import setup<br/><br/>setup(name="rebuildd",<br/>      description="Debian packages rebuild tool",<br/>      author="Julien Danjou",<br/>      author_email="acid@debian.org",<br/>      url="http://julien.danjou.info/software/rebuildd.html",<br/>      packages=['rebuildd'])</p>&#13;
<p class="listing1"><a id="ch5list1"/><em>Listing 5-1: Building a <span class="roman">setup.py</span> using <span class="codeitalic">distutils</span></em></p>&#13;
<p class="indent">With the <em>setup.py</em> file as the root of a project, all users have to do to build or install your software is run that file with the appropriate command as its argument. Even if your distribution includes C modules in addition to native Python ones, <span class="literal">distutils</span> can handle them automatically.</p>&#13;
<p class="indent">Development of <span class="literal">distutils</span> was abandoned in 2000; since then, other developers have picked up where it left off. One of the notable successors is the packaging library known as <span class="literal">setuptools</span>, which offers more frequent updates and advanced features, such as automatic dependency handling, the <span class="literal">Egg</span> distribution format, and the <span class="literal">easy_install</span> command. Since <span class="literal">distutils</span> was still the accepted means of packaging software included with the Python Standard Library at the time of development, <span class="literal">setuptools</span> provided a degree of backward compatibility with it. <a href="ch05.xhtml#ch5list2">Listing 5-2</a> shows how you’d use <span class="literal">setuptools</span> to build the same installation package as in <a href="ch05.xhtml#ch5list1">Listing 5-1</a>.</p>&#13;
<p class="programs">#!/usr/bin/env python<br/>import setuptools<br/><br/>setuptools.setup(<br/>    name="rebuildd",<br/>    version="0.2",<br/>    author="Julien Danjou",<br/>    author_email="acid@debian.org",<br/>    description="Debian packages rebuild tool",<br/>    license="GPL",<br/>    url="http://julien.danjou.info/software/rebuildd/",<br/>    packages=['rebuildd'],<br/>    classifiers=[<br/>        "Development Status :: 2 - Pre-Alpha",<br/>        "Intended Audience :: Developers",<br/>        "Intended Audience :: Information Technology",<br/>        "License :: OSI Approved :: GNU General Public License (GPL)",<span epub:type="pagebreak" id="page_59"/><br/>        "Operating System :: OS Independent",<br/>        "Programming Language :: Python"<br/>    ],<br/>)</p>&#13;
<p class="listing1"><a id="ch5list2"/><em>Listing 5-2: Building a <span class="roman">setup.py</span> using <span class="codeitalic">setuptools</span></em></p>&#13;
<p class="indent">Eventually, development on <span class="literal">setuptools</span> slowed down too, but it wasn’t long before another group of developers forked it to create a new library called <span class="literal">distribute</span>, which offered several advantages over <span class="literal">setuptools</span>, including fewer bugs and Python 3 support.</p>&#13;
<p class="indent">All the best stories have a twist ending, though: in March 2013, the teams behind <span class="literal">setuptools</span> and <span class="literal">distribute</span> decided to merge their codebases under the aegis of the original <span class="literal">setuptools</span> project. So <span class="literal">distribute</span> is now deprecated, and <span class="literal">setuptools</span> is once more the canonical way to handle advanced Python installations.</p>&#13;
<p class="indent">While all this was happening, another project, known as <span class="literal">distutils2</span>, was developed with the intention of completely replacing <span class="literal">distutils</span> in the Python Standard Library. Unlike both <span class="literal">distutils</span> and <span class="literal">setuptools</span>, it stored package metadata in a plaintext file, <em>setup.cfg</em>, which was easier both for developers to write and for external tools to read. However, <span class="literal">distutils2</span> retained some of the failings of <span class="literal">distutils</span>, such as its obtuse command-based design, and lacked support for entry points and native script execution on Windows—both features provided by <span class="literal">setuptools</span>. For these and other reasons, plans to include <span class="literal">distutils2</span>, renamed as <span class="literal">packaging</span>, in the Python 3.3 Standard Library fell through, and the project was abandoned in 2012.</p>&#13;
<p class="indent">There is still a chance for <span class="literal">packaging</span> to rise from the ashes through <span class="literal">distlib</span>, an up-and-coming effort to replace <span class="literal">distutils</span>. Before release, it was rumored that the <span class="literal">distlib</span> package would become part of the Standard Library in Python 3.4, but that never came to be. Including the best features from <span class="literal">packaging</span>, <span class="literal">distlib</span> implements the basic groundwork described in the packaging-related PEPs.</p>&#13;
<p class="indent">So, to recap:</p>&#13;
<ul>&#13;
<li><p class="noindent"><span class="codestrong">distutils</span> is part of the Python Standard Library and can handle simple package installations.</p></li>&#13;
<li><p class="noindent"><span class="codestrong">setuptools</span>, the standard for advanced package installations, was at first deprecated but is now back in active development and the de facto standard.</p></li>&#13;
<li><p class="noindent"><span class="codestrong">distribute</span> has been merged back into <span class="literal">setuptools</span> as of version 0.7; <span class="codestrong">distutils2</span> (aka <span class="literal">packaging</span>) has been abandoned.</p></li>&#13;
<li><p class="noindent"><span class="codestrong">distlib</span> <em>might</em> replace <span class="literal">distutils</span> in the future.</p></li>&#13;
</ul>&#13;
<p class="indent">There are other packaging libraries out there, but these are the five you’ll encounter the most. Be careful when researching these libraries on the internet: plenty of documentation is outdated due to the complicated history outlined above. The official documentation is up-to-date, however.</p>&#13;
<p class="indent">In short, <span class="literal">setuptools</span> is the distribution library to use for the time being, but keep an eye out for <span class="literal">distlib</span> in the future.</p>&#13;
<h3 class="h3" id="lev1sec24"><span epub:type="pagebreak" id="page_60"/><strong>Packaging with setup.cfg</strong></h3>&#13;
<p class="noindent">You’ve probably already tried to write a <em>setup.py</em> for a package at some point, either by copying one from another project or by skimming through the documentation and building it yourself. Building a <em>setup.py</em> is not an intuitive task. Choosing the right tool to use is just the first challenge. In this section, I want to introduce you to one of the recent improvements to <span class="literal">setuptools</span>: the <em>setup.cfg</em> file support.</p>&#13;
<p class="indent">This is what a <em>setup.py</em> using a <em>setup.cfg</em> file looks like:</p>&#13;
<p class="programs">import setuptools<br/><br/>setuptools.setup()</p>&#13;
<p class="indent">Two lines of code—it is that simple. The actual metadata the setup requires is stored in <em>setup.cfg</em>, as in <a href="ch05.xhtml#ch5list3">Listing 5-3</a>.</p>&#13;
<p class="programs">[metadata]<br/>name = foobar<br/>author = Dave Null<br/>author-email = foobar@example.org<br/>license = MIT<br/>long_description = file: README.rst<br/>url = http://pypi.python.org/pypi/foobar<br/>requires-python = &gt;=2.6<br/>classifiers =<br/>    Development Status :: 4 - Beta<br/>    Environment :: Console<br/>    Intended Audience :: Developers<br/>    Intended Audience :: Information Technology<br/>    License :: OSI Approved :: Apache Software License<br/>    Operating System :: OS Independent<br/>    Programming Language :: Python</p>&#13;
<p class="listing1"><a id="ch5list3"/><em>Listing 5-3: The <span class="roman">setup.cfg</span> metadata</em></p>&#13;
<p class="indent">As you can see, <em>setup.cfg</em> uses a format that’s easy to write and read, directly inspired by <span class="literal">distutils2</span>. Many other tools, such as <span class="literal">Sphinx</span> or <span class="literal">Wheel</span>, also read configuration from this <em>setup.cfg</em> file—that alone is a good argument to start using it.</p>&#13;
<p class="indent">In <a href="ch05.xhtml#ch5list3">Listing 5-3</a>, the description of the project is read from the <em>README.rst</em> file. It’s good practice to always have a README file—preferably in the RST format—so users can quickly understand what the project is about. With just these basic <em>setup.py</em> and <em>setup.cfg</em> files, your package is ready to be published and used by other developers and applications. The <span class="literal">setuptools</span> documentation provides more details if needed, for example, if you have some extra steps in your installation process or want to include extra files.</p>&#13;
<p class="indent">Another useful packaging tool is <span class="literal">pbr</span>, short for <em>Python Build Reasonableness</em>. The project was started in OpenStack as an extension of <span class="literal">setuptools</span> to <span epub:type="pagebreak" id="page_61"/>facilitate installation and deployment of packages. The <span class="literal">pbr</span> packaging tool, used alongside <span class="literal">setuptools</span>, implements features absent from <span class="literal">setuptools</span>, including these:</p>&#13;
<ul>&#13;
<li><p class="noindent">Automatic generation of Sphinx documentation</p></li>&#13;
<li><p class="noindent">Automatic generation of <em>AUTHORS</em> and <em>ChangeLog</em> files based on <span class="literal">git</span> history</p></li>&#13;
<li><p class="noindent">Automatic creation of file lists for <span class="literal">git</span></p></li>&#13;
<li><p class="noindent">Version management based on <span class="literal">git</span> tags using semantic versioning</p></li>&#13;
</ul>&#13;
<p class="indent">And all this with little to no effort on your part. To use <span class="literal">pbr</span>, you just need to enable it, as shown in <a href="ch05.xhtml#ch5list4">Listing 5-4</a>.</p>&#13;
<p class="programs"><span class="codestrong1">import setuptools</span><br/><br/><span class="codestrong1">setuptools.setup(setup_requires=['pbr'], pbr=True)</span></p>&#13;
<p class="listing1"><a id="ch5list4"/><em>Listing 5-4: <span class="roman">setup.py</span> using pbr</em></p>&#13;
<p class="indent">The <span class="literal">setup_requires</span> parameter indicates to <span class="literal">setuptools</span> that <span class="literal">pbr</span> must be installed prior to using <span class="literal">setuptools</span>. The <span class="literal">pbr=True</span> argument makes sure that the <span class="literal">pbr</span> extension for <span class="literal">setuptools</span> is loaded and called.</p>&#13;
<p class="indent">Once enabled, the <span class="literal">python setup.py</span> command is enhanced with the <span class="literal">pbr</span> features. Calling <span class="literal">python setup.py –version</span> will, for example, return the version number of the project based on existing <span class="literal">git</span> tags. Running <span class="literal">python setup.py sdist</span> would create a source tarball with automatically generated <em>ChangeLog</em> and <em>AUTHORS</em> files.</p>&#13;
<h3 class="h3" id="lev1sec25"><strong>The Wheel Format Distribution Standard</strong></h3>&#13;
<p class="noindent">For most of Python’s existence, there’s been no official standard distribution format. While different distribution tools generally use some common archive format—even the <span class="literal">Egg</span> format introduced by <span class="literal">setuptools</span> is just a zip file with a different extension—their metadata and package structures are incompatible with each other. This problem was compounded when an official installation standard was finally defined in PEP 376 that was also incompatible with existing formats.</p>&#13;
<p class="indent">To solve these problems, PEP 427 was written to define a new standard for Python distribution packages called <span class="literal">Wheel</span>. The reference implementation of this format is available as a tool, also called <span class="literal">Wheel</span>.</p>&#13;
<p class="indent"><span class="literal">Wheel</span> is supported by <span class="literal">pip</span> starting with version 1.4. If you’re using <span class="literal">setuptools</span> and have the <span class="literal">Wheel</span> package installed, it automatically integrates itself as a <span class="literal">setuptools</span> command named <span class="literal">bdist_wheel</span>. If you don’t have <span class="literal">Wheel</span> installed, you can install it using the command <span class="literal">pip install wheel</span>. <a href="ch05.xhtml#ch5list5">Listing 5-5</a> shows some of the output when calling <span class="literal">bdist_wheel</span>, abridged for print.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_62"/>   $ <span class="codestrong1">python setup.py bdist_wheel</span><br/>   running bdist_wheel<br/>   running build<br/>   running build_py<br/>   creating build/lib<br/>   creating build/lib/daiquiri<br/>   creating build/lib/daiquiri/tests<br/>   copying daiquiri/tests/__init__.py -&gt; build/lib/daiquiri/tests<br/>   <span class="codeitalic1">--snip--</span><br/>   running egg_info<br/>   writing requirements to daiquiri.egg-info/requires.txt<br/>   writing daiquiri.egg-info/PKG-INFO<br/>   writing top-level names to daiquiri.egg-info/top_level.txt<br/>   writing dependency_links to daiquiri.egg-info/dependency_links.txt<br/>   writing pbr to daiquiri.egg-info/pbr.json<br/>   writing manifest file 'daiquiri.egg-info/SOURCES.txt'<br/>   installing to build/bdist.macosx-10.12-x86_64/wheel<br/>   running install<br/>   running install_lib<br/>   <span class="codeitalic1">--snip--</span><br/><br/>   running install_scripts<br/>   creating build/bdist.macosx-10.12-x86_64/wheel/daiquiri-1.3.0.dist-info/WHEEL<br/><span class="ent">➊</span> creating '/Users/jd/Source/daiquiri/dist/daiquiri-1.3.0-py2.py3-none-any.whl'<br/>   and adding '.' to it<br/>   adding 'daiquiri/__init__.py'<br/>   adding 'daiquiri/formatter.py'<br/>   adding 'daiquiri/handlers.py'<br/><br/>   <span class="codeitalic1">--snip--</span></p>&#13;
<p class="listing1"><a id="ch5list5"/><em>Listing 5-5: Calling <span class="codeitalic">setup.py bdist_wheel</span></em></p>&#13;
<p class="indent">The <span class="literal">bdist_wheel</span> command creates a <em>.whl</em> file in the <em>dist</em> directory <span class="ent">➊</span>. As with the <span class="literal">Egg</span> format, a <span class="literal">Wheel</span> archive is just a zip file with a different extension. However, <span class="literal">Wheel</span> archives do not require installation—you can load and run your code just by adding a slash followed by the name of your module:</p>&#13;
<p class="programs">$ <span class="codestrong1">python wheel-0.21.0-py2.py3-none-any.whl/wheel -h</span><br/>usage: wheel [-h]<br/><br/>             {keygen,sign,unsign,verify,unpack,install,install-<br/>scripts,convert,help}<br/>             --<span class="codeitalic1">snip</span>--<br/><br/>positional arguments:<br/>--<span class="codeitalic1">snip</span>--</p>&#13;
<p class="indent">You might be surprised to learn this is not a feature introduced by the <span class="literal">Wheel</span> format itself. Python can also run regular zip files, just like with Java’s <em>.jar</em> files:</p>&#13;
<p class="programs">python foobar.zip</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>This is equivalent to:</p>&#13;
<p class="programs">PYTHONPATH=foobar.zip python -m __main__</p>&#13;
<p class="indent">In other words, the <span class="literal">__main__</span> module for your program will be automatically imported from <span class="literal">__main__.py</span>. You can also import <span class="literal">__main__</span> from a module you specify by appending a slash followed by the module name, just as with <span class="literal">Wheel</span>:</p>&#13;
<p class="programs">python foobar.zip/mymod</p>&#13;
<p class="indent">This is equivalent to:</p>&#13;
<p class="programs">PYTHONPATH=foobar.zip python -m mymod.__main__</p>&#13;
<p class="indent">One of the advantages of <span class="literal">Wheel</span> is that its naming conventions allow you to specify whether your distribution is intended for a specific architecture and/or Python implementation (CPython, PyPy, Jython, and so on). This is particularly useful if you need to distribute modules written in C.</p>&#13;
<p class="indent">By default, <span class="literal">Wheel</span> packages are tied to the major version of Python that you used to build them. When called with <span class="literal">python2 setup.py bdist_wheel</span>, the pattern of a <span class="literal">Wheel</span> filename will be something like <em>library-version-py2-none-any.whl</em>.</p>&#13;
<p class="indent">If your code is compatible with all major Python versions (that is, Python 2 and Python 3), you can build a universal <span class="literal">Wheel</span>:</p>&#13;
<p class="programs"><span class="codestrong1">python setup.py bdist_wheel --universal</span></p>&#13;
<p class="indent">The resulting filename will be different and contains both Python major versions—something like <em>library-version-py2.py3-none-any.whl</em>. Building a universal <span class="literal">Wheel</span> avoids ending up with two different <span class="literal">Wheel</span>s when only one would cover both Python major versions.</p>&#13;
<p class="indent">If you don’t want to pass the <span class="literal">--universal</span> flag each time you are building a <span class="literal">Wheel</span>, you can just add this to your <em>setup.cfg</em> file:</p>&#13;
<p class="programs">[wheel]<br/>universal=1</p>&#13;
<p class="indent">If the <span class="literal">Wheel</span> you build contains binary programs or libraries (like a Python extension written in C), the binary <span class="literal">Wheel</span> might not be as portable as you imagine. It will work by default on some platforms, such as Darwin (macOS) or Microsoft Windows, but it might not work on all Linux distributions. The PEP 513 (<em><a href="https://www.python.org/dev/peps/pep-0513">https://www.python.org/dev/peps/pep-0513</a></em>) targets this Linux problem by defining a new platform tag named <span class="literal">manylinux1</span> and a minimal set of libraries that are guaranteed to be available on that platform.</p>&#13;
<p class="indent"><span class="literal">Wheel</span> is a great format for distributing ready-to-install libraries and applications, so you are encouraged to build and upload them to PyPI as well.</p>&#13;
<h3 class="h3" id="lev1sec26"><span epub:type="pagebreak" id="page_64"/><strong>Sharing Your Work with the World</strong></h3>&#13;
<p class="noindent">Once you have a proper <em>setup.py</em> file, it is easy to build a source tarball that can be distributed. The <span class="literal">sdist setuptools</span> command does just that, as demonstrated in <a href="ch05.xhtml#ch5list6">Listing 5-6</a>.</p>&#13;
<p class="programs">$ <span class="codestrong1">python setup.py sdist</span><br/>running sdist<br/><br/>[pbr] Generating AUTHORS<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Processing SOURCES.txt<br/>[pbr] In git context, generating filelist from git<br/>warning: no previously-included files matching '*.pyc' found anywhere in<br/>distribution<br/>writing manifest file 'ceilometer.egg-info/SOURCES.txt'<br/>running check<br/>copying setup.cfg -&gt; ceilometer-2014.1.a6-g772e1a7<br/>Writing ceilometer-2014.1.a6-g772e1a7/setup.cfg<br/><br/><span class="codeitalic1">--snip--</span><br/><br/>Creating tar archive<br/>removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)</p>&#13;
<p class="listing1"><a id="ch5list6"/><em>Listing 5-6: Using <span class="codeitalic">setup.py sdist</span> to build a source tarball</em></p>&#13;
<p class="indent">The <span class="literal">sdist</span> command creates a tarball under the <em>dist</em> directory of the source tree. The tarball contains all the Python modules that are part of the source tree. As seen in the previous section, you can also build <span class="literal">Wheel</span> archives using the <span class="literal">bdist_wheel</span> command. <span class="literal">Wheel</span> archives are a bit faster to install as they’re already in the correct format for installation.</p>&#13;
<p class="indent">The final step to make that code accessible is to export your package somewhere users can install it via <span class="literal">pip</span>. That means publishing your project to PyPI.</p>&#13;
<p class="indent">If it’s your first time exporting to PyPI, it pays to test out the publishing process in a safe sandbox rather than on the production server. You can use the PyPI staging server for this purpose; it replicates all the functionality of the main index but is solely for testing purposes.</p>&#13;
<p class="indent">The first step is to register your project on the test server. Start by opening your <em>~/.pypirc</em> file and adding these lines:</p>&#13;
<p class="programs">[distutils]<br/>index-servers =<br/>    testpypi<span epub:type="pagebreak" id="page_65"/><br/>[testpypi]<br/>username = &lt;your username&gt;<br/>password = &lt;your password&gt;<br/>repository = https://testpypi.python.org/pypi</p>&#13;
<p class="indent">Save the file, and now you can register your project in the index:</p>&#13;
<p class="programs"><span class="codestrong1">$ python setup.py register -r testpypi</span><br/>running register<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Reusing existing SOURCES.txt<br/>running check<br/>Registering ceilometer to https://testpypi.python.org/pypi<br/>Server response (200): OK</p>&#13;
<p class="indent">This connects to the test PyPI server instance and creates a new entry. Don’t forget to use the <span class="literal">-r</span> option; otherwise, the real production PyPI instance would be used!</p>&#13;
<p class="indent">Obviously, if a project with the same name is already registered there, the process will fail. Retry with a new name, and once you get your program registered and receive the <span class="literal">OK</span> response, you can upload a source distribution tarball, as shown in <a href="ch05.xhtml#ch5list7">Listing 5-7</a>.</p>&#13;
<p class="programs">$ <span class="codestrong1">python setup.py sdist upload -r testpypi</span><br/>running sdist<br/>[pbr] Writing ChangeLog<br/>[pbr] Generating AUTHORS<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Processing SOURCES.txt<br/>[pbr] In git context, generating filelist from git<br/>warning: no previously-included files matching '*.pyc' found anywhere in<br/>distribution<br/>writing manifest file 'ceilometer.egg-info/SOURCES.txt'<br/>running check<br/>creating ceilometer-2014.1.a6.g772e1a7<br/><br/><span class="codeitalic1">--snip--</span><br/><br/>copying setup.cfg -&gt; ceilometer-2014.1.a6.g772e1a7<br/>Writing ceilometer-2014.1.a6.g772e1a7/setup.cfg<br/>Creating tar archive<br/>removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)<br/>running upload<span epub:type="pagebreak" id="page_66"/><br/>Submitting dist/ceilometer-2014.1.a6.g772e1a7.tar.gz to https://testpypi<br/>.python.org/pypi<br/>Server response (200): OK</p>&#13;
<p class="listing1"><a id="ch5list7"/><em>Listing 5-7: Uploading your tarball to PyPI</em></p>&#13;
<p class="indent">Alternatively, you could upload a <span class="literal">Wheel</span> archive, as in <a href="ch05.xhtml#ch5list8">Listing 5-8</a>.</p>&#13;
<p class="programs"><span class="codestrong1">$ python setup.py bdist_wheel upload -r testpypi</span><br/>running bdist_wheel<br/>running build<br/>running build_py<br/>running egg_info<br/>writing requirements to ceilometer.egg-info/requires.txt<br/>writing ceilometer.egg-info/PKG-INFO<br/>writing top-level names to ceilometer.egg-info/top_level.txt<br/>writing dependency_links to ceilometer.egg-info/dependency_links.txt<br/>writing entry points to ceilometer.egg-info/entry_points.txt<br/>[pbr] Reusing existing SOURCES.txt<br/>installing to build/bdist.linux-x86_64/wheel<br/>running install<br/>running install_lib<br/>creating build/bdist.linux-x86_64/wheel<br/><br/><span class="codeitalic1">--snip--</span><br/><br/>creating build/bdist.linux-x86_64/wheel/ceilometer-2014.1.a6.g772e1a7<br/>.dist-info/WHEEL<br/>running upload<br/>Submitting /home/jd/Source/ceilometer/dist/ceilometer-2014.1.a6<br/>.g772e1a7-py27-none-any.whl to https://testpypi.python.org/pypi<br/>Server response (200): OK</p>&#13;
<p class="listing1"><a id="ch5list8"/><em>Listing 5-8: Uploading a <span class="codeitalic">Wheel</span> archive to PyPI</em></p>&#13;
<p class="indent">Once those operations are finished, you and other users can search for the uploaded packages on the PyPI staging server, and even install those packages using <span class="literal">pip</span>, by specifying the test server using the <span class="literal">-i</span> option:</p>&#13;
<p class="programs"><span class="codestrong1">$ pip install -i https://testpypi.python.org/pypi ceilometer</span></p>&#13;
<p class="indent">If everything checks out, you can upload your project to the main PyPI server. Just make sure to add your credentials and the details for the server to your <span class="literal">~/.pypirc</span> file first, like so:</p>&#13;
<p class="programs">[distutils]<br/>index-servers =<br/>    pypi<br/>    testpypi<br/><br/>[pypi]<br/>username = <span class="codeitalic1">&lt;your username&gt;</span><br/>password = <span class="codeitalic1">&lt;your password&gt;</span><span epub:type="pagebreak" id="page_67"/><br/>[testpypi]<br/>repository = https://testpypi.python.org/pypi<br/>username = <span class="codeitalic1">&lt;your username&gt;</span><br/>password = <span class="codeitalic1">&lt;your password&gt;</span></p>&#13;
<p class="indent">Now if you run <span class="literal">register</span> and <span class="literal">upload</span> with the <span class="literal">-r pypi</span> switch, your package should be uploaded to PyPI.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>PyPI can keep several versions of your software in its index, allowing you to install specific and older versions, if you ever need to. Just pass the version number to the <span class="codeitalic">pip install</span> command; for example, <span class="codeitalic">pip install foobar==1.0.2</span>.</em></p>&#13;
</div>&#13;
<p class="indent">This process is straightforward to use and allows for any number of uploads. You can release your software as often as you want, and your users can install and update as often as they need.</p>&#13;
<h3 class="h3" id="lev1sec27"><strong>Entry Points</strong></h3>&#13;
<p class="noindent">You may have already used <span class="literal">setuptools</span> entry points without knowing anything about them. Software distributed using <span class="literal">setuptools</span> includes important metadata describing features such as its required dependencies and—more relevantly to this topic—a list of <em>entry points</em>. Entry points are methods by which other Python programs can discover the dynamic features a package provides.</p>&#13;
<p class="indent">The following example shows how to provide an entry point named <span class="literal">rebuildd</span> in the <span class="literal">console_scripts</span> entry point group:</p>&#13;
<p class="programs">#!/usr/bin/python<br/>from distutils.core import setup<br/><br/>setup(name="rebuildd",<br/>    description="Debian packages rebuild tool",<br/>    author="Julien Danjou",<br/>    author_email="acid@debian.org",<br/>    url="http://julien.danjou.info/software/rebuildd.html",<br/>    entry_points={<br/>        'console_scripts': [<br/>            'rebuildd = rebuildd:main',<br/>        ],<br/>    },<br/>    packages=['rebuildd'])</p>&#13;
<p class="indent">Any Python package can register entry points. Entry points are organized in groups: each group is made of a list of key and value pairs. Those pairs use the format <span class="literal"><span class="codeitalic">path</span>.<span class="codeitalic">to</span>.<span class="codeitalic">module</span>:<span class="codeitalic">variable</span>_<span class="codeitalic">name</span></span>. In the previous example, the key is <span class="literal">rebuildd</span>, and the value is <span class="literal">rebuildd:main</span>.</p>&#13;
<p class="indent">The list of entry points can be manipulated using various tools, from <span class="literal">setuptools</span> to <span class="literal">epi</span>, as I’ll show here. In the following sections, we discuss how we can use entry points to add extensibility to our software.</p>&#13;
<h4 class="h4" id="lev2sec18"><span epub:type="pagebreak" id="page_68"/><strong><em>Visualizing Entry Points</em></strong></h4>&#13;
<p class="noindent">The easiest way to visualize the entry points available in a package is to use a package called <span class="literal">entry point inspector</span>. You can install it by running <span class="literal">pip install entry-point-inspector</span>. When installed, it provides the command <span class="literal">epi</span> that you can run from your terminal to interactively discover the entry points provided by installed packages. <a href="ch05.xhtml#ch5list9">Listing 5-9</a> shows an example of running <span class="literal">epi group list</span> on my system.</p>&#13;
<p class="programs">$ <span class="codestrong1">epi group list</span><br/>---------------------------<br/>| Name                    |<br/>--------------------------<br/>| console_scripts |<br/>| distutils.commands |<br/>| distutils.setup_keywords |<br/>| egg_info.writers |<br/>| epi.commands |<br/>| flake8.extension |<br/>| setuptools.file_finders |<br/>| setuptools.installation |<br/>--------------------------</p>&#13;
<p class="listing1"><a id="ch5list9"/><em>Listing 5-9: Getting a list of entry point groups</em></p>&#13;
<p class="indent">The output from <span class="literal">epi group list</span> in <a href="ch05.xhtml#ch5list9">Listing 5-9</a> shows the different packages on a system that provide entry points. Each item in this table is the name of an entry point group. Note that this list includes <span class="literal">console_scripts</span>, which we’ll discuss shortly. We can use the <span class="literal">epi</span> command with the <span class="literal">show</span> command to show details of a particular entry point group, as in <a href="ch05.xhtml#ch5list10">Listing 5-10</a>.</p>&#13;
<p class="programs">$ <span class="codestrong1">epi group show console_scripts</span><br/>-------------------------------------------------<br/>| Name     | Module   | Member | Distribution | Error |<br/>-------------------------------------------------<br/>| coverage | coverage | main   | coverage 3.4 |       |</p>&#13;
<p class="listing1"><a id="ch5list10"/><em>Listing 5-10: Showing details of an entry point group</em></p>&#13;
<p class="indent">We can see that in the group <span class="literal">console_scripts</span>, an entry point named <span class="literal">coverage</span> refers to the member <span class="literal">main</span> of the module <span class="literal">coverage</span>. This entry point in particular, provided by the package <span class="literal">coverage 3.4</span>, indicates which Python function to call when the command line script <span class="literal">coverage</span> is executed. Here, the function <span class="literal">coverage.main</span> is to be called.</p>&#13;
<p class="indent">The <span class="literal">epi</span> tool is just a thin layer on top of the complete Python library <span class="literal">pkg_resources</span>. This module allows us to discover entry points for any Python library or program. Entry points are valuable for various things, including console scripts and dynamic code discovery, as you’ll see in the next few sections.</p>&#13;
<h4 class="h4" id="lev2sec19"><span epub:type="pagebreak" id="page_69"/><strong><em>Using Console Scripts</em></strong></h4>&#13;
<p class="noindent">When writing a Python application, you almost always have to provide a launchable program—a Python script that the end user can run—that needs to be installed inside a directory somewhere in the system path.</p>&#13;
<p class="indent">Most projects have a launchable program similar to this:</p>&#13;
<p class="programs">#!/usr/bin/python<br/>import sys<br/>import mysoftware<br/><br/>mysoftware.SomeClass(sys.argv).run()</p>&#13;
<p class="indent">This kind of script is a best-case scenario: many projects have a much longer script installed in the system path. However, such scripts pose some major issues:</p>&#13;
<ul>&#13;
<li><p class="noindent">There’s no way the user can know where the Python interpreter is or which version it uses.</p></li>&#13;
<li><p class="noindent">This script leaks binary code that can’t be imported by software or unit tests.</p></li>&#13;
<li><p class="noindent">There’s no easy way to define where to install this script.</p></li>&#13;
<li><p class="noindent">It’s not obvious how to install this in a portable way (for example, on both Unix and Windows).</p></li>&#13;
</ul>&#13;
<p class="indent">Helping us circumvent these problems, <span class="literal">setuptools</span> offers the <span class="literal">console_scripts</span> feature. This entry point can be used to make <span class="literal">setuptools</span> install a tiny program in the system path that calls a specific function in one of your modules. With <span class="literal">setuptools</span>, you can specify a function call to start your program by setting up a key/value pair in the <span class="literal">console_scripts</span> entry point group: the key is the script name that will be installed, and the value is the Python path to your function (something like <span class="literal">my_module.main</span>).</p>&#13;
<p class="indent">Let’s imagine a <span class="literal">foobar</span> program that consists of a client and a server. Each part is written in its module—<span class="literal">foobar.client</span> and <span class="literal">foobar.server</span>, respectively, in <em>foobar/client.py</em>:</p>&#13;
<p class="programs">def main():<br/>    print("Client started")</p>&#13;
<p class="noindent">And in <em>foobar/server.py</em>:</p>&#13;
<p class="programs">def main():<br/>    print("Server started")</p>&#13;
<p class="indent">Of course, this program doesn’t do much of anything—our client and server don’t even talk to each other. For our example, though, they just need to print a message letting us know they have started successfully.</p>&#13;
<p class="indent">We can now write the following <em>setup.py</em> file in the root directory with entry points defined in <em>setup.py</em>.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_70"/>from setuptools import setup<br/><br/>setup(<br/>    name="foobar",<br/>    version="1",<br/>    description="Foo!",<br/>    author="Julien Danjou",<br/>    author_email="julien@danjou.info",<br/>    packages=["foobar"],<br/>    entry_points={<br/>        "console_scripts": [<br/>         <span class="ent">➊</span> "foobard = foobar.server:main",<br/>            "foobar = foobar.client:main",<br/>        ],<br/>     },<br/>)</p>&#13;
<p class="indent">We define entry points using the format <span class="literal">module.submodule:function</span>. You can see here that we’ve defined an entry point each for both <span class="literal">client</span> and <span class="literal">server</span> <span class="ent">➊</span>.</p>&#13;
<p class="indent">When <span class="literal">python setup.py install</span> is run, <span class="literal">setuptools</span> will create a script that will look like the one in <a href="ch05.xhtml#ch5list11">Listing 5-11</a>.</p>&#13;
<p class="programs">#!/usr/bin/python<br/># EASY-INSTALL-ENTRY-SCRIPT: 'foobar==1','console_scripts','foobar'<br/>__requires__ = 'foobar==1'<br/>import sys<br/>from pkg_resources import load_entry_point<br/><br/>if __name__ == '__main__':<br/>    sys.exit(<br/>        load_entry_point('foobar==1', 'console_scripts', 'foobar')()<br/>    )</p>&#13;
<p class="listing1"><a id="ch5list11"/><em>Listing 5-11: A console script generated by <span class="codeitalic">setuptools</span></em></p>&#13;
<p class="indent">This code scans the entry points of the <span class="literal">foobar</span> package and retrieves the <span class="literal">foobar</span> key from the <span class="literal">console_scripts</span> group, which is used to locate and run the corresponding function. The return value of the <span class="literal">load_entry_point</span> will then be a reference to the function <span class="literal">foobar.client.main</span>, which will be called without any arguments and whose return value will be used as an exit code.</p>&#13;
<p class="indent">Notice that this code uses <span class="literal">pkg_resources</span> to discover and load entry point files from within your Python programs.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re using <span class="codeitalic">pbr</span> on top of <span class="codeitalic">setuptools</span>, the generated script is simpler (and therefore faster) than the default one built by <span class="codeitalic">setuptools</span>, as it will call the function you wrote in the entry point without having to search the entry point list dynamically at runtime.</em></p>&#13;
</div>&#13;
<p class="indent">Using console scripts is a technique that removes the burden of writing portable scripts, while ensuring that your code stays in your Python package and can be imported (and tested) by other programs.</p>&#13;
<h4 class="h4" id="lev2sec20"><span epub:type="pagebreak" id="page_71"/><strong><em>Using Plugins and Drivers</em></strong></h4>&#13;
<p class="noindent">Entry points make it easy to discover and dynamically load code deployed by other packages, but this is not their only use. Any application can propose and register entry points and groups and then use them as it wishes.</p>&#13;
<p class="indent">In this section, we’re going to create a <span class="literal">cron</span>-style daemon <span class="literal">pycrond</span> that will allow any Python program to register a command to be run once every few seconds by registering an entry point in the group <span class="literal">pytimed</span>. The attribute indicated by this entry point should be an object that returns <span class="literal">number_of_seconds, callable</span>.</p>&#13;
<p class="indent">Here’s our implementation of <span class="literal">pycrond</span> using <span class="literal">pkg_resources</span> to discover entry points, in a program I’ve named <em>pytimed.py</em>:</p>&#13;
<p class="programs">import pkg_resources<br/>import time<br/><br/>def main():<br/>    seconds_passed = 0<br/>    while True:<br/>        for entry_point in pkg_resources.iter_entry_points('pytimed'):<br/>            try:<br/>                seconds, callable = entry_point.load()()<br/>            except:<br/>                # Ignore failure<br/>                pass<br/>            else:<br/>                if seconds_passed % seconds == 0:<br/>                    callable()<br/>        time.sleep(1)<br/>        seconds_passed += 1</p>&#13;
<p class="indent">This program consists of an infinite loop that iterates over each entry point of the <span class="literal">pytimed</span> group. Each entry point is loaded using the <span class="literal">load()</span> method. The program then calls the returned method, which needs to return the number of seconds to wait before calling the callable as well as the aforementioned callable.</p>&#13;
<p class="indent">The program in <em>pytimed.py</em> is a very simplistic and naive implementation, but it is sufficient for our example. Now we can write another Python program, named <em>hello.py</em>, that needs one of its functions called on a periodic basis:</p>&#13;
<p class="programs">def print_hello():<br/>    print("Hello, world!")<br/><br/>def say_hello():<br/>    return 2, print_hello</p>&#13;
<p class="indent">Once we have that function defined, we register it using the appropriate entry points in <em>setup.py</em>.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_72"/>from setuptools import setup<br/><br/>setup(<br/>    name="hello",<br/>    version="1",<br/>    packages=["hello"],<br/>    entry_points={<br/>        "pytimed": [<br/>            "hello = hello:say_hello",<br/>        ],<br/>     },)</p>&#13;
<p class="indent">The <em>setup.py</em> script registers an entry point in the group <span class="literal">pytimed</span> with the key <span class="literal">hello</span> and the value pointing to the function <span class="literal">hello.say_hello</span>. Once that package is installed using that <em>setup.py</em>—for example, using <span class="literal">pip install</span>—the <span class="literal">pytimed</span> script can detect the newly added entry point.</p>&#13;
<p class="indent">At startup, <span class="literal">pytimed</span> will scan the group <span class="literal">pytimed</span> and find the key <span class="literal">hello</span>. It will then call the <span class="literal">hello.say_hello</span> function, getting two values: the number of seconds to wait between each call and the function to call, 2 seconds and <span class="literal">print_hello</span> in this case. By running the program, as we do in <a href="ch05.xhtml#ch5list12">Listing 5-12</a>, you can see “Hello, world!” printed on the screen every 2 seconds.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import pytimed</span><br/>&gt;&gt;&gt; <span class="codestrong1">pytimed.main()</span><br/>Hello, world!<br/>Hello, world!<br/>Hello, world!</p>&#13;
<p class="listing1"><a id="ch5list12"/><em>Listing 5-12: Running <span class="codeitalic">pytimed</span></em></p>&#13;
<p class="indent">The possibilities this mechanism offers are immense: you can build driver systems, hook systems, and extensions easily and generically. Implementing this mechanism by hand in every program you make would be tedious, but fortunately, there’s a Python library that can take care of the boring parts for us.</p>&#13;
<p class="indent">The <span class="literal">stevedore</span> library provides support for dynamic plugins based on the same mechanism demonstrated in our previous examples. The use case in this example is already simplistic, but we can still simplify it further in this script, <em>pytimed_stevedore.py</em>:</p>&#13;
<p class="programs">from stevedore.extension import ExtensionManager<br/>import time<br/><br/>def main():<br/>    seconds_passed = 0<br/>    extensions = ExtensionManager('pytimed', invoke_on_load=True)<br/>    while True:<br/>        for extension in extensions:<br/>            try:<br/>                seconds, callable = extension.obj<span epub:type="pagebreak" id="page_73"/><br/>            except:<br/>                # Ignore failure<br/>                pass<br/>            else:<br/>                if seconds_passed % seconds == 0:<br/>                    callable()<br/>        time.sleep(1)<br/>        seconds_passed += 1</p>&#13;
<p class="indent">The <span class="literal">ExtensionManager</span> class of <span class="literal">stevedore</span> provides a simple way to load all extensions of an entry point group. The name is passed as a first argument. The argument <span class="literal">invoke_on_load=True</span> makes sure that each function of the group is called once discovered. This makes the results accessible directly from the <span class="literal">obj</span> attribute of the extension.</p>&#13;
<p class="indent">If you look through the <span class="literal">stevedore</span> documentation, you will see that <span class="literal">ExtensionManager</span> has a variety of subclasses that can handle different situations, such as loading specific extensions based on their names or the result of a function. All of those are commonly used models you can apply to your program in order to implement those patterns directly.</p>&#13;
<p class="indent">For example, we might want to load and run only one extension from our entry point group. Leveraging the <span class="literal">stevedore.driver.DriverManager</span> class allows us to do that, as <a href="ch05.xhtml#ch5list13">Listing 5-13</a> shows.</p>&#13;
<p class="programs">from stevedore.driver import DriverManager<br/>import time<br/><br/>def main(name):<br/>    seconds_passed = 0<br/>    seconds, callable = DriverManager('pytimed', name, invoke_on_load=True).<br/>driver<br/>    while True:<br/>        if seconds_passed % seconds == 0:<br/>            callable()<br/>        time.sleep(1)<br/>        seconds_passed += 1<br/><br/>main("hello")</p>&#13;
<p class="listing1"><a id="ch5list13"/><em>Listing 5-13: Using <span class="codeitalic">stevedore</span> to run a single extension from an entry point</em></p>&#13;
<p class="indent">In this case, only one extension is loaded and selected by name. This allows us to quickly build a <em>driver system</em> in which only one extension is loaded and used by a program.</p>&#13;
<h3 class="h3" id="lev1sec28"><strong>Summary</strong></h3>&#13;
<p class="noindent">The packaging ecosystem in Python has a bumpy history; however, the situation is now settling. The <span class="literal">setuptools</span> library provides a complete solution to packaging, not only to transport your code in different formats and upload it to PyPI, but also to handle connection with other software and libraries via entry points.</p>&#13;
<h3 class="h3" id="lev1sec29"><span epub:type="pagebreak" id="page_74"/><strong>Nick Coghlan on Packaging</strong></h3>&#13;
<p class="noindent">Nick is a Python core developer working at Red Hat. He has written several PEP proposals, including PEP 426 (Metadata for Python Software Packages 2.0), and he is acting as delegate for our Benevolent Dictator for Life, Guido van Rossum, author of Python.</p>&#13;
<p class="noindentt"><strong>The number of packaging solutions (<span class="codestrong">distutils, setuptools, distutils2, distlib, bento, pbr</span>, and so on) for Python is quite extensive. In your opinion, what are the reasons for such fragmentation and divergence?</strong></p>&#13;
<p class="noindent">The short answer is that software publication, distribution, and integration is a complex problem with plenty of room for multiple solutions tailored for different use cases. In my recent talks on this, I have noted that the problem is mainly one of age, with the different packaging tools being born into different eras of software distribution.</p>&#13;
<p class="noindentt"><strong>PEP 426, which defines a new metadata format for Python packages, is still fairly recent and not yet approved. How do you think it will tackle current packaging problems?</strong></p>&#13;
<p class="noindent">PEP 426 originally started as part of the <span class="literal">Wheel</span> format definition, but Daniel Holth realized that <span class="literal">Wheel</span> could work with the existing metadata format defined by <span class="literal">setuptools</span>. PEP 426 is thus a consolidation of the existing <span class="literal">setuptools</span> metadata with some of the ideas from <span class="literal">distutils2</span> and other packaging systems (such as <span class="literal">RPM</span> and <span class="literal">npm</span>). It addresses some of the frustrations encountered with existing tools (for example, with cleanly separating different kinds of dependencies).</p>&#13;
<p class="indent">The main gains will be a REST API on PyPI offering full metadata access, as well as (hopefully) the ability to automatically generate distribution policy–compliant packages from upstream metadata.</p>&#13;
<p class="noindentt"><strong>The <span class="literal">Wheel</span> format is somewhat recent and not widely used yet, but it seems promising. Why is it not part of the Standard Library?</strong></p>&#13;
<p class="noindent">It turns out the Standard Library is not really a suitable place for packaging standards: it evolves too slowly, and an addition to a later version of the Standard Library cannot be used with earlier versions of Python. So, at the Python language summit earlier this year, we tweaked the PEP process to allow <span class="literal">distutils-sig</span> to manage the full approval cycle for packaging-related PEPs, and <span class="literal">python-dev</span> will only be involved for proposals that involve changing CPython directly (such as <span class="literal">pip</span> bootstrapping).</p>&#13;
<p class="noindentt"><strong>What is the future for <strong>Wheel</strong> packages?</strong></p>&#13;
<p class="noindent">We still have some tweaks to make before <span class="literal">Wheel</span> is suitable for use on Linux. However, <span class="literal">pip</span> is adopting <span class="literal">Wheel</span> as an alternative to the <span class="literal">Egg</span> format, allowing local caching of builds for fast virtual environment creation, and PyPI allows uploads of <span class="literal">Wheel</span> archives for Windows and macOS.</p>&#13;
</body></html>