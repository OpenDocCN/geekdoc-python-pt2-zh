- en: '[11](nsp-venkitachalam503045-0008.xhtml#rch11)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[11](nsp-venkitachalam503045-0008.xhtml#rch11)'
- en: Volume Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 体积渲染
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Magnetic resonance imaging (MRI) and computed tomography (CT) scans are diagnostic
    processes that create *volumetric data*, data that consists of a set of 2D images
    showing cross sections through a 3D volume. *Volume rendering* is a computer graphics
    technique used to construct 3D images from this type of volumetric data. Although
    volume rendering is commonly used to analyze medical scans, it can also be used
    to create 3D scientific visualizations in academic disciplines such as geology,
    archaeology, and molecular biology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 磁共振成像（MRI）和计算机断层扫描（CT）是诊断过程，用于创建*体积数据*，这些数据由一组二维图像组成，展示了穿过三维体积的横截面。*体积渲染*是一种计算机图形学技术，用于从这种类型的体积数据中构建三维图像。尽管体积渲染通常用于分析医学扫描，它也可以用于创建在地质学、考古学和分子生物学等学科中的三维科学可视化。
- en: The data captured by MRI and CT scans typically follows the form of a 3D grid
    of dimensions *N*[x]×*N*[y]×*N*[z]. In other words, there are *N*[z] 2D “slices,”
    where each slice is an image of size *N*[x]×*N*[y]. Volume rendering algorithms
    are used to display the collected slice data with some type of transparency, and
    various techniques are used to accentuate the parts of the rendered volume that
    are of interest.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: MRI和CT扫描捕获的数据通常呈现为*N*[x]×*N*[y]×*N*[z]大小的3D网格。换句话说，有*N*[z]个二维“切片”，每个切片是大小为*N*[x]×*N*[y]的图像。体积渲染算法用于以某种透明度显示收集的切片数据，并使用各种技术突出显示渲染体积中感兴趣的部分。
- en: In this project, you’ll look at a volume rendering called *volume ray casting*,
    which takes full advantage of the graphics processing unit (GPU) to perform computations
    using OpenGL Shading Language (GLSL) shaders. Your code executes for every pixel
    onscreen and leverages the GPU, which is designed to do parallel computations
    efficiently. You’ll use a folder of 2D images consisting of slices from a 3D data
    set to construct a volume-rendered image using the volume ray casting algorithm.
    You’ll also implement a method to show 2D slices of the data in the x-, y-, and
    z-directions so users can scroll through the slices using the arrow keys. Keyboard
    commands will let the user toggle between the 3D rendering and the 2D slices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将研究一种名为*体积光线投射*的体积渲染方法，它充分利用图形处理单元（GPU）来使用OpenGL着色语言（GLSL）着色器进行计算。你的代码将对每个屏幕上的像素进行执行，并利用GPU进行并行计算，它设计用于高效地执行并行计算。你将使用一个由二维图像组成的文件夹，这些图像是3D数据集的切片，并使用体积光线投射算法构建体积渲染图像。你还将实现一种方法，以便显示数据在x、y和z方向上的二维切片，这样用户可以使用箭头键浏览这些切片。键盘命令将允许用户在3D渲染和2D切片之间切换。
- en: 'Here are some of the topics covered in this project:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本项目中涉及的一些主题：
- en: • Using GLSL for GPU computations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用GLSL进行GPU计算
- en: • Creating vertex and fragment shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 创建顶点着色器和片段着色器
- en: • Representing 3D volumetric data and using the volume ray casting algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 表示3D体积数据并使用体积光线投射算法
- en: • Using `numpy` arrays for 3D transformation matrices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`数组进行3D变换矩阵
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1301)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah1301)'
- en: 'There are various ways to render a 3D data set. In this project, you’ll use
    the volume ray casting method, which is an *image*-*based* rendering technique
    used to generate the final image from the 2D slices, pixel by pixel. In contrast,
    typical 3D rendering methods are *object based*: they begin with a 3D object representation
    and then apply transformations to generate the pixels in the projected 2D image.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染3D数据集有多种方式。在这个项目中，你将使用体积光线投射方法，这是一种*基于图像*的渲染技术，用于逐像素地从二维切片生成最终图像。与此相对，典型的3D渲染方法是*基于对象*的：它们从3D对象表示开始，然后应用变换生成投影二维图像中的像素。
- en: In the volume ray casting method that you’ll use in this project, for each pixel
    in the output image, a ray is shot into the discrete 3D volumetric data set, which
    is typically represented as a cuboid. As the ray passes through the volume, the
    data is sampled at regular intervals, and the samples are combined, or *composited*,
    to compute the color value or intensity of the final image. (You might think of
    this process as similar to stacking a bunch of transparencies on top of each other
    and holding them up against a bright light to see a blend of all the sheets.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中你将使用体积光线投射方法，对于输出图像中的每个像素，一条光线会射入离散的 3D 体积数据集，通常该数据集表现为一个立方体。随着光线穿过体积，数据会在固定间隔下进行采样，采样结果将被组合或
    *合成*，用于计算最终图像的颜色值或强度。（你可以将这个过程类比为将一堆透明片叠加在一起，然后拿到强光下看它们融合的效果。）
- en: While volume ray casting rendering implementations typically use techniques
    such as applying gradients to improve the appearance of the final render, filtering
    to isolate 3D features, and using spatial optimization techniques to improve speed,
    you’ll just implement the basic ray casting algorithm and composite the final
    image by X-ray casting. (My implementation is largely based on the seminal paper
    on this topic by Kruger and Westermann, published in 2003.[1](nsp-venkitachalam503045-0025.xhtml#fn4))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管体积光线投射渲染实现通常使用技术，比如应用梯度以改善最终渲染效果，滤波以隔离 3D 特征，以及使用空间优化技术以提升速度，但你将仅实现基本的光线投射算法，并通过
    X 射线投射合成最终图像。（我的实现主要基于 Kruger 和 Westermann 在 2003 年发表的关于此主题的开创性论文。[1](nsp-venkitachalam503045-0025.xhtml#fn4)）
- en: '[The Data Format](nsp-venkitachalam503045-0008.xhtml#rbh1301)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[数据格式](nsp-venkitachalam503045-0008.xhtml#rbh1301)'
- en: For this project, you’ll use medical data from 3D scans from the Stanford Volume
    Data Archive.[2](nsp-venkitachalam503045-0025.xhtml#fn5) This archive offers a
    few excellent 3D medical data sets (both CT and MRI) of TIFF images, one for each
    2D cross section of the volume. You’ll read a folder of these images into an OpenGL
    3D texture; this is sort of like stacking a set of 2D images to form a cuboid,
    as shown in [Figure 11-1](nsp-venkitachalam503045-0025.xhtml#fig11-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本项目，你将使用来自斯坦福体积数据档案的 3D 扫描医学数据。[2](nsp-venkitachalam503045-0025.xhtml#fn5)该档案提供了几个优秀的
    3D 医学数据集（包括 CT 和 MRI），每个数据集包含一组 TIFF 图像，代表体积的每个 2D 截面。你将把这些图像文件夹读取到 OpenGL 3D
    纹理中；这有点像将一组 2D 图像叠加在一起形成一个立方体，如[图 11-1](nsp-venkitachalam503045-0025.xhtml#fig11-1)所示。
- en: '![](images/nsp-venkitachalam503045-f11001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11001.jpg)'
- en: 'Figure 11-1: Building 3D volumetric data from 2D slices'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：从 2D 切片构建 3D 体积数据
- en: Recall from [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09) that a 2D texture
    in OpenGL is addressed with a 2D coordinate (*s*, *t*). Similarly, a 3D texture
    is addressed using a 3D texture coordinate of the form (*s*, *t*, *p*). As you’ll
    see, storing the volumetric data as a 3D texture allows you to access the data
    quickly and provides you with interpolated values required by your ray casting
    scheme.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第 9 章](nsp-venkitachalam503045-0023.xhtml#ch09)，你会发现 OpenGL 中的 2D 纹理是通过 2D
    坐标 (*s*, *t*) 来寻址的。类似地，3D 纹理是通过 3D 纹理坐标 (*s*, *t*, *p*) 来寻址的。如你所见，将体积数据存储为 3D
    纹理可以让你快速访问数据，并为光线投射方案提供插值值。
- en: '[Ray Generation](nsp-venkitachalam503045-0008.xhtml#rbh1302)'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[光线生成](nsp-venkitachalam503045-0008.xhtml#rbh1302)'
- en: Your goal in this project is to generate a perspective projection of the 3D
    volumetric data, as shown in [Figure 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2).
    The figure shows the OpenGL view frustum, as discussed in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).
    Specifically, it shows how a ray from the eye enters this frustum at the near
    plane, passes through the cubic volume (which contains the volumetric data), and
    exits from the rear at the far plane.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目标是生成 3D 体积数据的透视投影，如[图 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2)所示。该图展示了
    OpenGL 视锥体，如[第 9 章](nsp-venkitachalam503045-0023.xhtml#ch09)中所讨论。具体来说，它展示了从眼睛发出的光线如何进入视锥体的近平面，穿过包含体积数据的立方体体积，并从远平面的后端退出。
- en: '![](images/nsp-venkitachalam503045-f11002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11002.jpg)'
- en: 'Figure 11-2: A perspective projection of 3D volumetric data'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：3D 体积数据的透视投影
- en: To implement ray casting, you need to generate rays that go into the volume.
    For each pixel in the output window shown in [Figure 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2),
    you generate a vector *R* that goes into the volume you consider a unit cube (which
    I’ll refer to as the *color cube*) defined between the coordinates (0, 0, 0) and
    (1, 1, 1). You color each point inside this cube with the RGB values equal to
    the 3D coordinates of the cube. The origin is colored (0, 0, 0), or black; the
    (1, 0, 0) corner is red; and the point on the cube diagonally opposite the origin
    is colored (1, 1, 1), or white. [Figure 11-3](nsp-venkitachalam503045-0025.xhtml#fig11-3)
    shows this cube.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现光线投射，你需要生成进入体积的光线。对于输出窗口中每个像素，如[图 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2)所示，你生成一个进入体积的向量*R*，你可以将其视为一个单位立方体（我称之为*颜色立方体*），该立方体的坐标范围为（0，0，0）到（1，1，1）。你用与立方体的三维坐标相等的RGB值为立方体内部的每个点上色。原点被涂成（0，0，0），即黑色；（1，0，0）角为红色；而与原点对角的立方体点则被涂成（1，1，1），即白色。[图
    11-3](nsp-venkitachalam503045-0025.xhtml#fig11-3)展示了这个立方体。
- en: '![](images/nsp-venkitachalam503045-f11003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11003.jpg)'
- en: 'Figure 11-3: A color cube'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：颜色立方体
- en: NOTE In OpenGL, a color can be represented as a strip of 8-bit unsigned values
    (*r*, *g*, *b*), where *r*, *g*, and *b* are in the range [0, 255]. It can also
    be represented as a triplet of 32-bit floating-point values (*r*, *g*, *b*), where
    *r*, *g*, and *b* are in the range [0.0, 1.0]. These representations are equivalent.
    For example, the red color (255, 0, 0) in the former is the same as (1.0, 0.0,
    0.0) in the latter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在OpenGL中，颜色可以表示为一组8位无符号值（*r*，*g*，*b*），其中 *r*，*g* 和 *b* 的取值范围为[0，255]。也可以表示为一组三个32位浮点值（*r*，*g*，*b*），其中
    *r*，*g* 和 *b* 的取值范围为[0.0，1.0]。这两种表示方式是等效的。例如，前者的红色（255，0，0）与后者的（1.0，0.0，0.0）是一样的。
- en: To draw the cube, first draw its six faces using the OpenGL primitive `GL_TRIANGLES`.
    Then color each vertex and use the interpolation provided by OpenGL when it rasterizes
    polygons to take care of the colors between each vertex. For example, [Figure
    11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4) shows the three front-faces
    of the cube. The back-faces of the cube are drawn in [Figure 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    by setting OpenGL to cull front-faces.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制这个立方体，首先使用OpenGL原始图元`GL_TRIANGLES`绘制它的六个面。然后为每个顶点上色，并使用OpenGL在光栅化多边形时提供的插值功能来处理每个顶点之间的颜色。例如，[图
    11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4)展示了立方体的三个前面。立方体的背面则在[图 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4)中绘制，方法是将OpenGL设置为剔除前面。
- en: '![](images/nsp-venkitachalam503045-f11004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11004.jpg)'
- en: 'Figure 11-4: The color cube used to compute rays'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：用于计算光线的颜色立方体
- en: If you subtract the colors in [Figure 11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    from [Figure 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4) by subtracting
    (*r*, *g*, *b*)[front] from (*r*, *g*, *b*)[back], you actually compute a set
    of vectors that go from the front to the back of the cube because each color (*r*, *g*, *b*)
    on this cube is the same as the 3D coordinate at that color’s location. [Figure 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    shows the result. (Negative values have been flipped to positive for the purposes
    of this illustration because negative numbers cannot be displayed as colors directly.)
    Reading the color value (*r*, *g*, *b*) of a pixel, as shown in [Figure 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4),
    gives the (*r*[x], *r*[y], *r*[z]) coordinates for the ray passing into the volume
    at that point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过从[图 11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4)中减去[图 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4)中的颜色，即将(*r*，*g*，*b*)[front]从(*r*，*g*，*b*)[back]中减去，你实际上计算出了一组从立方体前面到背面的向量，因为该立方体上每种颜色（*r*，*g*，*b*）与该颜色位置的三维坐标是相同的。[图
    11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4)展示了结果。（为了说明的目的，负值已被转换为正值，因为负数不能直接作为颜色显示。）读取像素的颜色值（*r*，*g*，*b*），如[图
    11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4)所示，会得到该点上射入体积的光线的（*r*[x]，*r*[y]，*r*[z]）坐标。
- en: Once you have the casting rays, you render them into an image or 2D texture
    for later use with OpenGL’s frame buffer object (FBO) feature. After this texture
    is generated, you can access it inside the shaders that you’ll use to implement
    the ray casting algorithm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到了光线投射，你就可以将它们渲染为图像或2D纹理，供以后在OpenGL的帧缓冲对象（FBO）特性中使用。在生成这个纹理之后，你可以在实现光线投射算法的着色器中访问它。
- en: Ray Casting in the GPU
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPU中的光线投射
- en: To implement the ray casting algorithm, you first draw the back-faces of the
    color cube into an FBO. Next, the front-faces are drawn on the screen. The bulk
    of the ray casting algorithm happens in the fragment shader for this second rendering,
    which runs for each pixel in the output. The ray is computed by subtracting the
    front-face color of the incoming fragment from the back-face color of the color
    cube, which is read in from a texture. The computed ray is then used to accumulate
    and compute the final pixel value using the 3D volumetric texture data, available
    within the shader.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现光线投射算法，你首先将颜色立方体的背面绘制到 FBO 中。接下来，前面绘制到屏幕上。光线投射算法的主要部分发生在第二次渲染的片段着色器中，该着色器会为输出的每个像素运行。通过将传入片段的前面颜色从颜色立方体的背面颜色中减去，计算出光线，该背面颜色是从纹理中读取的。然后，使用
    3D 体积纹理数据，该数据在着色器内可用，计算并累积最终的像素值。
- en: Showing 2D Slices
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示 2D 切片
- en: In addition to the 3D rendering, you show 2D slices of the data by extracting
    the 2D cross section from the 3D data perpendicular to the x-, y-, or z-axis and
    applying that as a texture on a quad. Because you store the volume as a 3D texture,
    you can easily get the required data by specifying the texture coordinates (*s*,
    *t*, *p*). OpenGL’s built-in texture interpolation gives you the texture values
    anywhere inside the 3D texture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 3D 渲染，你还通过从 3D 数据中提取与 x、y 或 z 轴垂直的 2D 截面，并将其作为纹理应用到四边形上来显示 2D 切片。由于你将体积数据存储为
    3D 纹理，因此可以通过指定纹理坐标（*s*、*t*、*p*）轻松获得所需数据。OpenGL 内建的纹理插值会根据 3D 纹理内部的坐标获取纹理值。
- en: '[The OpenGL Window](nsp-venkitachalam503045-0008.xhtml#rbh1303)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[OpenGL 窗口](nsp-venkitachalam503045-0008.xhtml#rbh1303)'
- en: As in your other OpenGL projects, this project uses the GLFW library to display
    the OpenGL window. You’ll use handlers for drawing, for resizing the window, and
    for keyboard events. You’ll use keyboard events to toggle between volume and slice
    rendering, as well as for rotating and slicing through the 3D data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 OpenGL 项目一样，本项目使用 GLFW 库来显示 OpenGL 窗口。你将使用处理器来绘制、调整窗口大小以及处理键盘事件。你将使用键盘事件在体积渲染和切片渲染之间切换，以及旋转和切片
    3D 数据。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1302)'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah1302)'
- en: You’ll use `PyOpenGL`, a popular Python binding for OpenGL, for rendering. You’ll
    also use the Python Imaging Library (PIL) to load the 2D images from the volumetric
    data set, and you’ll use `numpy` arrays to represent 3D coordinates and transformation
    matrices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `PyOpenGL`，一个流行的 OpenGL Python 绑定库来进行渲染。你还将使用 Python 图像库（PIL）来加载来自体积数据集的
    2D 图像，并使用 `numpy` 数组表示 3D 坐标和变换矩阵。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1303)'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1303)'
- en: You’ll begin by generating a 3D texture from the volumetric data read in from
    the image files. Next, you’ll look at a color cube technique for generating rays
    from the eye that point into the volume, which is a key concept in implementing
    the volume ray casting algorithm. You’ll look at how to define the cube geometry
    as well as how to draw the back- and front-faces of this cube. You’ll then explore
    the volume ray casting algorithm and the associated vertex and fragment shaders.
    Finally, you’ll learn how to implement 2D slicing of the volumetric data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先通过从图像文件读取的体积数据生成一个 3D 纹理。接下来，你将研究一种从眼睛生成射线的颜色立方体技术，该射线指向体积，这是实现体积光线投射算法的关键概念。你将研究如何定义立方体几何形状以及如何绘制该立方体的前后面。然后，你将探讨体积光线投射算法以及相关的顶点着色器和片段着色器。最后，你将学习如何实现体积数据的
    2D 切片。
- en: 'This project has seven Python files:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目包含七个 Python 文件：
- en: glutils.py Contains the utility methods for OpenGL shaders, transformations,
    and so on
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: glutils.py 包含 OpenGL 着色器、变换等的实用方法
- en: makedata.py Contains utility methods for creating volumetric data for testing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: makedata.py 包含用于创建测试用体积数据的实用方法
- en: raycast.py Implements the `RayCastRender` class for ray casting
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: raycast.py 实现了用于光线投射的 `RayCastRender` 类
- en: raycube.py Implements the `RayCube` class for use in `RayCastRender`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: raycube.py 实现了用于 `RayCastRender` 的 `RayCube` 类
- en: slicerender.py Implements the `SliceRender` class for 2D slicing of volumetric
    data
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: slicerender.py 实现了用于体积数据 2D 切片的 `SliceRender` 类
- en: volreader.py Contains the utility method to read volumetric data into the OpenGL
    3D texture
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: volreader.py 包含将体积数据读取到 OpenGL 3D 纹理中的实用方法
- en: volrender.py Contains the main methods that create the GLFW window and the renderers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: volrender.py 包含创建 GLFW 窗口和渲染器的主要方法
- en: We’ll cover all but two of these files in this chapter. The *makedata.py* file
    lives with the other project files for this chapter at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
    The *glutils.py* file can be downloaded from [https://github.com/mkvenkit/pp2e/tree/main/common](https://github.com/mkvenkit/pp2e/tree/main/common).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍除这两个文件外的所有文件。*makedata.py* 文件与本章的其他项目文件一起存放在 [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)
    中。*glutils.py* 文件可以从 [https://github.com/mkvenkit/pp2e/tree/main/common](https://github.com/mkvenkit/pp2e/tree/main/common)
    下载。
- en: '[Generating a 3D Texture](nsp-venkitachalam503045-0008.xhtml#rbh1304)'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[生成 3D 纹理](nsp-venkitachalam503045-0008.xhtml#rbh1304)'
- en: The first step is to read the volumetric data from a folder containing images,
    as shown in the following code. To see the complete *volreader.py* code, skip
    ahead to [“The Complete 3D Texture Code”](nsp-venkitachalam503045-0025.xhtml#ah1307)
    on [page 241](nsp-venkitachalam503045-0025.xhtml#p241). You can also find the
    *volreader.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
    Note that the `loadTexture()` function in this file is used to open an image file,
    read the contents, and create an OpenGL texture object out of it, which is subsequently
    used in rendering.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从包含图像的文件夹中读取体积数据，如以下代码所示。要查看完整的 *volreader.py* 代码，请跳到 [“完整的 3D 纹理代码”](nsp-venkitachalam503045-0025.xhtml#ah1307)
    在 [第241页](nsp-venkitachalam503045-0025.xhtml#p241)。你也可以在 [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)
    找到 *volreader.py* 文件。请注意，该文件中的 `loadTexture()` 函数用于打开图像文件，读取其内容，并创建一个 OpenGL 纹理对象，然后在渲染中使用它。
- en: 'def loadVolume(dirName):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'def loadVolume(dirName):'
- en: '"""read volume from directory as a 3D texture"""'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从目录读取体积数据作为3D纹理"""'
- en: '# list images in directory'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '# 列出目录中的图像'
- en: ❶ files = sorted(os.listdir(dirName))
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ files = sorted(os.listdir(dirName))
- en: 'print(''loading images from: %s'' % dirName)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''从以下目录加载图像: %s'' % dirName)'
- en: imgDataList = []
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: imgDataList = []
- en: count = 0
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: width, height = 0, 0
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: width, height = 0, 0
- en: 'for file in files:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'for file in files:'
- en: ❷ file_path = os.path.abspath(os.path.join(dirName, file))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ file_path = os.path.abspath(os.path.join(dirName, file))
- en: 'try:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: '# read image'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取图像'
- en: ❸ img = Image.open(file_path)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ img = Image.open(file_path)
- en: imgData = np.array(img.getdata(), np.uint8)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: imgData = np.array(img.getdata(), np.uint8)
- en: '# check if all images are of the same size'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查所有图像是否具有相同的大小'
- en: '❹ if count is 0:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ if count is 0:'
- en: width, height = img.size[0], img.size[1]
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: width, height = img.size[0], img.size[1]
- en: imgDataList.append(imgData)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: imgDataList.append(imgData)
- en: 'else:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '❺ if (width, height) == (img.size[0], img.size[1]):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ if (width, height) == (img.size[0], img.size[1]):'
- en: imgDataList.append(imgData)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: imgDataList.append(imgData)
- en: 'else:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('mismatch')
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: print('不匹配')
- en: raise RunTimeError("image size mismatch")
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: raise RunTimeError("图像大小不匹配")
- en: count += 1
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: '# print img.size'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印 img.size'
- en: '❻ except:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '❻ except:'
- en: '# skip'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '# 跳过'
- en: 'print(''Invalid image: %s'' % file_path)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''无效的图像: %s'' % file_path)'
- en: '# load image data into single array'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将图像数据加载到一个单一数组中'
- en: depth = count
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: depth = count
- en: ❼ data = np.concatenate(imgDataList)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ data = np.concatenate(imgDataList)
- en: 'print(''volume data dims: %d %d %d'' % (width, height, depth))'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''体积数据维度: %d %d %d'' % (width, height, depth))'
- en: The `loadVolume()` method first lists the files in the given directory using
    the `listdir()` method from the `os` module ❶. Then you iterate through the image
    files themselves, loading them one at a time. To do this, you append the current
    filename to the directory using `os.path.abspath()` and `os.path.join()` ❷, eliminating
    the need to deal with relative filepaths and operating system–specific path conventions.
    (You often see this useful idiom in Python code that traverses files and directories.)
    Next, you use the `Image` class from the PIL to load the current image into an
    8-bit `numpy` array ❸. If the file specified isn’t an image or if the image fails
    to load, an exception is thrown, which you catch by printing an error ❻.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadVolume()` 方法首先使用 `os` 模块中的 `listdir()` 方法列出给定目录中的文件 ❶。然后，逐个加载图像文件。在此过程中，你将当前的文件名与目录一起通过
    `os.path.abspath()` 和 `os.path.join()` ❷ 追加，从而避免了处理相对文件路径和操作系统特定的路径规范的需要。（你会在遍历文件和目录的
    Python 代码中经常看到这个有用的习惯用法。）接下来，使用 PIL 中的 `Image` 类将当前图像加载到一个 8 位的 `numpy` 数组中 ❸。如果指定的文件不是图像，或者图像加载失败，会抛出异常，你可以通过打印错误来捕捉该异常
    ❻。'
- en: Because you’re loading these image slices into a 3D texture, you need to ensure
    they all have the same dimensions (width × height), which you confirm at ❹ and
    ❺. You store the dimensions for the first image and compare them against new incoming
    images. Once all the images are loaded into individual arrays, you create the
    final array containing the 3D data by joining these arrays using the `concatenate()`
    method from `numpy` ❼.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您将这些图像切片加载到 3D 纹理中，所以您需要确保它们的尺寸（宽度×高度）相同，您可以在❹和❺处确认这一点。您将第一个图像的尺寸存储下来，并将其与新的图像进行比较。一旦所有图像都加载到单独的数组中，您就可以通过使用`numpy`的`concatenate()`方法将这些数组连接起来，创建包含
    3D 数据的最终数组❼。
- en: 'The `loadVolume()` function continues by loading the array of 3D image data
    into an OpenGL texture:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadVolume()`函数继续将 3D 图像数据数组加载到 OpenGL 纹理中：'
- en: '# load data into 3D texture'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将数据加载到 3D 纹理'
- en: ❶ texture = glGenTextures(1)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ texture = glGenTextures(1)
- en: glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
- en: glBindTexture(GL_TEXTURE_3D, texture)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_3D, texture)
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D，GL_TEXTURE_WRAP_S，GL_CLAMP_TO_EDGE）
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D，GL_TEXTURE_WRAP_T，GL_CLAMP_TO_EDGE）
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D，GL_TEXTURE_WRAP_R，GL_CLAMP_TO_EDGE）
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D，GL_TEXTURE_MAG_FILTER，GL_LINEAR）
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D，GL_TEXTURE_MIN_FILTER，GL_LINEAR）
- en: ❷ glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ glTexImage3D(GL_TEXTURE_3D，0，GL_RED，
- en: width, height, depth, 0,
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度，高度，深度，0，
- en: GL_RED, GL_UNSIGNED_BYTE, data)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GL_RED，GL_UNSIGNED_BYTE，数据）
- en: '# return texture'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回纹理'
- en: ❸ return (texture, width, height, depth)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ return (texture, width, height, depth)
- en: Here you create an OpenGL texture ❶ and set parameters for filtering and unpacking.
    Then you load the 3D data array into the OpenGL texture ❷. The format used here
    is `GL_RED`, and the data format is `GL_UNSIGNED_BYTE` because you have only one
    8-bit value associated with each pixel in the data. Finally, you return the OpenGL
    texture ID and the dimensions of the 3D texture ❸.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个 OpenGL 纹理❶并设置了过滤和解包的参数。然后，您将 3D 数据数组加载到 OpenGL 纹理❷中。这里使用的格式是`GL_RED`，数据格式是`GL_UNSIGNED_BYTE`，因为每个像素只与一个
    8 位值相关联。最后，您返回 OpenGL 纹理 ID 和 3D 纹理的尺寸❸。
- en: '[Generating Rays](nsp-venkitachalam503045-0008.xhtml#rbh1305)'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[生成射线](nsp-venkitachalam503045-0008.xhtml#rbh1305)'
- en: The code for generating the rays is encapsulated in a class called `RayCube`.
    This class is responsible for drawing the color cube and has methods to draw the
    back-faces of the cube to an FBO or texture and to draw the front-faces of the
    cube to the screen. To see the complete *raycube.py* code, skip ahead to [“The
    Complete Ray Generation Code”](nsp-venkitachalam503045-0025.xhtml#ah1308) on [page
    242](nsp-venkitachalam503045-0025.xhtml#p242). You can also find the *raycube.py*
    file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 生成射线的代码封装在一个名为`RayCube`的类中。这个类负责绘制颜色立方体，并具有将立方体的背面绘制到 FBO 或纹理、以及将立方体的前面绘制到屏幕上的方法。要查看完整的*raycube.py*代码，请跳到
    [“完整的射线生成代码”](nsp-venkitachalam503045-0025.xhtml#ah1308)，位于 [第 242 页](nsp-venkitachalam503045-0025.xhtml#p242)。您还可以在[https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)找到*raycube.py*文件。
- en: 'First, let’s define the shaders used by this class. The shaders will be compiled
    as part of the `RayCube` class’s constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义此类使用的着色器。这些着色器将在`RayCube`类的构造函数中编译：
- en: ❶ strVS = """
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ strVS = """
- en: version 410 core
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: layout(location = 1) in vec3 cubePos;
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 1) in vec3 cubePos;
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 2) in vec3 cubeCol;
- en: uniform mat4 uMVMatrix;
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: out vec4 vColor;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 vColor;
- en: void main()
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // set back-face color
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置背面颜色
- en: vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: vColor = vec4(cubeCol.rgb, 1.0);
- en: // transformed position
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: // 变换后的位置
- en: vec4 newPos = vec4(cubePos.xyz, 1.0);
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 newPos = vec4(cubePos.xyz, 1.0);
- en: // set position
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置位置
- en: gl_Position = uPMatrix * uMVMatrix * newPos;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: gl_Position = uPMatrix * uMVMatrix * newPos;
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❷ strFS = """
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ strFS = """
- en: version 410 core
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: in vec4 vColor;
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: in vec4 vColor;
- en: out vec4 fragColor;
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 fragColor;
- en: void main()
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: fragColor = vColor;
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: fragColor = vColor;
- en: '}'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: You define the vertex shader used by the `RayCube` class ❶. This shader has
    two input attributes, `cubePos` and `cubeCol`, which are used to access the position
    and color values of the vertices, respectively. The modelview and projection matrices
    are passed in with the uniform variables `uMVMatrix` and `uPMatrix`, respectively.
    The `vColor` variable is declared as output because it needs to be passed on to
    the fragment shader, where it will be interpolated. The fragment shader ❷ sets
    the fragment color to the (interpolated) value of the incoming `vColor` set in
    the vertex shader.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了`RayCube`类使用的顶点着色器 ❶。这个着色器有两个输入属性，`cubePos`和`cubeCol`，分别用于访问顶点的位置和颜色值。模型视图矩阵和投影矩阵分别通过统一变量`uMVMatrix`和`uPMatrix`传入。`vColor`变量被声明为输出，因为它需要传递给片段着色器，在那里它将被插值。片段着色器
    ❷ 将片段颜色设置为在顶点着色器中设置的（插值后的）`vColor`值。
- en: Defining the Color Cube Geometry
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义颜色立方体几何形状
- en: 'Now let’s look at the geometry of the color cube, defined in the `RayCube`
    class’s constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在`RayCube`类构造函数中定义的颜色立方体几何形状：
- en: 'class RayCube:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RayCube:'
- en: 'def __init__(self, width, height):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, height):'
- en: --`snip`--
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: '# cube vertices'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '# 立方体顶点'
- en: ❶ vertices = numpy.array([
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ vertices = numpy.array([
- en: 0.0, 0.0, 0.0,
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 0.0, 0.0,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 0.0, 1.0, 0.0,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0,
- en: 0.0, 0.0, 1.0,
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0,
- en: 1.0, 0.0, 1.0,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 1.0,
- en: 1.0, 1.0, 1.0,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 1.0,
- en: 0.0, 1.0, 1.0
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 1.0
- en: '], numpy.float32)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.float32)'
- en: '# cube colors'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '# 立方体颜色'
- en: ❷ colors = numpy.array([
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ colors = numpy.array([
- en: 0.0, 0.0, 0.0,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 0.0, 0.0,
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 0.0, 1.0, 0.0,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0,
- en: 0.0, 0.0, 1.0,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0,
- en: 1.0, 0.0, 1.0,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 1.0,
- en: 1.0, 1.0, 1.0,
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 1.0,
- en: 0.0, 1.0, 1.0
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 1.0
- en: '], numpy.float32)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.float32)'
- en: '# individual triangles'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '# 单独的三角形'
- en: ❸ indices = numpy.array([
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ indices = numpy.array([
- en: 4, 5, 7,
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 4, 5, 7,
- en: 7, 5, 6,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 7, 5, 6,
- en: 5, 1, 6,
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 5, 1, 6,
- en: 6, 1, 2,
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 6, 1, 2,
- en: 1, 0, 2,
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 0, 2,
- en: 2, 0, 3,
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 2, 0, 3,
- en: 0, 4, 3,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 4, 3,
- en: 3, 4, 7,
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 3, 4, 7,
- en: 6, 2, 7,
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 6, 2, 7,
- en: 7, 2, 3,
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 7, 2, 3,
- en: 4, 0, 5,
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 4, 0, 5,
- en: 5, 0, 1
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 5, 0, 1
- en: '], numpy.int16)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.int16)'
- en: You define the cube geometry ❶ and the colors ❷ as `numpy` arrays. Notice that
    the values in these two definitions are the same. As we discussed earlier, the
    color of each pixel in the color cube corresponds to that pixel’s 3D coordinates.
    The color cube has six faces, each of which can be drawn as two triangles, for
    a total of 6×6, or 36, vertices. But rather than specify all 36 vertices, you
    specify just the cube’s eight corners ❶ and then define the triangles formed with
    those corners using an `indices` array ❸, as illustrated in [Figure 11-5](nsp-venkitachalam503045-0025.xhtml#fig11-5).
    The first two sets of three indices, for example, (4, 5, 7) and (7, 5, 6), define
    the triangles on the top face of the cube.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了立方体几何形状 ❶ 和颜色 ❷ 作为`numpy`数组。注意，这两个定义中的值是相同的。正如我们之前讨论的，颜色立方体中每个像素的颜色对应于该像素的
    3D 坐标。颜色立方体有六个面，每个面可以由两个三角形组成，总共是6×6，或者36个顶点。但与其指定所有36个顶点，你只需要指定立方体的八个角 ❶ ，然后使用`indices`数组
    ❸ 定义这些角构成的三角形，如[图11-5](nsp-venkitachalam503045-0025.xhtml#fig11-5)所示。例如，前两组三个索引（4，5，7）和（7，5，6）定义了立方体顶部面的三角形。
- en: '![](images/nsp-venkitachalam503045-f11005.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11005.jpg)'
- en: 'Figure 11-5: Using indexing, a cube can be represented as a collection of triangles,
    with each face composed of two triangles.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-5：使用索引，立方体可以表示为三角形集合，每个面由两个三角形组成。
- en: 'Next, still within the `RayCube` class constructor, you need to put the vertex
    information into buffers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，仍然在`RayCube`类的构造函数中，你需要将顶点信息放入缓冲区：
- en: '# set up vertex array object (VAO)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置顶点数组对象（VAO）'
- en: self.vao = glGenVertexArrays(1)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: self.vao = glGenVertexArrays(1)
- en: glBindVertexArray(self.vao)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# vertex buffer'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区'
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: self.vertexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
- en: '# vertex buffer – cube vertex colors'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区 – 立方体顶点颜色'
- en: self.colorBuffer = glGenBuffers(1)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: self.colorBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW)
- en: '# index buffer'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 索引缓冲区'
- en: self.indexBuffer = glGenBuffers(1)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: self.indexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer); ❶
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer); ❶
- en: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
- en: GL_STATIC_DRAW)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: GL_STATIC_DRAW)
- en: As with previous projects, you create and bind to a vertex array object (VAO)
    and then define the buffers it manages. One difference here is that the `indices`
    array is given the designation `GL_ELEMENT_ARRAY_BUFFER` ❶, which means the elements
    in its buffer will be used to index and access the data in the color and vertex
    buffers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，你需要创建并绑定一个顶点数组对象（VAO），然后定义它所管理的缓冲区。这里的一个不同之处是，`indices` 数组被指定为 `GL_ELEMENT_ARRAY_BUFFER`
    ❶，这意味着它缓冲区中的元素将用于索引并访问颜色和顶点缓冲区中的数据。
- en: Creating the Frame Buffer Object
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建帧缓冲对象
- en: 'Now let’s jump to the `RayCube` class method that creates the frame buffer
    object, where you’ll direct your rendering:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到 `RayCube` 类的方法，该方法创建帧缓冲对象，并将渲染目标指向该对象：
- en: 'def initFBO(self):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'def initFBO(self):'
- en: '# create frame buffer object'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建帧缓冲对象'
- en: self.fboHandle = glGenFramebuffers(1)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: self.fboHandle = glGenFramebuffers(1)
- en: '# create texture'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建纹理'
- en: self.texHandle = glGenTextures(1)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: self.texHandle = glGenTextures(1)
- en: '# create depth buffer'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建深度缓冲区'
- en: self.depthHandle = glGenRenderbuffers(1)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: self.depthHandle = glGenRenderbuffers(1)
- en: '# bind'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定'
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, self.texHandle)
- en: '# set parameters to draw the image at different sizes'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数以在不同大小下绘制图像'
- en: ❶ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
- en: '# set up texture'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置纹理'
- en: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
- en: '# bind texture to FBO'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定纹理到 FBO'
- en: ❷ glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
- en: GL_TEXTURE_2D, self.texHandle, 0)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: GL_TEXTURE_2D, self.texHandle, 0)
- en: '# bind'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定'
- en: ❸ glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
- en: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
- en: self.width, self.height)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height)
- en: '# bind depth buffer to FBO'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定深度缓冲区到 FBO'
- en: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
- en: GL_RENDERBUFFER, self.depthHandle)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: GL_RENDERBUFFER, self.depthHandle)
- en: '# check status'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查状态'
- en: ❹ status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 状态 = glCheckFramebufferStatus(GL_FRAMEBUFFER)
- en: 'if status == GL_FRAMEBUFFER_COMPLETE:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '如果状态 == GL_FRAMEBUFFER_COMPLETE:'
- en: pass
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '# print "fbo %d complete" % self.fboHandle'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '# print "fbo %d 完成" % self.fboHandle'
- en: 'elif status == GL_FRAMEBUFFER_UNSUPPORTED:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif 状态 == GL_FRAMEBUFFER_UNSUPPORTED:'
- en: print "fbo %d unsupported" % self.fboHandle
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: print "fbo %d 不支持" % self.fboHandle
- en: 'else:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print "fbo %d Error" % self.fboHandle
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: print "fbo %d 错误" % self.fboHandle
- en: Here you create a frame buffer object, a 2D texture, and a render buffer object;
    then you set up the texture parameters ❶. The texture is bound to the frame buffer
    ❷, and at ❸ and in the lines that follow, the render buffer sets up a 24-bit depth
    buffer and is attached to the frame buffer. Next, you check the status of the
    frame buffers ❹ and print a status message if something goes wrong. Now, as long
    as the frame buffer and render buffer are bound correctly, all of your rendering
    will go into the texture.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个帧缓冲对象、一个2D纹理和一个渲染缓冲对象；然后设置纹理参数 ❶。纹理被绑定到帧缓冲 ❷，在 ❸ 以及接下来的几行中，渲染缓冲区设置了一个24位深度缓冲，并将其附加到帧缓冲。接下来，你检查帧缓冲区的状态
    ❹，如果出现问题，会打印状态信息。只要帧缓冲区和渲染缓冲区正确绑定，所有渲染操作都会写入到纹理中。
- en: Rendering the Back-Faces of the Cube
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染立方体的背面
- en: 'Here is the code for rendering the back-faces of the color cube:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是渲染颜色立方体背面的代码：
- en: 'def renderBackFace(self, pMatrix, mvMatrix):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderBackFace(self, pMatrix, mvMatrix):'
- en: '"""renders back-face of ray-cube to a texture and returns it"""'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将射线立方体的背面渲染到纹理并返回它"""'
- en: '# render to FBO'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染到 FBO'
- en: ❶ glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
- en: '# set active texture'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置激活的纹理'
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: '# bind to FBO texture'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定到 FBO 纹理'
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, self.texHandle)
- en: '# render cube with face culling enabled'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染带有面剔除启用的立方体'
- en: ❷ self.renderCube(pMatrix, mvMatrix, self.program, True)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.renderCube(pMatrix, mvMatrix, self.program, True)
- en: '# unbind texture'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解除绑定纹理'
- en: ❸ glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ glBindTexture(GL_TEXTURE_2D, 0)
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, 0)
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: glBindRenderbuffer(GL_RENDERBUFFER, 0)
- en: '# return texture ID'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回纹理 ID'
- en: ❹ return self.texHandle
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回 self.texHandle
- en: First you bind the FBO ❶, set the active texture unit, and bind to the texture
    handle so that you can render to the FBO. Then you call the `RayCube` class’s
    `renderCube()` method ❷, which we’ll look at soon. It has a face-culling flag
    as an argument, allowing you to draw either the front-face or the back-face of
    the cube using the same code. You set the flag to `True` to make the back-faces
    appear in the FBO texture.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您绑定 FBO ❶，设置活动纹理单元，并绑定纹理句柄，以便您可以渲染到 FBO。然后调用 `RayCube` 类的 `renderCube()`
    方法 ❷，我们稍后会详细讲解。它有一个面剔除标志作为参数，允许您使用相同的代码绘制立方体的前面或背面。您将标志设置为 `True`，使背面出现在 FBO 纹理中。
- en: Next, you make the necessary calls to unbind from the FBO so that other rendering
    code is unaffected ❸. Finally, you return the FBO texture ID ❹ for use in the
    next stage of the algorithm.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要做必要的调用以从 FBO 中解除绑定，以便其他渲染代码不受影响 ❸。最后，您返回 FBO 纹理 ID ❹，以便在算法的下一阶段使用。
- en: Rendering the Front-Faces of the Cube
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染立方体的前面
- en: 'The following code is used to draw the front-faces of the color cube during
    the second rendering pass of the ray casting algorithm:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于在射线投射算法的第二次渲染过程中绘制色彩立方体的前面：
- en: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
- en: '"""render front-face of ray-cube"""'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '"""渲染射线立方体的前面"""'
- en: '# no face culling'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不进行面剔除'
- en: self.renderCube(pMatrix, mvMatrix, program, False)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderCube(pMatrix, mvMatrix, program, False)
- en: This method simply calls `renderCube()`, with the face-culling flag set to `False`
    so the front-faces will appear.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地调用 `renderCube()`，并将面剔除标志设置为 `False`，以便显示前面。
- en: Rendering the Whole Cube
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染整个立方体
- en: 'Now let’s look at the `renderCube()` method, which draws the color cube discussed
    previously:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下 `renderCube()` 方法，它绘制了前面讨论的色彩立方体：
- en: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
- en: '"""renderCube uses face culling if flag set"""'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '"""renderCube 使用面剔除，如果设置了标志"""'
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
- en: '# set shader program'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置着色器程序'
- en: glUseProgram(program)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: glUseProgram(program)
- en: '# set projection matrix'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置投影矩阵'
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
- en: 1, GL_FALSE, pMatrix)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 1, GL_FALSE, pMatrix)
- en: '# set modelview matrix'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置模型视图矩阵'
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
- en: 1, GL_FALSE, mvMatrix)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 1, GL_FALSE, mvMatrix)
- en: '# enable face culling'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用面剔除'
- en: glDisable(GL_CULL_FACE)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: glDisable(GL_CULL_FACE)
- en: '❶ if cullFace:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ 如果 cullFace:'
- en: glFrontFace(GL_CCW)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: glFrontFace(GL_CCW)
- en: glCullFace(GL_FRONT)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: glCullFace(GL_FRONT)
- en: glEnable(GL_CULL_FACE)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: glEnable(GL_CULL_FACE)
- en: '# bind VAO'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定 VAO'
- en: glBindVertexArray(self.vao)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# animated slice'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '# 动画切片'
- en: ❷ glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)
- en: '# unbind VAO'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: '# reset cull face'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置面剔除'
- en: 'if cullFace:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 cullFace:'
- en: '# disable face culling'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '# 禁用面剔除'
- en: glDisable(GL_CULL_FACE)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: glDisable(GL_CULL_FACE)
- en: You clear the color and depth buffers, select the shader program, and set the
    transformation matrices. Then you set a flag to control face culling ❶, which
    determines whether the cube’s front-face or back-face is drawn. Notice that you
    use `glDrawElements()` ❷ because you’re using an index array to render the cube,
    rather than a vertex array.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您清除颜色和深度缓冲区，选择着色器程序，并设置变换矩阵。然后，您设置一个标志来控制面剔除 ❶，以确定绘制的是立方体的前面还是背面。注意，您使用 `glDrawElements()`
    ❷，因为您正在使用索引数组来渲染立方体，而不是顶点数组。
- en: Resizing the Window
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整窗口大小
- en: 'Because the FBO is created for a particular window size, you need to re-create
    it when the window size changes. To do that, you create a resize handler for the
    `RayCube` class, as shown here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FBO 是为特定的窗口大小创建的，因此当窗口大小发生变化时，需要重新创建它。为此，您需要为 `RayCube` 类创建一个调整大小的处理程序，如下所示：
- en: 'def reshape(self, width, height):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 'def reshape(self, width, height):'
- en: self.width = width
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: '# re-create FBO'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重新创建 FBO'
- en: self.clearFBO()
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: self.clearFBO()
- en: self.initFBO()
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: self.initFBO()
- en: The `reshape()` method is called when the OpenGL window is resized. It checks
    the new window dimensions and then clears and re-creates the FBO.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape()` 方法在 OpenGL 窗口被调整大小时被调用。它检查新的窗口尺寸，然后清除并重新创建 FBO。'
- en: '[Implementing the Ray Casting Algorithm](nsp-venkitachalam503045-0008.xhtml#rbh1306)'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现射线投射算法](nsp-venkitachalam503045-0008.xhtml#rbh1306)'
- en: Next, you’ll implement the ray casting algorithm in the `RayCastRender` class.
    The core of the algorithm happens inside the fragment shader used by this class,
    which also uses the `RayCube` class to help generate the rays. To see the complete
    *raycast.py* code, skip ahead to [“The Complete Volume Ray Casting Code”](nsp-venkitachalam503045-0025.xhtml#ah1309)
    on [page 248](nsp-venkitachalam503045-0025.xhtml#p248). You can also find this
    file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将在 `RayCastRender` 类中实现射线投射算法。算法的核心部分发生在该类使用的片段着色器中，该着色器还使用 `RayCube` 类来帮助生成射线。要查看完整的
    *raycast.py* 代码，请跳转到 [“完整的体积射线投射代码”](nsp-venkitachalam503045-0025.xhtml#ah1309)，位于
    [第 248 页](nsp-venkitachalam503045-0025.xhtml#p248)。你也可以在 [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)
    找到这个文件。
- en: 'Begin in the `RayCastRender` constructor by creating a `RayCube` object and
    loading the shaders:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `RayCastRender` 构造函数开始，创建一个 `RayCube` 对象并加载着色器：
- en: 'class RayCastRender:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RayCastRender:'
- en: 'def __init__(self, width, height, volume):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, height, volume):'
- en: '"""RayCastRender construction"""'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '"""RayCastRender 构造函数"""'
- en: '# create RayCube object'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 RayCube 对象'
- en: ❶ self.raycube = raycube.RayCube(width, height)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.raycube = raycube.RayCube(width, height)
- en: '# set dimensions'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置尺寸'
- en: self.width = width
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: '# create shader'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建着色器'
- en: ❷ self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.program = glutils.loadShaders(strVS, strFS)
- en: '# texture'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '# 纹理'
- en: ❸ self.texVolume, self.Nx, self.Ny, self.Nz = volume
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.texVolume, self.Nx, self.Ny, self.Nz = volume
- en: '# initialize camera'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化相机'
- en: ❹ self.camera = Camera()
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.camera = Camera()
- en: The constructor creates an object of type `RayCube` ❶, which is used to generate
    rays. You load the shaders used by the ray casting ❷ and then set the OpenGL 3D
    texture and dimensions ❸, which were passed into the constructor as the tuple
    `volume`. Next, you create a `Camera` object ❹, which you’ll use to set up the
    OpenGL perspective transformation for the 3D rendering.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数创建了一个 `RayCube` 类型的对象 ❶，该对象用于生成射线。你加载了射线投射使用的着色器 ❷，然后设置了通过构造函数传入的 `volume`
    元组中的 OpenGL 3D 纹理和尺寸 ❸。接下来，你创建了一个 `Camera` 对象 ❹，你将用它来设置 OpenGL 的透视变换，以便进行 3D 渲染。
- en: NOTE The `Camera` class, also declared in *raycast.py*, is basically the same
    as the one used in [Chapter 10](nsp-venkitachalam503045-0024.xhtml#ch10). You’ll
    see it in the complete code listing on [page 248](nsp-venkitachalam503045-0025.xhtml#p248).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`Camera` 类（同样在 *raycast.py* 中声明）基本与在 [第 10 章](nsp-venkitachalam503045-0024.xhtml#ch10)中使用的相同。你将在
    [第 248 页](nsp-venkitachalam503045-0025.xhtml#p248)的完整代码清单中看到它。
- en: 'Here is the rendering method for `RayCastRender`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `RayCastRender` 的渲染方法：
- en: 'def draw(self):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: '# build projection matrix'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建投影矩阵'
- en: ❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
- en: '# modelview matrix'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '# 模型视图矩阵'
- en: ❷ mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,
- en: self.camera.up)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: self.camera.up)
- en: '# render'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染'
- en: '# generate ray-cube back-face texture'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成射线立方体的背面纹理'
- en: ❸ texture = self.raycube.renderBackFace(pMatrix, mvMatrix)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ texture = self.raycube.renderBackFace(pMatrix, mvMatrix)
- en: '# set shader program'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置着色器程序'
- en: ❹ glUseProgram(self.program)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ glUseProgram(self.program)
- en: '# set window dimensions'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置窗口尺寸'
- en: glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),
- en: float(self.width), float(self.height))
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: float(self.width), float(self.height))
- en: '# bind to texture unit 0, which represents back-faces of cube'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定到纹理单元 0，代表立方体的背面'
- en: ❺ glActiveTexture(GL_TEXTURE0)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ glActiveTexture(GL_TEXTURE0)
- en: glBindTexture(GL_TEXTURE_2D, texture)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, texture)
- en: glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)
- en: '# texture unit 1: 3D volume texture'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '# 纹理单元 1：3D 卷积纹理'
- en: ❻ glActiveTexture(GL_TEXTURE1)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ glActiveTexture(GL_TEXTURE1)
- en: glBindTexture(GL_TEXTURE_3D, self.texVolume)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_3D, self.texVolume)
- en: glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)
- en: '# draw front-face of cubes'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制立方体的正面'
- en: ❼ self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)
- en: First you set up a perspective projection matrix for the rendering, using the
    `glutils.perspective()` utility method ❶. Then you set the current camera parameters
    into the `glutils.lookAt()` method ❷. Next, the first pass of the rendering is
    done ❸, using the `renderBackFace()` method in `RayCube` to draw the back-faces
    of the color cube into a texture. (This method also returns the ID of the generated
    texture.)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要设置一个透视投影矩阵用于渲染，使用`glutils.perspective()`工具方法❶。接着，你将当前的相机参数传入`glutils.lookAt()`方法❷。然后，渲染的第一遍就完成了❸，通过在`RayCube`中使用`renderBackFace()`方法将色块的背面绘制到纹理中。（这个方法还会返回生成的纹理ID。）
- en: You continue by enabling the shaders for the ray casting algorithm ❹. Then you
    set up the textures for use in the shader program. The texture returned at ❸ is
    set up as texture unit 0 ❺, and the 3D texture created from the volumetric data
    you read in is set up as texture unit 1 ❻. Finally, you render the front-faces
    of the cube using the `renderFrontFace()` method in `RayCube` ❼. When this code
    is executed, the shaders for `RayCastRender` will act on the vertices and fragments.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你通过启用射线投射算法的着色器❹来继续。然后你设置着色器程序中将使用的纹理。第❸步返回的纹理被设置为纹理单元0❺，你从体积数据中读取的3D纹理被设置为纹理单元1❻。最后，你使用`RayCube`中的`renderFrontFace()`方法来渲染立方体的前面❼。当这段代码执行时，`RayCastRender`的着色器将作用于顶点和片段。
- en: The Vertex Shader
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: 'Now you come to the shaders used by `RayCastRender`. Let’s look at the vertex
    shader first:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你来到了`RayCastRender`所使用的着色器。我们首先来看一下顶点着色器：
- en: strVS = """
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: strVS = """
- en: version 410 core
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: ❶ layout(location = 1) in vec3 cubePos;
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ layout(location = 1) in vec3 cubePos;
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 2) in vec3 cubeCol;
- en: ❷ uniform mat4 uMVMatrix;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: ❸ out vec4 vColor;
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ out vec4 vColor;
- en: void main()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // set position
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置位置
- en: ❹ gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);
- en: // set color
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置颜色
- en: ❺ vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ vColor = vec4(cubeCol.rgb, 1.0);
- en: '}'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: First you set the input variables of position and color ❶. The layout uses the
    same indices as defined in the `RayCube` vertex shader because `RayCastRender`
    uses the VBO defined in that class to draw the geometry, and the locations in
    the shaders have to match. Then you define the input transformation matrices ❷
    and set a color value as the shader output ❸. The usual transformation computes
    the built-in `gl_Position` output ❹, before you set the output as the current
    color of the cube vertex ❺. The latter will be interpolated across vertices to
    give you the correct color in the fragment shader.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你设置了位置和颜色的输入变量❶。布局使用与`RayCube`顶点着色器中定义的相同索引，因为`RayCastRender`使用该类中定义的VBO来绘制几何图形，而着色器中的位置必须匹配。然后，你定义了输入变换矩阵❷，并将颜色值设置为着色器的输出❸。通常的变换会计算内置的`gl_Position`输出❹，然后你将输出设置为当前的立方体顶点颜色❺。后者将在顶点之间插值，确保片段着色器中的颜色正确。
- en: The Fragment Shader
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 片段着色器
- en: The fragment shader is the star of the show. It implements the core of the ray
    casting algorithm.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器是整个过程的核心。它实现了射线投射算法的核心部分。
- en: strFS = """
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: strFS = """
- en: version 410 core
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: in vec4 vColor;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: in vec4 vColor;
- en: uniform sampler2D texBackFaces;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: uniform sampler2D texBackFaces;
- en: uniform sampler3D texVolume;
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: uniform sampler3D texVolume;
- en: uniform vec2 uWinDims;
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: uniform vec2 uWinDims;
- en: out vec4 fragColor;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 fragColor;
- en: void main()
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // start of ray
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: // 射线起点
- en: ❶ vec3 start = vColor.rgb;
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ vec3 start = vColor.rgb;
- en: // calculate texture coordinates at fragment,
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: // 计算片段的纹理坐标，
- en: // which is a fraction of window coordinates
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: // 这是窗口坐标的一部分
- en: ❷ vec2 texc = gl_FragCoord.xy/uWinDims.xy;
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vec2 texc = gl_FragCoord.xy/uWinDims.xy;
- en: // get end of ray by looking up back-face color
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: // 通过查找背面颜色来获取射线的终点
- en: ❸ vec3 end = texture(texBackFaces, texc).rgb;
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ vec3 end = texture(texBackFaces, texc).rgb;
- en: // calculate ray direction
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: // 计算射线方向
- en: ❹ vec3 dir = end – start;
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ vec3 dir = end – start;
- en: // normalized ray direction
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: // 归一化的射线方向
- en: vec3 norm_dir = normalize(dir);
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 norm_dir = normalize(dir);
- en: // the length from front to back is calculated and
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: // 从前到后的长度被计算出来
- en: // used to terminate the ray
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: // 用于终止射线
- en: float len = length(dir.xyz);
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: float len = length(dir.xyz);
- en: // ray step size
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: // 射线步进大小
- en: float stepSize = 0.01;
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: float stepSize = 0.01;
- en: // X-ray projection
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: // X射线投影
- en: vec4 dst = vec4(0.0);
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 dst = vec4(0.0);
- en: // step through the ray
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: // 步进射线
- en: ❺ for(float t = 0.0; t < len; t += stepSize) {
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ for(float t = 0.0; t < len; t += stepSize) {
- en: // set position to endpoint of ray
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置射线的终点位置
- en: ❻ vec3 samplePos = start + t*norm_dir;
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ vec3 samplePos = start + t*norm_dir;
- en: // get texture value at position
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: // 获取位置处的纹理值
- en: ❼ float val = texture(texVolume, samplePos).r;
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ float val = texture(texVolume, samplePos).r;
- en: vec4 src = vec4(val);
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 src = vec4(val);
- en: // set opacity
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置不透明度
- en: ❽ src.a *= 0.1;
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ src.a *= 0.1;
- en: src.rgb *= src.a;
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: src.rgb *= src.a;
- en: // blend with previous value
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: // 与前一个值混合
- en: ❾ dst = (1.0 - dst.a)*src + dst;
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ dst = (1.0 - dst.a)*src + dst;
- en: // exit loop when alpha exceeds threshold
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: // 当 alpha 超过阈值时退出循环
- en: ❿ if(dst.a >= 0.95)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ if(dst.a >= 0.95)
- en: break;
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // set fragment color
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置片段颜色
- en: fragColor = dst;
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: fragColor = dst;
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: The input to the fragment shader is the cube vertex color. The fragment shader
    also has access to the 2D texture generated by rendering the color cube, the 3D
    texture containing the volumetric data, and the dimensions of the OpenGL window.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器的输入是立方体的顶点颜色。片段着色器还可以访问通过渲染颜色立方体生成的 2D 纹理、包含体积数据的 3D 纹理，以及 OpenGL 窗口的维度。
- en: While the fragment shader executes, you send in the front-faces of the cube,
    so by looking up the incoming color value ❶, you get the starting point of the
    ray that goes into this cube. (Recall the discussion in [“Ray Generation”](nsp-venkitachalam503045-0025.xhtml#bh1302)
    on [page 217](nsp-venkitachalam503045-0025.xhtml#p217) about the connection between
    the colors in the cube and the ray directions.)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当片段着色器执行时，你会发送立方体的前面朝向，因此通过查找传入的颜色值 ❶，你可以得到进入该立方体的射线起始点。（回顾[“射线生成”](nsp-venkitachalam503045-0025.xhtml#bh1302)中关于立方体中的颜色与射线方向之间的关系，参见[第
    217 页](nsp-venkitachalam503045-0025.xhtml#p217)）
- en: You calculate the texture coordinate of the incoming fragment on the screen
    ❷. Here, dividing the location of the fragment in window coordinates by the window
    dimensions maps the location to the range [0, 1]. The ending point of the ray
    is obtained by looking up the back-face color of the cube using this texture coordinate
    ❸.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你计算屏幕上传入片段的纹理坐标 ❷。这里，将片段在窗口坐标中的位置除以窗口的维度，映射该位置到范围[0, 1]。射线的终点是通过查找立方体的背面颜色来获得的，使用这个纹理坐标
    ❸。
- en: You next calculate the ray direction ❹ and then calculate the normalized direction
    and length of this ray, which will be useful in the ray casting computation. Then
    you loop through the volume using the ray’s starting point and direction until
    it hits the ray’s endpoint ❺. In this loop, you compute the ray’s current position
    inside the data volume ❻ and look up the data value at this point ❼. You then
    perform the blending equation at ❽ and ❾, which gives you the X-ray effect. You
    combine the `dst` value with the current value of the intensity (which is attenuated
    using the alpha value), and the process continues along the ray. The alpha value
    keeps increasing until it equals the maximum threshold of 0.95 ❿, at which point
    you exit the loop. The end result is a sort of average opacity through the volume
    at each pixel, which produces a “see-through” or X-ray effect. (Try varying the
    threshold and alpha attenuation to produce different effects.)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会计算射线方向 ❹，并计算该射线的归一化方向和长度，这对射线投射计算很有用。然后，你使用射线的起点和方向在体积中循环，直到射线到达终点 ❺。在这个循环中，你计算射线在数据体积中的当前位置
    ❻，并查找该点的数据值 ❼。然后，在 ❽ 和 ❾ 处执行混合方程，从而得到 X 射线效果。你将`dst`值与当前强度值（使用 alpha 值衰减）结合，并沿射线继续这一过程。alpha
    值会不断增加，直到达到最大阈值 0.95 ❿，此时退出循环。最终结果是在每个像素处通过体积的平均不透明度，从而产生“透视”或 X 射线效果。（尝试改变阈值和
    alpha 衰减来产生不同的效果。）
- en: '[Showing 2D Slices](nsp-venkitachalam503045-0008.xhtml#rbh1307)'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[显示 2D 切片](nsp-venkitachalam503045-0008.xhtml#rbh1307)'
- en: In addition to showing the 3D view of the volumetric data, you want to show
    2D slices of the data in the x-, y-, and z-directions onscreen. The code for this
    is encapsulated in a class called `SliceRender`, which creates 2D volumetric slices.
    To see the complete *slicerender.py* code, skip ahead to [“The Complete 2D Slicing
    Code”](nsp-venkitachalam503045-0025.xhtml#ah1310) on [page 251](nsp-venkitachalam503045-0025.xhtml#p251).
    You can also find the *slicerender.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示体积数据的 3D 视图外，你还需要在屏幕上显示数据在 x、y 和 z 方向上的 2D 切片。实现这一功能的代码封装在一个名为`SliceRender`的类中，该类创建
    2D 体积切片。要查看完整的 *slicerender.py* 代码，请跳转到[“完整的 2D 切片代码”](nsp-venkitachalam503045-0025.xhtml#ah1310)，位于[第
    251 页](nsp-venkitachalam503045-0025.xhtml#p251)。你也可以在[https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)找到
    *slicerender.py* 文件。
- en: 'Here’s the initialization code in the `SliceRender` class constructor that
    sets up the geometry for the slices:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SliceRender`类构造函数中的初始化代码，用于设置切片的几何体：
- en: 'class SliceRender:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SliceRender:'
- en: 'def __init__(self, width, height, volume):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, height, volume):'
- en: --`snip`--
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: '# set up vertex array object (VAO)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置顶点数组对象 (VAO)'
- en: self.vao = glGenVertexArrays(1)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: self.vao = glGenVertexArrays(1)
- en: glBindVertexArray(self.vao)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# define quad vertices'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '# 定义四边形顶点'
- en: ❶ vertexData = numpy.array([0.0, 1.0, 0.0,
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ vertexData = numpy.array([0.0, 1.0, 0.0,
- en: 0.0, 0.0, 0.0,
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 1.0, 0.0, 0.0], numpy.float32)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0], numpy.float32)
- en: '# vertex buffer'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区'
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: self.vertexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
- en: GL_STATIC_DRAW)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: GL_STATIC_DRAW)
- en: '# enable arrays'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用数组'
- en: glEnableVertexAttribArray(self.vertIndex)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: glEnableVertexAttribArray(self.vertIndex)
- en: '# set buffers'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置缓冲区'
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)
- en: '# unbind VAO'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: This code sets up a VAO to manage the VBO, as in earlier examples. You define
    the geometry of a square in the XY plane ❶. (The vertex order is that of the `GL_TRIANGLE_STRIP`,
    introduced in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).) You’ll use
    this same geometry regardless of whether you’re showing slices perpendicular to
    *x*, *y*, or *z*. All that changes between these cases is the data plane that
    you pick to display from within the 3D texture. We’ll return to this idea when
    we look at the vertex shader.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了一个 VAO 来管理 VBO，就像早期的示例一样。你定义了一个位于 XY 平面的正方形几何体❶。（顶点顺序使用的是 `GL_TRIANGLE_STRIP`，在[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)中介绍。）无论你是展示与
    *x*、*y* 还是 *z* 垂直的切片，都将使用相同的几何体。唯一变化的是你从 3D 纹理中选择显示的数据平面。我们将在查看顶点着色器时回到这个概念。
- en: 'Here’s a method to render the 2D slices:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个方法来渲染 2D 切片：
- en: 'def draw(self):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: '# clear buffers'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清除缓冲区'
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
- en: '# build projection matrix'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建投影矩阵'
- en: ❶ pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)
- en: '# modelview matrix'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '# 模型视图矩阵'
- en: ❷ mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,
- en: 0.0, 1.0, 0.0, 0.0,
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0, 0.0,
- en: 0.0, 0.0, 1.0, 0.0,
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0, 0.0,
- en: -0.5, -0.5, -1.0, 1.0], numpy.float32)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: -0.5, -0.5, -1.0, 1.0], numpy.float32)
- en: '# use shader'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用着色器'
- en: glUseProgram(self.program)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: glUseProgram(self.program)
- en: '# set projection matrix'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置投影矩阵'
- en: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
- en: '# set modelview matrix'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置模型视图矩阵'
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
- en: '# set current slice fraction'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置当前切片分数'
- en: ❸ glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),
- en: float(self.currSliceIndex)/float(self.currSliceMax))
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: float(self.currSliceIndex)/float(self.currSliceMax))
- en: '# set current slice mode'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置当前切片模式'
- en: ❹ glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),
- en: self.mode)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode)
- en: '# enable texture'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用纹理'
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: glBindTexture(GL_TEXTURE_3D, self.texture)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_3D, self.texture)
- en: glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)
- en: '# bind VAO'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定 VAO'
- en: glBindVertexArray(self.vao)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# draw'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制'
- en: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
- en: '# unbind VAO'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: Each 2D slice is a square, which you build up using an OpenGL triangle strip
    primitive. This code goes through the render setup for the triangle strip. Note
    that you implement the orthographic projection using the `glutils.ortho()` method
    at ❶. You set up a projection that adds a 0.1 buffer around the unit square representing
    the slice.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 2D 切片都是一个正方形，使用 OpenGL 三角形条带原语构建。这段代码执行了三角形条带的渲染设置。请注意，你在❶处使用 `glutils.ortho()`
    方法实现了正交投影。你设置了一个投影，在单位正方形的周围添加了 0.1 的缓冲区，表示切片。
- en: When you draw something with OpenGL, the default view (without any transformation
    applied) puts the eye at (0, 0, 0) looking down the z-axis with the y-axis pointing
    up. Applying the translation (−0.5, −0.5, −1.0) to your geometry centers it on
    the z-axis ❷. You set the current slice fraction ❸ (where, for example, the 10th
    slice out of 100 would be 0.1), set the slice mode ❹ (to view the slices in the
    x-, y-, or z-direction, as represented by the integers 0, 1, and 2, respectively),
    and set both values to the shaders.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用OpenGL绘制图形时，默认视图（没有任何变换应用）将眼睛置于(0, 0, 0)，沿着z轴向下看，y轴指向上方。将平移（−0.5, −0.5,
    −1.0）应用到几何体时，会将其居中于z轴 ❷。你设置当前的切片比例 ❸（例如，100个切片中的第10个切片的比例是0.1），设置切片模式 ❹（用于查看x、y或z方向的切片，分别用整数0、1和2表示），并将这两个值传递给着色器。
- en: The Vertex Shader
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: 'Now let’s look at the vertex shader for `SliceRender`:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`SliceRender`的顶点着色器：
- en: strVS = """
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: strVS = """
- en: version 410 core
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: in vec3 aVert;
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: in vec3 aVert;
- en: uniform mat4 uMVMatrix;
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: uniform float uSliceFrac;
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: uniform float uSliceFrac;
- en: uniform int uSliceMode;
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: uniform int uSliceMode;
- en: out vec3 texcoord;
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: out vec3 texcoord;
- en: void main() {
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: // x slice
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: // x 切片
- en: if (uSliceMode == 0) {
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: if (uSliceMode == 0) {
- en: ❶ texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);
- en: '}'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // y slice
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: // y 切片
- en: else if (uSliceMode == 1) {
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: else if (uSliceMode == 1) {
- en: ❷ texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);
- en: '}'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // z slice
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: // z 切片
- en: else {
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: ❸ texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);
- en: '}'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // calculate transformed vertex
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: // 计算变换后的顶点
- en: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
- en: '}'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: The vertex shader takes the triangle strip vertex array as input and sets a
    texture coordinate as output. The current slice fraction and slice mode are passed
    in as uniform variables `uSliceFrac` and `uSliceMode`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器将三角带顶点数组作为输入，并设置纹理坐标为输出。当前的切片比例和切片模式作为`uSliceFrac`和`uSliceMode`的uniform变量传入。
- en: The shader has three branches, depending on the slice mode. For example, if
    `uSliceMode` is `0`, you calculate the texture coordinates for an *x* slice ❶.
    Because you’re slicing perpendicular to the x-direction, you want a slice parallel
    to the YZ plane. The 3D vertices coming in to the vertex shader also double as
    the 3D texture coordinates because they are in the range [0, 1], so the texture
    coordinates are given as (*f*, *V*[x], *V*[y]), where *f* is the fraction of the
    slice number in the direction of the x-axis and where *V*[x] and *V*[y] are the
    vertex coordinates. Unfortunately, the resulting image will appear upside down
    because the OpenGL coordinate system has its origin at the bottom left, with the
    y-direction pointing up; this is the reverse of what you want. To resolve this
    problem, you change the texture coordinate *t* to (1 − *t*) and use (*f*, *V*[x],
    1 − *V*[y]) ❶. You use similar logic to compute the texture coordinates for y-
    ❷ and z- ❸ direction slices if the `uSliceMode` value is `1` or `2`, respectively.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器有三个分支，具体取决于切片模式。例如，如果`uSliceMode`为`0`，你计算*x*方向的切片纹理坐标 ❶。因为你要在x方向上切片，所以需要得到一个平行于YZ平面的切片。进入顶点着色器的3D顶点也充当3D纹理坐标，因为它们的范围是[0,
    1]，因此纹理坐标表示为(*f*, *V*[x], *V*[y])，其中*f*是x轴方向上切片数的比例，*V*[x]和*V*[y]是顶点坐标。不幸的是，生成的图像会显示倒立，因为OpenGL的坐标系统原点位于左下角，y轴指向上；这与所需的方向相反。为了解决这个问题，你将纹理坐标*t*改为(1
    − *t*)，并使用(*f*, *V*[x], 1 − *V*[y]) ❶。如果`uSliceMode`的值为`1`或`2`，你可以用类似的逻辑来计算y方向
    ❷ 和z方向 ❸的切片纹理坐标。
- en: The Fragment Shader
  id: totrans-515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 片段着色器
- en: 'Here is the fragment shader:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是片段着色器：
- en: strFS = """
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: strFS = """
- en: version 410 core
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: ❶ in vec3 texcoord;
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ in vec3 texcoord;
- en: ❷ uniform sampler3D texture;
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ uniform sampler3D texture;
- en: out vec4 fragColor;
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 fragColor;
- en: void main() {
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: // look up color in texture
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: // 在纹理中查找颜色
- en: ❸ vec4 col = texture(tex, texcoord);
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ vec4 col = texture(tex, texcoord);
- en: ❹ fragColor = col.rrra;
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ fragColor = col.rrra;
- en: '}'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: The fragment shader declares `texcoord` as input ❶, which was set as output
    in the vertex shader. The texture sampler is declared as `uniform` ❷. You look
    up the texture color using `texcoord` ❸ and set `fragColor` as the output ❹. (Because
    you read in your texture only as the red channel, you use `col.rrra`.)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器将`texcoord`声明为输入 ❶，该输入在顶点着色器中设置为输出。纹理采样器声明为`uniform` ❷。你使用`texcoord` ❸查找纹理颜色，并将`fragColor`设置为输出
    ❹。（因为你只读取纹理的红色通道，所以使用`col.rrra`。）
- en: A User Interface for 2D Slicing
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2D切片的用户界面
- en: 'Now you need a way for the user to slice through the data. Do this using a
    keyboard handling method on the `SliceRender` class:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要一种方法让用户可以对数据进行切片。通过在 `SliceRender` 类中使用键盘处理方法来实现：
- en: 'def keyPressed(self, key):'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 'def keyPressed(self, key):'
- en: '"""keypress handler"""'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '"""按键处理程序"""'
- en: '❶ if key == ''x'':'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果按下的键是 'x'：
- en: self.mode = SliceRender.XSLICE
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode = SliceRender.XSLICE
- en: '# reset slice index'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置切片索引'
- en: self.currSliceIndex = int(self.Nx/2)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = int(self.Nx/2)
- en: self.currSliceMax = self.Nx
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceMax = self.Nx
- en: 'elif key == ''y'':'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif key == ''y'':'
- en: self.mode = SliceRender.YSLICE
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode = SliceRender.YSLICE
- en: '# reset slice index'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置切片索引'
- en: self.currSliceIndex = int(self.Ny/2)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = int(self.Ny/2)
- en: self.currSliceMax = self.Ny
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceMax = self.Ny
- en: 'elif key == ''z'':'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif key == ''z'':'
- en: self.mode = SliceRender.ZSLICE
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode = SliceRender.ZSLICE
- en: '# reset slice index'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置切片索引'
- en: self.currSliceIndex = int(self.Nz/2)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = int(self.Nz/2)
- en: self.currSliceMax = self.Nz
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceMax = self.Nz
- en: 'elif key == ''l'':'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif key == ''l'':'
- en: ❷ self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax
- en: 'elif key == ''r'':'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif key == ''r'':'
- en: self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax
- en: When the X, Y, or Z key on the keyboard is pressed, `SliceRender` switches to
    the *x*, *y*, or *z* slice mode. You can see this in action for the *x* slice,
    for example ❶, where you set the appropriate mode, set the current slice index
    to the middle of the data, and update the maximum slice number.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下键盘上的 X、Y 或 Z 键时，`SliceRender` 会切换到 *x*、*y* 或 *z* 切片模式。例如，查看 *x* 切片时 ❶，你设置了适当的模式，将当前切片索引设置为数据的中间位置，并更新最大切片数。
- en: When the left or right arrow key on the keyboard is pressed, you page through
    the slices. For instance, the slice index is incremented ❷ when the left arrow
    key is pressed. The modulo operator (`%`) ensures that the index “rolls over”
    to 0 when you exceed the maximum value.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下键盘上的左箭头或右箭头键时，你可以翻阅切片。例如，当按下左箭头键时，切片索引会递增 ❷。模运算符（`%`）确保当超出最大值时，索引会“回绕”到 0。
- en: '[Putting the Code Together](nsp-venkitachalam503045-0008.xhtml#rbh1308)'
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将代码整合在一起](nsp-venkitachalam503045-0008.xhtml#rbh1308)'
- en: Let’s take a quick look at the main file in the project, *volrender.py*. This
    file uses a class `RenderWin`, which creates and manages the GLFW OpenGL window.
    (I won’t cover this class in detail because it’s similar to the class used in
    [Chapters 9](nsp-venkitachalam503045-0023.xhtml#ch09) and [10](nsp-venkitachalam503045-0024.xhtml#ch10).)
    To see the complete *volrender.py* code, skip ahead to [“The Complete Main File
    Code”](nsp-venkitachalam503045-0025.xhtml#ah1311) on [page 254](nsp-venkitachalam503045-0025.xhtml#p254).
    You can also find the *volrender.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下项目中的主文件 *volrender.py*。这个文件使用了一个 `RenderWin` 类，该类创建并管理 GLFW OpenGL 窗口。（我不会详细讲解这个类，因为它与
    [第 9 章](nsp-venkitachalam503045-0023.xhtml#ch09) 和 [第 10 章](nsp-venkitachalam503045-0024.xhtml#ch10)
    中使用的类相似。）要查看完整的 *volrender.py* 代码，可以跳到 [“完整主文件代码”](nsp-venkitachalam503045-0025.xhtml#ah1311)
    在 [第 254 页](nsp-venkitachalam503045-0025.xhtml#p254)。你还可以在 [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)
    找到 *volrender.py* 文件。
- en: 'In the initialization code for this class, you create the renderer as follows:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类的初始化代码中，你会创建渲染器，如下所示：
- en: 'class RenderWin:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RenderWin:'
- en: 'def __init__(self, imageDir):'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, imageDir):'
- en: --`snip`--
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: '# load volume data'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '# 加载体积数据'
- en: ❶ self.volume = volreader.loadVolume(imageDir)
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.volume = volreader.loadVolume(imageDir)
- en: '# create renderer'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建渲染器'
- en: ❷ self.renderer = RayCastRender(self.width, self.height, self.volume)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.renderer = RayCastRender(self.width, self.height, self.volume)
- en: Here you read the 3D data into an OpenGL texture using the `loadVolume()` function
    we discussed earlier ❶. Then you create an object of type `RayCastRender` to display
    the data ❷.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用之前讨论过的 `loadVolume()` 函数将 3D 数据读取到 OpenGL 纹理中 ❶。然后，你创建一个 `RayCastRender`
    类型的对象来显示数据 ❷。
- en: The Keypress Handler
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 键盘按键处理程序
- en: The `RenderWindow` class needs its own keyboard handler method for toggling
    between volume and slice rendering and for closing the window. This method also
    passes along keypresses to the `RayCastRender` and `SliceRender` classes’ keyboard
    handlers, to either rotate the camera or navigate through the 2D slices.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow` 类需要一个自己的键盘处理方法，用于在体积渲染和切片渲染之间切换，并用于关闭窗口。此方法还将按键事件传递给 `RayCastRender`
    和 `SliceRender` 类的键盘处理程序，以旋转相机或在 2D 切片之间导航。'
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 'def onKeyboard(self, win, key, scancode, action, mods):'
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印 ''keyboard: '', win, key, scancode, action, mods'
- en: '# ESC to quit'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '# ESC 键退出'
- en: 'if key is glfw.GLFW_KEY_ESCAPE:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下 ESC 键：
- en: self.renderer.close()
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.close()
- en: self.exitNow = True
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: self.exitNow = True
- en: 'else:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '❶ if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 action 是 glfw.GLFW_PRESS 或 action 是 glfw.GLFW_REPEAT：
- en: 'if key == glfw.GLFW_KEY_V:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下 V 键：
- en: '# toggle render mode'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '# 切换渲染模式'
- en: '❷ if isinstance(self.renderer, RayCastRender):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ 如果 isinstance(self.renderer, RayCastRender):'
- en: self.renderer = SliceRender(self.width, self.height,
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer = SliceRender(self.width, self.height,
- en: self.volume)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: self.volume)
- en: 'else:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.renderer = RayCastRender(self.width, self.height,
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer = RayCastRender(self.width, self.height,
- en: self.volume)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: self.volume)
- en: '# call reshape on renderer'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '# 调用渲染器的 reshape 方法'
- en: self.renderer.reshape(self.width, self.height)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.reshape(self.width, self.height)
- en: 'else:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# send keypress to renderer'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '# 发送按键事件给渲染器'
- en: '❸ keyDict = {glfw.GLFW_KEY_X: ''x'', glfw.GLFW_KEY_Y: ''y'','
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ keyDict = {glfw.GLFW_KEY_X: ''x'', glfw.GLFW_KEY_Y: ''y'','
- en: 'glfw.GLFW_KEY_Z: ''z'', glfw.GLFW_KEY_LEFT: ''l'','
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 'glfw.GLFW_KEY_Z: ''z'', glfw.GLFW_KEY_LEFT: ''l'','
- en: 'glfw.GLFW_KEY_RIGHT: ''r''}'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 'glfw.GLFW_KEY_RIGHT: ''r''}'
- en: 'try:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: self.renderer.keyPressed(keyDict[key])
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.keyPressed(keyDict[key])
- en: 'except:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: pass
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: Pressing ESC quits the program. You set other keypresses to work whether you
    have just pressed the key down or you are keeping it pressed ❶. If the V key is
    pressed, you toggle the renderer between volume and slice ❷, using Python’s `isinstance()`
    method to identify the current class type. To handle any other keypress events
    (X, Y, Z, or the left and right arrows), you use a dictionary ❸ and pass the keypress
    to the current renderer’s `keyPressed()` handler method. We looked at the slice
    renderer’s `keyPressed()` method in [“A User Interface for 2D Slicing”](nsp-venkitachalam503045-0025.xhtml#ch1313)
    on [page 237](nsp-venkitachalam503045-0025.xhtml#p237), for example.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ESC 键退出程序。你设置了其他按键事件，使得无论是按下键还是长按键都能触发❶。如果按下 V 键，你可以使用 Python 的 `isinstance()`
    方法来判断当前类类型，在体积渲染和切片渲染之间切换 ❷。为了处理其他按键事件（X、Y、Z 或左右箭头），你使用字典 ❸ 并将按键事件传递给当前渲染器的 `keyPressed()`
    处理方法。我们在[《2D 切片用户界面》](nsp-venkitachalam503045-0025.xhtml#ch1313)的[237 页](nsp-venkitachalam503045-0025.xhtml#p237)中，曾经讨论过切片渲染器的
    `keyPressed()` 方法。
- en: NOTE I’m choosing not to pass in the `glfw.KEY` values directly and using a
    dictionary to convert these to character values instead, because it’s a good practice
    to reduce dependencies in source files. Currently, the only file in this project
    that depends on GLFW is *volrender.py*. If you were to pass GLFW-specific types
    into other code, they would need to import and depend on the GLFW library too.
    Then, if you were to switch to a different OpenGL windowing toolkit, the code
    would become messy.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我选择不直接传递 `glfw.KEY` 值，而是使用字典将它们转换为字符值，这是一个好的做法，可以减少源文件中的依赖关系。目前，项目中唯一依赖 GLFW
    的文件是 *volrender.py*。如果你将 GLFW 特定的类型传递给其他代码，它们也需要导入并依赖 GLFW 库。如果之后你切换到其他 OpenGL
    窗口工具包，代码会变得混乱。
- en: '[Running the Program](nsp-venkitachalam503045-0008.xhtml#rah1304)'
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行程序](nsp-venkitachalam503045-0008.xhtml#rah1304)'
- en: 'Here is a sample run of the application using data from the Stanford Volume
    Data Archive:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用斯坦福体积数据档案中的数据运行应用程序的示例：
- en: $ `python volrender.py --dir mrbrain-8bit/`
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python volrender.py --dir mrbrain-8bit/`
- en: You should see something like [Figure 11-6](nsp-venkitachalam503045-0025.xhtml#fig11-6).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似于[图 11-6](nsp-venkitachalam503045-0025.xhtml#fig11-6)的效果。
- en: '![](images/nsp-venkitachalam503045-f11006.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11006.jpg)'
- en: 'Figure 11-6: A sample run of *volrender.py*. The image on the left is the volumetric
    rendering, and the image on the right is a 2D slice.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：*volrender.py* 的示例运行。左侧是体积渲染图像，右侧是 2D 切片图像。
- en: As the application runs, use the V key to toggle between volume and slice rendering.
    In slice mode, use the X, Y, and Z keys to change the slicing axis, and use the
    arrow keys to change the slicing location.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序运行时，使用 V 键在体积渲染和切片渲染之间切换。在切片模式下，使用 X、Y 和 Z 键来改变切片轴，并使用箭头键来改变切片位置。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1305)'
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1305)'
- en: In this chapter, you implemented the volume ray casting algorithm using Python
    and OpenGL. You learned how to use GLSL shaders to implement this algorithm efficiently,
    as well as how to create 2D slices from the volumetric data.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你实现了使用 Python 和 OpenGL 的体积光线投射算法。你学会了如何使用 GLSL 着色器高效实现该算法，以及如何从体积数据中创建
    2D 切片。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1306)'
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1306)'
- en: 'Here are a few ways you could keep tinkering with the volume ray casting program:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种方法可以继续调整体积光线投射程序：
- en: 1\. Currently, it’s hard to see the boundary of the volumetric data “cube” in
    the ray casting mode. Implement a class `WireFrame` that draws a box around this
    cube. Color the x-, y-, and z-axes red, green, and blue, respectively, and give
    each its own shaders. You’ll use `WireFrame` from within the `RayCastRender` class.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 目前，在射线投射模式下，很难看到体积数据“立方体”的边界。实现一个名为 `WireFrame` 的类，围绕该立方体绘制一个框。将x、y和z轴分别着色为红色、绿色和蓝色，并为每个轴提供自己的着色器。您将从
    `RayCastRender` 类内部使用 `WireFrame`。
- en: 2\. Implement data scaling. In the current implementation, you’re drawing a
    cube for the volume and a square for 2D slices, which assumes you have a symmetric
    data set (that the number of slices are the same in each direction), but most
    real data has a varying number of slices. Medical data, in particular, often has
    fewer slices in the z-direction, with dimensions such as 256×256×99, for example.
    To display this data correctly, you have to introduce a scale into your computations.
    One way to do so is to apply the scale to the cube vertices (3D volume) and square
    vertices (2D slice). The user can then input the scaling parameters as command
    line arguments.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 实现数据缩放。在当前实现中，您为体积绘制了一个立方体，为2D切片绘制了一个正方形，这假设您有一个对称的数据集（每个方向的切片数量相同），但大多数真实数据在z方向上的切片数量是不同的。特别是医学数据通常在z方向上有较少的切片，例如256×256×99。为了正确显示这些数据，您必须在计算中引入一个比例。一种方法是将比例应用于立方体顶点（3D体积）和正方形顶点（2D切片）。用户可以将缩放参数作为命令行参数输入。
- en: '3\. Our volume ray casting implementation uses X-ray casting to calculate the
    final color or intensity of a pixel. Another popular way to do this is to use
    *maximum intensity projection (MIP)* to set the maximum intensity at each pixel.
    Implement this in your code. (Hint: in the fragment shader of `RayCastRender`,
    modify the code that steps through the ray to check and set the maximum value
    along the ray, instead of blending values.)'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 我们的体积射线投射实现使用X射线投射来计算像素的最终颜色或强度。另一种流行的方法是使用 *最大强度投影 (MIP)* 在每个像素处设置最大强度。在您的代码中实现这一点。（提示：在
    `RayCastRender` 的片段着色器中，修改通过射线的步骤以检查并设置沿射线的最大值，而不是混合值。）
- en: '4\. Currently, the only UI you have implemented is rotation around the x-,
    y-, and z-axes. Implement a zoom feature so pressing I/O will zoom in/out of the
    volume-rendered image. You could do this by setting the appropriate camera parameters
    in the `glutils.lookAt()` method, with one caveat: if you move your view inside
    the data cube, the ray casting will fail because OpenGL will clip the front-faces
    of the cube; the ray computation needed for ray casting requires both the front-
    and back-faces of the color cube to be rendered correctly. Instead, zoom by adjusting
    the field of view in the `glutils.projecton()` method.'
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 目前，您仅实现了围绕 x、y 和 z 轴旋转的 UI。实现一个缩放功能，使得按下 I/O 键可以放大/缩小体渲染图像。您可以通过在 `glutils.lookAt()`
    方法中设置适当的摄像机参数来实现这一点，但有一个注意事项：如果您在数据立方体内部移动视角，射线投射将失败，因为OpenGL会裁剪立方体的前表面；射线投射所需的射线计算需要正确渲染彩色立方体的前表面和后表面。相反，请通过调整
    `glutils.projecton()` 方法中的视场来进行缩放。
- en: '[The Complete 3D Texture Code](nsp-venkitachalam503045-0008.xhtml#rah1307)'
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的3D纹理代码](nsp-venkitachalam503045-0008.xhtml#rah1307)'
- en: Here’s the full *volreader.py* code listing.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的 *volreader.py* 代码清单。
- en: import os
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: import numpy as np
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: from PIL import Image
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: from PIL import Image
- en: import OpenGL
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: import OpenGL
- en: from OpenGL.GL import *
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: from OpenGL.GL import *
- en: from scipy import misc
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: from scipy import misc
- en: 'def loadVolume(dirName):'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 'def loadVolume(dirName):'
- en: '"""read volume from directory as a 3D texture"""'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从目录中读取体积作为3D纹理"""'
- en: '# list images in directory'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '# 列出目录中的图像'
- en: files = sorted(os.listdir(dirName))
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: files = sorted(os.listdir(dirName))
- en: 'print(''loading images from: %s'' % dirName)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: print('从以下位置加载图像：%s' % dirName)
- en: imgDataList = []
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: imgDataList = []
- en: count = 0
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: width, height = 0, 0
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: width, height = 0, 0
- en: 'for file in files:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 'for file in files:'
- en: file_path = os.path.abspath(os.path.join(dirName, file))
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: file_path = os.path.abspath(os.path.join(dirName, file))
- en: 'try:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: '# read image'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取图像'
- en: img = Image.open(file_path)
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: img = Image.open(file_path)
- en: imgData = np.array(img.getdata(), np.uint8)
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: imgData = np.array(img.getdata(), np.uint8)
- en: '# check if all are of the same size'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否所有大小都相同'
- en: 'if count is 0:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 'if count is 0:'
- en: width, height = img.size[0], img.size[1]
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: width, height = img.size[0], img.size[1]
- en: imgDataList.append(imgData)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: imgDataList.append(imgData)
- en: 'else:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'if (width, height) == (img.size[0], img.size[1]):'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (width, height) == (img.size[0], img.size[1]):'
- en: imgDataList.append(imgData)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: imgDataList.append(imgData)
- en: 'else:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('mismatch')
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: print('不匹配')
- en: raise RunTimeError("image size mismatch")
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: raise RunTimeError("图像大小不匹配")
- en: count += 1
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: '# print img.size'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印图像大小'
- en: 'except:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: '# skip'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '# 跳过'
- en: 'print(''Invalid image: %s'' % file_path)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''Invalid image: %s'' % file_path)'
- en: '# load image data into single array'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将图像数据加载到单一数组中'
- en: depth = count
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: depth = count
- en: data = np.concatenate(imgDataList)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: data = np.concatenate(imgDataList)
- en: 'print(''volume data dims: %d %d %d'' % (width, height, depth))'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''volume data dims: %d %d %d'' % (width, height, depth))'
- en: '# load data into 3D texture'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将数据加载到3D纹理中'
- en: texture = glGenTextures(1)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: texture = glGenTextures(1)
- en: glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
- en: glBindTexture(GL_TEXTURE_3D, texture)
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_3D, texture)
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
- en: glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,
- en: width, height, depth, 0,
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: width, height, depth, 0,
- en: GL_RED, GL_UNSIGNED_BYTE, data)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: GL_RED, GL_UNSIGNED_BYTE, data)
- en: '# return texture'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回纹理'
- en: return (texture, width, height, depth)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: return (texture, width, height, depth)
- en: load texture
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: load texture
- en: 'def loadTexture(filename):'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 'def loadTexture(filename):'
- en: img = Image.open(filename)
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: img = Image.open(filename)
- en: img_data = np.array(list(img.getdata()), 'B')
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: img_data = np.array(list(img.getdata()), 'B')
- en: texture = glGenTextures(1)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: texture = glGenTextures(1)
- en: glPixelStorei(GL_UNPACK_ALIGNMENT,1)
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: glPixelStorei(GL_UNPACK_ALIGNMENT,1)
- en: glBindTexture(GL_TEXTURE_2D, texture)
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, texture)
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
- en: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, img_data)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 0, GL_RGBA, GL_UNSIGNED_BYTE, img_data)
- en: return texture
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: return texture
- en: '[The Complete Ray Generation Code](nsp-venkitachalam503045-0008.xhtml#rah1308)'
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的射线生成代码](nsp-venkitachalam503045-0008.xhtml#rah1308)'
- en: Here’s the full code listing for the `RayCube` class.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`RayCube`类的完整代码列表。
- en: import OpenGL
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: import OpenGL
- en: from OpenGL.GL import *
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: from OpenGL.GL import *
- en: from OpenGL.GL.shaders import *
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: from OpenGL.GL.shaders import *
- en: import numpy, math, sys
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy, math, sys
- en: import volreader, glutils
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: import volreader, glutils
- en: strVS = """
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: strVS = """
- en: version 330 core
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本 330 核心
- en: layout(location = 1) in vec3 cubePos;
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 1) in vec3 cubePos;
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 2) in vec3 cubeCol;
- en: uniform mat4 uMVMatrix;
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: out vec4 vColor;
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 vColor;
- en: void main()
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // set back-face color
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: // set back-face color
- en: vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: vColor = vec4(cubeCol.rgb, 1.0);
- en: // transformed position
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: // transformed position
- en: vec4 newPos = vec4(cubePos.xyz, 1.0);
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 newPos = vec4(cubePos.xyz, 1.0);
- en: // set position
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: // set position
- en: gl_Position = uPMatrix * uMVMatrix * newPos;
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: gl_Position = uPMatrix * uMVMatrix * newPos;
- en: '}'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: strFS = """
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: strFS = """
- en: version 330 core
  id: totrans-705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本 330 核心
- en: in vec4 vColor;
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: in vec4 vColor;
- en: out vec4 fragColor;
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 fragColor;
- en: void main()
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: fragColor = vColor;
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: fragColor = vColor;
- en: '}'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'class RayCube:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RayCube:'
- en: '"""class used to generate rays used in ray casting"""'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '"""用于生成射线的类"""'
- en: 'def __init__(self, width, height):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, height):'
- en: '"""RayCube constructor"""'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '"""RayCube constructor"""'
- en: '# set dims'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置维度'
- en: self.width, self.height = width, height
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height = width, height
- en: '# create shader'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建着色器'
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: self.program = glutils.loadShaders(strVS, strFS)
- en: '# cube vertices'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '# 方块顶点'
- en: vertices = numpy.array([
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: vertices = numpy.array([
- en: 0.0, 0.0, 0.0,
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 0.0, 0.0,
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 0.0, 1.0, 0.0,
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0,
- en: 0.0, 0.0, 1.0,
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0,
- en: 1.0, 0.0, 1.0,
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 1.0,
- en: 1.0, 1.0, 1.0,
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 1.0,
- en: 0.0, 1.0, 1.0
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 1.0
- en: '], numpy.float32)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.float32)'
- en: '# cube colors'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '# 方块颜色'
- en: colors = numpy.array([
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: colors = numpy.array([
- en: 0.0, 0.0, 0.0,
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 0.0, 0.0,
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 0.0, 1.0, 0.0,
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0,
- en: 0.0, 0.0, 1.0,
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0,
- en: 1.0, 0.0, 1.0,
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 1.0,
- en: 1.0, 1.0, 1.0,
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 1.0,
- en: 0.0, 1.0, 1.0
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 1.0
- en: '], numpy.float32)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.float32)'
- en: '# individual triangles'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '# individual triangles'
- en: indices = numpy.array([
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: indices = numpy.array([
- en: 4, 5, 7,
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 4, 5, 7,
- en: 7, 5, 6,
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 7, 5, 6,
- en: 5, 1, 6,
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 5, 1, 6,
- en: 6, 1, 2,
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 6, 1, 2,
- en: 1, 0, 2,
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 0, 2,
- en: 2, 0, 3,
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 2, 0, 3,
- en: 0, 4, 3,
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 4, 3,
- en: 3, 4, 7,
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 3, 4, 7,
- en: 6, 2, 7,
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 6, 2, 7,
- en: 7, 2, 3,
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 7, 2, 3,
- en: 4, 0, 5,
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 4, 0, 5,
- en: 5, 0, 1
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 5, 0, 1
- en: '], numpy.int16)'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.int16)'
- en: self.nIndices = indices.size
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: self.nIndices = indices.size
- en: '# set up vertex array object (VAO)'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置顶点数组对象（VAO）'
- en: self.vao = glGenVertexArrays(1)
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: self.vao = glGenVertexArrays(1)
- en: glBindVertexArray(self.vao)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# vertex buffer'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区'
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: self.vertexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
- en: '# vertex buffer - cube vertex colors'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区 - 立方体顶点颜色'
- en: self.colorBuffer = glGenBuffers(1)
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: self.colorBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW);
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW);
- en: '# index buffer'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '# 索引缓冲区'
- en: self.indexBuffer = glGenBuffers(1)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: self.indexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer);
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer);
- en: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
- en: GL_STATIC_DRAW)
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: GL_STATIC_DRAW)
- en: '# enable attrs using the layout indices in shader'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用着色器中的布局索引启用属性'
- en: aPosLoc = 1
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: aPosLoc = 1
- en: aColorLoc = 2
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: aColorLoc = 2
- en: '# bind buffers'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定缓冲区'
- en: glEnableVertexAttribArray(1)
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: glEnableVertexAttribArray(1)
- en: glEnableVertexAttribArray(2)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: glEnableVertexAttribArray(2)
- en: '# vertex'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点'
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glVertexAttribPointer(aPosLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: glVertexAttribPointer(aPosLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
- en: '# color'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '# 颜色'
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
- en: glVertexAttribPointer(aColorLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: glVertexAttribPointer(aColorLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
- en: '# index'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '# 索引'
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer)
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer)
- en: '# unbind VAO'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: '# FBO'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '# FBO'
- en: self.initFBO()
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: self.initFBO()
- en: 'def renderBackFace(self, pMatrix, mvMatrix):'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderBackFace(self, pMatrix, mvMatrix):'
- en: '"""renders back-face of ray-cube to a texture and returns it"""'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将射线立方体的背面渲染到纹理并返回"""'
- en: '# render to FBO'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染到 FBO'
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
- en: '# set active texture'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置活动纹理'
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: '# bind to FBO texture'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定到 FBO 纹理'
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, self.texHandle)
- en: '# render cube with face culling enabled'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染启用了面剔除的立方体'
- en: self.renderCube(pMatrix, mvMatrix, self.program, True)
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderCube(pMatrix, mvMatrix, self.program, True)
- en: '# unbind texture'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑纹理'
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, 0)
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, 0)
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: glBindRenderbuffer(GL_RENDERBUFFER, 0)
- en: '# return texture ID'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回纹理 ID'
- en: return self.texHandle
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: return self.texHandle
- en: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
- en: '"""render front-face of ray-cube"""'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '"""渲染射线立方体的正面"""'
- en: '# no face culling'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不进行面剔除'
- en: self.renderCube(pMatrix, mvMatrix, program, False)
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderCube(pMatrix, mvMatrix, program, False)
- en: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
- en: '"""render cube using face culling if flag set"""'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '"""如果启用标志，则使用面剔除渲染立方体"""'
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
- en: '# set shader program'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置着色器程序'
- en: glUseProgram(program)
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: glUseProgram(program)
- en: '# set projection matrix'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置投影矩阵'
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
- en: 1, GL_FALSE, pMatrix)
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 1, GL_FALSE, pMatrix)
- en: '# set modelview matrix'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置模型视图矩阵'
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
- en: 1, GL_FALSE, mvMatrix)
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 1, GL_FALSE, mvMatrix)
- en: '# enable face culling'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用面剔除'
- en: glDisable(GL_CULL_FACE)
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: glDisable(GL_CULL_FACE)
- en: 'if cullFace:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 'if cullFace:'
- en: glFrontFace(GL_CCW)
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: glFrontFace(GL_CCW)
- en: glCullFace(GL_FRONT)
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: glCullFace(GL_FRONT)
- en: glEnable(GL_CULL_FACE)
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: glEnable(GL_CULL_FACE)
- en: '# bind VAO'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定 VAO'
- en: glBindVertexArray(self.vao)
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# animated slice'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '# 动态切片'
- en: glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)
- en: '# unbind VAO'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: '# reset cull face'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置剔除面'
- en: 'if cullFace:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 'if cullFace:'
- en: '# disable face culling'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '# 禁用面剔除'
- en: glDisable(GL_CULL_FACE)
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: glDisable(GL_CULL_FACE)
- en: 'def reshape(self, width, height):'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 'def reshape(self, width, height):'
- en: self.width = width
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: '# re-create FBO'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重新创建 FBO'
- en: self.clearFBO()
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: self.clearFBO()
- en: self.initFBO()
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: self.initFBO()
- en: 'def initFBO(self):'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 'def initFBO(self):'
- en: '# create frame buffer object'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建帧缓冲对象'
- en: self.fboHandle = glGenFramebuffers(1)
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: self.fboHandle = glGenFramebuffers(1)
- en: '# create texture'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建纹理'
- en: self.texHandle = glGenTextures(1)
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: self.texHandle = glGenTextures(1)
- en: '# create depth buffer'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建深度缓冲'
- en: self.depthHandle = glGenRenderbuffers(1)
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: self.depthHandle = glGenRenderbuffers(1)
- en: '# bind'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定'
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, self.texHandle)
- en: '# set parameters to draw the image at different sizes'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置不同大小绘制图像的参数'
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
- en: '# set up texture'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置纹理'
- en: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
- en: '# bind texture to FBO'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定纹理到 FBO'
- en: glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
- en: GL_TEXTURE_2D, self.texHandle, 0)
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: GL_TEXTURE_2D, self.texHandle, 0)
- en: '# bind'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定'
- en: glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
- en: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
- en: self.width, self.height)
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height)
- en: '# bind depth buffer to FBO'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定深度缓冲区到 FBO'
- en: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
- en: GL_RENDERBUFFER, self.depthHandle)
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: GL_RENDERBUFFER, self.depthHandle)
- en: '# check status'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查状态'
- en: status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
- en: 'if status == GL_FRAMEBUFFER_COMPLETE:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '如果状态 == GL_FRAMEBUFFER_COMPLETE:'
- en: pass
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '# print "fbo %d complete" % self.fboHandle'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '# print "fbo %d 完成" % self.fboHandle'
- en: 'elif status == GL_FRAMEBUFFER_UNSUPPORTED:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif status == GL_FRAMEBUFFER_UNSUPPORTED:'
- en: print("fbo %d unsupported" % self.fboHandle)
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: print("fbo %d 不支持" % self.fboHandle)
- en: 'else:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print("fbo %d Error" % self.fboHandle)
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: print("fbo %d 错误" % self.fboHandle)
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, 0)
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, 0)
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: glBindRenderbuffer(GL_RENDERBUFFER, 0)
- en: return
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: 'def clearFBO(self):'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 'def clearFBO(self):'
- en: '"""clears old FBO"""'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '"""清除旧的 FBO"""'
- en: '# delete FBO'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '# 删除 FBO'
- en: 'if glIsFramebuffer(self.fboHandle):'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 glIsFramebuffer(self.fboHandle):'
- en: glDeleteFramebuffers(1, int(self.fboHandle))
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteFramebuffers(1, int(self.fboHandle))
- en: '# delete texture'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '# 删除纹理'
- en: 'if glIsTexture(self.texHandle):'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 glIsTexture(self.texHandle):'
- en: glDeleteTextures(int(self.texHandle))
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteTextures(int(self.texHandle))
- en: 'def close(self):'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 'def close(self):'
- en: '"""call this to free up OpenGL resources"""'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '"""调用此方法释放 OpenGL 资源"""'
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, 0)
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, 0)
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: glBindRenderbuffer(GL_RENDERBUFFER, 0)
- en: '# delete FBO'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '# 删除 FBO'
- en: 'if glIsFramebuffer(self.fboHandle):'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 glIsFramebuffer(self.fboHandle):'
- en: glDeleteFramebuffers(1, int(self.fboHandle))
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteFramebuffers(1, int(self.fboHandle))
- en: '# delete texture'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '# 删除纹理'
- en: 'if glIsTexture(self.texHandle):'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 glIsTexture(self.texHandle):'
- en: glDeleteTextures(int(self.texHandle))
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteTextures(int(self.texHandle))
- en: '# delete render buffer'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '# 删除渲染缓冲区'
- en: '"""'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if glIsRenderbuffer(self.depthHandle):'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 glIsRenderbuffer(self.depthHandle):'
- en: glDeleteRenderbuffers(1, int(self.depthHandle))
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteRenderbuffers(1, int(self.depthHandle))
- en: '"""'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# delete buffers'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '# 删除缓冲区'
- en: '"""'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: glDeleteBuffers(1, self._vertexBuffer)
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteBuffers(1, self._vertexBuffer)
- en: glDeleteBuffers(1, &_indexBuffer)
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteBuffers(1, &_indexBuffer)
- en: glDeleteBuffers(1, &_colorBuffer)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: glDeleteBuffers(1, &_colorBuffer)
- en: '"""'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '[The Complete Volume Ray Casting Code](nsp-venkitachalam503045-0008.xhtml#rah1309)'
  id: totrans-919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整体积光线投射代码](nsp-venkitachalam503045-0008.xhtml#rah1309)'
- en: Here’s the full *raycast.py* code listing.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的*raycast.py*代码清单。
- en: import OpenGL
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 OpenGL
- en: from OpenGL.GL import *
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenGL.GL 导入 *
- en: from OpenGL.GL.shaders import *
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenGL.GL.shaders 导入 *
- en: import numpy as np
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 numpy as np
- en: import math, sys
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 math, sys
- en: import raycube, glutils, volreader
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 raycube, glutils, volreader
- en: strVS = """
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: strVS = """
- en: version 330 core
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 330 core
- en: layout(location = 1) in vec3 cubePos;
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 1) in vec3 cubePos;
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 2) in vec3 cubeCol;
- en: uniform mat4 uMVMatrix;
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: out vec4 vColor;
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 vColor;
- en: void main()
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // set position
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置位置
- en: gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);
- en: // set color
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置颜色
- en: vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: vColor = vec4(cubeCol.rgb, 1.0);
- en: '}'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: strFS = """
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: strFS = """
- en: version 330 core
  id: totrans-943
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 330 core
- en: in vec4 vColor;
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在 vec4 vColor;
- en: uniform sampler2D texBackFaces;
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: uniform sampler2D texBackFaces;
- en: uniform sampler3D texVolume;
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: uniform sampler3D texVolume;
- en: uniform vec2 uWinDims;
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: uniform vec2 uWinDims;
- en: out vec4 fragColor;
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 fragColor;
- en: void main()
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // start of ray
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: // 光线的起始点
- en: vec3 start = vColor.rgb;
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 start = vColor.rgb;
- en: // calculate texture coords at fragment,
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: // 计算片段的纹理坐标，
- en: // which is a fraction of window coords
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: // 这是窗口坐标的一部分
- en: vec2 texc = gl_FragCoord.xy/uWinDims.xy;
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: vec2 texc = gl_FragCoord.xy/uWinDims.xy;
- en: // get end of ray by looking up back-face color
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: // 通过查找背面颜色来获取射线的终点
- en: vec3 end = texture(texBackFaces, texc).rgb;
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 end = texture(texBackFaces, texc).rgb;
- en: // calculate ray direction
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: // 计算射线方向
- en: vec3 dir = end - start;
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 dir = end - start;
- en: // normalized ray direction
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: // 归一化的射线方向
- en: vec3 norm_dir = normalize(dir);
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 norm_dir = normalize(dir);
- en: // the length from front to back is calculated and
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: // 从前到后的长度被计算出来
- en: // used to terminate the ray
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: // 用于终止射线
- en: float len = length(dir.xyz);
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: float len = length(dir.xyz);
- en: // ray step size
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: // 射线步长
- en: float stepSize = 0.01;
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: float stepSize = 0.01;
- en: // X-ray projection
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: // X射线投影
- en: vec4 dst = vec4(0.0);
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 dst = vec4(0.0);
- en: // step through the ray
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: // 步进射线
- en: for(float t = 0.0; t < len; t += stepSize) {
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: for(float t = 0.0; t < len; t += stepSize) {
- en: // set position to endpoint of ray
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置位置到射线终点
- en: vec3 samplePos = start + t*norm_dir;
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 samplePos = start + t*norm_dir;
- en: // get texture value at position
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: // 获取当前位置的纹理值
- en: float val = texture(texVolume, samplePos).r;
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: float val = texture(texVolume, samplePos).r;
- en: vec4 src = vec4(val);
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 src = vec4(val);
- en: // set opacity
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置透明度
- en: src.a *= 0.1;
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: src.a *= 0.1;
- en: src.rgb *= src.a;
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: src.rgb *= src.a;
- en: // blend with previous value
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: // 与前一个值混合
- en: dst = (1.0 - dst.a)*src + dst;
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: dst = (1.0 - dst.a)*src + dst;
- en: // exit loop when alpha exceeds threshold
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: // 当 alpha 超过阈值时退出循环
- en: if(dst.a >= 0.95)
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: if(dst.a >= 0.95)
- en: break;
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // set fragment color
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置片段颜色
- en: fragColor =  dst;
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: fragColor =  dst;
- en: '}'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'class Camera:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Camera:'
- en: '"""helper class for viewing"""'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '"""用于视图的辅助类"""'
- en: 'def __init__(self):'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: self.r = 1.5
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: self.r = 1.5
- en: self.theta = 0
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: self.theta = 0
- en: self.center = [0.5, 0.5, 0.5]
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: self.center = [0.5, 0.5, 0.5]
- en: self.eye = [0.5 + self.r, 0.5, 0.5]
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: self.eye = [0.5 + self.r, 0.5, 0.5]
- en: self.up = [0.0, 0.0, 1.0]
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: self.up = [0.0, 0.0, 1.0]
- en: 'def rotate(self, clockWise):'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 'def rotate(self, clockWise):'
- en: '"""rotate eye by one step"""'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '"""旋转视点一步"""'
- en: 'if clockWise:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 'if clockWise:'
- en: self.theta = (self.theta + 5) % 360
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: self.theta = (self.theta + 5) % 360
- en: 'else:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.theta = (self.theta - 5) % 360
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: self.theta = (self.theta - 5) % 360
- en: '# recalculate eye'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重新计算视点'
- en: self.eye = [0.5 + self.r*math.cos(math.radians(self.theta)),
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: self.eye = [0.5 + self.r*math.cos(math.radians(self.theta)),
- en: 0.5 + self.r*math.sin(math.radians(self.theta)),
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5 + self.r*math.sin(math.radians(self.theta)),
- en: 0.5]
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5]
- en: 'class RayCastRender:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RayCastRender:'
- en: '"""class that does Ray Casting"""'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '"""执行射线投射的类"""'
- en: 'def __init__(self, width, height, volume):'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, height, volume):'
- en: '"""RayCastRender constr"""'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '"""RayCastRender 构造函数"""'
- en: '# create RayCube object'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 RayCube 对象'
- en: self.raycube = raycube.RayCube(width, height)
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: self.raycube = raycube.RayCube(width, height)
- en: '# set dimensions'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置尺寸'
- en: self.width = width
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: '# create shader'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建着色器'
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: self.program = glutils.loadShaders(strVS, strFS)
- en: '# texture'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '# 纹理'
- en: self.texVolume, self.Nx, self.Ny, self.Nz = volume
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: self.texVolume, self.Nx, self.Ny, self.Nz = volume
- en: '# initialize camera'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化相机'
- en: self.camera = Camera()
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: self.camera = Camera()
- en: 'def draw(self):'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: '# build projection matrix'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建投影矩阵'
- en: pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
- en: '# modelview matrix'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '# 模型视图矩阵'
- en: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,
- en: self.camera.up)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: self.camera.up)
- en: '# render'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染'
- en: '# generate ray-cube back-face texture'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成射线立方体的背面纹理'
- en: texture = self.raycube.renderBackFace(pMatrix, mvMatrix)
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: texture = self.raycube.renderBackFace(pMatrix, mvMatrix)
- en: '# set shader program'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置着色器程序'
- en: glUseProgram(self.program)
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: glUseProgram(self.program)
- en: '# set window dimensions'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置窗口尺寸'
- en: glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),
- en: float(self.width), float(self.height))
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: float(self.width), float(self.height))
- en: '# texture unit 0, which represents back-faces of cube'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '# 纹理单元 0，代表立方体的背面纹理'
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: glBindTexture(GL_TEXTURE_2D, texture)
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, texture)
- en: glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)
- en: '# texture unit 1: 3D volume texture'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '# 纹理单元 1: 3D 卷积纹理'
- en: glActiveTexture(GL_TEXTURE1)
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE1)
- en: glBindTexture(GL_TEXTURE_3D, self.texVolume)
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_3D, self.texVolume)
- en: glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)
- en: '# draw front-face of cubes'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制立方体的前面'
- en: self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)
- en: '#self.render(pMatrix, mvMatrix)'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '#self.render(pMatrix, mvMatrix)'
- en: 'def keyPressed(self, key):'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 'def keyPressed(self, key):'
- en: 'if key == ''l'':'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 'if key == ''l'':'
- en: self.camera.rotate(True)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: self.camera.rotate(True)
- en: 'elif key == ''r'':'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif key == ''r'':'
- en: self.camera.rotate(False)
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: self.camera.rotate(False)
- en: 'def reshape(self, width, height):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 'def reshape(self, width, height):'
- en: self.width = width
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: self.raycube.reshape(width, height)
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: self.raycube.reshape(width, height)
- en: 'def close(self):'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 'def close(self):'
- en: self.raycube.close()
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: self.raycube.close()
- en: '[The Complete 2D Slicing Code](nsp-venkitachalam503045-0008.xhtml#rah1310)'
  id: totrans-1060
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的2D切片代码](nsp-venkitachalam503045-0008.xhtml#rah1310)'
- en: Here is the full 2D slicing code listing.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的2D切片代码列表。
- en: import OpenGL
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: import OpenGL
- en: from OpenGL.GL import *
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: from OpenGL.GL import *
- en: from OpenGL.GL.shaders import *
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: from OpenGL.GL.shaders import *
- en: import numpy, math, sys
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy, math, sys
- en: import volreader, glutils
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: import volreader, glutils
- en: strVS = """
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: strVS = """
- en: version 330 core
  id: totrans-1068
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 330 core
- en: in vec3 aVert;
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: in vec3 aVert;
- en: uniform mat4 uMVMatrix;
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: uniform float uSliceFrac;
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: uniform float uSliceFrac;
- en: uniform int uSliceMode;
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: uniform int uSliceMode;
- en: out vec3 texcoord;
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: out vec3 texcoord;
- en: void main() {
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: // x slice
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: // x 轴切片
- en: if (uSliceMode == 0) {
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: if (uSliceMode == 0) {
- en: texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);
- en: '}'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // y slice
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: // y 轴切片
- en: else if (uSliceMode == 1) {
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: else if (uSliceMode == 1) {
- en: texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);
- en: '}'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // z slice
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: // z 轴切片
- en: else {
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);
- en: '}'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // calculate transformed vertex
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: // 计算变换后的顶点
- en: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
- en: '}'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: strFS = """
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: strFS = """
- en: version 330 core
  id: totrans-1093
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 330 core
- en: in vec3 texcoord;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: in vec3 texcoord;
- en: uniform sampler3D tex;
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: uniform sampler3D tex;
- en: out vec4 fragColor;
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 fragColor;
- en: void main() {
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: // look up color in texture
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: // 在纹理中查找颜色
- en: vec4 col = texture(tex, texcoord);
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 col = texture(tex, texcoord);
- en: fragColor = col.rrra;
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: fragColor = col.rrra;
- en: '}'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'class SliceRender:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SliceRender:'
- en: '# slice modes'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '# 切片模式'
- en: XSLICE, YSLICE, ZSLICE = 0, 1, 2
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: XSLICE, YSLICE, ZSLICE = 0, 1, 2
- en: 'def __init__(self, width, height, volume):'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, height, volume):'
- en: '"""SliceRender constructor"""'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '"""SliceRender 构造函数"""'
- en: self.width = width
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: '# slice mode'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '# 切片模式'
- en: self.mode = SliceRender.ZSLICE
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode = SliceRender.ZSLICE
- en: '# create shader'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建着色器'
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: self.program = glutils.loadShaders(strVS, strFS)
- en: glUseProgram(self.program)
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: glUseProgram(self.program)
- en: self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')
- en: self.mvMatrixUniform = glGetUniformLocation(self.program, b"uMVMatrix")
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: self.mvMatrixUniform = glGetUniformLocation(self.program, b"uMVMatrix")
- en: '# attributes'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '# 属性'
- en: self.vertIndex = glGetAttribLocation(self.program, b"aVert")
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: self.vertIndex = glGetAttribLocation(self.program, b"aVert")
- en: '# set up vertex array object (VAO)'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置顶点数组对象（VAO）'
- en: self.vao = glGenVertexArrays(1)
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: self.vao = glGenVertexArrays(1)
- en: glBindVertexArray(self.vao)
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# define quad vertices'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '# 定义四边形顶点'
- en: vertexData = numpy.array([0.0, 1.0, 0.0,
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: vertexData = numpy.array([0.0, 1.0, 0.0,
- en: 0.0, 0.0, 0.0,
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 1.0, 0.0, 0.0], numpy.float32)
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0], numpy.float32)
- en: '# vertex buffer'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区'
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: self.vertexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
- en: GL_STATIC_DRAW)
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: GL_STATIC_DRAW)
- en: '# enable arrays'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用数组'
- en: glEnableVertexAttribArray(self.vertIndex)
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: glEnableVertexAttribArray(self.vertIndex)
- en: '# set buffers'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置缓冲区'
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)
- en: '# unbind VAO'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: '# load texture'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '# 加载纹理'
- en: self.texture, self.Nx, self.Ny, self.Nz = volume
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: self.texture, self.Nx, self.Ny, self.Nz = volume
- en: '# current slice index'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '# 当前切片索引'
- en: self.currSliceIndex = int(self.Nz/2);
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = int(self.Nz/2);
- en: self.currSliceMax = self.Nz;
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceMax = self.Nz;
- en: 'def reshape(self, width, height):'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 'def reshape(self, width, height):'
- en: self.width = width
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: 'def draw(self):'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: '# clear buffers'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清除缓冲区'
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
- en: '# build projection matrix'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建投影矩阵'
- en: pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)
- en: '# modelview matrix'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '# 模型视图矩阵'
- en: mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,
- en: 0.0, 1.0, 0.0, 0.0,
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0, 0.0,
- en: 0.0, 0.0, 1.0, 0.0,
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0, 0.0,
- en: -0.5, -0.5, -1.0, 1.0], numpy.float32)
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: -0.5, -0.5, -1.0, 1.0], numpy.float32)
- en: '# use shader'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用着色器'
- en: glUseProgram(self.program)
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: glUseProgram(self.program)
- en: '# set projection matrix'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置投影矩阵'
- en: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
- en: '# set modelview matrix'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置模型视图矩阵'
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
- en: '# set current slice fraction'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置当前切片分数'
- en: glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),
- en: float(self.currSliceIndex)/float(self.currSliceMax))
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: float(self.currSliceIndex)/float(self.currSliceMax))
- en: '# set current slice mode'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置当前切片模式'
- en: glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),
- en: self.mode)
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode)
- en: '# enable texture'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用纹理'
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: glBindTexture(GL_TEXTURE_3D, self.texture)
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_3D, self.texture)
- en: glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)
- en: '# bind VAO'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定 VAO'
- en: glBindVertexArray(self.vao)
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# draw'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染'
- en: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
- en: '# unbind VAO'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: 'def keyPressed(self, key):'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 'def keyPressed(self, key):'
- en: '"""keypress handler"""'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '"""按键处理函数"""'
- en: 'if key == ''x'':'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是 'x'：
- en: self.mode = SliceRender.XSLICE
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode = SliceRender.XSLICE
- en: '# reset slice index'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置切片索引'
- en: self.currSliceIndex = int(self.Nx/2)
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = int(self.Nx/2)
- en: self.currSliceMax = self.Nx
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceMax = self.Nx
- en: 'elif key == ''y'':'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是 'y'：
- en: self.mode = SliceRender.YSLICE
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode = SliceRender.YSLICE
- en: '# reset slice index'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置切片索引'
- en: self.currSliceIndex = int(self.Ny/2)
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = int(self.Ny/2)
- en: self.currSliceMax = self.Ny
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceMax = self.Ny
- en: 'elif key == ''z'':'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是 'z'：
- en: self.mode = SliceRender.ZSLICE
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: self.mode = SliceRender.ZSLICE
- en: '# reset slice index'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置切片索引'
- en: self.currSliceIndex = int(self.Nz/2)
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = int(self.Nz/2)
- en: self.currSliceMax = self.Nz
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceMax = self.Nz
- en: 'elif key == ''l'':'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是 'l'：
- en: self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax
- en: 'elif key == ''r'':'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是 'r'：
- en: self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax
- en: 'def close(self):'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 定义关闭方法（close）
- en: pass
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '[The Complete Main File Code](nsp-venkitachalam503045-0008.xhtml#rah1311)'
  id: totrans-1204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整主文件代码](nsp-venkitachalam503045-0008.xhtml#rah1311)'
- en: Here is the full code listing for the main file.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主文件的完整代码列表。
- en: import sys, argparse, os
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: import sys, argparse, os
- en: from slicerender import *
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: from slicerender import *
- en: from raycast import *
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: from raycast import *
- en: import glfw
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: import glfw
- en: 'class RenderWin:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RenderWin:'
- en: '"""GLFW Rendering window class"""'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '"""GLFW 渲染窗口类"""'
- en: 'def __init__(self, imageDir):'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, imageDir):'
- en: '# save current working directory'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '# 保存当前工作目录'
- en: cwd = os.getcwd()
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: cwd = os.getcwd()
- en: '# initialize glfw; this changes cwd'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化 glfw；这会改变 cwd'
- en: glfw.glfwInit()
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwInit()
- en: '# restore cwd'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '# 恢复 cwd'
- en: os.chdir(cwd)
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: os.chdir(cwd)
- en: '# version hints'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '# 版本提示'
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,
- en: glfw.GLFW_OPENGL_CORE_PROFILE)
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.GLFW_OPENGL_CORE_PROFILE)
- en: '# make a window'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个窗口'
- en: self.width, self.height = 512, 512
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height = 512, 512
- en: self.aspect = self.width/float(self.height)
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = self.width/float(self.height)
- en: self.win = glfw.glfwCreateWindow(self.width, self.height, b"volrender")
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: self.win = glfw.glfwCreateWindow(self.width, self.height, b"volrender")
- en: '# make context current'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使上下文当前'
- en: glfw.glfwMakeContextCurrent(self.win)
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwMakeContextCurrent(self.win)
- en: '# initialize GL'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化 GL'
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: glViewport(0, 0, self.width, self.height)
- en: glEnable(GL_DEPTH_TEST)
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: glEnable(GL_DEPTH_TEST)
- en: glClearColor(0.0, 0.0, 0.0, 0.0)
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: glClearColor(0.0, 0.0, 0.0, 0.0)
- en: '# set window callbacks'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置窗口回调函数'
- en: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
- en: glfw.glfwSetWindowSizeCallback(self.win, self.onSize)
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSetWindowSizeCallback(self.win, self.onSize)
- en: '# load volume data'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '# 加载体积数据'
- en: self.volume =  volreader.loadVolume(imageDir)
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: self.volume = volreader.loadVolume(imageDir)
- en: '# create renderer'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建渲染器'
- en: self.renderer = RayCastRender(self.width, self.height, self.volume)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer = RayCastRender(self.width, self.height, self.volume)
- en: '# exit flag'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '# 退出标志'
- en: self.exitNow = False
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: self.exitNow = False
- en: 'def onMouseButton(self, win, button, action, mods):'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 'def onMouseButton(self, win, button, action, mods):'
- en: '# print ''mouse button: '', win, button, action, mods'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印 ''鼠标按键: '', win, button, action, mods'
- en: pass
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 'def onKeyboard(self, win, key, scancode, action, mods):'
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印 ''键盘: '', win, key, scancode, action, mods'
- en: '# ESC to quit'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '# ESC 键退出'
- en: 'if key is glfw.GLFW_KEY_ESCAPE:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是 glfw.GLFW_KEY_ESCAPE：
- en: self.renderer.close()
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.close()
- en: self.exitNow = True
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: self.exitNow = True
- en: 'else:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作是 glfw.GLFW_PRESS 或 glfw.GLFW_REPEAT：
- en: 'if key == glfw.GLFW_KEY_V:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是 glfw.GLFW_KEY_V：
- en: '# toggle render mode'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '# 切换渲染模式'
- en: 'if isinstance(self.renderer, RayCastRender):'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(self.renderer, RayCastRender):'
- en: self.renderer = SliceRender(self.width, self.height,
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer = SliceRender(self.width, self.height,
- en: self.volume)
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: self.volume)
- en: 'else:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.renderer = RayCastRender(self.width, self.height,
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer = RayCastRender(self.width, self.height,
- en: self.volume)
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: self.volume)
- en: '# call reshape on renderer'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '# 调用渲染器的 reshape'
- en: self.renderer.reshape(self.width, self.height)
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.reshape(self.width, self.height)
- en: 'else:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# send keypress to renderer'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '# 发送按键到渲染器'
- en: 'keyDict = {glfw.GLFW_KEY_X: ''x'', glfw.GLFW_KEY_Y: ''y'','
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 'keyDict = {glfw.GLFW_KEY_X: ''x'', glfw.GLFW_KEY_Y: ''y'','
- en: 'glfw.GLFW_KEY_Z: ''z'', glfw.GLFW_KEY_LEFT: ''l'','
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 'glfw.GLFW_KEY_Z: ''z'', glfw.GLFW_KEY_LEFT: ''l'','
- en: 'glfw.GLFW_KEY_RIGHT: ''r''}'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 'glfw.GLFW_KEY_RIGHT: ''r''}'
- en: 'try:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: self.renderer.keyPressed(keyDict[key])
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.keyPressed(keyDict[key])
- en: 'except:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: pass
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'def onSize(self, win, width, height):'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 'def onSize(self, win, width, height):'
- en: '# print ''onsize: '', win, width, height'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印 ''onsize: '', win, width, height'
- en: self.width = width
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.height = height
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = height
- en: self.aspect = width/float(height)
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = width/float(height)
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: glViewport(0, 0, self.width, self.height)
- en: self.renderer.reshape(width, height)
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.reshape(width, height)
- en: 'def run(self):'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 'def run(self):'
- en: '# start loop'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '# 开始循环'
- en: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
- en: '# render'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染'
- en: self.renderer.draw()
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderer.draw()
- en: '# swap buffers'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '# 交换缓冲区'
- en: glfw.glfwSwapBuffers(self.win)
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSwapBuffers(self.win)
- en: '# wait for events'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '# 等待事件'
- en: glfw.glfwWaitEvents()
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWaitEvents()
- en: '# end'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '# 结束'
- en: glfw.glfwTerminate()
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwTerminate()
- en: main() function
  id: totrans-1293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print('starting volrender...')
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: print('开始体积渲染...')
- en: '# create parser'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建解析器'
- en: parser = argparse.ArgumentParser(description="Volume Rendering...")
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="体积渲染...")
- en: '# add expected arguments'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加预期参数'
- en: parser.add_argument('--dir', dest='imageDir', required=True)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--dir', dest='imageDir', required=True)
- en: '# parse args'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: args = parser.parse_args()
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# create render window'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建渲染窗口'
- en: rwin = RenderWin(args.imageDir)
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: rwin = RenderWin(args.imageDir)
- en: rwin.run()
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: rwin.run()
- en: call main
  id: totrans-1305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '[1](nsp-venkitachalam503045-0025.xhtml#fn4r) J. Kruger and R. Westermann, “Acceleration
    Techniques for GPU-based Volume Rendering,” IEEE Visualization, 2003.'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](nsp-venkitachalam503045-0025.xhtml#fn4r) J. Kruger 和 R. Westermann，"基于
    GPU 的体积渲染加速技术"，IEEE 可视化，2003。'
- en: '[2](nsp-venkitachalam503045-0025.xhtml#fn5r) [https://graphics.stanford.edu/data/voldata/](https://graphics.stanford.edu/data/voldata/)'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](nsp-venkitachalam503045-0025.xhtml#fn5r) [https://graphics.stanford.edu/data/voldata/](https://graphics.stanford.edu/data/voldata/)'
