- en: '[11](nsp-venkitachalam503045-0008.xhtml#rch11)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[11](nsp-venkitachalam503045-0008.xhtml#rch11)'
- en: Volume Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 体积渲染
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Magnetic resonance imaging (MRI) and computed tomography (CT) scans are diagnostic
    processes that create *volumetric data*, data that consists of a set of 2D images
    showing cross sections through a 3D volume. *Volume rendering* is a computer graphics
    technique used to construct 3D images from this type of volumetric data. Although
    volume rendering is commonly used to analyze medical scans, it can also be used
    to create 3D scientific visualizations in academic disciplines such as geology,
    archaeology, and molecular biology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 磁共振成像（MRI）和计算机断层扫描（CT）是诊断过程，用于创建*体积数据*，这些数据由一组二维图像组成，展示了穿过三维体积的横截面。*体积渲染*是一种计算机图形学技术，用于从这种类型的体积数据中构建三维图像。尽管体积渲染通常用于分析医学扫描，它也可以用于创建在地质学、考古学和分子生物学等学科中的三维科学可视化。
- en: The data captured by MRI and CT scans typically follows the form of a 3D grid
    of dimensions *N*[x]×*N*[y]×*N*[z]. In other words, there are *N*[z] 2D “slices,”
    where each slice is an image of size *N*[x]×*N*[y]. Volume rendering algorithms
    are used to display the collected slice data with some type of transparency, and
    various techniques are used to accentuate the parts of the rendered volume that
    are of interest.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: MRI和CT扫描捕获的数据通常呈现为*N*[x]×*N*[y]×*N*[z]大小的3D网格。换句话说，有*N*[z]个二维“切片”，每个切片是大小为*N*[x]×*N*[y]的图像。体积渲染算法用于以某种透明度显示收集的切片数据，并使用各种技术突出显示渲染体积中感兴趣的部分。
- en: In this project, you’ll look at a volume rendering called *volume ray casting*,
    which takes full advantage of the graphics processing unit (GPU) to perform computations
    using OpenGL Shading Language (GLSL) shaders. Your code executes for every pixel
    onscreen and leverages the GPU, which is designed to do parallel computations
    efficiently. You’ll use a folder of 2D images consisting of slices from a 3D data
    set to construct a volume-rendered image using the volume ray casting algorithm.
    You’ll also implement a method to show 2D slices of the data in the x-, y-, and
    z-directions so users can scroll through the slices using the arrow keys. Keyboard
    commands will let the user toggle between the 3D rendering and the 2D slices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将研究一种名为*体积光线投射*的体积渲染方法，它充分利用图形处理单元（GPU）来使用OpenGL着色语言（GLSL）着色器进行计算。你的代码将对每个屏幕上的像素进行执行，并利用GPU进行并行计算，它设计用于高效地执行并行计算。你将使用一个由二维图像组成的文件夹，这些图像是3D数据集的切片，并使用体积光线投射算法构建体积渲染图像。你还将实现一种方法，以便显示数据在x、y和z方向上的二维切片，这样用户可以使用箭头键浏览这些切片。键盘命令将允许用户在3D渲染和2D切片之间切换。
- en: 'Here are some of the topics covered in this project:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本项目中涉及的一些主题：
- en: • Using GLSL for GPU computations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用GLSL进行GPU计算
- en: • Creating vertex and fragment shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 创建顶点着色器和片段着色器
- en: • Representing 3D volumetric data and using the volume ray casting algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 表示3D体积数据并使用体积光线投射算法
- en: • Using `numpy` arrays for 3D transformation matrices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`数组进行3D变换矩阵
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1301)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah1301)'
- en: 'There are various ways to render a 3D data set. In this project, you’ll use
    the volume ray casting method, which is an *image*-*based* rendering technique
    used to generate the final image from the 2D slices, pixel by pixel. In contrast,
    typical 3D rendering methods are *object based*: they begin with a 3D object representation
    and then apply transformations to generate the pixels in the projected 2D image.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染3D数据集有多种方式。在这个项目中，你将使用体积光线投射方法，这是一种*基于图像*的渲染技术，用于逐像素地从二维切片生成最终图像。与此相对，典型的3D渲染方法是*基于对象*的：它们从3D对象表示开始，然后应用变换生成投影二维图像中的像素。
- en: In the volume ray casting method that you’ll use in this project, for each pixel
    in the output image, a ray is shot into the discrete 3D volumetric data set, which
    is typically represented as a cuboid. As the ray passes through the volume, the
    data is sampled at regular intervals, and the samples are combined, or *composited*,
    to compute the color value or intensity of the final image. (You might think of
    this process as similar to stacking a bunch of transparencies on top of each other
    and holding them up against a bright light to see a blend of all the sheets.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: While volume ray casting rendering implementations typically use techniques
    such as applying gradients to improve the appearance of the final render, filtering
    to isolate 3D features, and using spatial optimization techniques to improve speed,
    you’ll just implement the basic ray casting algorithm and composite the final
    image by X-ray casting. (My implementation is largely based on the seminal paper
    on this topic by Kruger and Westermann, published in 2003.[1](nsp-venkitachalam503045-0025.xhtml#fn4))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[The Data Format](nsp-venkitachalam503045-0008.xhtml#rbh1301)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, you’ll use medical data from 3D scans from the Stanford Volume
    Data Archive.[2](nsp-venkitachalam503045-0025.xhtml#fn5) This archive offers a
    few excellent 3D medical data sets (both CT and MRI) of TIFF images, one for each
    2D cross section of the volume. You’ll read a folder of these images into an OpenGL
    3D texture; this is sort of like stacking a set of 2D images to form a cuboid,
    as shown in [Figure 11-1](nsp-venkitachalam503045-0025.xhtml#fig11-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f11001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: Building 3D volumetric data from 2D slices'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09) that a 2D texture
    in OpenGL is addressed with a 2D coordinate (*s*, *t*). Similarly, a 3D texture
    is addressed using a 3D texture coordinate of the form (*s*, *t*, *p*). As you’ll
    see, storing the volumetric data as a 3D texture allows you to access the data
    quickly and provides you with interpolated values required by your ray casting
    scheme.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[Ray Generation](nsp-venkitachalam503045-0008.xhtml#rbh1302)'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your goal in this project is to generate a perspective projection of the 3D
    volumetric data, as shown in [Figure 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2).
    The figure shows the OpenGL view frustum, as discussed in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).
    Specifically, it shows how a ray from the eye enters this frustum at the near
    plane, passes through the cubic volume (which contains the volumetric data), and
    exits from the rear at the far plane.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f11002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: A perspective projection of 3D volumetric data'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: To implement ray casting, you need to generate rays that go into the volume.
    For each pixel in the output window shown in [Figure 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2),
    you generate a vector *R* that goes into the volume you consider a unit cube (which
    I’ll refer to as the *color cube*) defined between the coordinates (0, 0, 0) and
    (1, 1, 1). You color each point inside this cube with the RGB values equal to
    the 3D coordinates of the cube. The origin is colored (0, 0, 0), or black; the
    (1, 0, 0) corner is red; and the point on the cube diagonally opposite the origin
    is colored (1, 1, 1), or white. [Figure 11-3](nsp-venkitachalam503045-0025.xhtml#fig11-3)
    shows this cube.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f11003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: A color cube'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: NOTE In OpenGL, a color can be represented as a strip of 8-bit unsigned values
    (*r*, *g*, *b*), where *r*, *g*, and *b* are in the range [0, 255]. It can also
    be represented as a triplet of 32-bit floating-point values (*r*, *g*, *b*), where
    *r*, *g*, and *b* are in the range [0.0, 1.0]. These representations are equivalent.
    For example, the red color (255, 0, 0) in the former is the same as (1.0, 0.0,
    0.0) in the latter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: To draw the cube, first draw its six faces using the OpenGL primitive `GL_TRIANGLES`.
    Then color each vertex and use the interpolation provided by OpenGL when it rasterizes
    polygons to take care of the colors between each vertex. For example, [Figure
    11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4) shows the three front-faces
    of the cube. The back-faces of the cube are drawn in [Figure 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    by setting OpenGL to cull front-faces.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f11004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: The color cube used to compute rays'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: If you subtract the colors in [Figure 11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    from [Figure 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4) by subtracting
    (*r*, *g*, *b*)[front] from (*r*, *g*, *b*)[back], you actually compute a set
    of vectors that go from the front to the back of the cube because each color (*r*, *g*, *b*)
    on this cube is the same as the 3D coordinate at that color’s location. [Figure 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    shows the result. (Negative values have been flipped to positive for the purposes
    of this illustration because negative numbers cannot be displayed as colors directly.)
    Reading the color value (*r*, *g*, *b*) of a pixel, as shown in [Figure 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4),
    gives the (*r*[x], *r*[y], *r*[z]) coordinates for the ray passing into the volume
    at that point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the casting rays, you render them into an image or 2D texture
    for later use with OpenGL’s frame buffer object (FBO) feature. After this texture
    is generated, you can access it inside the shaders that you’ll use to implement
    the ray casting algorithm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Ray Casting in the GPU
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To implement the ray casting algorithm, you first draw the back-faces of the
    color cube into an FBO. Next, the front-faces are drawn on the screen. The bulk
    of the ray casting algorithm happens in the fragment shader for this second rendering,
    which runs for each pixel in the output. The ray is computed by subtracting the
    front-face color of the incoming fragment from the back-face color of the color
    cube, which is read in from a texture. The computed ray is then used to accumulate
    and compute the final pixel value using the 3D volumetric texture data, available
    within the shader.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Showing 2D Slices
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the 3D rendering, you show 2D slices of the data by extracting
    the 2D cross section from the 3D data perpendicular to the x-, y-, or z-axis and
    applying that as a texture on a quad. Because you store the volume as a 3D texture,
    you can easily get the required data by specifying the texture coordinates (*s*,
    *t*, *p*). OpenGL’s built-in texture interpolation gives you the texture values
    anywhere inside the 3D texture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[The OpenGL Window](nsp-venkitachalam503045-0008.xhtml#rbh1303)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in your other OpenGL projects, this project uses the GLFW library to display
    the OpenGL window. You’ll use handlers for drawing, for resizing the window, and
    for keyboard events. You’ll use keyboard events to toggle between volume and slice
    rendering, as well as for rotating and slicing through the 3D data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1302)'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll use `PyOpenGL`, a popular Python binding for OpenGL, for rendering. You’ll
    also use the Python Imaging Library (PIL) to load the 2D images from the volumetric
    data set, and you’ll use `numpy` arrays to represent 3D coordinates and transformation
    matrices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1303)'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll begin by generating a 3D texture from the volumetric data read in from
    the image files. Next, you’ll look at a color cube technique for generating rays
    from the eye that point into the volume, which is a key concept in implementing
    the volume ray casting algorithm. You’ll look at how to define the cube geometry
    as well as how to draw the back- and front-faces of this cube. You’ll then explore
    the volume ray casting algorithm and the associated vertex and fragment shaders.
    Finally, you’ll learn how to implement 2D slicing of the volumetric data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'This project has seven Python files:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: glutils.py Contains the utility methods for OpenGL shaders, transformations,
    and so on
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: makedata.py Contains utility methods for creating volumetric data for testing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: raycast.py Implements the `RayCastRender` class for ray casting
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: raycube.py Implements the `RayCube` class for use in `RayCastRender`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: slicerender.py Implements the `SliceRender` class for 2D slicing of volumetric
    data
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: volreader.py Contains the utility method to read volumetric data into the OpenGL
    3D texture
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: volrender.py Contains the main methods that create the GLFW window and the renderers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover all but two of these files in this chapter. The *makedata.py* file
    lives with the other project files for this chapter at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
    The *glutils.py* file can be downloaded from [https://github.com/mkvenkit/pp2e/tree/main/common](https://github.com/mkvenkit/pp2e/tree/main/common).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[Generating a 3D Texture](nsp-venkitachalam503045-0008.xhtml#rbh1304)'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to read the volumetric data from a folder containing images,
    as shown in the following code. To see the complete *volreader.py* code, skip
    ahead to [“The Complete 3D Texture Code”](nsp-venkitachalam503045-0025.xhtml#ah1307)
    on [page 241](nsp-venkitachalam503045-0025.xhtml#p241). You can also find the
    *volreader.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
    Note that the `loadTexture()` function in this file is used to open an image file,
    read the contents, and create an OpenGL texture object out of it, which is subsequently
    used in rendering.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'def loadVolume(dirName):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '"""read volume from directory as a 3D texture"""'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '# list images in directory'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: ❶ files = sorted(os.listdir(dirName))
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''loading images from: %s'' % dirName)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: imgDataList = []
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: width, height = 0, 0
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'for file in files:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: ❷ file_path = os.path.abspath(os.path.join(dirName, file))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '# read image'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: ❸ img = Image.open(file_path)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: imgData = np.array(img.getdata(), np.uint8)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '# check if all images are of the same size'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '❹ if count is 0:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: width, height = img.size[0], img.size[1]
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: imgDataList.append(imgData)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '❺ if (width, height) == (img.size[0], img.size[1]):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: imgDataList.append(imgData)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: print('mismatch')
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: raise RunTimeError("image size mismatch")
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '# print img.size'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '❻ except:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '# skip'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Invalid image: %s'' % file_path)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '# load image data into single array'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: depth = count
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: ❼ data = np.concatenate(imgDataList)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''volume data dims: %d %d %d'' % (width, height, depth))'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The `loadVolume()` method first lists the files in the given directory using
    the `listdir()` method from the `os` module ❶. Then you iterate through the image
    files themselves, loading them one at a time. To do this, you append the current
    filename to the directory using `os.path.abspath()` and `os.path.join()` ❷, eliminating
    the need to deal with relative filepaths and operating system–specific path conventions.
    (You often see this useful idiom in Python code that traverses files and directories.)
    Next, you use the `Image` class from the PIL to load the current image into an
    8-bit `numpy` array ❸. If the file specified isn’t an image or if the image fails
    to load, an exception is thrown, which you catch by printing an error ❻.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Because you’re loading these image slices into a 3D texture, you need to ensure
    they all have the same dimensions (width × height), which you confirm at ❹ and
    ❺. You store the dimensions for the first image and compare them against new incoming
    images. Once all the images are loaded into individual arrays, you create the
    final array containing the 3D data by joining these arrays using the `concatenate()`
    method from `numpy` ❼.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadVolume()` function continues by loading the array of 3D image data
    into an OpenGL texture:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '# load data into 3D texture'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: ❶ texture = glGenTextures(1)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_3D, texture)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: ❷ glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: width, height, depth, 0,
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: GL_RED, GL_UNSIGNED_BYTE, data)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '# return texture'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: ❸ return (texture, width, height, depth)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Here you create an OpenGL texture ❶ and set parameters for filtering and unpacking.
    Then you load the 3D data array into the OpenGL texture ❷. The format used here
    is `GL_RED`, and the data format is `GL_UNSIGNED_BYTE` because you have only one
    8-bit value associated with each pixel in the data. Finally, you return the OpenGL
    texture ID and the dimensions of the 3D texture ❸.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[Generating Rays](nsp-venkitachalam503045-0008.xhtml#rbh1305)'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for generating the rays is encapsulated in a class called `RayCube`.
    This class is responsible for drawing the color cube and has methods to draw the
    back-faces of the cube to an FBO or texture and to draw the front-faces of the
    cube to the screen. To see the complete *raycube.py* code, skip ahead to [“The
    Complete Ray Generation Code”](nsp-venkitachalam503045-0025.xhtml#ah1308) on [page
    242](nsp-venkitachalam503045-0025.xhtml#p242). You can also find the *raycube.py*
    file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define the shaders used by this class. The shaders will be compiled
    as part of the `RayCube` class’s constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: ❶ strVS = """
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layout(location = 1) in vec3 cubePos;
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 vColor;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: // set back-face color
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: // transformed position
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: vec4 newPos = vec4(cubePos.xyz, 1.0);
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: // set position
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * newPos;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: ❷ strFS = """
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec4 vColor;
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = vColor;
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: You define the vertex shader used by the `RayCube` class ❶. This shader has
    two input attributes, `cubePos` and `cubeCol`, which are used to access the position
    and color values of the vertices, respectively. The modelview and projection matrices
    are passed in with the uniform variables `uMVMatrix` and `uPMatrix`, respectively.
    The `vColor` variable is declared as output because it needs to be passed on to
    the fragment shader, where it will be interpolated. The fragment shader ❷ sets
    the fragment color to the (interpolated) value of the incoming `vColor` set in
    the vertex shader.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Color Cube Geometry
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at the geometry of the color cube, defined in the `RayCube`
    class’s constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'class RayCube:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, width, height):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: --`snip`--
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '# cube vertices'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: ❶ vertices = numpy.array([
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 0.0,
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 0.0,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 0.0,
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 0.0,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 1.0,
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 1.0,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 1.0,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 1.0
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '], numpy.float32)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '# cube colors'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: ❷ colors = numpy.array([
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 0.0,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 0.0,
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 0.0,
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 0.0,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 1.0,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 1.0,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 1.0,
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 1.0
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '], numpy.float32)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '# individual triangles'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: ❸ indices = numpy.array([
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 4, 5, 7,
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 7, 5, 6,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 5, 1, 6,
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 6, 1, 2,
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 1, 0, 2,
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 2, 0, 3,
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 0, 4, 3,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 3, 4, 7,
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 6, 2, 7,
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 7, 2, 3,
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 4, 0, 5,
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 5, 0, 1
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '], numpy.int16)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: You define the cube geometry ❶ and the colors ❷ as `numpy` arrays. Notice that
    the values in these two definitions are the same. As we discussed earlier, the
    color of each pixel in the color cube corresponds to that pixel’s 3D coordinates.
    The color cube has six faces, each of which can be drawn as two triangles, for
    a total of 6×6, or 36, vertices. But rather than specify all 36 vertices, you
    specify just the cube’s eight corners ❶ and then define the triangles formed with
    those corners using an `indices` array ❸, as illustrated in [Figure 11-5](nsp-venkitachalam503045-0025.xhtml#fig11-5).
    The first two sets of three indices, for example, (4, 5, 7) and (7, 5, 6), define
    the triangles on the top face of the cube.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f11005.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: Using indexing, a cube can be represented as a collection of triangles,
    with each face composed of two triangles.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, still within the `RayCube` class constructor, you need to put the vertex
    information into buffers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: self.vao = glGenVertexArrays(1)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex buffer'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex buffer – cube vertex colors'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: self.colorBuffer = glGenBuffers(1)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '# index buffer'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: self.indexBuffer = glGenBuffers(1)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer); ❶
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: As with previous projects, you create and bind to a vertex array object (VAO)
    and then define the buffers it manages. One difference here is that the `indices`
    array is given the designation `GL_ELEMENT_ARRAY_BUFFER` ❶, which means the elements
    in its buffer will be used to index and access the data in the color and vertex
    buffers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，你需要创建并绑定一个顶点数组对象（VAO），然后定义它所管理的缓冲区。这里的一个不同之处是，`indices` 数组被指定为 `GL_ELEMENT_ARRAY_BUFFER`
    ❶，这意味着它缓冲区中的元素将用于索引并访问颜色和顶点缓冲区中的数据。
- en: Creating the Frame Buffer Object
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建帧缓冲对象
- en: 'Now let’s jump to the `RayCube` class method that creates the frame buffer
    object, where you’ll direct your rendering:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到 `RayCube` 类的方法，该方法创建帧缓冲对象，并将渲染目标指向该对象：
- en: 'def initFBO(self):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'def initFBO(self):'
- en: '# create frame buffer object'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建帧缓冲对象'
- en: self.fboHandle = glGenFramebuffers(1)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: self.fboHandle = glGenFramebuffers(1)
- en: '# create texture'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建纹理'
- en: self.texHandle = glGenTextures(1)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: self.texHandle = glGenTextures(1)
- en: '# create depth buffer'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建深度缓冲区'
- en: self.depthHandle = glGenRenderbuffers(1)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: self.depthHandle = glGenRenderbuffers(1)
- en: '# bind'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定'
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, self.texHandle)
- en: '# set parameters to draw the image at different sizes'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数以在不同大小下绘制图像'
- en: ❶ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
- en: '# set up texture'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置纹理'
- en: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
- en: '# bind texture to FBO'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定纹理到 FBO'
- en: ❷ glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
- en: GL_TEXTURE_2D, self.texHandle, 0)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: GL_TEXTURE_2D, self.texHandle, 0)
- en: '# bind'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定'
- en: ❸ glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
- en: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
- en: self.width, self.height)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height)
- en: '# bind depth buffer to FBO'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定深度缓冲区到 FBO'
- en: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
- en: GL_RENDERBUFFER, self.depthHandle)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: GL_RENDERBUFFER, self.depthHandle)
- en: '# check status'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查状态'
- en: ❹ status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 状态 = glCheckFramebufferStatus(GL_FRAMEBUFFER)
- en: 'if status == GL_FRAMEBUFFER_COMPLETE:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '如果状态 == GL_FRAMEBUFFER_COMPLETE:'
- en: pass
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '# print "fbo %d complete" % self.fboHandle'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '# print "fbo %d 完成" % self.fboHandle'
- en: 'elif status == GL_FRAMEBUFFER_UNSUPPORTED:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif 状态 == GL_FRAMEBUFFER_UNSUPPORTED:'
- en: print "fbo %d unsupported" % self.fboHandle
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: print "fbo %d 不支持" % self.fboHandle
- en: 'else:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print "fbo %d Error" % self.fboHandle
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: print "fbo %d 错误" % self.fboHandle
- en: Here you create a frame buffer object, a 2D texture, and a render buffer object;
    then you set up the texture parameters ❶. The texture is bound to the frame buffer
    ❷, and at ❸ and in the lines that follow, the render buffer sets up a 24-bit depth
    buffer and is attached to the frame buffer. Next, you check the status of the
    frame buffers ❹ and print a status message if something goes wrong. Now, as long
    as the frame buffer and render buffer are bound correctly, all of your rendering
    will go into the texture.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个帧缓冲对象、一个2D纹理和一个渲染缓冲对象；然后设置纹理参数 ❶。纹理被绑定到帧缓冲 ❷，在 ❸ 以及接下来的几行中，渲染缓冲区设置了一个24位深度缓冲，并将其附加到帧缓冲。接下来，你检查帧缓冲区的状态
    ❹，如果出现问题，会打印状态信息。只要帧缓冲区和渲染缓冲区正确绑定，所有渲染操作都会写入到纹理中。
- en: Rendering the Back-Faces of the Cube
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染立方体的背面
- en: 'Here is the code for rendering the back-faces of the color cube:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是渲染颜色立方体背面的代码：
- en: 'def renderBackFace(self, pMatrix, mvMatrix):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderBackFace(self, pMatrix, mvMatrix):'
- en: '"""renders back-face of ray-cube to a texture and returns it"""'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将射线立方体的背面渲染到纹理并返回它"""'
- en: '# render to FBO'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染到 FBO'
- en: ❶ glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
- en: '# set active texture'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置激活的纹理'
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: '# bind to FBO texture'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定到 FBO 纹理'
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, self.texHandle)
- en: '# render cube with face culling enabled'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染带有面剔除启用的立方体'
- en: ❷ self.renderCube(pMatrix, mvMatrix, self.program, True)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.renderCube(pMatrix, mvMatrix, self.program, True)
- en: '# unbind texture'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解除绑定纹理'
- en: ❸ glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ glBindTexture(GL_TEXTURE_2D, 0)
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '# return texture ID'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: ❹ return self.texHandle
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: First you bind the FBO ❶, set the active texture unit, and bind to the texture
    handle so that you can render to the FBO. Then you call the `RayCube` class’s
    `renderCube()` method ❷, which we’ll look at soon. It has a face-culling flag
    as an argument, allowing you to draw either the front-face or the back-face of
    the cube using the same code. You set the flag to `True` to make the back-faces
    appear in the FBO texture.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Next, you make the necessary calls to unbind from the FBO so that other rendering
    code is unaffected ❸. Finally, you return the FBO texture ID ❹ for use in the
    next stage of the algorithm.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Front-Faces of the Cube
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code is used to draw the front-faces of the color cube during
    the second rendering pass of the ray casting algorithm:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '"""render front-face of ray-cube"""'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '# no face culling'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: self.renderCube(pMatrix, mvMatrix, program, False)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: This method simply calls `renderCube()`, with the face-culling flag set to `False`
    so the front-faces will appear.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Whole Cube
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at the `renderCube()` method, which draws the color cube discussed
    previously:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '"""renderCube uses face culling if flag set"""'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '# set shader program'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(program)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '# set projection matrix'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 1, GL_FALSE, pMatrix)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 1, GL_FALSE, mvMatrix)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '# enable face culling'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: glDisable(GL_CULL_FACE)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if cullFace:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: glFrontFace(GL_CCW)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: glCullFace(GL_FRONT)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_CULL_FACE)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '# animated slice'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: ❷ glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '# reset cull face'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'if cullFace:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '# disable face culling'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: glDisable(GL_CULL_FACE)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: You clear the color and depth buffers, select the shader program, and set the
    transformation matrices. Then you set a flag to control face culling ❶, which
    determines whether the cube’s front-face or back-face is drawn. Notice that you
    use `glDrawElements()` ❷ because you’re using an index array to render the cube,
    rather than a vertex array.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Resizing the Window
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because the FBO is created for a particular window size, you need to re-create
    it when the window size changes. To do that, you create a resize handler for the
    `RayCube` class, as shown here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'def reshape(self, width, height):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '# re-create FBO'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: self.clearFBO()
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: self.initFBO()
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The `reshape()` method is called when the OpenGL window is resized. It checks
    the new window dimensions and then clears and re-creates the FBO.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing the Ray Casting Algorithm](nsp-venkitachalam503045-0008.xhtml#rbh1306)'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you’ll implement the ray casting algorithm in the `RayCastRender` class.
    The core of the algorithm happens inside the fragment shader used by this class,
    which also uses the `RayCube` class to help generate the rays. To see the complete
    *raycast.py* code, skip ahead to [“The Complete Volume Ray Casting Code”](nsp-venkitachalam503045-0025.xhtml#ah1309)
    on [page 248](nsp-venkitachalam503045-0025.xhtml#p248). You can also find this
    file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin in the `RayCastRender` constructor by creating a `RayCube` object and
    loading the shaders:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'class RayCastRender:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, width, height, volume):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '"""RayCastRender construction"""'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '# create RayCube object'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.raycube = raycube.RayCube(width, height)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '# set dimensions'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '# texture'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.texVolume, self.Nx, self.Ny, self.Nz = volume
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize camera'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.camera = Camera()
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The constructor creates an object of type `RayCube` ❶, which is used to generate
    rays. You load the shaders used by the ray casting ❷ and then set the OpenGL 3D
    texture and dimensions ❸, which were passed into the constructor as the tuple
    `volume`. Next, you create a `Camera` object ❹, which you’ll use to set up the
    OpenGL perspective transformation for the 3D rendering.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: NOTE The `Camera` class, also declared in *raycast.py*, is basically the same
    as the one used in [Chapter 10](nsp-venkitachalam503045-0024.xhtml#ch10). You’ll
    see it in the complete code listing on [page 248](nsp-venkitachalam503045-0025.xhtml#p248).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rendering method for `RayCastRender`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: ❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '# modelview matrix'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: ❷ mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: self.camera.up)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '# generate ray-cube back-face texture'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: ❸ texture = self.raycube.renderBackFace(pMatrix, mvMatrix)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '# set shader program'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: ❹ glUseProgram(self.program)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '# set window dimensions'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: float(self.width), float(self.height))
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '# bind to texture unit 0, which represents back-faces of cube'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: ❺ glActiveTexture(GL_TEXTURE0)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, texture)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '# texture unit 1: 3D volume texture'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: ❻ glActiveTexture(GL_TEXTURE1)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_3D, self.texVolume)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '# draw front-face of cubes'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: ❼ self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: First you set up a perspective projection matrix for the rendering, using the
    `glutils.perspective()` utility method ❶. Then you set the current camera parameters
    into the `glutils.lookAt()` method ❷. Next, the first pass of the rendering is
    done ❸, using the `renderBackFace()` method in `RayCube` to draw the back-faces
    of the color cube into a texture. (This method also returns the ID of the generated
    texture.)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: You continue by enabling the shaders for the ray casting algorithm ❹. Then you
    set up the textures for use in the shader program. The texture returned at ❸ is
    set up as texture unit 0 ❺, and the 3D texture created from the volumetric data
    you read in is set up as texture unit 1 ❻. Finally, you render the front-faces
    of the cube using the `renderFrontFace()` method in `RayCube` ❼. When this code
    is executed, the shaders for `RayCastRender` will act on the vertices and fragments.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The Vertex Shader
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now you come to the shaders used by `RayCastRender`. Let’s look at the vertex
    shader first:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ❶ layout(location = 1) in vec3 cubePos;
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: ❷ uniform mat4 uMVMatrix;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: ❸ out vec4 vColor;
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: // set position
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: ❹ gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: // set color
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: ❺ vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: First you set the input variables of position and color ❶. The layout uses the
    same indices as defined in the `RayCube` vertex shader because `RayCastRender`
    uses the VBO defined in that class to draw the geometry, and the locations in
    the shaders have to match. Then you define the input transformation matrices ❷
    and set a color value as the shader output ❸. The usual transformation computes
    the built-in `gl_Position` output ❹, before you set the output as the current
    color of the cube vertex ❺. The latter will be interpolated across vertices to
    give you the correct color in the fragment shader.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment Shader
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fragment shader is the star of the show. It implements the core of the ray
    casting algorithm.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec4 vColor;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: uniform sampler2D texBackFaces;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: uniform sampler3D texVolume;
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: uniform vec2 uWinDims;
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: // start of ray
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: ❶ vec3 start = vColor.rgb;
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: // calculate texture coordinates at fragment,
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: // which is a fraction of window coordinates
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: ❷ vec2 texc = gl_FragCoord.xy/uWinDims.xy;
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: // get end of ray by looking up back-face color
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: ❸ vec3 end = texture(texBackFaces, texc).rgb;
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: // calculate ray direction
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: ❹ vec3 dir = end – start;
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: // normalized ray direction
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: vec3 norm_dir = normalize(dir);
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: // the length from front to back is calculated and
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: // used to terminate the ray
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: float len = length(dir.xyz);
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: // ray step size
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: float stepSize = 0.01;
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: // X-ray projection
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: vec4 dst = vec4(0.0);
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: // step through the ray
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: ❺ for(float t = 0.0; t < len; t += stepSize) {
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: // set position to endpoint of ray
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: ❻ vec3 samplePos = start + t*norm_dir;
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: // get texture value at position
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: ❼ float val = texture(texVolume, samplePos).r;
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: vec4 src = vec4(val);
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: // set opacity
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: ❽ src.a *= 0.1;
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: src.rgb *= src.a;
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: // blend with previous value
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: ❾ dst = (1.0 - dst.a)*src + dst;
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: // exit loop when alpha exceeds threshold
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: ❿ if(dst.a >= 0.95)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: break;
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: // set fragment color
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = dst;
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The input to the fragment shader is the cube vertex color. The fragment shader
    also has access to the 2D texture generated by rendering the color cube, the 3D
    texture containing the volumetric data, and the dimensions of the OpenGL window.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: While the fragment shader executes, you send in the front-faces of the cube,
    so by looking up the incoming color value ❶, you get the starting point of the
    ray that goes into this cube. (Recall the discussion in [“Ray Generation”](nsp-venkitachalam503045-0025.xhtml#bh1302)
    on [page 217](nsp-venkitachalam503045-0025.xhtml#p217) about the connection between
    the colors in the cube and the ray directions.)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: You calculate the texture coordinate of the incoming fragment on the screen
    ❷. Here, dividing the location of the fragment in window coordinates by the window
    dimensions maps the location to the range [0, 1]. The ending point of the ray
    is obtained by looking up the back-face color of the cube using this texture coordinate
    ❸.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: You next calculate the ray direction ❹ and then calculate the normalized direction
    and length of this ray, which will be useful in the ray casting computation. Then
    you loop through the volume using the ray’s starting point and direction until
    it hits the ray’s endpoint ❺. In this loop, you compute the ray’s current position
    inside the data volume ❻ and look up the data value at this point ❼. You then
    perform the blending equation at ❽ and ❾, which gives you the X-ray effect. You
    combine the `dst` value with the current value of the intensity (which is attenuated
    using the alpha value), and the process continues along the ray. The alpha value
    keeps increasing until it equals the maximum threshold of 0.95 ❿, at which point
    you exit the loop. The end result is a sort of average opacity through the volume
    at each pixel, which produces a “see-through” or X-ray effect. (Try varying the
    threshold and alpha attenuation to produce different effects.)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[Showing 2D Slices](nsp-venkitachalam503045-0008.xhtml#rbh1307)'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to showing the 3D view of the volumetric data, you want to show
    2D slices of the data in the x-, y-, and z-directions onscreen. The code for this
    is encapsulated in a class called `SliceRender`, which creates 2D volumetric slices.
    To see the complete *slicerender.py* code, skip ahead to [“The Complete 2D Slicing
    Code”](nsp-venkitachalam503045-0025.xhtml#ah1310) on [page 251](nsp-venkitachalam503045-0025.xhtml#p251).
    You can also find the *slicerender.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the initialization code in the `SliceRender` class constructor that
    sets up the geometry for the slices:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'class SliceRender:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, width, height, volume):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: --`snip`--
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: self.vao = glGenVertexArrays(1)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '# define quad vertices'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: ❶ vertexData = numpy.array([0.0, 1.0, 0.0,
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 0.0,
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 0.0,
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 0.0], numpy.float32)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex buffer'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '# enable arrays'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(self.vertIndex)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffers'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: This code sets up a VAO to manage the VBO, as in earlier examples. You define
    the geometry of a square in the XY plane ❶. (The vertex order is that of the `GL_TRIANGLE_STRIP`,
    introduced in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).) You’ll use
    this same geometry regardless of whether you’re showing slices perpendicular to
    *x*, *y*, or *z*. All that changes between these cases is the data plane that
    you pick to display from within the 3D texture. We’ll return to this idea when
    we look at the vertex shader.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a method to render the 2D slices:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '# clear buffers'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: ❶ pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '# modelview matrix'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: ❷ mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 0.0, 0.0,
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 1.0, 0.0,
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: -0.5, -0.5, -1.0, 1.0], numpy.float32)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '# use shader'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '# set projection matrix'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '# set current slice fraction'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: ❸ glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: float(self.currSliceIndex)/float(self.currSliceMax))
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '# set current slice mode'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: ❹ glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: self.mode)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '# enable texture'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_3D, self.texture)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '# draw'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Each 2D slice is a square, which you build up using an OpenGL triangle strip
    primitive. This code goes through the render setup for the triangle strip. Note
    that you implement the orthographic projection using the `glutils.ortho()` method
    at ❶. You set up a projection that adds a 0.1 buffer around the unit square representing
    the slice.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: When you draw something with OpenGL, the default view (without any transformation
    applied) puts the eye at (0, 0, 0) looking down the z-axis with the y-axis pointing
    up. Applying the translation (−0.5, −0.5, −1.0) to your geometry centers it on
    the z-axis ❷. You set the current slice fraction ❸ (where, for example, the 10th
    slice out of 100 would be 0.1), set the slice mode ❹ (to view the slices in the
    x-, y-, or z-direction, as represented by the integers 0, 1, and 2, respectively),
    and set both values to the shaders.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: The Vertex Shader
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at the vertex shader for `SliceRender`:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec3 aVert;
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: uniform float uSliceFrac;
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: uniform int uSliceMode;
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: out vec3 texcoord;
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: // x slice
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: if (uSliceMode == 0) {
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: ❶ texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: // y slice
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: else if (uSliceMode == 1) {
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: ❷ texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: // z slice
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: ❸ texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: // calculate transformed vertex
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader takes the triangle strip vertex array as input and sets a
    texture coordinate as output. The current slice fraction and slice mode are passed
    in as uniform variables `uSliceFrac` and `uSliceMode`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The shader has three branches, depending on the slice mode. For example, if
    `uSliceMode` is `0`, you calculate the texture coordinates for an *x* slice ❶.
    Because you’re slicing perpendicular to the x-direction, you want a slice parallel
    to the YZ plane. The 3D vertices coming in to the vertex shader also double as
    the 3D texture coordinates because they are in the range [0, 1], so the texture
    coordinates are given as (*f*, *V*[x], *V*[y]), where *f* is the fraction of the
    slice number in the direction of the x-axis and where *V*[x] and *V*[y] are the
    vertex coordinates. Unfortunately, the resulting image will appear upside down
    because the OpenGL coordinate system has its origin at the bottom left, with the
    y-direction pointing up; this is the reverse of what you want. To resolve this
    problem, you change the texture coordinate *t* to (1 − *t*) and use (*f*, *V*[x],
    1 − *V*[y]) ❶. You use similar logic to compute the texture coordinates for y-
    ❷ and z- ❸ direction slices if the `uSliceMode` value is `1` or `2`, respectively.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment Shader
  id: totrans-515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is the fragment shader:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ❶ in vec3 texcoord;
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: ❷ uniform sampler3D texture;
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: // look up color in texture
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: ❸ vec4 col = texture(tex, texcoord);
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: ❹ fragColor = col.rrra;
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: The fragment shader declares `texcoord` as input ❶, which was set as output
    in the vertex shader. The texture sampler is declared as `uniform` ❷. You look
    up the texture color using `texcoord` ❸ and set `fragColor` as the output ❹. (Because
    you read in your texture only as the red channel, you use `col.rrra`.)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: A User Interface for 2D Slicing
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now you need a way for the user to slice through the data. Do this using a
    keyboard handling method on the `SliceRender` class:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'def keyPressed(self, key):'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '"""keypress handler"""'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if key == ''x'':'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.XSLICE
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nx/2)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nx
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''y'':'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.YSLICE
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Ny/2)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Ny
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''z'':'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.ZSLICE
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nz/2)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nz
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''l'':'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''r'':'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: When the X, Y, or Z key on the keyboard is pressed, `SliceRender` switches to
    the *x*, *y*, or *z* slice mode. You can see this in action for the *x* slice,
    for example ❶, where you set the appropriate mode, set the current slice index
    to the middle of the data, and update the maximum slice number.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: When the left or right arrow key on the keyboard is pressed, you page through
    the slices. For instance, the slice index is incremented ❷ when the left arrow
    key is pressed. The modulo operator (`%`) ensures that the index “rolls over”
    to 0 when you exceed the maximum value.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[Putting the Code Together](nsp-venkitachalam503045-0008.xhtml#rbh1308)'
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a quick look at the main file in the project, *volrender.py*. This
    file uses a class `RenderWin`, which creates and manages the GLFW OpenGL window.
    (I won’t cover this class in detail because it’s similar to the class used in
    [Chapters 9](nsp-venkitachalam503045-0023.xhtml#ch09) and [10](nsp-venkitachalam503045-0024.xhtml#ch10).)
    To see the complete *volrender.py* code, skip ahead to [“The Complete Main File
    Code”](nsp-venkitachalam503045-0025.xhtml#ah1311) on [page 254](nsp-venkitachalam503045-0025.xhtml#p254).
    You can also find the *volrender.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initialization code for this class, you create the renderer as follows:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'class RenderWin:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, imageDir):'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: --`snip`--
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '# load volume data'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.volume = volreader.loadVolume(imageDir)
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '# create renderer'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.renderer = RayCastRender(self.width, self.height, self.volume)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Here you read the 3D data into an OpenGL texture using the `loadVolume()` function
    we discussed earlier ❶. Then you create an object of type `RayCastRender` to display
    the data ❷.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: The Keypress Handler
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `RenderWindow` class needs its own keyboard handler method for toggling
    between volume and slice rendering and for closing the window. This method also
    passes along keypresses to the `RayCastRender` and `SliceRender` classes’ keyboard
    handlers, to either rotate the camera or navigate through the 2D slices.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '# ESC to quit'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'if key is glfw.GLFW_KEY_ESCAPE:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.close()
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = True
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == glfw.GLFW_KEY_V:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '# toggle render mode'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if isinstance(self.renderer, RayCastRender):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = SliceRender(self.width, self.height,
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: self.volume)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = RayCastRender(self.width, self.height,
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: self.volume)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '# call reshape on renderer'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.reshape(self.width, self.height)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '# send keypress to renderer'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '❸ keyDict = {glfw.GLFW_KEY_X: ''x'', glfw.GLFW_KEY_Y: ''y'','
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'glfw.GLFW_KEY_Z: ''z'', glfw.GLFW_KEY_LEFT: ''l'','
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'glfw.GLFW_KEY_RIGHT: ''r''}'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.keyPressed(keyDict[key])
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Pressing ESC quits the program. You set other keypresses to work whether you
    have just pressed the key down or you are keeping it pressed ❶. If the V key is
    pressed, you toggle the renderer between volume and slice ❷, using Python’s `isinstance()`
    method to identify the current class type. To handle any other keypress events
    (X, Y, Z, or the left and right arrows), you use a dictionary ❸ and pass the keypress
    to the current renderer’s `keyPressed()` handler method. We looked at the slice
    renderer’s `keyPressed()` method in [“A User Interface for 2D Slicing”](nsp-venkitachalam503045-0025.xhtml#ch1313)
    on [page 237](nsp-venkitachalam503045-0025.xhtml#p237), for example.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: NOTE I’m choosing not to pass in the `glfw.KEY` values directly and using a
    dictionary to convert these to character values instead, because it’s a good practice
    to reduce dependencies in source files. Currently, the only file in this project
    that depends on GLFW is *volrender.py*. If you were to pass GLFW-specific types
    into other code, they would need to import and depend on the GLFW library too.
    Then, if you were to switch to a different OpenGL windowing toolkit, the code
    would become messy.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the Program](nsp-venkitachalam503045-0008.xhtml#rah1304)'
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample run of the application using data from the Stanford Volume
    Data Archive:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: $ `python volrender.py --dir mrbrain-8bit/`
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: You should see something like [Figure 11-6](nsp-venkitachalam503045-0025.xhtml#fig11-6).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f11006.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: A sample run of *volrender.py*. The image on the left is the volumetric
    rendering, and the image on the right is a 2D slice.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: As the application runs, use the V key to toggle between volume and slice rendering.
    In slice mode, use the X, Y, and Z keys to change the slicing axis, and use the
    arrow keys to change the slicing location.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1305)'
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you implemented the volume ray casting algorithm using Python
    and OpenGL. You learned how to use GLSL shaders to implement this algorithm efficiently,
    as well as how to create 2D slices from the volumetric data.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1306)'
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few ways you could keep tinkering with the volume ray casting program:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Currently, it’s hard to see the boundary of the volumetric data “cube” in
    the ray casting mode. Implement a class `WireFrame` that draws a box around this
    cube. Color the x-, y-, and z-axes red, green, and blue, respectively, and give
    each its own shaders. You’ll use `WireFrame` from within the `RayCastRender` class.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Implement data scaling. In the current implementation, you’re drawing a
    cube for the volume and a square for 2D slices, which assumes you have a symmetric
    data set (that the number of slices are the same in each direction), but most
    real data has a varying number of slices. Medical data, in particular, often has
    fewer slices in the z-direction, with dimensions such as 256×256×99, for example.
    To display this data correctly, you have to introduce a scale into your computations.
    One way to do so is to apply the scale to the cube vertices (3D volume) and square
    vertices (2D slice). The user can then input the scaling parameters as command
    line arguments.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3\. Our volume ray casting implementation uses X-ray casting to calculate the
    final color or intensity of a pixel. Another popular way to do this is to use
    *maximum intensity projection (MIP)* to set the maximum intensity at each pixel.
    Implement this in your code. (Hint: in the fragment shader of `RayCastRender`,
    modify the code that steps through the ray to check and set the maximum value
    along the ray, instead of blending values.)'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4\. Currently, the only UI you have implemented is rotation around the x-,
    y-, and z-axes. Implement a zoom feature so pressing I/O will zoom in/out of the
    volume-rendered image. You could do this by setting the appropriate camera parameters
    in the `glutils.lookAt()` method, with one caveat: if you move your view inside
    the data cube, the ray casting will fail because OpenGL will clip the front-faces
    of the cube; the ray computation needed for ray casting requires both the front-
    and back-faces of the color cube to be rendered correctly. Instead, zoom by adjusting
    the field of view in the `glutils.projecton()` method.'
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete 3D Texture Code](nsp-venkitachalam503045-0008.xhtml#rah1307)'
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the full *volreader.py* code listing.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: import os
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: from PIL import Image
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: from scipy import misc
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'def loadVolume(dirName):'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '"""read volume from directory as a 3D texture"""'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '# list images in directory'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: files = sorted(os.listdir(dirName))
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''loading images from: %s'' % dirName)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: imgDataList = []
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: width, height = 0, 0
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'for file in files:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: file_path = os.path.abspath(os.path.join(dirName, file))
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '# read image'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: img = Image.open(file_path)
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: imgData = np.array(img.getdata(), np.uint8)
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '# check if all are of the same size'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 'if count is 0:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: width, height = img.size[0], img.size[1]
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: imgDataList.append(imgData)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'if (width, height) == (img.size[0], img.size[1]):'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: imgDataList.append(imgData)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: print('mismatch')
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: raise RunTimeError("image size mismatch")
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '# print img.size'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '# skip'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Invalid image: %s'' % file_path)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '# load image data into single array'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: depth = count
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: data = np.concatenate(imgDataList)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''volume data dims: %d %d %d'' % (width, height, depth))'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '# load data into 3D texture'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: texture = glGenTextures(1)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_3D, texture)
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: width, height, depth, 0,
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: GL_RED, GL_UNSIGNED_BYTE, data)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '# return texture'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: return (texture, width, height, depth)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: load texture
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def loadTexture(filename):'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: img = Image.open(filename)
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: img_data = np.array(list(img.getdata()), 'B')
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: texture = glGenTextures(1)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: glPixelStorei(GL_UNPACK_ALIGNMENT,1)
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, texture)
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, img_data)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: return texture
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Ray Generation Code](nsp-venkitachalam503045-0008.xhtml#rah1308)'
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the full code listing for the `RayCube` class.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL.shaders import *
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: import numpy, math, sys
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: import volreader, glutils
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layout(location = 1) in vec3 cubePos;
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 vColor;
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: // set back-face color
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: // transformed position
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: vec4 newPos = vec4(cubePos.xyz, 1.0);
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: // set position
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * newPos;
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec4 vColor;
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = vColor;
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'class RayCube:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '"""class used to generate rays used in ray casting"""'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, width, height):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '"""RayCube constructor"""'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '# set dims'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = width, height
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '# cube vertices'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: vertices = numpy.array([
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 0.0,
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 0.0,
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 0.0,
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 0.0,
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 1.0,
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 1.0,
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 1.0,
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 1.0
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '], numpy.float32)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '# cube colors'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: colors = numpy.array([
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 0.0,
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 0.0,
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 0.0,
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 0.0,
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 1.0,
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 1.0,
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 1.0,
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 1.0
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '], numpy.float32)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '# individual triangles'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: indices = numpy.array([
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 4, 5, 7,
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: 7, 5, 6,
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 5, 1, 6,
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 6, 1, 2,
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 1, 0, 2,
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: 2, 0, 3,
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 0, 4, 3,
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 3, 4, 7,
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: 6, 2, 7,
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 7, 2, 3,
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: 4, 0, 5,
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: 5, 0, 1
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '], numpy.int16)'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: self.nIndices = indices.size
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: self.vao = glGenVertexArrays(1)
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex buffer'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex buffer - cube vertex colors'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: self.colorBuffer = glGenBuffers(1)
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW);
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '# index buffer'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: self.indexBuffer = glGenBuffers(1)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer);
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '# enable attrs using the layout indices in shader'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: aPosLoc = 1
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: aColorLoc = 2
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '# bind buffers'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(1)
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(2)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(aPosLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '# color'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(aColorLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '# index'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer)
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '# FBO'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: self.initFBO()
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: 'def renderBackFace(self, pMatrix, mvMatrix):'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '"""renders back-face of ray-cube to a texture and returns it"""'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '# render to FBO'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: '# set active texture'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '# bind to FBO texture'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '# render cube with face culling enabled'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: self.renderCube(pMatrix, mvMatrix, self.program, True)
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind texture'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '# return texture ID'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: return self.texHandle
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '"""render front-face of ray-cube"""'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '# no face culling'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: self.renderCube(pMatrix, mvMatrix, program, False)
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '"""render cube using face culling if flag set"""'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '# set shader program'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(program)
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '# set projection matrix'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: 1, GL_FALSE, pMatrix)
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: 1, GL_FALSE, mvMatrix)
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '# enable face culling'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: glDisable(GL_CULL_FACE)
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: 'if cullFace:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: glFrontFace(GL_CCW)
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: glCullFace(GL_FRONT)
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_CULL_FACE)
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '# animated slice'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '# reset cull face'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: 'if cullFace:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '# disable face culling'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: glDisable(GL_CULL_FACE)
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: 'def reshape(self, width, height):'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '# re-create FBO'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: self.clearFBO()
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: self.initFBO()
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: 'def initFBO(self):'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '# create frame buffer object'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: self.fboHandle = glGenFramebuffers(1)
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '# create texture'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: self.texHandle = glGenTextures(1)
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '# create depth buffer'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: self.depthHandle = glGenRenderbuffers(1)
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '# bind'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '# set parameters to draw the image at different sizes'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '# set up texture'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '# bind texture to FBO'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: GL_TEXTURE_2D, self.texHandle, 0)
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '# bind'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height)
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '# bind depth buffer to FBO'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: GL_RENDERBUFFER, self.depthHandle)
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '# check status'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: 'if status == GL_FRAMEBUFFER_COMPLETE:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '# print "fbo %d complete" % self.fboHandle'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'elif status == GL_FRAMEBUFFER_UNSUPPORTED:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: print("fbo %d unsupported" % self.fboHandle)
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: print("fbo %d Error" % self.fboHandle)
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'def clearFBO(self):'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '"""clears old FBO"""'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '# delete FBO'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsFramebuffer(self.fboHandle):'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteFramebuffers(1, int(self.fboHandle))
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '# delete texture'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsTexture(self.texHandle):'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteTextures(int(self.texHandle))
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'def close(self):'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '"""call this to free up OpenGL resources"""'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '# delete FBO'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsFramebuffer(self.fboHandle):'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteFramebuffers(1, int(self.fboHandle))
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '# delete texture'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsTexture(self.texHandle):'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteTextures(int(self.texHandle))
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '# delete render buffer'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsRenderbuffer(self.depthHandle):'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteRenderbuffers(1, int(self.depthHandle))
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: '# delete buffers'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteBuffers(1, self._vertexBuffer)
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteBuffers(1, &_indexBuffer)
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteBuffers(1, &_colorBuffer)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Volume Ray Casting Code](nsp-venkitachalam503045-0008.xhtml#rah1309)'
  id: totrans-919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the full *raycast.py* code listing.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL.shaders import *
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: import math, sys
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: import raycube, glutils, volreader
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layout(location = 1) in vec3 cubePos;
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 vColor;
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: // set position
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: // set color
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-943
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec4 vColor;
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: uniform sampler2D texBackFaces;
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: uniform sampler3D texVolume;
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: uniform vec2 uWinDims;
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: void main()
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: // start of ray
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: vec3 start = vColor.rgb;
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: // calculate texture coords at fragment,
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: // which is a fraction of window coords
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: vec2 texc = gl_FragCoord.xy/uWinDims.xy;
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: // get end of ray by looking up back-face color
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: vec3 end = texture(texBackFaces, texc).rgb;
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: // calculate ray direction
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: vec3 dir = end - start;
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: // normalized ray direction
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: vec3 norm_dir = normalize(dir);
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: // the length from front to back is calculated and
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: // used to terminate the ray
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: float len = length(dir.xyz);
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: // ray step size
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: float stepSize = 0.01;
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: // X-ray projection
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: vec4 dst = vec4(0.0);
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: // step through the ray
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: for(float t = 0.0; t < len; t += stepSize) {
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: // set position to endpoint of ray
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: vec3 samplePos = start + t*norm_dir;
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: // get texture value at position
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: float val = texture(texVolume, samplePos).r;
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: vec4 src = vec4(val);
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: // set opacity
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: src.a *= 0.1;
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: src.rgb *= src.a;
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: // blend with previous value
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: dst = (1.0 - dst.a)*src + dst;
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: // exit loop when alpha exceeds threshold
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: if(dst.a >= 0.95)
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: break;
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: // set fragment color
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: fragColor =  dst;
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: 'class Camera:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '"""helper class for viewing"""'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: self.r = 1.5
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: self.theta = 0
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: self.center = [0.5, 0.5, 0.5]
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: self.eye = [0.5 + self.r, 0.5, 0.5]
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: self.up = [0.0, 0.0, 1.0]
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: 'def rotate(self, clockWise):'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: '"""rotate eye by one step"""'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 'if clockWise:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: self.theta = (self.theta + 5) % 360
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: self.theta = (self.theta - 5) % 360
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '# recalculate eye'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: self.eye = [0.5 + self.r*math.cos(math.radians(self.theta)),
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: 0.5 + self.r*math.sin(math.radians(self.theta)),
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: 0.5]
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: 'class RayCastRender:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: '"""class that does Ray Casting"""'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, width, height, volume):'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: '"""RayCastRender constr"""'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '# create RayCube object'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: self.raycube = raycube.RayCube(width, height)
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '# set dimensions'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '# texture'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: self.texVolume, self.Nx, self.Ny, self.Nz = volume
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize camera'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: self.camera = Camera()
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '# modelview matrix'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: self.camera.up)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '# generate ray-cube back-face texture'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: texture = self.raycube.renderBackFace(pMatrix, mvMatrix)
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '# set shader program'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '# set window dimensions'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: float(self.width), float(self.height))
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '# texture unit 0, which represents back-faces of cube'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, texture)
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '# texture unit 1: 3D volume texture'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE1)
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_3D, self.texVolume)
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '# draw front-face of cubes'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '#self.render(pMatrix, mvMatrix)'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 'def keyPressed(self, key):'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == ''l'':'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: self.camera.rotate(True)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''r'':'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: self.camera.rotate(False)
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 'def reshape(self, width, height):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: self.raycube.reshape(width, height)
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: 'def close(self):'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: self.raycube.close()
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete 2D Slicing Code](nsp-venkitachalam503045-0008.xhtml#rah1310)'
  id: totrans-1060
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the full 2D slicing code listing.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL.shaders import *
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: import numpy, math, sys
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: import volreader, glutils
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-1068
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec3 aVert;
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: uniform float uSliceFrac;
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: uniform int uSliceMode;
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: out vec3 texcoord;
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: // x slice
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: if (uSliceMode == 0) {
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: // y slice
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: else if (uSliceMode == 1) {
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: // z slice
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: // calculate transformed vertex
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-1093
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec3 texcoord;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: uniform sampler3D tex;
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: // look up color in texture
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: vec4 col = texture(tex, texcoord);
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = col.rrra;
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: 'class SliceRender:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '# slice modes'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: XSLICE, YSLICE, ZSLICE = 0, 1, 2
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, width, height, volume):'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '"""SliceRender constructor"""'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: '# slice mode'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.ZSLICE
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: self.mvMatrixUniform = glGetUniformLocation(self.program, b"uMVMatrix")
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '# attributes'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: self.vertIndex = glGetAttribLocation(self.program, b"aVert")
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: self.vao = glGenVertexArrays(1)
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: '# define quad vertices'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: vertexData = numpy.array([0.0, 1.0, 0.0,
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 0.0,
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 0.0,
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 0.0], numpy.float32)
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex buffer'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '# enable arrays'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(self.vertIndex)
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffers'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '# load texture'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: self.texture, self.Nx, self.Ny, self.Nz = volume
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '# current slice index'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nz/2);
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nz;
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: 'def reshape(self, width, height):'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '# clear buffers'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '# modelview matrix'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 0.0, 0.0,
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 1.0, 0.0,
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: -0.5, -0.5, -1.0, 1.0], numpy.float32)
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '# use shader'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '# set projection matrix'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: '# set current slice fraction'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: float(self.currSliceIndex)/float(self.currSliceMax))
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '# set current slice mode'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: self.mode)
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '# enable texture'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_3D, self.texture)
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '# draw'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: 'def keyPressed(self, key):'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '"""keypress handler"""'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == ''x'':'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.XSLICE
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nx/2)
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nx
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''y'':'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.YSLICE
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Ny/2)
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Ny
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''z'':'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.ZSLICE
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nz/2)
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nz
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''l'':'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''r'':'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: 'def close(self):'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Main File Code](nsp-venkitachalam503045-0008.xhtml#rah1311)'
  id: totrans-1204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the full code listing for the main file.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: import sys, argparse, os
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: from slicerender import *
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: from raycast import *
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: import glfw
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: 'class RenderWin:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '"""GLFW Rendering window class"""'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, imageDir):'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '# save current working directory'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: cwd = os.getcwd()
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize glfw; this changes cwd'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwInit()
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '# restore cwd'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: os.chdir(cwd)
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '# version hints'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: glfw.GLFW_OPENGL_CORE_PROFILE)
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '# make a window'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = 512, 512
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: self.win = glfw.glfwCreateWindow(self.width, self.height, b"volrender")
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '# make context current'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwMakeContextCurrent(self.win)
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize GL'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_DEPTH_TEST)
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: glClearColor(0.0, 0.0, 0.0, 0.0)
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '# set window callbacks'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetWindowSizeCallback(self.win, self.onSize)
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '# load volume data'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: self.volume =  volreader.loadVolume(imageDir)
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: '# create renderer'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = RayCastRender(self.width, self.height, self.volume)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '# exit flag'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = False
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: 'def onMouseButton(self, win, button, action, mods):'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''mouse button: '', win, button, action, mods'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '# ESC to quit'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: 'if key is glfw.GLFW_KEY_ESCAPE:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.close()
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = True
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: 'if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == glfw.GLFW_KEY_V:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '# toggle render mode'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(self.renderer, RayCastRender):'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = SliceRender(self.width, self.height,
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: self.volume)
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = RayCastRender(self.width, self.height,
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: self.volume)
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '# call reshape on renderer'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.reshape(self.width, self.height)
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '# send keypress to renderer'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: 'keyDict = {glfw.GLFW_KEY_X: ''x'', glfw.GLFW_KEY_Y: ''y'','
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: 'glfw.GLFW_KEY_Z: ''z'', glfw.GLFW_KEY_LEFT: ''l'','
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: 'glfw.GLFW_KEY_RIGHT: ''r''}'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.keyPressed(keyDict[key])
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: 'def onSize(self, win, width, height):'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''onsize: '', win, width, height'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.reshape(width, height)
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: '# start loop'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.draw()
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: '# swap buffers'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSwapBuffers(self.win)
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: '# wait for events'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWaitEvents()
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: '# end'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwTerminate()
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  id: totrans-1293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: print('starting volrender...')
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: '# create parser'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Volume Rendering...")
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: '# add expected arguments'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--dir', dest='imageDir', required=True)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '# parse args'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '# create render window'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: rwin = RenderWin(args.imageDir)
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: rwin.run()
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: call main
  id: totrans-1305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '[1](nsp-venkitachalam503045-0025.xhtml#fn4r) J. Kruger and R. Westermann, “Acceleration
    Techniques for GPU-based Volume Rendering,” IEEE Visualization, 2003.'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: '[2](nsp-venkitachalam503045-0025.xhtml#fn5r) [https://graphics.stanford.edu/data/voldata/](https://graphics.stanford.edu/data/voldata/)'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
