- en: '[11](nsp-venkitachalam503045-0008.xhtml#rch11)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[11](nsp-venkitachalam503045-0008.xhtml#rch11)'
- en: Volume Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷积渲染
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Magnetic resonance imaging (MRI) and computed tomography (CT) scans are diagnostic
    processes that create *volumetric data*, data that consists of a set of 2D images
    showing cross sections through a 3D volume. *Volume rendering* is a computer graphics
    technique used to construct 3D images from this type of volumetric data. Although
    volume rendering is commonly used to analyze medical scans, it can also be used
    to create 3D scientific visualizations in academic disciplines such as geology,
    archaeology, and molecular biology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 磁共振成像（MRI）和计算机断层扫描（CT）是诊断过程，用于生成*体积数据*，这类数据由一组2D图像组成，显示了通过3D体积的横截面。*卷积渲染*是一种计算机图形技术，用于从这种类型的体积数据中构建3D图像。尽管卷积渲染通常用于分析医学扫描数据，但它也可以用于在地质学、考古学和分子生物学等学术领域中创建3D科学可视化。
- en: The data captured by MRI and CT scans typically follows the form of a 3D grid
    of dimensions *N*[x]×*N*[y]×*N*[z]. In other words, there are *N*[z] 2D “slices,”
    where each slice is an image of size *N*[x]×*N*[y]. Volume rendering algorithms
    are used to display the collected slice data with some type of transparency, and
    various techniques are used to accentuate the parts of the rendered volume that
    are of interest.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: MRI和CT扫描捕获的数据通常采用*N*[x]×*N*[y]×*N*[z]维度的3D网格形式。换句话说，有*N*[z]个2D“切片”，每个切片的大小为*N*[x]×*N*[y]。卷积渲染算法用于以某种透明度显示收集到的切片数据，采用各种技术突出渲染体积中感兴趣的部分。
- en: In this project, you’ll look at a volume rendering called *volume ray casting*,
    which takes full advantage of the graphics processing unit (GPU) to perform computations
    using OpenGL Shading Language (GLSL) shaders. Your code executes for every pixel
    onscreen and leverages the GPU, which is designed to do parallel computations
    efficiently. You’ll use a folder of 2D images consisting of slices from a 3D data
    set to construct a volume-rendered image using the volume ray casting algorithm.
    You’ll also implement a method to show 2D slices of the data in the x-, y-, and
    z-directions so users can scroll through the slices using the arrow keys. Keyboard
    commands will let the user toggle between the 3D rendering and the 2D slices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，您将研究一种叫做*体积光线投射*的卷积渲染方法，它充分利用图形处理单元（GPU）通过OpenGL着色语言（GLSL）着色器执行计算。您的代码会对每个屏幕上的像素进行计算，并利用GPU进行高效的并行计算。您将使用一组包含来自3D数据集切片的2D图像的文件夹，通过体积光线投射算法构建卷积渲染图像。您还将实现一种方法，展示数据在x、y和z方向上的2D切片，用户可以使用箭头键浏览这些切片。键盘命令将允许用户在3D渲染和2D切片之间切换。
- en: 'Here are some of the topics covered in this project:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本项目中涵盖的一些主题：
- en: • Using GLSL for GPU computations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用GLSL进行GPU计算
- en: • Creating vertex and fragment shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 创建顶点和片段着色器
- en: • Representing 3D volumetric data and using the volume ray casting algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 表示3D体积数据并使用体积光线投射算法
- en: • Using `numpy` arrays for 3D transformation matrices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`数组进行3D变换矩阵
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1301)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah1301)'
- en: 'There are various ways to render a 3D data set. In this project, you’ll use
    the volume ray casting method, which is an *image*-*based* rendering technique
    used to generate the final image from the 2D slices, pixel by pixel. In contrast,
    typical 3D rendering methods are *object based*: they begin with a 3D object representation
    and then apply transformations to generate the pixels in the projected 2D image.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染3D数据集有多种方式。在本项目中，您将使用体积光线投射方法，这是一种*基于图像*的渲染技术，用于逐像素生成最终图像。与之相比，典型的3D渲染方法是*基于对象*的：它们从3D对象表示开始，然后应用变换生成投影2D图像中的像素。
- en: In the volume ray casting method that you’ll use in this project, for each pixel
    in the output image, a ray is shot into the discrete 3D volumetric data set, which
    is typically represented as a cuboid. As the ray passes through the volume, the
    data is sampled at regular intervals, and the samples are combined, or *composited*,
    to compute the color value or intensity of the final image. (You might think of
    this process as similar to stacking a bunch of transparencies on top of each other
    and holding them up against a bright light to see a blend of all the sheets.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将要使用的体积光线投射方法中，对于输出图像中的每一个像素，都会向离散的3D体积数据集发射一条光线，这些数据集通常表示为一个长方体。当光线穿过体积时，数据会按照规则的间隔进行采样，并将这些采样结果进行组合或*合成*，以计算最终图像的颜色值或强度。（你可以将这个过程理解为像是将一堆透明片堆叠在一起，并将其举到明亮的光源下，以查看所有图层的混合效果。）
- en: While volume ray casting rendering implementations typically use techniques
    such as applying gradients to improve the appearance of the final render, filtering
    to isolate 3D features, and using spatial optimization techniques to improve speed,
    you’ll just implement the basic ray casting algorithm and composite the final
    image by X-ray casting. (My implementation is largely based on the seminal paper
    on this topic by Kruger and Westermann, published in 2003.[1](nsp-venkitachalam503045-0025.xhtml#fn4))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然体积光线投射渲染实现通常会采用诸如应用渐变以改善最终渲染效果、滤波以隔离3D特征、以及使用空间优化技术以提高速度等技巧，但你将仅实现基本的光线投射算法，并通过X射线投射合成最终图像。（我的实现主要基于2003年Kruger和Westermann在该领域的开创性论文。[1](nsp-venkitachalam503045-0025.xhtml#fn4)）
- en: '[The Data Format](nsp-venkitachalam503045-0008.xhtml#rbh1301)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[数据格式](nsp-venkitachalam503045-0008.xhtml#rbh1301)'
- en: For this project, you’ll use medical data from 3D scans from the Stanford Volume
    Data Archive.[2](nsp-venkitachalam503045-0025.xhtml#fn5) This archive offers a
    few excellent 3D medical data sets (both CT and MRI) of TIFF images, one for each
    2D cross section of the volume. You’ll read a folder of these images into an OpenGL
    3D texture; this is sort of like stacking a set of 2D images to form a cuboid,
    as shown in [Figure 11-1](nsp-venkitachalam503045-0025.xhtml#fig11-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用来自斯坦福体积数据档案的3D扫描医学数据。[2](nsp-venkitachalam503045-0025.xhtml#fn5)该档案提供了一些优秀的3D医学数据集（包括CT和MRI）TIFF图像，每一幅图像代表体积的2D切面。你将把这些图像文件夹读入OpenGL
    3D纹理；这有点像是将一组2D图像堆叠起来形成一个长方体，如[图11-1](nsp-venkitachalam503045-0025.xhtml#fig11-1)所示。
- en: '![](images/nsp-venkitachalam503045-f11001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11001.jpg)'
- en: 'Figure 11-1: Building 3D volumetric data from 2D slices'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：从2D切片构建3D体积数据
- en: Recall from [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09) that a 2D texture
    in OpenGL is addressed with a 2D coordinate (*s*, *t*). Similarly, a 3D texture
    is addressed using a 3D texture coordinate of the form (*s*, *t*, *p*). As you’ll
    see, storing the volumetric data as a 3D texture allows you to access the data
    quickly and provides you with interpolated values required by your ray casting
    scheme.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)中提到的，在OpenGL中，2D纹理是通过2D坐标（*s*，*t*）来寻址的。类似地，3D纹理是通过形如（*s*，*t*，*p*）的3D纹理坐标来寻址的。正如你将看到的，将体积数据存储为3D纹理可以让你快速访问数据，并为光线投射方案提供所需的插值值。
- en: '[Ray Generation](nsp-venkitachalam503045-0008.xhtml#rbh1302)'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[光线生成](nsp-venkitachalam503045-0008.xhtml#rbh1302)'
- en: Your goal in this project is to generate a perspective projection of the 3D
    volumetric data, as shown in [Figure 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2).
    The figure shows the OpenGL view frustum, as discussed in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).
    Specifically, it shows how a ray from the eye enters this frustum at the near
    plane, passes through the cubic volume (which contains the volumetric data), and
    exits from the rear at the far plane.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个项目中的目标是生成3D体积数据的透视投影，如[图11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2)所示。该图展示了OpenGL视锥体，如[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)所讨论。具体来说，它展示了一个从眼睛发出的光线如何在近平面进入视锥体，通过包含体积数据的立方体体积，并从远平面后方退出。
- en: '![](images/nsp-venkitachalam503045-f11002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11002.jpg)'
- en: 'Figure 11-2: A perspective projection of 3D volumetric data'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：3D体积数据的透视投影
- en: To implement ray casting, you need to generate rays that go into the volume.
    For each pixel in the output window shown in [Figure 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2),
    you generate a vector *R* that goes into the volume you consider a unit cube (which
    I’ll refer to as the *color cube*) defined between the coordinates (0, 0, 0) and
    (1, 1, 1). You color each point inside this cube with the RGB values equal to
    the 3D coordinates of the cube. The origin is colored (0, 0, 0), or black; the
    (1, 0, 0) corner is red; and the point on the cube diagonally opposite the origin
    is colored (1, 1, 1), or white. [Figure 11-3](nsp-venkitachalam503045-0025.xhtml#fig11-3)
    shows this cube.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现光线投射，你需要生成进入体积的光线。对于输出窗口中的每个像素，如 [图 11-2](nsp-venkitachalam503045-0025.xhtml#fig11-2)
    所示，你需要生成一个进入体积的向量 *R*，你可以认为该体积是一个单位立方体（我称之为 *颜色立方体*），它的坐标范围在 (0, 0, 0) 和 (1, 1,
    1) 之间。你为立方体内的每个点着色，RGB 值等于该点的 3D 坐标。原点的颜色是 (0, 0, 0)，即黑色；(1, 0, 0) 角是红色；与原点对角的立方体上的点的颜色是
    (1, 1, 1)，即白色。[图 11-3](nsp-venkitachalam503045-0025.xhtml#fig11-3) 显示了这个立方体。
- en: '![](images/nsp-venkitachalam503045-f11003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11003.jpg)'
- en: 'Figure 11-3: A color cube'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：一个颜色立方体
- en: NOTE In OpenGL, a color can be represented as a strip of 8-bit unsigned values
    (*r*, *g*, *b*), where *r*, *g*, and *b* are in the range [0, 255]. It can also
    be represented as a triplet of 32-bit floating-point values (*r*, *g*, *b*), where
    *r*, *g*, and *b* are in the range [0.0, 1.0]. These representations are equivalent.
    For example, the red color (255, 0, 0) in the former is the same as (1.0, 0.0,
    0.0) in the latter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在 OpenGL 中，颜色可以表示为一组 8 位无符号值 (*r*, *g*, *b*)，其中 *r*、*g* 和 *b* 的取值范围是 [0,
    255]。它也可以表示为一组三个 32 位浮点值 (*r*, *g*, *b*)，其中 *r*、*g* 和 *b* 的取值范围是 [0.0, 1.0]。这两种表示方式是等价的。例如，前者中的红色（255,
    0, 0）与后者中的（1.0, 0.0, 0.0）是一样的。
- en: To draw the cube, first draw its six faces using the OpenGL primitive `GL_TRIANGLES`.
    Then color each vertex and use the interpolation provided by OpenGL when it rasterizes
    polygons to take care of the colors between each vertex. For example, [Figure
    11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4) shows the three front-faces
    of the cube. The back-faces of the cube are drawn in [Figure 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    by setting OpenGL to cull front-faces.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制这个立方体，首先使用 OpenGL 基本图元 `GL_TRIANGLES` 绘制其六个面。然后为每个顶点着色，并在 OpenGL 光栅化多边形时利用其提供的插值功能，处理各顶点之间的颜色。例如，[图
    11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4) 显示了立方体的三个前面。立方体的后面通过在 [图
    11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4) 中设置 OpenGL 剔除前面来绘制。
- en: '![](images/nsp-venkitachalam503045-f11004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11004.jpg)'
- en: 'Figure 11-4: The color cube used to compute rays'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：用于计算光线的颜色立方体
- en: If you subtract the colors in [Figure 11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    from [Figure 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4) by subtracting
    (*r*, *g*, *b*)[front] from (*r*, *g*, *b*)[back], you actually compute a set
    of vectors that go from the front to the back of the cube because each color (*r*, *g*, *b*)
    on this cube is the same as the 3D coordinate at that color’s location. [Figure 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    shows the result. (Negative values have been flipped to positive for the purposes
    of this illustration because negative numbers cannot be displayed as colors directly.)
    Reading the color value (*r*, *g*, *b*) of a pixel, as shown in [Figure 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4),
    gives the (*r*[x], *r*[y], *r*[z]) coordinates for the ray passing into the volume
    at that point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 [图 11-4(a)](nsp-venkitachalam503045-0025.xhtml#fig11-4) 中的颜色从 [图 11-4(b)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    中减去，方法是将 (*r*, *g*, *b*)[front] 减去 (*r*, *g*, *b*)[back]，你实际上计算了一组从立方体前面到后面的向量，因为这个立方体上每个颜色
    (*r*, *g*, *b*) 都等同于该颜色位置的 3D 坐标。[图 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    显示了结果。（为了说明的目的，负值已被转换为正值，因为负数不能直接显示为颜色。）读取像素的颜色值 (*r*, *g*, *b*)，如 [图 11-4(c)](nsp-venkitachalam503045-0025.xhtml#fig11-4)
    所示，会给出穿过该点的光线的 (*r*[x]，*r*[y]，*r*[z]) 坐标。
- en: Once you have the casting rays, you render them into an image or 2D texture
    for later use with OpenGL’s frame buffer object (FBO) feature. After this texture
    is generated, you can access it inside the shaders that you’ll use to implement
    the ray casting algorithm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了光线投射结果，就可以将它们渲染为图像或 2D 纹理，以便稍后与 OpenGL 的帧缓冲对象（FBO）功能一起使用。在生成此纹理后，你可以在着色器中访问它，以实现光线投射算法。
- en: Ray Casting in the GPU
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPU 中的光线投射
- en: To implement the ray casting algorithm, you first draw the back-faces of the
    color cube into an FBO. Next, the front-faces are drawn on the screen. The bulk
    of the ray casting algorithm happens in the fragment shader for this second rendering,
    which runs for each pixel in the output. The ray is computed by subtracting the
    front-face color of the incoming fragment from the back-face color of the color
    cube, which is read in from a texture. The computed ray is then used to accumulate
    and compute the final pixel value using the 3D volumetric texture data, available
    within the shader.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现光线投射算法，首先在 FBO 中绘制颜色立方体的背面。接着，前面绘制到屏幕上。大部分光线投射算法发生在第二次渲染的片段着色器中，该着色器针对输出的每个像素运行。光线是通过从纹理中读取颜色立方体的背面颜色，并减去传入片段的前面颜色来计算的。然后，计算出的光线被用来通过
    3D 体积纹理数据累加和计算最终的像素值，这些数据在着色器中可用。
- en: Showing 2D Slices
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示 2D 切片
- en: In addition to the 3D rendering, you show 2D slices of the data by extracting
    the 2D cross section from the 3D data perpendicular to the x-, y-, or z-axis and
    applying that as a texture on a quad. Because you store the volume as a 3D texture,
    you can easily get the required data by specifying the texture coordinates (*s*,
    *t*, *p*). OpenGL’s built-in texture interpolation gives you the texture values
    anywhere inside the 3D texture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 3D 渲染，你还可以通过从 3D 数据中提取垂直于 x、y 或 z 轴的 2D 截面并将其作为纹理应用于四边形，来显示数据的 2D 切片。由于你将体积数据存储为
    3D 纹理，你可以通过指定纹理坐标（*s*，*t*，*p*）轻松获取所需的数据。OpenGL 内建的纹理插值使你能够在 3D 纹理内部的任何位置获得纹理值。
- en: '[The OpenGL Window](nsp-venkitachalam503045-0008.xhtml#rbh1303)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[OpenGL 窗口](nsp-venkitachalam503045-0008.xhtml#rbh1303)'
- en: As in your other OpenGL projects, this project uses the GLFW library to display
    the OpenGL window. You’ll use handlers for drawing, for resizing the window, and
    for keyboard events. You’ll use keyboard events to toggle between volume and slice
    rendering, as well as for rotating and slicing through the 3D data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 OpenGL 项目一样，该项目使用 GLFW 库来显示 OpenGL 窗口。你将使用处理程序来绘制、调整窗口大小以及处理键盘事件。你将使用键盘事件在体积和切片渲染之间切换，还可以旋转和切片
    3D 数据。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1302)'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah1302)'
- en: You’ll use `PyOpenGL`, a popular Python binding for OpenGL, for rendering. You’ll
    also use the Python Imaging Library (PIL) to load the 2D images from the volumetric
    data set, and you’ll use `numpy` arrays to represent 3D coordinates and transformation
    matrices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用流行的 Python OpenGL 绑定库 `PyOpenGL` 进行渲染。你还将使用 Python 图像库（PIL）加载来自体积数据集的 2D
    图像，并使用 `numpy` 数组表示 3D 坐标和变换矩阵。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1303)'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1303)'
- en: You’ll begin by generating a 3D texture from the volumetric data read in from
    the image files. Next, you’ll look at a color cube technique for generating rays
    from the eye that point into the volume, which is a key concept in implementing
    the volume ray casting algorithm. You’ll look at how to define the cube geometry
    as well as how to draw the back- and front-faces of this cube. You’ll then explore
    the volume ray casting algorithm and the associated vertex and fragment shaders.
    Finally, you’ll learn how to implement 2D slicing of the volumetric data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从读取的图像文件中的体积数据生成 3D 纹理。接着，你会学习一种颜色立方体技术，用于生成从眼睛发出的射线指向体积，这在实现体积光线投射算法时是一个关键概念。你将学习如何定义立方体几何体，以及如何绘制立方体的前后面。然后，你将探索体积光线投射算法及相关的顶点着色器和片段着色器。最后，你将学习如何实现体积数据的
    2D 切片。
- en: 'This project has seven Python files:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目有七个 Python 文件：
- en: glutils.py Contains the utility methods for OpenGL shaders, transformations,
    and so on
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: glutils.py 包含 OpenGL 着色器、变换等的实用方法
- en: makedata.py Contains utility methods for creating volumetric data for testing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: makedata.py 包含用于创建测试用体积数据的实用方法
- en: raycast.py Implements the `RayCastRender` class for ray casting
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: raycast.py 实现了用于光线投射的 `RayCastRender` 类
- en: raycube.py Implements the `RayCube` class for use in `RayCastRender`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: raycube.py 实现了用于 `RayCastRender` 的 `RayCube` 类
- en: slicerender.py Implements the `SliceRender` class for 2D slicing of volumetric
    data
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: slicerender.py 实现了用于体积数据 2D 切片的 `SliceRender` 类
- en: volreader.py Contains the utility method to read volumetric data into the OpenGL
    3D texture
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: volreader.py 包含将体积数据读入 OpenGL 3D 纹理的实用方法
- en: volrender.py Contains the main methods that create the GLFW window and the renderers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: volrender.py 包含创建 GLFW 窗口和渲染器的主要方法
- en: We’ll cover all but two of these files in this chapter. The *makedata.py* file
    lives with the other project files for this chapter at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
    The *glutils.py* file can be downloaded from [https://github.com/mkvenkit/pp2e/tree/main/common](https://github.com/mkvenkit/pp2e/tree/main/common).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖除了两个文件以外的所有文件。*makedata.py*文件与本章的其他项目文件一起位于[https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)。*glutils.py*文件可以从[https://github.com/mkvenkit/pp2e/tree/main/common](https://github.com/mkvenkit/pp2e/tree/main/common)下载。
- en: '[Generating a 3D Texture](nsp-venkitachalam503045-0008.xhtml#rbh1304)'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[生成 3D 纹理](nsp-venkitachalam503045-0008.xhtml#rbh1304)'
- en: The first step is to read the volumetric data from a folder containing images,
    as shown in the following code. To see the complete *volreader.py* code, skip
    ahead to [“The Complete 3D Texture Code”](nsp-venkitachalam503045-0025.xhtml#ah1307)
    on [page 241](nsp-venkitachalam503045-0025.xhtml#p241). You can also find the
    *volreader.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
    Note that the `loadTexture()` function in this file is used to open an image file,
    read the contents, and create an OpenGL texture object out of it, which is subsequently
    used in rendering.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从包含图像的文件夹中读取体积数据，如以下代码所示。要查看完整的*volreader.py*代码，请跳转到[“完整的 3D 纹理代码”](nsp-venkitachalam503045-0025.xhtml#ah1307)在[第
    241 页](nsp-venkitachalam503045-0025.xhtml#p241)。你也可以在[https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)找到*volreader.py*文件。请注意，此文件中的`loadTexture()`函数用于打开图像文件，读取内容，并创建一个
    OpenGL 纹理对象，随后该对象将在渲染中使用。
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `loadVolume()` method first lists the files in the given directory using
    the `listdir()` method from the `os` module ❶. Then you iterate through the image
    files themselves, loading them one at a time. To do this, you append the current
    filename to the directory using `os.path.abspath()` and `os.path.join()` ❷, eliminating
    the need to deal with relative filepaths and operating system–specific path conventions.
    (You often see this useful idiom in Python code that traverses files and directories.)
    Next, you use the `Image` class from the PIL to load the current image into an
    8-bit `numpy` array ❸. If the file specified isn’t an image or if the image fails
    to load, an exception is thrown, which you catch by printing an error ❻.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadVolume()`方法首先使用`os`模块的`listdir()`方法列出给定目录中的文件❶。然后，你逐一加载图像文件。为此，你将当前文件名附加到目录路径，使用`os.path.abspath()`和`os.path.join()`❷，这样就避免了需要处理相对路径和操作系统特定的路径约定。（你经常会在遍历文件和目录的
    Python 代码中看到这个有用的惯用法。）接下来，你使用 PIL 的 `Image` 类将当前图像加载到 8 位的 `numpy` 数组中❸。如果指定的文件不是图像或图像加载失败，则会抛出异常，你可以通过打印错误信息来捕获此异常❻。'
- en: Because you’re loading these image slices into a 3D texture, you need to ensure
    they all have the same dimensions (width × height), which you confirm at ❹ and
    ❺. You store the dimensions for the first image and compare them against new incoming
    images. Once all the images are loaded into individual arrays, you create the
    final array containing the 3D data by joining these arrays using the `concatenate()`
    method from `numpy` ❼.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你正在将这些图像切片加载到一个 3D 纹理中，所以需要确保它们的尺寸（宽度×高度）一致，你可以在❹和❺确认这一点。你存储第一张图像的尺寸，并将其与新加载的图像进行比较。一旦所有图像加载到独立的数组中，你可以使用
    `numpy` 的 `concatenate()` 方法将这些数组连接成一个包含 3D 数据的最终数组❼。
- en: 'The `loadVolume()` function continues by loading the array of 3D image data
    into an OpenGL texture:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadVolume()`函数继续将 3D 图像数据数组加载到 OpenGL 纹理中：'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here you create an OpenGL texture ❶ and set parameters for filtering and unpacking.
    Then you load the 3D data array into the OpenGL texture ❷. The format used here
    is `GL_RED`, and the data format is `GL_UNSIGNED_BYTE` because you have only one
    8-bit value associated with each pixel in the data. Finally, you return the OpenGL
    texture ID and the dimensions of the 3D texture ❸.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会创建一个 OpenGL 纹理❶并设置过滤和解包的参数。然后，你将 3D 数据数组加载到 OpenGL 纹理中❷。此处使用的格式是`GL_RED`，数据格式是`GL_UNSIGNED_BYTE`，因为每个像素的数据仅包含一个
    8 位值。最后，你返回 OpenGL 纹理 ID 和 3D 纹理的尺寸❸。
- en: '[Generating Rays](nsp-venkitachalam503045-0008.xhtml#rbh1305)'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[生成光线](nsp-venkitachalam503045-0008.xhtml#rbh1305)'
- en: The code for generating the rays is encapsulated in a class called `RayCube`.
    This class is responsible for drawing the color cube and has methods to draw the
    back-faces of the cube to an FBO or texture and to draw the front-faces of the
    cube to the screen. To see the complete *raycube.py* code, skip ahead to [“The
    Complete Ray Generation Code”](nsp-venkitachalam503045-0025.xhtml#ah1308) on [page
    242](nsp-venkitachalam503045-0025.xhtml#p242). You can also find the *raycube.py*
    file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 生成射线的代码被封装在一个名为`RayCube`的类中。这个类负责绘制颜色立方体，并且有方法将立方体的背面绘制到FBO或纹理中，将前面绘制到屏幕上。如需查看完整的*raycube.py*代码，可以跳到[“完整的射线生成代码”](nsp-venkitachalam503045-0025.xhtml#ah1308)，该内容位于[第242页](nsp-venkitachalam503045-0025.xhtml#p242)。你还可以在[https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)找到*raycube.py*文件。
- en: 'First, let’s define the shaders used by this class. The shaders will be compiled
    as part of the `RayCube` class’s constructor:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义此类使用的着色器。着色器将在`RayCube`类的构造函数中编译：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You define the vertex shader used by the `RayCube` class ❶. This shader has
    two input attributes, `cubePos` and `cubeCol`, which are used to access the position
    and color values of the vertices, respectively. The modelview and projection matrices
    are passed in with the uniform variables `uMVMatrix` and `uPMatrix`, respectively.
    The `vColor` variable is declared as output because it needs to be passed on to
    the fragment shader, where it will be interpolated. The fragment shader ❷ sets
    the fragment color to the (interpolated) value of the incoming `vColor` set in
    the vertex shader.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了`RayCube`类使用的顶点着色器❶。该着色器有两个输入属性，`cubePos`和`cubeCol`，分别用于访问顶点的位置和颜色值。模型视图和投影矩阵通过统一变量`uMVMatrix`和`uPMatrix`传入。`vColor`变量被声明为输出，因为它需要传递给片段着色器，在那里它将被插值。片段着色器❷将片段的颜色设置为顶点着色器中传入的（插值后的）`vColor`值。
- en: Defining the Color Cube Geometry
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义颜色立方体几何形状
- en: 'Now let’s look at the geometry of the color cube, defined in the `RayCube`
    class’s constructor:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`RayCube`类的构造函数中定义的颜色立方体几何形状：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You define the cube geometry ❶ and the colors ❷ as `numpy` arrays. Notice that
    the values in these two definitions are the same. As we discussed earlier, the
    color of each pixel in the color cube corresponds to that pixel’s 3D coordinates.
    The color cube has six faces, each of which can be drawn as two triangles, for
    a total of 6×6, or 36, vertices. But rather than specify all 36 vertices, you
    specify just the cube’s eight corners ❶ and then define the triangles formed with
    those corners using an `indices` array ❸, as illustrated in [Figure 11-5](nsp-venkitachalam503045-0025.xhtml#fig11-5).
    The first two sets of three indices, for example, (4, 5, 7) and (7, 5, 6), define
    the triangles on the top face of the cube.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你将立方体的几何形状❶和颜色❷定义为`numpy`数组。注意，这两种定义中的数值是相同的。正如我们之前讨论的，颜色立方体中每个像素的颜色对应于该像素的三维坐标。颜色立方体有六个面，每个面可以由两个三角形构成，共有6×6或36个顶点。但你并不需要指定所有36个顶点，而是只指定立方体的八个角❶，然后使用`indices`数组❸定义由这些角点构成的三角形，如[图11-5](nsp-venkitachalam503045-0025.xhtml#fig11-5)所示。例如，前两个三元组索引(4,
    5, 7)和(7, 5, 6)定义了立方体顶部面的三角形。
- en: '![](images/nsp-venkitachalam503045-f11005.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11005.jpg)'
- en: 'Figure 11-5: Using indexing, a cube can be represented as a collection of triangles,
    with each face composed of two triangles.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-5：通过索引，立方体可以表示为一组三角形，每个面由两个三角形组成。
- en: 'Next, still within the `RayCube` class constructor, you need to put the vertex
    information into buffers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，仍然在`RayCube`类的构造函数中，你需要将顶点信息放入缓冲区：
- en: '# set up vertex array object (VAO)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置顶点数组对象（VAO）'
- en: self.vao = glGenVertexArrays(1)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: self.vao = glGenVertexArrays(1)
- en: glBindVertexArray(self.vao)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# vertex buffer'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区'
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: self.vertexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
- en: '# vertex buffer – cube vertex colors'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区 – 立方体顶点颜色'
- en: self.colorBuffer = glGenBuffers(1)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: self.colorBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW)
- en: '# index buffer'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '# 索引缓冲区'
- en: self.indexBuffer = glGenBuffers(1)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: self.indexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer); ❶
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer); ❶
- en: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
- en: GL_STATIC_DRAW)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GL_STATIC_DRAW)
- en: As with previous projects, you create and bind to a vertex array object (VAO)
    and then define the buffers it manages. One difference here is that the `indices`
    array is given the designation `GL_ELEMENT_ARRAY_BUFFER` ❶, which means the elements
    in its buffer will be used to index and access the data in the color and vertex
    buffers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，你会创建并绑定一个顶点数组对象（VAO），然后定义它管理的缓冲区。这里的一个不同之处是，`indices` 数组被指定为 `GL_ELEMENT_ARRAY_BUFFER`
    ❶，这意味着它的缓冲区中的元素将用于索引和访问颜色与顶点缓冲区中的数据。
- en: Creating the Frame Buffer Object
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建帧缓冲对象
- en: 'Now let’s jump to the `RayCube` class method that creates the frame buffer
    object, where you’ll direct your rendering:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们跳转到 `RayCube` 类的方法，它创建了帧缓冲对象，你将进行渲染：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here you create a frame buffer object, a 2D texture, and a render buffer object;
    then you set up the texture parameters ❶. The texture is bound to the frame buffer
    ❷, and at ❸ and in the lines that follow, the render buffer sets up a 24-bit depth
    buffer and is attached to the frame buffer. Next, you check the status of the
    frame buffers ❹ and print a status message if something goes wrong. Now, as long
    as the frame buffer and render buffer are bound correctly, all of your rendering
    will go into the texture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建一个帧缓冲对象、一个 2D 纹理和一个渲染缓冲对象；然后设置纹理参数 ❶。纹理被绑定到帧缓冲 ❷，在 ❸ 和接下来的几行代码中，渲染缓冲设置了一个
    24 位深度缓冲并附加到帧缓冲。接下来，你检查帧缓冲的状态 ❹，并在出现问题时打印状态信息。现在，只要帧缓冲和渲染缓冲正确绑定，所有的渲染都会输出到纹理中。
- en: Rendering the Back-Faces of the Cube
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染立方体的背面
- en: 'Here is the code for rendering the back-faces of the color cube:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是渲染颜色立方体背面的代码：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First you bind the FBO ❶, set the active texture unit, and bind to the texture
    handle so that you can render to the FBO. Then you call the `RayCube` class’s
    `renderCube()` method ❷, which we’ll look at soon. It has a face-culling flag
    as an argument, allowing you to draw either the front-face or the back-face of
    the cube using the same code. You set the flag to `True` to make the back-faces
    appear in the FBO texture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先你绑定 FBO ❶，设置活动纹理单元，并绑定纹理句柄，以便你可以渲染到 FBO。然后你调用 `RayCube` 类的 `renderCube()`
    方法 ❷，我们稍后会看看它。该方法将面剔除标志作为参数，允许你使用相同的代码绘制立方体的正面或背面。你将该标志设置为 `True`，以便在 FBO 纹理中显示背面。
- en: Next, you make the necessary calls to unbind from the FBO so that other rendering
    code is unaffected ❸. Finally, you return the FBO texture ID ❹ for use in the
    next stage of the algorithm.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你进行必要的调用，以解除 FBO 的绑定，这样其他渲染代码就不会受到影响 ❸。最后，你返回 FBO 纹理 ID ❹，以便在算法的下一阶段使用。
- en: Rendering the Front-Faces of the Cube
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染立方体的正面
- en: 'The following code is used to draw the front-faces of the color cube during
    the second rendering pass of the ray casting algorithm:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于在射线投射算法的第二次渲染过程中绘制颜色立方体的正面：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method simply calls `renderCube()`, with the face-culling flag set to `False`
    so the front-faces will appear.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法仅调用 `renderCube()`，并将面剔除标志设置为 `False`，以便显示正面。
- en: Rendering the Whole Cube
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染整个立方体
- en: 'Now let’s look at the `renderCube()` method, which draws the color cube discussed
    previously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下 `renderCube()` 方法，它绘制了前面讨论的颜色立方体：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You clear the color and depth buffers, select the shader program, and set the
    transformation matrices. Then you set a flag to control face culling ❶, which
    determines whether the cube’s front-face or back-face is drawn. Notice that you
    use `glDrawElements()` ❷ because you’re using an index array to render the cube,
    rather than a vertex array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你清除颜色和深度缓冲区，选择着色器程序，并设置变换矩阵。然后你设置一个标志来控制面剔除 ❶，它决定是否绘制立方体的正面或背面。注意，你使用 `glDrawElements()`
    ❷，因为你使用的是索引数组来渲染立方体，而不是顶点数组。
- en: Resizing the Window
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整窗口大小
- en: 'Because the FBO is created for a particular window size, you need to re-create
    it when the window size changes. To do that, you create a resize handler for the
    `RayCube` class, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 FBO 是为特定的窗口大小创建的，当窗口大小变化时，你需要重新创建它。为此，你为 `RayCube` 类创建了一个调整大小处理函数，如下所示：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `reshape()` method is called when the OpenGL window is resized. It checks
    the new window dimensions and then clears and re-creates the FBO.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape()` 方法在 OpenGL 窗口大小调整时被调用。它检查新的窗口尺寸，然后清除并重新创建 FBO。'
- en: '[Implementing the Ray Casting Algorithm](nsp-venkitachalam503045-0008.xhtml#rbh1306)'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现射线投射算法](nsp-venkitachalam503045-0008.xhtml#rbh1306)'
- en: Next, you’ll implement the ray casting algorithm in the `RayCastRender` class.
    The core of the algorithm happens inside the fragment shader used by this class,
    which also uses the `RayCube` class to help generate the rays. To see the complete
    *raycast.py* code, skip ahead to [“The Complete Volume Ray Casting Code”](nsp-venkitachalam503045-0025.xhtml#ah1309)
    on [page 248](nsp-venkitachalam503045-0025.xhtml#p248). You can also find this
    file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将在`RayCastRender`类中实现射线投射算法。算法的核心在于该类使用的片段着色器，它还借助`RayCube`类生成射线。要查看完整的*raycast.py*代码，请跳到[“完整的体积射线投射代码”](nsp-venkitachalam503045-0025.xhtml#ah1309)，在[第248页](nsp-venkitachalam503045-0025.xhtml#p248)。你也可以在[https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)找到该文件。
- en: 'Begin in the `RayCastRender` constructor by creating a `RayCube` object and
    loading the shaders:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RayCastRender`的构造函数中，首先创建一个`RayCube`对象，并加载着色器：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The constructor creates an object of type `RayCube` ❶, which is used to generate
    rays. You load the shaders used by the ray casting ❷ and then set the OpenGL 3D
    texture and dimensions ❸, which were passed into the constructor as the tuple
    `volume`. Next, you create a `Camera` object ❹, which you’ll use to set up the
    OpenGL perspective transformation for the 3D rendering.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数创建了一个`RayCube`类型的对象 ❶，用于生成射线。你加载射线投射所需的着色器 ❷，然后设置OpenGL的3D纹理和维度 ❸，这些数据作为元组`volume`传递给构造函数。接着，你创建一个`Camera`对象
    ❹，用来设置OpenGL的透视变换，以进行3D渲染。
- en: NOTE The `Camera` class, also declared in *raycast.py*, is basically the same
    as the one used in [Chapter 10](nsp-venkitachalam503045-0024.xhtml#ch10). You’ll
    see it in the complete code listing on [page 248](nsp-venkitachalam503045-0025.xhtml#p248).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`Camera`类，也在*raycast.py*中声明，基本与[第10章](nsp-venkitachalam503045-0024.xhtml#ch10)中使用的类相同。你将在[第248页](nsp-venkitachalam503045-0025.xhtml#p248)的完整代码清单中看到它。
- en: 'Here is the rendering method for `RayCastRender`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`RayCastRender`的渲染方法：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First you set up a perspective projection matrix for the rendering, using the
    `glutils.perspective()` utility method ❶. Then you set the current camera parameters
    into the `glutils.lookAt()` method ❷. Next, the first pass of the rendering is
    done ❸, using the `renderBackFace()` method in `RayCube` to draw the back-faces
    of the color cube into a texture. (This method also returns the ID of the generated
    texture.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为渲染设置一个透视投影矩阵，使用`glutils.perspective()`工具方法 ❶。然后，你将当前的相机参数设置到`glutils.lookAt()`方法中
    ❷。接着，进行渲染的第一遍 ❸，使用`RayCube`中的`renderBackFace()`方法将颜色立方体的背面绘制到纹理中。（此方法还会返回生成纹理的ID。）
- en: You continue by enabling the shaders for the ray casting algorithm ❹. Then you
    set up the textures for use in the shader program. The texture returned at ❸ is
    set up as texture unit 0 ❺, and the 3D texture created from the volumetric data
    you read in is set up as texture unit 1 ❻. Finally, you render the front-faces
    of the cube using the `renderFrontFace()` method in `RayCube` ❼. When this code
    is executed, the shaders for `RayCastRender` will act on the vertices and fragments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启用射线投射算法的着色器 ❹。接下来，为着色器程序设置纹理。步骤❸中返回的纹理被设置为纹理单元 0 ❺，而从你读取的体积数据中创建的3D纹理被设置为纹理单元
    1 ❻。最后，使用`RayCube`中的`renderFrontFace()`方法渲染立方体的正面 ❼。当这段代码执行时，`RayCastRender`的着色器将作用于顶点和片段。
- en: The Vertex Shader
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: 'Now you come to the shaders used by `RayCastRender`. Let’s look at the vertex
    shader first:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看`RayCastRender`使用的着色器。首先来看顶点着色器：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First you set the input variables of position and color ❶. The layout uses the
    same indices as defined in the `RayCube` vertex shader because `RayCastRender`
    uses the VBO defined in that class to draw the geometry, and the locations in
    the shaders have to match. Then you define the input transformation matrices ❷
    and set a color value as the shader output ❸. The usual transformation computes
    the built-in `gl_Position` output ❹, before you set the output as the current
    color of the cube vertex ❺. The latter will be interpolated across vertices to
    give you the correct color in the fragment shader.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你设置位置和颜色的输入变量❶。布局使用与`RayCube`顶点着色器中定义的相同索引，因为`RayCastRender`使用该类中定义的VBO来绘制几何体，并且着色器中的位置必须匹配。然后，你定义输入的变换矩阵❷，并设置颜色值作为着色器输出❸。常规的变换计算内建的`gl_Position`输出❹，然后将输出设置为当前的立方体顶点颜色❺。后者将在顶点之间插值，以便在片段着色器中获得正确的颜色。
- en: The Fragment Shader
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 片段着色器
- en: The fragment shader is the star of the show. It implements the core of the ray
    casting algorithm.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器是整个过程的核心。它实现了射线投射算法的核心部分。
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The input to the fragment shader is the cube vertex color. The fragment shader
    also has access to the 2D texture generated by rendering the color cube, the 3D
    texture containing the volumetric data, and the dimensions of the OpenGL window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器的输入是立方体的顶点颜色。片段着色器还可以访问通过渲染颜色立方体生成的2D纹理、包含体积数据的3D纹理以及OpenGL窗口的尺寸。
- en: While the fragment shader executes, you send in the front-faces of the cube,
    so by looking up the incoming color value ❶, you get the starting point of the
    ray that goes into this cube. (Recall the discussion in [“Ray Generation”](nsp-venkitachalam503045-0025.xhtml#bh1302)
    on [page 217](nsp-venkitachalam503045-0025.xhtml#p217) about the connection between
    the colors in the cube and the ray directions.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器执行时，你将立方体的正面传入，因此通过查找传入的颜色值❶，你可以得到进入立方体的射线起点。（回顾一下在[“射线生成”](nsp-venkitachalam503045-0025.xhtml#bh1302)一节中关于立方体内颜色与射线方向之间关系的讨论，[第217页](nsp-venkitachalam503045-0025.xhtml#p217)）
- en: You calculate the texture coordinate of the incoming fragment on the screen
    ❷. Here, dividing the location of the fragment in window coordinates by the window
    dimensions maps the location to the range [0, 1]. The ending point of the ray
    is obtained by looking up the back-face color of the cube using this texture coordinate
    ❸.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你计算传入片段在屏幕上的纹理坐标❷。这里，通过将片段在窗口坐标中的位置除以窗口尺寸，将位置映射到[0, 1]的范围内。射线的终点通过使用这个纹理坐标查找立方体的背面颜色来获得❸。
- en: You next calculate the ray direction ❹ and then calculate the normalized direction
    and length of this ray, which will be useful in the ray casting computation. Then
    you loop through the volume using the ray’s starting point and direction until
    it hits the ray’s endpoint ❺. In this loop, you compute the ray’s current position
    inside the data volume ❻ and look up the data value at this point ❼. You then
    perform the blending equation at ❽ and ❾, which gives you the X-ray effect. You
    combine the `dst` value with the current value of the intensity (which is attenuated
    using the alpha value), and the process continues along the ray. The alpha value
    keeps increasing until it equals the maximum threshold of 0.95 ❿, at which point
    you exit the loop. The end result is a sort of average opacity through the volume
    at each pixel, which produces a “see-through” or X-ray effect. (Try varying the
    threshold and alpha attenuation to produce different effects.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你计算射线的方向❹，然后计算该射线的标准化方向和长度，这在射线投射计算中会派上用场。然后，你通过射线的起点和方向遍历体积，直到它击中射线的终点❺。在这个循环中，你计算射线在数据体积内的当前位置❻，并查找该点的数据值❼。然后，你在❽和❾处执行混合方程，产生X射线效果。你将`dst`值与当前的强度值结合（该强度值通过alpha值进行衰减），并且该过程沿射线继续进行。alpha值会不断增加，直到它达到最大阈值0.95❿，此时你退出循环。最终结果是每个像素在体积中的一种平均不透明度，从而产生“透视”或X射线效果。（尝试改变阈值和alpha衰减，产生不同的效果。）
- en: '[Showing 2D Slices](nsp-venkitachalam503045-0008.xhtml#rbh1307)'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[显示2D切片](nsp-venkitachalam503045-0008.xhtml#rbh1307)'
- en: In addition to showing the 3D view of the volumetric data, you want to show
    2D slices of the data in the x-, y-, and z-directions onscreen. The code for this
    is encapsulated in a class called `SliceRender`, which creates 2D volumetric slices.
    To see the complete *slicerender.py* code, skip ahead to [“The Complete 2D Slicing
    Code”](nsp-venkitachalam503045-0025.xhtml#ah1310) on [page 251](nsp-venkitachalam503045-0025.xhtml#p251).
    You can also find the *slicerender.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示体积数据的 3D 视图外，你还希望在屏幕上显示沿 x、y 和 z 方向的 2D 切片数据。为此，代码封装在一个名为 `SliceRender`
    的类中，该类创建 2D 体积切片。要查看完整的 *slicerender.py* 代码，请跳到[《完整的 2D 切片代码》](nsp-venkitachalam503045-0025.xhtml#ah1310)，它位于[第
    251 页](nsp-venkitachalam503045-0025.xhtml#p251)。你还可以在 [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)
    找到 *slicerender.py* 文件。
- en: 'Here’s the initialization code in the `SliceRender` class constructor that
    sets up the geometry for the slices:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `SliceRender` 类构造函数中的初始化代码，它设置了切片的几何形状：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code sets up a VAO to manage the VBO, as in earlier examples. You define
    the geometry of a square in the XY plane ❶. (The vertex order is that of the `GL_TRIANGLE_STRIP`,
    introduced in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).) You’ll use
    this same geometry regardless of whether you’re showing slices perpendicular to
    *x*, *y*, or *z*. All that changes between these cases is the data plane that
    you pick to display from within the 3D texture. We’ll return to this idea when
    we look at the vertex shader.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了一个 VAO 来管理 VBO，和之前的示例一样。你在 XY 平面 ❶ 中定义了一个正方形的几何形状。（顶点顺序使用的是 `GL_TRIANGLE_STRIP`，该顺序在[第
    9 章](nsp-venkitachalam503045-0023.xhtml#ch09)中介绍过。）无论你显示的是与 *x*、*y* 还是 *z* 垂直的切片，你都会使用相同的几何形状。在这些情况下唯一变化的是你选择在
    3D 纹理中显示的数据平面。我们在查看顶点着色器时会回到这个概念。
- en: 'Here’s a method to render the 2D slices:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染 2D 切片的方法：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each 2D slice is a square, which you build up using an OpenGL triangle strip
    primitive. This code goes through the render setup for the triangle strip. Note
    that you implement the orthographic projection using the `glutils.ortho()` method
    at ❶. You set up a projection that adds a 0.1 buffer around the unit square representing
    the slice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 2D 切片都是一个正方形，你使用 OpenGL 三角形带原语将其构建起来。此代码处理三角形带的渲染设置。请注意，你在 ❶ 使用 `glutils.ortho()`
    方法实现了正交投影。你设置了一个投影，在表示切片的单位正方形周围添加了 0.1 的缓冲区。
- en: When you draw something with OpenGL, the default view (without any transformation
    applied) puts the eye at (0, 0, 0) looking down the z-axis with the y-axis pointing
    up. Applying the translation (−0.5, −0.5, −1.0) to your geometry centers it on
    the z-axis ❷. You set the current slice fraction ❸ (where, for example, the 10th
    slice out of 100 would be 0.1), set the slice mode ❹ (to view the slices in the
    x-, y-, or z-direction, as represented by the integers 0, 1, and 2, respectively),
    and set both values to the shaders.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 OpenGL 绘制某些东西时，默认视图（没有应用任何变换）会将视角设定在 (0, 0, 0)，并沿着 z 轴查看，y 轴指向上方。将平移变换（−0.5,
    −0.5, −1.0）应用到几何体上会使其在 z 轴上居中 ❷。你设置当前的切片分数 ❸（例如，100 个切片中的第 10 个切片为 0.1），设置切片模式
    ❹（选择沿 x、y 或 z 方向查看切片，分别由整数 0、1 和 2 表示），并将这两个值传递给着色器。
- en: The Vertex Shader
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: 'Now let’s look at the vertex shader for `SliceRender`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `SliceRender` 的顶点着色器：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The vertex shader takes the triangle strip vertex array as input and sets a
    texture coordinate as output. The current slice fraction and slice mode are passed
    in as uniform variables `uSliceFrac` and `uSliceMode`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器将三角形带顶点数组作为输入，并将纹理坐标作为输出。当前的切片分数和切片模式作为统一变量 `uSliceFrac` 和 `uSliceMode`
    传入。
- en: The shader has three branches, depending on the slice mode. For example, if
    `uSliceMode` is `0`, you calculate the texture coordinates for an *x* slice ❶.
    Because you’re slicing perpendicular to the x-direction, you want a slice parallel
    to the YZ plane. The 3D vertices coming in to the vertex shader also double as
    the 3D texture coordinates because they are in the range [0, 1], so the texture
    coordinates are given as (*f*, *V*[x], *V*[y]), where *f* is the fraction of the
    slice number in the direction of the x-axis and where *V*[x] and *V*[y] are the
    vertex coordinates. Unfortunately, the resulting image will appear upside down
    because the OpenGL coordinate system has its origin at the bottom left, with the
    y-direction pointing up; this is the reverse of what you want. To resolve this
    problem, you change the texture coordinate *t* to (1 − *t*) and use (*f*, *V*[x],
    1 − *V*[y]) ❶. You use similar logic to compute the texture coordinates for y-
    ❷ and z- ❸ direction slices if the `uSliceMode` value is `1` or `2`, respectively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该着色器有三个分支，具体取决于切片模式。例如，如果 `uSliceMode` 为 `0`，您将计算 *x* 切片的纹理坐标 ❶。由于您在 x 方向上进行切片，因此您希望得到与
    YZ 平面平行的切片。传入顶点着色器的 3D 顶点也作为 3D 纹理坐标，因为它们的范围是 [0, 1]，因此纹理坐标表示为 (*f*, *V*[x], *V*[y])，其中
    *f* 是在 x 轴方向上切片编号的分数，而 *V*[x] 和 *V*[y] 是顶点坐标。不幸的是，生成的图像会颠倒过来，因为 OpenGL 的坐标系统原点位于左下角，y
    方向朝上；这与您希望的效果相反。为了解决这个问题，您将纹理坐标 *t* 修改为 (1 − *t*) 并使用 (*f*, *V*[x], 1 − *V*[y])
    ❶。如果 `uSliceMode` 的值为 `1` 或 `2`，您将使用类似的逻辑来计算 y 方向 ❷ 和 z 方向 ❸ 的切片纹理坐标。
- en: The Fragment Shader
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 片段着色器
- en: 'Here is the fragment shader:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是片段着色器：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The fragment shader declares `texcoord` as input ❶, which was set as output
    in the vertex shader. The texture sampler is declared as `uniform` ❷. You look
    up the texture color using `texcoord` ❸ and set `fragColor` as the output ❹. (Because
    you read in your texture only as the red channel, you use `col.rrra`.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器将 `texcoord` 声明为输入 ❶，这在顶点着色器中设置为输出。纹理采样器声明为 `uniform` ❷。您使用 `texcoord`
    ❸ 查找纹理颜色，并将 `fragColor` 设置为输出 ❹。（因为您只读取纹理的红色通道，所以使用 `col.rrra`。）
- en: A User Interface for 2D Slicing
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2D 切片的用户界面
- en: 'Now you need a way for the user to slice through the data. Do this using a
    keyboard handling method on the `SliceRender` class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要一种方法，让用户能够切片数据。可以通过在 `SliceRender` 类上使用键盘处理方法来实现：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the X, Y, or Z key on the keyboard is pressed, `SliceRender` switches to
    the *x*, *y*, or *z* slice mode. You can see this in action for the *x* slice,
    for example ❶, where you set the appropriate mode, set the current slice index
    to the middle of the data, and update the maximum slice number.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下键盘上的 X、Y 或 Z 键时，`SliceRender` 切换到 *x*、*y* 或 *z* 切片模式。例如，在 *x* 切片模式下，您可以看到这种效果
    ❶，在这里，您设置适当的模式，将当前切片索引设置为数据的中间位置，并更新最大切片数。
- en: When the left or right arrow key on the keyboard is pressed, you page through
    the slices. For instance, the slice index is incremented ❷ when the left arrow
    key is pressed. The modulo operator (`%`) ensures that the index “rolls over”
    to 0 when you exceed the maximum value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下键盘上的左箭头或右箭头键时，您可以翻页切片。例如，当按下左箭头键时，切片索引会增加 ❷。取模运算符 (`%`) 确保当索引超过最大值时，“回绕”到
    0。
- en: '[Putting the Code Together](nsp-venkitachalam503045-0008.xhtml#rbh1308)'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将代码整合在一起](nsp-venkitachalam503045-0008.xhtml#rbh1308)'
- en: Let’s take a quick look at the main file in the project, *volrender.py*. This
    file uses a class `RenderWin`, which creates and manages the GLFW OpenGL window.
    (I won’t cover this class in detail because it’s similar to the class used in
    [Chapters 9](nsp-venkitachalam503045-0023.xhtml#ch09) and [10](nsp-venkitachalam503045-0024.xhtml#ch10).)
    To see the complete *volrender.py* code, skip ahead to [“The Complete Main File
    Code”](nsp-venkitachalam503045-0025.xhtml#ah1311) on [page 254](nsp-venkitachalam503045-0025.xhtml#p254).
    You can also find the *volrender.py* file at [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看项目中的主文件 *volrender.py*。该文件使用一个 `RenderWin` 类，它创建并管理 GLFW OpenGL 窗口。（由于与
    [第9章](nsp-venkitachalam503045-0023.xhtml#ch09) 和 [第10章](nsp-venkitachalam503045-0024.xhtml#ch10)
    中使用的类类似，因此我不会详细介绍此类。）要查看完整的 *volrender.py* 代码，请跳到 [“完整的主文件代码”](nsp-venkitachalam503045-0025.xhtml#ah1311)，位于
    [第254页](nsp-venkitachalam503045-0025.xhtml#p254)。您还可以在 [https://github.com/mkvenkit/pp2e/tree/main/volrender](https://github.com/mkvenkit/pp2e/tree/main/volrender)
    找到 *volrender.py* 文件。
- en: 'In the initialization code for this class, you create the renderer as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类的初始化代码中，您按如下方式创建渲染器：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here you read the 3D data into an OpenGL texture using the `loadVolume()` function
    we discussed earlier ❶. Then you create an object of type `RayCastRender` to display
    the data ❷.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用我们之前讨论的 `loadVolume()` 函数将 3D 数据读取到 OpenGL 纹理中❶。然后，你创建一个 `RayCastRender`
    类型的对象来显示这些数据❷。
- en: The Keypress Handler
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按键处理器
- en: The `RenderWindow` class needs its own keyboard handler method for toggling
    between volume and slice rendering and for closing the window. This method also
    passes along keypresses to the `RayCastRender` and `SliceRender` classes’ keyboard
    handlers, to either rotate the camera or navigate through the 2D slices.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow` 类需要一个自己的键盘处理方法，用于在体积渲染和切片渲染之间切换，以及关闭窗口。这个方法还会将按键事件传递给 `RayCastRender`
    和 `SliceRender` 类的键盘处理器，用于旋转相机或在 2D 切片中导航。'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pressing ESC quits the program. You set other keypresses to work whether you
    have just pressed the key down or you are keeping it pressed ❶. If the V key is
    pressed, you toggle the renderer between volume and slice ❷, using Python’s `isinstance()`
    method to identify the current class type. To handle any other keypress events
    (X, Y, Z, or the left and right arrows), you use a dictionary ❸ and pass the keypress
    to the current renderer’s `keyPressed()` handler method. We looked at the slice
    renderer’s `keyPressed()` method in [“A User Interface for 2D Slicing”](nsp-venkitachalam503045-0025.xhtml#ch1313)
    on [page 237](nsp-venkitachalam503045-0025.xhtml#p237), for example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ESC 键退出程序。你设置了其他按键事件，无论是按下键还是保持按下都能触发❶。如果按下 V 键，则在体积和切片渲染之间切换❷，通过 Python
    的 `isinstance()` 方法来识别当前类类型。为了处理其他按键事件（如 X、Y、Z 或左右箭头键），你使用字典 ❸ 并将按键事件传递给当前渲染器的
    `keyPressed()` 处理方法。例如，我们在[《2D 切片的用户界面》](nsp-venkitachalam503045-0025.xhtml#ch1313)一章的[第
    237 页](nsp-venkitachalam503045-0025.xhtml#p237)中查看了切片渲染器的 `keyPressed()` 方法。
- en: NOTE I’m choosing not to pass in the `glfw.KEY` values directly and using a
    dictionary to convert these to character values instead, because it’s a good practice
    to reduce dependencies in source files. Currently, the only file in this project
    that depends on GLFW is *volrender.py*. If you were to pass GLFW-specific types
    into other code, they would need to import and depend on the GLFW library too.
    Then, if you were to switch to a different OpenGL windowing toolkit, the code
    would become messy.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我选择不直接传递 `glfw.KEY` 值，而是使用字典将这些值转换为字符值，因为减少源文件中的依赖是一个好习惯。目前，项目中唯一依赖于 GLFW
    的文件是 *volrender.py*。如果你将 GLFW 特定的类型传递给其他代码，它们也需要导入并依赖于 GLFW 库。然后，如果你切换到不同的 OpenGL
    窗口工具包，代码就会变得凌乱。
- en: '[Running the Program](nsp-venkitachalam503045-0008.xhtml#rah1304)'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行程序](nsp-venkitachalam503045-0008.xhtml#rah1304)'
- en: 'Here is a sample run of the application using data from the Stanford Volume
    Data Archive:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用斯坦福体积数据档案中的数据运行应用程序的示例：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You should see something like [Figure 11-6](nsp-venkitachalam503045-0025.xhtml#fig11-6).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于[图 11-6](nsp-venkitachalam503045-0025.xhtml#fig11-6)的内容。
- en: '![](images/nsp-venkitachalam503045-f11006.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f11006.jpg)'
- en: 'Figure 11-6: A sample run of *volrender.py*. The image on the left is the volumetric
    rendering, and the image on the right is a 2D slice.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：*volrender.py* 的一个示例运行。左侧是体积渲染图像，右侧是 2D 切片图像。
- en: As the application runs, use the V key to toggle between volume and slice rendering.
    In slice mode, use the X, Y, and Z keys to change the slicing axis, and use the
    arrow keys to change the slicing location.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，使用 V 键在体积和切片渲染之间切换。在切片模式下，使用 X、Y 和 Z 键来更改切片轴，使用箭头键来更改切片位置。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1305)'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1305)'
- en: In this chapter, you implemented the volume ray casting algorithm using Python
    and OpenGL. You learned how to use GLSL shaders to implement this algorithm efficiently,
    as well as how to create 2D slices from the volumetric data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你实现了使用 Python 和 OpenGL 的体积射线投射算法。你学习了如何使用 GLSL 着色器高效实现该算法，以及如何从体积数据中创建
    2D 切片。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1306)'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1306)'
- en: 'Here are a few ways you could keep tinkering with the volume ray casting program:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种方法，你可以继续修改体积射线投射程序：
- en: 1\. Currently, it’s hard to see the boundary of the volumetric data “cube” in
    the ray casting mode. Implement a class `WireFrame` that draws a box around this
    cube. Color the x-, y-, and z-axes red, green, and blue, respectively, and give
    each its own shaders. You’ll use `WireFrame` from within the `RayCastRender` class.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 当前，在射线投射模式下，很难看到体积数据“立方体”的边界。实现一个类`WireFrame`，在这个立方体周围绘制一个框。将x轴、y轴和z轴分别涂成红色、绿色和蓝色，并为每个轴指定不同的着色器。你将在`RayCastRender`类中使用`WireFrame`。
- en: 2\. Implement data scaling. In the current implementation, you’re drawing a
    cube for the volume and a square for 2D slices, which assumes you have a symmetric
    data set (that the number of slices are the same in each direction), but most
    real data has a varying number of slices. Medical data, in particular, often has
    fewer slices in the z-direction, with dimensions such as 256×256×99, for example.
    To display this data correctly, you have to introduce a scale into your computations.
    One way to do so is to apply the scale to the cube vertices (3D volume) and square
    vertices (2D slice). The user can then input the scaling parameters as command
    line arguments.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 实现数据缩放。在当前实现中，你为体积绘制了一个立方体，为二维切片绘制了一个正方形，这假设你有一个对称的数据集（每个方向上的切片数量相同），但大多数真实数据的切片数量是变化的。尤其是医学数据，通常在z方向上切片较少，例如，维度可能是256×256×99。为了正确显示这些数据，你需要在计算中引入缩放。可以通过将缩放应用于立方体顶点（3D体积）和正方形顶点（2D切片）来实现这一点。用户可以通过命令行参数输入缩放参数。
- en: '3\. Our volume ray casting implementation uses X-ray casting to calculate the
    final color or intensity of a pixel. Another popular way to do this is to use
    *maximum intensity projection (MIP)* to set the maximum intensity at each pixel.
    Implement this in your code. (Hint: in the fragment shader of `RayCastRender`,
    modify the code that steps through the ray to check and set the maximum value
    along the ray, instead of blending values.)'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 我们的体积射线投射实现使用X射线投射来计算像素的最终颜色或强度。另一种常用的方法是使用*最大强度投影（MIP）*，在每个像素处设置最大强度。请在代码中实现此功能。（提示：在`RayCastRender`的片段着色器中，修改通过射线逐步计算的代码，检查并设置沿射线的最大值，而不是混合值。）
- en: '4\. Currently, the only UI you have implemented is rotation around the x-,
    y-, and z-axes. Implement a zoom feature so pressing I/O will zoom in/out of the
    volume-rendered image. You could do this by setting the appropriate camera parameters
    in the `glutils.lookAt()` method, with one caveat: if you move your view inside
    the data cube, the ray casting will fail because OpenGL will clip the front-faces
    of the cube; the ray computation needed for ray casting requires both the front-
    and back-faces of the color cube to be rendered correctly. Instead, zoom by adjusting
    the field of view in the `glutils.projecton()` method.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 目前，你实现的唯一UI功能是围绕x、y和z轴的旋转。实现一个缩放功能，使得按I/O键可以放大/缩小体积渲染的图像。你可以通过在`glutils.lookAt()`方法中设置适当的相机参数来实现这一点，但有一个警告：如果你将视角移到数据立方体内部，射线投射将会失败，因为OpenGL会裁剪立方体的前面；射线投射所需的计算需要同时渲染立方体的前面和背面。相反，你可以通过调整`glutils.projecton()`方法中的视场来实现缩放。
- en: '[The Complete 3D Texture Code](nsp-venkitachalam503045-0008.xhtml#rah1307)'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的3D纹理代码](nsp-venkitachalam503045-0008.xhtml#rah1307)'
- en: Here’s the full *volreader.py* code listing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*volreader.py*的完整代码列表。
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[The Complete Ray Generation Code](nsp-venkitachalam503045-0008.xhtml#rah1308)'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的射线生成代码](nsp-venkitachalam503045-0008.xhtml#rah1308)'
- en: Here’s the full code listing for the `RayCube` class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`RayCube`类的完整代码列表。
- en: import OpenGL
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 导入OpenGL
- en: from OpenGL.GL import *
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从OpenGL.GL导入*
- en: from OpenGL.GL.shaders import *
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从OpenGL.GL.shaders导入*
- en: import numpy, math, sys
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 导入numpy, math, sys
- en: import volreader, glutils
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 导入volreader, glutils
- en: strVS = """
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: strVS = """
- en: version 330 core
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本330核心
- en: layout(location = 1) in vec3 cubePos;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 布局(位置 = 1) 输入vec3 cubePos;
- en: layout(location = 2) in vec3 cubeCol;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 布局(位置 = 2) 输入vec3 cubeCol;
- en: uniform mat4 uMVMatrix;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: out vec4 vColor;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出vec4 vColor;
- en: void main()
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // set back-face color
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置背面颜色
- en: vColor = vec4(cubeCol.rgb, 1.0);
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: vColor = vec4(cubeCol.rgb, 1.0);
- en: // transformed position
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: // 变换后的位置
- en: vec4 newPos = vec4(cubePos.xyz, 1.0);
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: vec4 newPos = vec4(cubePos.xyz, 1.0);
- en: // set position
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置位置
- en: gl_Position = uPMatrix * uMVMatrix * newPos;
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: gl_Position = uPMatrix * uMVMatrix * newPos;
- en: '}'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: strFS = """
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: strFS = """
- en: version 330 core
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本330核心
- en: in vec4 vColor;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 输入vec4 vColor;
- en: out vec4 fragColor;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出vec4 fragColor;
- en: void main()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: void main()
- en: '{'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: fragColor = vColor;
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: fragColor = vColor;
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'class RayCube:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '类RayCube:'
- en: '"""class used to generate rays used in ray casting"""'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '"""用于生成射线的类，供射线投射使用"""'
- en: 'def __init__(self, width, height):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, height):'
- en: '"""RayCube constructor"""'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '"""RayCube 构造函数"""'
- en: '# set dims'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置尺寸'
- en: self.width, self.height = width, height
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height = width, height
- en: '# create shader'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建着色器'
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: self.program = glutils.loadShaders(strVS, strFS)
- en: '# cube vertices'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '# 立方体顶点'
- en: vertices = numpy.array([
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: vertices = numpy.array([
- en: 0.0, 0.0, 0.0,
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 0.0, 0.0,
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 0.0, 1.0, 0.0,
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0,
- en: 0.0, 0.0, 1.0,
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0,
- en: 1.0, 0.0, 1.0,
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 1.0,
- en: 1.0, 1.0, 1.0,
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 1.0,
- en: 0.0, 1.0, 1.0
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 1.0
- en: '], numpy.float32)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.float32)'
- en: '# cube colors'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 立方体颜色'
- en: colors = numpy.array([
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: colors = numpy.array([
- en: 0.0, 0.0, 0.0,
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 0.0,
- en: 1.0, 0.0, 0.0,
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 0.0,
- en: 1.0, 1.0, 0.0,
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 0.0,
- en: 0.0, 1.0, 0.0,
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 0.0,
- en: 0.0, 0.0, 1.0,
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 0.0, 1.0,
- en: 1.0, 0.0, 1.0,
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 0.0, 1.0,
- en: 1.0, 1.0, 1.0,
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0, 1.0, 1.0,
- en: 0.0, 1.0, 1.0
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0, 1.0, 1.0
- en: '], numpy.float32)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.float32)'
- en: '# individual triangles'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '# 单独的三角形'
- en: indices = numpy.array([
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: indices = numpy.array([
- en: 4, 5, 7,
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 4, 5, 7,
- en: 7, 5, 6,
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 7, 5, 6,
- en: 5, 1, 6,
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 5, 1, 6,
- en: 6, 1, 2,
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 6, 1, 2,
- en: 1, 0, 2,
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 0, 2,
- en: 2, 0, 3,
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 2, 0, 3,
- en: 0, 4, 3,
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 4, 3,
- en: 3, 4, 7,
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 3, 4, 7,
- en: 6, 2, 7,
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 6, 2, 7,
- en: 7, 2, 3,
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 7, 2, 3,
- en: 4, 0, 5,
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 4, 0, 5,
- en: 5, 0, 1
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 5, 0, 1
- en: '], numpy.int16)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '], numpy.int16)'
- en: self.nIndices = indices.size
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: self.nIndices = indices.size
- en: '# set up vertex array object (VAO)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置顶点数组对象（VAO）'
- en: self.vao = glGenVertexArrays(1)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: self.vao = glGenVertexArrays(1)
- en: glBindVertexArray(self.vao)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(self.vao)
- en: '# vertex buffer'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点缓冲区'
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: self.vertexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)
- en: '# vertex buffer - cube vertex colors'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '# 立方体顶点颜色 - 顶点缓冲区'
- en: self.colorBuffer = glGenBuffers(1)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: self.colorBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW);
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW);
- en: '# index buffer'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '# 索引缓冲区'
- en: self.indexBuffer = glGenBuffers(1)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: self.indexBuffer = glGenBuffers(1)
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer);
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer);
- en: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,
- en: GL_STATIC_DRAW)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: GL_STATIC_DRAW)
- en: '# enable attrs using the layout indices in shader'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用着色器中的布局索引启用属性'
- en: aPosLoc = 1
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: aPosLoc = 1
- en: aColorLoc = 2
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: aColorLoc = 2
- en: '# bind buffers'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定缓冲区'
- en: glEnableVertexAttribArray(1)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: glEnableVertexAttribArray(1)
- en: glEnableVertexAttribArray(2)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: glEnableVertexAttribArray(2)
- en: '# vertex'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '# 顶点'
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
- en: glVertexAttribPointer(aPosLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: glVertexAttribPointer(aPosLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
- en: '# color'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '# 颜色'
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
- en: glVertexAttribPointer(aColorLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: glVertexAttribPointer(aColorLoc, 3, GL_FLOAT, GL_FALSE, 0, None)
- en: '# index'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '# 索引'
- en: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer)
- en: '# unbind VAO'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑 VAO'
- en: glBindVertexArray(0)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: glBindVertexArray(0)
- en: '# FBO'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '# FBO'
- en: self.initFBO()
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: self.initFBO()
- en: 'def renderBackFace(self, pMatrix, mvMatrix):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderBackFace(self, pMatrix, mvMatrix):'
- en: '"""renders back-face of ray-cube to a texture and returns it"""'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将射线立方体的背面渲染到纹理并返回"""'
- en: '# render to FBO'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染到 FBO'
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
- en: '# set active texture'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置激活的纹理'
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: glActiveTexture(GL_TEXTURE0)
- en: '# bind to FBO texture'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绑定到 FBO 纹理'
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, self.texHandle)
- en: '# render cube with face culling enabled'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用面剔除渲染立方体'
- en: self.renderCube(pMatrix, mvMatrix, self.program, True)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderCube(pMatrix, mvMatrix, self.program, True)
- en: '# unbind texture'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解绑纹理'
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: glBindTexture(GL_TEXTURE_2D, 0)
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: glBindFramebuffer(GL_FRAMEBUFFER, 0)
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: glBindRenderbuffer(GL_RENDERBUFFER, 0)
- en: '# return texture ID'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回纹理 ID'
- en: return self.texHandle
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: return self.texHandle
- en: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderFrontFace(self, pMatrix, mvMatrix, program):'
- en: '"""render front-face of ray-cube"""'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '"""渲染射线立方体的前面"""'
- en: '# no face culling'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不进行面剔除'
- en: self.renderCube(pMatrix, mvMatrix, program, False)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: self.renderCube(pMatrix, mvMatrix, program, False)
- en: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'def renderCube(self, pMatrix, mvMatrix, program, cullFace):'
- en: '"""render cube using face culling if flag set"""'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用面剔除渲染立方体（如果标志设置了的话）"""'
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
- en: '# set shader program'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置着色器程序'
- en: glUseProgram(program)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: glUseProgram(program)
- en: '# set projection matrix'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置投影矩阵'
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),
- en: 1, GL_FALSE, pMatrix)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 1, GL_FALSE, pMatrix)
- en: '# set modelview matrix'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置模型视图矩阵'
- en: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),
- en: 1, GL_FALSE, mvMatrix)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 1, GL_FALSE, mvMatrix)
- en: '# enable face culling'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: glDisable(GL_CULL_FACE)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'if cullFace:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: glFrontFace(GL_CCW)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: glCullFace(GL_FRONT)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_CULL_FACE)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '# animated slice'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '# reset cull face'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'if cullFace:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '# disable face culling'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: glDisable(GL_CULL_FACE)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'def reshape(self, width, height):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '# re-create FBO'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: self.clearFBO()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: self.initFBO()
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'def initFBO(self):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '# create frame buffer object'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: self.fboHandle = glGenFramebuffers(1)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '# create texture'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: self.texHandle = glGenTextures(1)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '# create depth buffer'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: self.depthHandle = glGenRenderbuffers(1)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '# bind'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, self.texHandle)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '# set parameters to draw the image at different sizes'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '# set up texture'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, None)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '# bind texture to FBO'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: GL_TEXTURE_2D, self.texHandle, 0)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '# bind'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '# bind depth buffer to FBO'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: GL_RENDERBUFFER, self.depthHandle)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '# check status'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: status = glCheckFramebufferStatus(GL_FRAMEBUFFER)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'if status == GL_FRAMEBUFFER_COMPLETE:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '# print "fbo %d complete" % self.fboHandle'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'elif status == GL_FRAMEBUFFER_UNSUPPORTED:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: print("fbo %d unsupported" % self.fboHandle)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: print("fbo %d Error" % self.fboHandle)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'def clearFBO(self):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '"""clears old FBO"""'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '# delete FBO'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsFramebuffer(self.fboHandle):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteFramebuffers(1, int(self.fboHandle))
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '# delete texture'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsTexture(self.texHandle):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteTextures(int(self.texHandle))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'def close(self):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '"""call this to free up OpenGL resources"""'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, 0)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: glBindFramebuffer(GL_FRAMEBUFFER, 0)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: glBindRenderbuffer(GL_RENDERBUFFER, 0)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '# delete FBO'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsFramebuffer(self.fboHandle):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteFramebuffers(1, int(self.fboHandle))
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '# delete texture'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsTexture(self.texHandle):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteTextures(int(self.texHandle))
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '# delete render buffer'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'if glIsRenderbuffer(self.depthHandle):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteRenderbuffers(1, int(self.depthHandle))
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '# delete buffers'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteBuffers(1, self._vertexBuffer)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteBuffers(1, &_indexBuffer)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: glDeleteBuffers(1, &_colorBuffer)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Volume Ray Casting Code](nsp-venkitachalam503045-0008.xhtml#rah1309)'
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the full *raycast.py* code listing.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[The Complete 2D Slicing Code](nsp-venkitachalam503045-0008.xhtml#rah1310)'
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the full 2D slicing code listing.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL.shaders import *
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: import numpy, math, sys
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: import volreader, glutils
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec3 aVert;
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: uniform float uSliceFrac;
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: uniform int uSliceMode;
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: out vec3 texcoord;
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: // x slice
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: if (uSliceMode == 0) {
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: // y slice
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: else if (uSliceMode == 1) {
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: // z slice
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: // calculate transformed vertex
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec3 texcoord;
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: uniform sampler3D tex;
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: // look up color in texture
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: vec4 col = texture(tex, texcoord);
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = col.rrra;
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'class SliceRender:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '# slice modes'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: XSLICE, YSLICE, ZSLICE = 0, 1, 2
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, width, height, volume):'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '"""SliceRender constructor"""'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '# slice mode'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.ZSLICE
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: self.mvMatrixUniform = glGetUniformLocation(self.program, b"uMVMatrix")
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '# attributes'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: self.vertIndex = glGetAttribLocation(self.program, b"aVert")
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: self.vao = glGenVertexArrays(1)
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '# define quad vertices'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: vertexData = numpy.array([0.0, 1.0, 0.0,
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 0.0,
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 1.0, 0.0,
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 1.0, 0.0, 0.0], numpy.float32)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '# vertex buffer'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '# enable arrays'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(self.vertIndex)
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffers'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '# load texture'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: self.texture, self.Nx, self.Ny, self.Nz = volume
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '# current slice index'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nz/2);
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nz;
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'def reshape(self, width, height):'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '# clear buffers'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '# modelview matrix'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 1.0, 0.0, 0.0,
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 0.0, 0.0, 1.0, 0.0,
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: -0.5, -0.5, -1.0, 1.0], numpy.float32)
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '# use shader'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '# set projection matrix'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '# set current slice fraction'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: float(self.currSliceIndex)/float(self.currSliceMax))
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '# set current slice mode'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: self.mode)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '# enable texture'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_3D, self.texture)
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '# draw'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'def keyPressed(self, key):'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '"""keypress handler"""'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == ''x'':'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.XSLICE
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nx/2)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nx
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''y'':'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.YSLICE
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Ny/2)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Ny
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''z'':'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: self.mode = SliceRender.ZSLICE
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '# reset slice index'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = int(self.Nz/2)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceMax = self.Nz
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''l'':'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == ''r'':'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'def close(self):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Main File Code](nsp-venkitachalam503045-0008.xhtml#rah1311)'
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the full code listing for the main file.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: import sys, argparse, os
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: from slicerender import *
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: from raycast import *
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: import glfw
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'class RenderWin:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '"""GLFW Rendering window class"""'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, imageDir):'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '# save current working directory'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: cwd = os.getcwd()
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize glfw; this changes cwd'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwInit()
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '# restore cwd'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: os.chdir(cwd)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '# version hints'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: glfw.GLFW_OPENGL_CORE_PROFILE)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '# make a window'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = 512, 512
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: self.win = glfw.glfwCreateWindow(self.width, self.height, b"volrender")
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '# make context current'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwMakeContextCurrent(self.win)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize GL'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_DEPTH_TEST)
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: glClearColor(0.0, 0.0, 0.0, 0.0)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '# set window callbacks'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetWindowSizeCallback(self.win, self.onSize)
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '# load volume data'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: self.volume =  volreader.loadVolume(imageDir)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '# create renderer'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = RayCastRender(self.width, self.height, self.volume)
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '# exit flag'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = False
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'def onMouseButton(self, win, button, action, mods):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''mouse button: '', win, button, action, mods'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '# ESC to quit'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'if key is glfw.GLFW_KEY_ESCAPE:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.close()
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = True
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == glfw.GLFW_KEY_V:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '# toggle render mode'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(self.renderer, RayCastRender):'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = SliceRender(self.width, self.height,
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: self.volume)
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer = RayCastRender(self.width, self.height,
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: self.volume)
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '# call reshape on renderer'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.reshape(self.width, self.height)
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '# send keypress to renderer'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'keyDict = {glfw.GLFW_KEY_X: ''x'', glfw.GLFW_KEY_Y: ''y'','
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'glfw.GLFW_KEY_Z: ''z'', glfw.GLFW_KEY_LEFT: ''l'','
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 'glfw.GLFW_KEY_RIGHT: ''r''}'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.keyPressed(keyDict[key])
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 'def onSize(self, win, width, height):'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''onsize: '', win, width, height'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: self.width = width
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = width/float(height)
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.reshape(width, height)
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '# start loop'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: self.renderer.draw()
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '# swap buffers'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSwapBuffers(self.win)
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '# wait for events'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWaitEvents()
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '# end'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwTerminate()
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: print('starting volrender...')
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '# create parser'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Volume Rendering...")
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '# add expected arguments'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--dir', dest='imageDir', required=True)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '# parse args'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '# create render window'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: rwin = RenderWin(args.imageDir)
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: rwin.run()
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: call main
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[1](nsp-venkitachalam503045-0025.xhtml#fn4r) J. Kruger and R. Westermann, “Acceleration
    Techniques for GPU-based Volume Rendering,” IEEE Visualization, 2003.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[2](nsp-venkitachalam503045-0025.xhtml#fn5r) [https://graphics.stanford.edu/data/voldata/](https://graphics.stanford.edu/data/voldata/)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
