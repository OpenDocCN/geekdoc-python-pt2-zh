- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Errors and Exceptions
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In many languages, exceptions are regarded as the archnemeses of programmers
    and the hallmarks of some degree of failure. Something, somewhere was used improperly!
    Python developers, on the other hand, recognize exceptions as friends that help
    write better code.
  prefs: []
  type: TYPE_NORMAL
- en: Python offers many familiar error-handling tools, but the way we use them may
    look different from what you’re used to. These tools can help you do more than
    clean up messes. You might even say, error handling in Python is “exceptional.”
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start by demonstrating what exceptions look like in Python and how to read
    their accompanying messages. I’ll cover catching exceptions, handling them, and
    raising them. Then, I’ll show you how to leverage errors to control the flow of
    your program. Finally, I’ll give you a tour of the common exception types.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If case *exceptions*, which are sometimes called *errors* in Python, are unfamiliar
    to you, here’s the general definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'exception: (computing) An interruption in normal processing, typically caused
    by an error condition, that can be handled by another part of the program. (Wiktionary)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s start with a seemingly innocuous program: a number-guessing game. I’m
    only using concepts introduced in previous chapters, so see if you can spot the
    bug before I point it out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I create a function that selects a random number, which the player will
    have to try to guess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: *number_guess.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I create a function that gets a guess from the user and outputs whether
    the number guessed was too high, too low, or correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: *number_guess.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: I return a boolean value to indicate whether the `guess` is correct or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function is responsible for running the game and tracking how
    many guesses the player has left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: *number_guess.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I call the `play()` function when the module is executed directly, thereby
    starting the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: *number_guess.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I test this game by playing it the normal way, everything seems to work
    as expected. Here’s my first playthrough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our first instinct as programmers is to test things politely. We have a subconscious
    sense about what will cause the code to break, and we inherently tiptoe around
    those possible errors. However, if you’ve done any meaningful testing, you know
    the value of “doing horrible things to your code,” as Stack Overflow cofounder
    Jeff Atwood says.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as programmer Bill Sempf puts it:'
  prefs: []
  type: TYPE_NORMAL
- en: QA Engineer walks into a bar. Orders a beer. Orders 0 beers. Orders 999999999
    beers. Orders a lizard. Orders ‒1 beers. Orders a sfdeljknesv.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, proper testing of this code involves throwing input to it that it doesn’t
    expect or understand, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: Traceback from running *number_guess.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Eww, a bug! My program can’t handle numbers spelled out as words. Clearly, I
    need to do something about this.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Tracebacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That block of output you receive when an error occurs is called the *traceback*,
    and it tells you what went wrong and where. It includes the details of the error
    that occurred, the line where it happened, and the entire *call stack*—which contains
    the function calls leading directly from the main function to the error. The entire
    call stack will always be displayed; it is up to you to determine the location
    of the coding mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend reading tracebacks from the bottom up. Let’s take apart that traceback
    I received in [Listing 8-5](#listing8-5), piece by piece, starting from the final
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This tells you what went wrong. Specifically, a `ValueError` was raised because
    the value `'Fifty'` was passed to the `int()` function. The `with base 10` part
    has to do with the default value of the `base` parameter. In other words, Python
    can’t convert the string `'Fifty'` to an integer using the `int()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This last line of the traceback is the single-most important. Always read and
    completely understand it before moving forward with fixing the bug!
  prefs: []
  type: TYPE_NORMAL
- en: 'The two lines above the error tell you precisely where the error occurred:
    in file `./number_guess.py`, on line 10, in the `make_guess()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Python even gives you the offending line in question, and sure enough, you can
    see the `int()` function wrapped around `input()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you can stop there and go fix the problem. In this case, the problem
    is right here. In other situations, the error may occur because of a mistake in
    the code further up in the call stack, such as passing bad data to a parameter.
    Even though I know that’s not the problem here, I’ll go up another step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You already know that the error is occurring in the `make_guess()` function,
    and that is being called from within `./number_guess.py`, on line 25, in the `play()`
    function. No problem here; the argument `target` had nothing to do with the error.
    Likewise, this part of the code can’t possibly have caused the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now I’m at the top of the traceback. The `play()` function is being called on
    line 35 of `./number_guess.py`, and the call isn’t occurring inside of any function;
    rather it’s coming from the module scope, as indicated by `<module>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That first line is always the same, but it’s a useful reminder if you ever
    forget how to read a traceback properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The most recently executed code is always listed last! Thus, as I’ve said before,
    always read tracebacks from the bottom up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Catching Exceptions: LBYL vs. EAFP'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many languages, the common practice is to test the input before trying to
    convert it to an integer. This is known as the *Look Before You Leap (LBYL)* philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a different approach, officially known as *Easier to Ask Forgiveness
    than Permission (EAFP)*. Instead of preventing errors, we embrace them, using
    `try` statements to handle exceptional situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll rewrite my `make_guess()` function to use error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: *number_guess.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: I initially set the value of `guess` to `None`, so that as long as I don’t have
    something usable assigned to guess, I keep prompting the user for input. I use
    `None` instead of `0`, since `0` is still technically a valid integer.
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration of the loop, in the context of `try`, I attempt to get the
    user input and convert it to an `int()`. If that conversion fails, `int()` will
    raise a `ValueError`, as you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If `ValueError` is raised, it can only mean that the user entered some non-numeric
    input, such as `'Fifty'` or an empty string. I catch that error and handle the
    situation by printing an error message. Because `guess` is still `None`, the entire
    loop repeats to prompt for input again.
  prefs: []
  type: TYPE_NORMAL
- en: If `int()` is successful, no further action is taken in this section of code,
    and I move on to the rest of the function. The so-called *happy path*, the one
    with no errors, is efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why the EAFP approach is the preferred error-handling philosophy,
    compare it to the LBYL strategy. Here’s the LBYL approach to confirming that the
    string only contains digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: *number_guess.py:2c*'
  prefs: []
  type: TYPE_NORMAL
- en: While this code is perfectly valid, it’s not very efficient. I run `isdigit()`
    on *every single guess*, whether it’s erroneous or not, and then I run the `int()`
    conversion if it passes the test. Thus, I process the string in `guess` *twice*
    on the happy path, and once in the case of an error. Contrast this with the EAFP
    strategy with the `try` statement from earlier, where I only ever process the
    string once.
  prefs: []
  type: TYPE_NORMAL
- en: Some will complain, “Yes, but, error handling is expensive!” True, but only
    on the exceptions. A successful try typically has very little overhead in Python.
    The extra code for handling special cases is run when an error occurs. If you’ve
    designed your code right, the happy path should be far more common than the exceptional
    path, such as in the example above.
  prefs: []
  type: TYPE_NORMAL
- en: The EAFP approach is also easier to think about. Instead of coming up with tests
    to anticipate every possible erroneous input—an arduous task in more complex,
    real-world scenarios—you only need to anticipate the likely exceptions, catch
    them, and handle them accordingly. That said, it can sometimes take some real
    effort to figure out what errors to expect. Be prepared to invest time here, either
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `try` statement is not limited to a single error type. I can handle multiple
    scenarios in one compound statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll create a simple, callable `AverageCalculator` class
    that will accept a list of inputs and use them to recalculate a stored running
    average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-8: *average_calculator.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few possible errors that can occur while using this `AverageCalculator`
    class, but I’d prefer to let the user interface code handle those, so they can
    be used for displaying error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a basic command line interface for the calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-9: *average_calculator.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three errors that can occur when calling `average()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The user might pass no values, meaning `total` (the divisor of the division
    in `__call__()`) might be zero and thus raise a `ZeroDivisionError` ❶.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more of the inputs might not be convertible by `float()`, thus raising
    a `ValueError` ❷.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There might be a problem encoding or decoding Unicode, which will raise a `UnicodeError`
    ❸. (Actually, that last one is entirely redundant with `ValueError` in this case;
    I’m only including it to demonstrate the concept.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I handle all three exceptional cases by calling `average()` within the `try`
    clause’s suite and then catching the errors in the `except` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: When a `ZeroDivisionError` is caught ❶, I print that no values were provided
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: I handle the `ValueError` ❷ and the (redundant) `UnicodeError` ❸ in the same
    way; either error would occur if the user tried inputting something non-numeric.
    By specifying both in a tuple after `except`, I catch either error and handle
    both the same way—in this case, by printing a message that some inputs weren’t
    numeric.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this in a reasonably contained example, I’ve written slightly
    convoluted code here. In the real world, I’d place the `try` statement within
    the `__call__()` method itself. While this example code departs from idiomatic
    Python, it demonstrates a more complex `try` statement, albeit without any truly
    useful error-handling behavior (which I’ll get to shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Beware the Diaper Anti-pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sooner or later, every Python developer will discover that a bare `except`
    clause will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-10: *diaper_antipattern.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a bare `except` allows you to catch all exceptions in one. This is one
    of the most insidious anti-patterns in Python. It catches and silences literally
    every conceivable exception, whether you expect it to or not.
  prefs: []
  type: TYPE_NORMAL
- en: The entire point of an exception is to alert you that your program is now in
    an *exceptional state*, meaning it can no longer proceed along the ordinary, intended
    happy path without unexpected or even disastrous results. By silencing every error,
    you have created a situation where you have no idea what those exceptional states
    are or what is causing them. You’ve thrown away your precious traceback and forced
    the program to continue as if nothing had happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his book *How to Make Mistakes in Python*, Mike Pirnat calls this the *diaper
    pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A]ll the precious context for the actual error is being trapped in the diaper,
    never to see the light of day or the inside of your issue tracker. When the “blowout”
    exception occurs later on, the stack trace points to the location where the secondary
    error happened, not to the actual failure inside the try block.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Worse yet, if your program never raises another exception but keeps attempting
    to work in its invalid state, weird behavior will often abound.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, always explicitly catch a particular exception type! Any error that
    you cannot foresee is probably related to some bug that needs to be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, The Zen of Python has something to say about this:'
  prefs: []
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There’s another diabolical side effect of this anti-pattern, which I can demonstrate
    with this simple program for greeting someone by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-11: *no_escape.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were running this program in the Linux terminal and decided I wanted to
    quit, I’d press Ctrl-C. Look what happens when I do exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Ack! I’m trapped! The trouble is, the `KeyboardInterrupt`, which is produced
    by pressing Ctrl-C on a UNIX terminal, uses the `except` system. It’s getting
    caught, “handled,” and utterly ignored. There’s no escape from this program, except
    to kill my terminal altogether and manually kill the Python process. (Thankfully
    in this example, you can still quit by typing a name.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `KeyboardInterrupt` exception does not itself inherit from the `Exception`
    class, like errors do. Thus, some (overly) clever developer might try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-12: *no_escape.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m no longer catching `KeyboardInterrupt`, which is good, so I can now escape
    with Ctrl-C. Unfortunately, this is still a form of the *diaper anti-pattern*,
    for the reasons I mentioned earlier: it catches every conceivable error! The one
    time this might be acceptable would be in conjunction with logging, which I’ll
    address later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Raising Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also *raise* exceptions to indicate the occurrence of a problem that
    your code cannot recover from automatically, such as when someone calling a function
    you wrote passes an unusable argument. There are several dozen common exceptions
    available for you to raise as needed (see “A Gallery of Exceptions” near the end
    of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, here’s a function that accepts a string containing numbers
    (separated by spaces) and calculates the average. Here, I’m catching the most
    common error scenario and providing a more useful and relevant error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-13: *average.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I split the provided string into the individual space-separated parts, looping
    through each part. Within a `try` clause ❶, I attempt to convert each part to
    a floating-point number and add it to the `total` accumulator. If any of the values
    cannot be converted to a number, thereby raising a `ValueError` ❷, I mark that
    I’ve skipped an item, and I move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'I continue with that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-14: *average.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: Once I’ve processed the string, I check whether I’ve skipped all the values
    ❸. If I have, I’ll `raise` another `ValueError`, passing my error message to the
    constructor of the exception. Otherwise, if only some of the values have been
    skipped, I’ll print a helpful message and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Raising an exception breaks out of the function *immediately*, in the same manner
    as a `return` statement. Thus, I don’t need to worry about the final `return`
    statement being run if I have no values (such as if the user passed in an empty
    string).
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of that function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-15: *average.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll run that code and try some inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first input works just fine, returning the average of the four numbers I
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The second input works as well, skipping my two invalid values and returning
    the average of the other two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The third input contains no valid numbers, so it crashes the program, which
    is exactly what I wanted. Reading the traceback, you can see the exception I raised
    earlier and where I raised it from.
  prefs: []
  type: TYPE_NORMAL
- en: 'I wouldn’t ship a program like this, so I can, in turn, catch the exception
    I raised. I’ll rewrite my infinite loop at the bottom of the program, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-16: *average.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I wrap the user input/output logic in a `try` clause, and then I catch the
    `ValueError` and print a nice message instead. Let’s try out this new version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! When the input is bad, the exception I raised inside the `average()`
    function is caught here, and the appropriate message is printed. (I can press
    CTRL-C to quit.)
  prefs: []
  type: TYPE_NORMAL
- en: Using Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like everything else in Python, exceptions are objects that you can both use
    directly and extract information from.
  prefs: []
  type: TYPE_NORMAL
- en: You can, for example, use exceptions to handle the logic of accessing values
    from a dictionary, without knowing in advance whether the key you specified is
    valid. (There’s some debate about whether and when to use this approach, which
    I’ll revisit in Chapter 9.)
  prefs: []
  type: TYPE_NORMAL
- en: As an example of using exceptions with dictionaries, here’s a program that allows
    a user to look up an email address by a person’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'I start by defining a dictionary containing names and email addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-17: *address_book.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is my lookup function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-18: *address_book.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: I start by trying to use the `name` argument as a key on my dictionary, within
    the context of a `try` clause. If the key is not in the dictionary, a `KeyError`
    will be raised, which I’ll catch. I capture said exception with `as e` ❶, allowing
    me to use the exception object later. In the case of a `KeyError`, `str(e)` will
    return the value that I just tried to use as a key in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here’s the code using that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-19: *address_book.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I run this code and pass a name that isn’t in my dictionary, I see the result
    of the error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions and Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An unusual aspect of `KeyError` is that its message consists purely of the erroneous
    key. Most exceptions contain their complete error message, one use of which is
    *logging*, wherein errors, warnings, and other informational messages are printed
    to the terminal or saved to a file for inspection by the end user, in case of
    bugs. Users expect programs to behave well and not crash, but errors aren’t always
    avoidable. It’s common for software to log errors to a file or the terminal, to
    aid in debugging crashes and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, I’ll write a very basic calculator program, which is intended
    to demonstrate the concept without getting too deep into the logging tools and
    practices themselves. I’ll cover logging more thoroughly in Chapter 19.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'My calculator program will need a few imports that may be unfamiliar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-20: *calculator.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: The `logging` module contains Python’s built-in logging tools, which I’ll use
    in a moment. The `operator` module contains optimized functions for performing
    mathematical operations on arbitrary values, which I’ll use in my calculator function.
    Third, `sys` provides tools for interacting with the interpreter itself; in my
    case, I’ll use one of its functions later on to tell my program to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logging.basicConfig()` function allows me to configure my logging level,
    as well as specify things like which file to write the log to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-21: *calculator.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five increasing severity levels of logging: `DEBUG`, `INFO`, `WARNING`,
    `ERROR`, and `CRITICAL`. By passing `level=logging.INFO`, I’m telling the logging
    module to log all messages of that level, as well as the three severity levels
    above it (`WARNING`, `ERROR`, and `CRITICAL`). That means only log messages marked
    as `DEBUG` are ignored on this setting.'
  prefs: []
  type: TYPE_NORMAL
- en: With the argument `filename=log.txt`, I also specify that the log should be
    written to a file called *log.txt*. I could also leave this blank if I wanted
    to print the log to the console instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is my actual `calculator()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-22: *calculator.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: The math operator functions, such as `add()` ❶, are coming from the `operator`
    module I imported earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The `calculator()` function doesn’t perform error checking by design, according
    to the *single-responsibility principle* from Chapter 7. Code that uses the `calculator()`
    function should provide the right arguments to the function, anticipate and handle
    the errors itself, or crash with an explicit unhandled error (thereby indicating
    the code is erroneous).
  prefs: []
  type: TYPE_NORMAL
- en: There is one exception (no pun intended). If the user specifies an operator
    in the `op` parameter that I don’t support in my `calculator()` function, I raise
    `NotImplementedError` ❷. This exception should be raised anytime functionality
    that doesn’t exist is requested.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is my usage of the `calculator()` function, along with all the
    error handling and logging code. I’ll break this down into several pieces and
    discuss each separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-23: *calculator.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I print the program name and some user instructions. Then, in my program
    loop ❶, within a `try` ❷, I attempt to collect the input from the user and pass
    it to the `calculator()` function. If that works, I print the result, and the
    loop starts over. However, there are a number of errors that can occur, and I
    handle them in my `except` clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-24: *calculator.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: If I encounter the `NotImplementedError`, which I capture as a usable object
    with `as e`, it means an invalid operator was specified in the `op=` argument
    passed to `calculator()`. After printing some information for the user, I log
    this (as level `INFO`) by passing the error, `e`, to the `logging.info()` function.
    That logs the error message (which you’ll see in a moment), but it throws away
    the traceback, which I do not need to show to the program’s user, since the problem
    was their input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-25: *calculator.py:6*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ValueError` is raised if `float()` was not able to convert the arguments
    `a` or `b` to floating-point numbers. That might mean that the user entered non-numeric
    characters for one of the operands, or that the operator was specified in the
    wrong order. Remember, I ask the user for *postfix notation*, meaning the operator
    comes after the two operands. In either case, I remind the user of the format
    they need to use, and once again, I log the error to level `INFO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-26: *calculator.py:7*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TypeError` shows up if the user passes either too many or too few arguments
    to the `calculator()` function. Once again, I log this as level `INFO`, print
    a reminder for the user about the proper format of input, and move on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-27: *calculator.py:8*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user tries to divide by zero, it raises the error `ZeroDivisionError`.
    Handling that error is, again, a matter of logging to `INFO` and notifying the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-28: *calculator.py:9*'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, I use `KeyboardInterrupt` and `EOFError` to catch the UNIX terminal
    keystrokes Ctrl-C (abort) and Ctrl-D (end of file), respectively. In either case,
    I print a friendly farewell message and then use `sys.exit(0)` to properly quit
    the program. Technically, I could have left both of these uncaught, but that would
    have resulted in an ugly error message appearing upon quitting the program. That
    might scare some users into thinking there’s a bug in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll run this program now and try things out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: All in all, this is a clean user experience. All the errors I’ve anticipated
    are being caught and handled appropriately, and I can quit nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Logs and Cleaning Up
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Take a look at the *log.txt* file that’s been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-29: *log.txt*'
  prefs: []
  type: TYPE_NORMAL
- en: Here are all five of the error messages that were logged while I used the program.
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, in production software, I’d never write any of the expected
    errors to a file, because it would result in a huge and unwieldy file! Thus, I
    might change all my logging commands to `logging.debug()`, to log the error messages
    at the `DEBUG` level. That way, if I were to need to peruse the errors during
    debugging, I’d only need to change my logging configuration to `logging.basicConfig(filename='log.txt',
    level=logging.DEBUG)`. I’d ship with a logging level of `INFO`, thereby suppressing
    the `DEBUG` messages. That way, the end user wouldn’t see a bloated log.
  prefs: []
  type: TYPE_NORMAL
- en: Bubbling Up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s one nonoptimal part of the logging scheme I’ve created: any unexpected
    errors won’t get logged. Ideally, any exception I haven’t anticipated should be
    logged at level `ERROR` but still be allowed to crash the program, so the code
    doesn’t try to carry on in an unhandled exceptional state.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, any error you catch can be re-raised, or *bubbled up* in Python
    terminology. Since the error isn’t caught again after being re-raised, the program
    will crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m leaving the rest of the earlier `try` statement the same (Listings 8-23
    through 8-28), but I’m adding one more `except` to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-30: *calculator.py:10*'
  prefs: []
  type: TYPE_NORMAL
- en: The `except` clauses are evaluated in order, which is why this new clause has
    to appear at the end of the current `try` statement. I don’t want this “catch-all”
    to gobble up the exceptions I specifically want to handle separately.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem dangerously close to the diaper anti-pattern, except here, I don’t
    hide the error, and I’m only catching *actual errors*—that is, any object that
    inherits from `Exception`. Non-error “exceptions” like `StopIteration` and `KeyboardInterrupt`,
    which don’t inherit from `Exception`, won’t get caught by this `except` clause.
  prefs: []
  type: TYPE_NORMAL
- en: I log the error message, *along with the traceback*, at `ERROR` level, using
    the special method `logging.exception(e)`. When the user sends me the log file
    with his bug report, I, the developer, will need this traceback to find and fix
    the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I bubble up the error with a bare `raise` statement, which raises the
    *last-caught* exception ❶. (I could also have done `raise e`, but the bare `raise`
    is preferred in this context for brevity in my code and traceback.) It is *absolutely
    essential* that I bubble up the error here, lest this become a case of the diaper
    anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you catch one exception and then raise another, you’re at risk of losing
    the context of the original error. To avoid this situation, Python offers *exception
    chaining*, whereby you can raise a new exception without throwing away all the
    helpful information already provided. This feature was added in Python 3.0 (via
    PEP 3134).
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll apply this concept to a program for looking up the city and state of famous
    landmarks. I start by defining the dictionaries for the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-31: *landmarks.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function for looking up landmarks and their corresponding cities
    in the dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-32: *landmarks.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, I try to find the landmark in the `landmarks` dictionary.
    If it’s not there, a `KeyError` is raised, which I catch ❶ and then re-raise with
    more useful information in the error message ❷. When I raise the new exception,
    I use `from e` to specify that it was caused by the exception (`e`) I caught.
    This ensures that the traceback shows what led to the error: either the city or
    the landmark not being found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example usage of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-33: *landmarks.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I test the `lookup_landmark()` function by looking up three landmarks, two of
    which (`"alamo"` and `"golden gate bridge"`) are going to throw an exception,
    but for different reasons. In the case of the Alamo, although the landmark is
    in the `landmarks` dictionary, the corresponding city of "`SAN ANTONIO`" is missing
    from the cities dictionary. In the case of the Golden Gate Bridge, the landmark
    isn’t even in the `landmarks` dictionary. (Sorry, San Francisco!)
  prefs: []
  type: TYPE_NORMAL
- en: 'The code as written won’t get to the last line, because the second-to-last
    line will throw an exception, as you’ll see in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `lookup_landmark()` works, as you can see from the output.
    Remembering that you read traceback from the bottom up, you see that the second
    call fails, raising the `"Landmark not found"` error ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Above that traceback is a notification that the exception was caused by a different
    exception ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, in the traceback above that, you find the problem; Python couldn’t
    find the city of `"SAN ANTONIO"` in the `cities` dictionary ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if I hadn’t taken the time to add `raise KeyError from e` earlier, Python
    would ordinarily have included the context, although the two tracebacks would
    have been separated with a message I consider far more cryptic and less helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: So, even though you might be able to get away without explicit exception chaining,
    it’s just a good habit to take on.
  prefs: []
  type: TYPE_NORMAL
- en: Else and Finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, all my error handling examples have relied on `try` and `except`,
    which leaves the rest of the code to run the same in any case, whatever happens,
    unless I call `return` or take advantage of the breaking behavior of a `raise`
    statement to bail out of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more optional clauses for `try` statements: `else` runs if there
    is no exception, and `finally` runs in any situation, but in a surprising way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Else: “If All Goes Well”'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You would use the `else` clause for any section of code that should only run
    if none of the `except` clauses caught anything.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, I’ll revise my program for finding the average of a list
    of numbers. This time, I want it to always output a valid `float` value. The average
    of an empty string should be the constant `math.inf` (the result of division by
    zero), and the presence of any non-numeric values should produce the constant
    `math.nan`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-34: *average_string.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: Every time the `average_string()` function is called, it first tries to create
    a list of `float` values. If any part of the string is non-numeric, a `ValueError`
    is raised. I catch that exception, assign the value `math.nan` to `total`, and
    ensure there is a `1` in `values`, which I will use as the divisor in the upcoming
    division.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no exception was raised by that first `try` clause, the `else` clause is
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-35: *average_string.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The `total` and `values` are calculated based on the now-valid assumption that
    `numbers` is a list of `float` values. *The* `else` *clause only runs if the*
    `try` *raises no exceptions.*
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why not just return `math.nan` in the `except ValueError` clause? That
    would certainly be a bit more efficient, but there are two reasons I chose not
    to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: This approach better accommodates later refactoring; the rest of the math is
    always executed, and it always produces a valid result (except for the division-by-zero
    scenario I handle separately in the next part of the code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I need to add a `finally` clause anywhere, the code will still behave as
    expected (see next section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the rest of the program. Notice that I have a separate `try` statement
    to handle attempted division by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-36: *average_string.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve handled all of the exceptional paths that could be reasonably anticipated
    in the code. Testing this out, everything behaves as expected, with no unhandled
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally: “After Everything”'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `finally` clause is always executed, no matter what! There aren’t any exceptions
    to this: even `raise` or `return` will not prevent the `finally` clause from being
    executed. This is what sets `finally` apart from plain code after the `try` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, `finally` is especially well-suited for any cleanup code you
    need to run, *no matter what*.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a function that reads numbers from a file, one number per line, and finds
    the average. In this case, I want exceptions to be raised if the file contains
    non-numeric data or if the file cannot be found.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, I’ll use manual opening and closing of a file—although in
    production, I’d use a *context manager* for this instead (see Chapter 11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-37: *average_file.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: When the `average_file()` function is called, it attempts to open the file indicated
    by the argument `path`. If this file doesn’t exist, `file.open()` will raise a
    `FileNotFoundError` exception, which I’m allowing as is, in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file is opened, I try to iterate over it, converting it into a list
    of numbers ❶. (You’re welcome to take this particular line of code for granted
    for now. See Chapters 10 and 11.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-38: *average_file.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: If any of the values are non-numeric, I catch the `ValueError`. In this clause,
    I raise a chained exception with more specific information describing what was
    wrong with the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, if no errors were raised by the `try` clause, the `else` clause
    runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-39: *average_file.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: This clause’s suite attempts to calculate and return the average, but it also
    contains a nested `try` statement to handle an empty file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After either the `except` or the `else` clause has run, the `finally` clause
    is always executed, *even after a* `raise` *or* `return`! This is important, because
    no matter the outcome, the file needs to be closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-40: *average_file.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll test the program with four files, three of which I’ve created: a file
    containing integers called *numbers_good.txt*, a file containing words called
    *numbers_bad.txt*, an empty file called *numbers_empty.txt*, and a nonexistent
    file called *nonexistent.txt*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the output of these four scenarios one by one. These have to
    be run separately, because the program execution ceases when an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-41: *average_file.py:5a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file *numbers_good.txt* contains 12 integers, each on a separate line.
    Running that scenario, I get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The function works correctly; it opens the file and calculates the average of
    the values. Notice when the `finally` clause runs, as evidenced by the printed
    message "`Closing file.`" Although it is running *after* the `return` statement
    in the `average_file()` function from earlier, it appears *before* the function
    returns. This is a good thing, because the `finally` clause in this function is
    responsible for closing the file, which absolutely *must* happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the second scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-42: *average_file_usage.py:5b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *numbers_bad.txt* file contains words, not numbers. This output is a lot
    longer because of the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a `ValueError` is raised. Yet, once again, the `finally` clause
    is run ❶ before the exception is raised, even though the `raise` statement seems
    to come first in the function’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the third scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-43: *average_file_usage.py:5c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file *numbers_empty.txt* is, as its name suggests, an empty file. The output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the error message about the empty file is working as well ❷.
    Also, as before, it is evident the `finally` clause is running ❶ before the exception
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the last scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-44: *average_file_usage.py:5d*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is attempting to read from a file that *doesn’t exist*. Here’s the output
    of that scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This exception comes from the `file.open()` call, which, if you refer back to
    the source code for `average_file()`, you’ll notice occurs *before* the `try`
    statement. The `finally` clause only runs if its connected `try` clause is executed;
    since control flow never reached the `try`, the `finally` never gets called. Just
    as well, since there’s no point in trying to close a file that was never opened.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has quite the menagerie of exceptions, and their uses are very well documented.
    Sometimes, however, you need something a bit more customized.
  prefs: []
  type: TYPE_NORMAL
- en: All error-type exception classes inherit from the `Exception` class, which in
    turn inherits from the `BaseException` class. This dual hierarchy exists to let
    you catch all error exceptions, as I did earlier, without also reacting to the
    special, non-error exceptions like `KeyboardInterrupt`, which inherit from `BaseException`
    and not `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: When making a custom exception class, you can inherit from any exception class
    you like. However, avoid inheriting from `BaseException`, as that class is not
    designed to be directly inherited from by custom classes. Sometimes, it’s best
    to inherit from the exception class that is closest in purpose to the one you’re
    making (see the next section). However, if you’re at a loss, you can inherit from
    `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going through all the effort to write a custom exception, consider why
    you *want* to. My recommendation is to ensure your use case fits at least two
    of these three criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: No existing exception effectively describes the error, even if you provide a
    custom message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will raise or catch the exception more than once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to be able to catch this specific exception, without catching any of
    the similar built-in exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your use case cannot satisfy at least two of these criteria, you *probably*
    don’t need a custom exception and can instead use one of the existing exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, the need for custom exceptions arises in more complicated
    projects, so it’s very difficult to create a practical example for this. For demonstration
    purposes, here’s the code for a uselessly simple and rather silly custom exception
    and its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-45: *silly_walk_exception.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I define a new class with the name of the exception ❶, and I inherit from the
    most *specific* exception class that makes sense ❷. In this case, I’m inheriting
    from `RuntimeError` because my exception doesn’t fit into the description of any
    of the other built-in exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: There’s some debate about whether it’s necessary to write an initializer for
    custom exceptions. I prefer to, because it provides an opportunity to specify
    a default error message ❸. Writing your own initializer also allows you to accept
    and store multiple parameters for various bits of information, not just the message
    attribute that all `Exception` classes must have (although I don’t do that here).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you accept a string for a message and don’t want to provide a default, you
    can get away with this version to define the custom exception class with nothing
    more than a header and a docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Either way, the custom exception can be raised ❹ and caught ❺ in the same way
    as any other exception.
  prefs: []
  type: TYPE_NORMAL
- en: A Gallery of Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python documentation provides an exhaustive list of all the built-in exceptions
    and their uses. You can find this list at [https://docs.python.org/library/exceptions.xhtml](https://docs.python.org/library/exceptions.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since that documentation can feel like an information dump, I’ll briefly
    cover the most common exception classes. There are four base classes from which
    all the other exceptions are inherited; when you need to catch an entire category
    of exceptions, you can often use these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseException` is the base class for all exceptions. Remember not to inherit
    directly from this; it’s not designed to be used as such.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Exception` is the base class for all error-type exceptions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ArithmeticError` is the base class for arithmetic-related errors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LookupError` is the base class for any error related to finding values in
    collections.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, after the base exception classes, come the *concrete exceptions*, each
    of which describes a particular type of error. As of this writing, there are 35
    concrete exceptions in the Python language, although I’m only covering some of
    the most common of these (see the documentation for the rest). A few others will
    be introduced in later chapters. All of these inherit directly from `Exception`,
    except as noted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AttributeError` is raised when accessing or assigning to a class attribute
    that doesn’t exist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ImportError` is raised when an `import` statement isn’t able to find a package,
    module, or a name within the module. You may also encounter the subclass exception
    `ModuleNotFoundError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IndexError` is raised when an index (subscript) is out of range for a sequential
    collection, such as a list or tuple. This inherits from `LookupError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`KeyError` is raised when a key is not found in a dictionary. This inherits
    from `LookupError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`KeyboardInterrupt` is raised when the user presses a key-key combination to
    interrupt the running program, such as with Ctrl-C on UNIX-like systems. This
    inherits from `BaseException`, not `Exception`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MemoryError` is raised when Python runs out of memory. However, there are
    still steps you can take to (probably) fix the problem, usually by deleting stuff.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NameError` is raised when a name is not found in the local or global scope.
    This isn’t used in relation to class attributes (see `AttributeError`) or imports
    (see `ImportError`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OSError` is both a concrete error and a base class for many exceptions relating
    to the operating system, including `FileNotFoundError` (which is raised when a
    file cannot be opened). I’ll explore some of these in later chapters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OverflowError` is raised when an arithmetic operation would produce a result
    that is too large to be represented or stored. This mainly occurs with floating-point
    numbers. Integers never raise `OverflowError`, because they have no official size
    limits in Python; they will raise a `BufferError` if a similar situation occurs.
    This inherits from `ArithmeticError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RecursionError` is raised when a function calls itself too many times (see
    Chapter 6), whether directly or indirectly. This inherits from `RuntimeError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RuntimeError` is a sort of catch-all for any error that doesn’t fit into the
    other categories.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SyntaxError` is raised if there are any syntax errors in the Python code.
    These often come up when you run your program, but you may encounter them at any
    point during runtime when using arbitrary execution (see Chapter 15). This also
    includes the subclasses `IndentationError` and `TabError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SystemError` is raised when the interpreter has an internal error. There’s
    not much you can do about these errors; report them to the developers of the Python
    implementation you use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SystemExit` is raised when `sys.exit()` is called. Be careful about catching
    this, as you can prevent your program from quitting normally! This inherits from
    `BaseException`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TypeError` is raised when an operation or function tries to act on an object
    of the wrong type. This is the best exception to raise if your function is not
    intended to work on a particular value type received as an argument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UnboundLocalError`, a subclass of `NameError`, is raised when you try to access
    a local name that has no value yet assigned to it. This inherits from `NameError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ValueError` is raised when an operation or function tries to act on an argument
    that is the right *type*, but the wrong *value*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ZeroDivisionError` is raised when trying to divide by zero, whether through
    the true division (`/`), floor division (`//`), modulo (`%`), or `divmod()` operators.
    This inherits from `ArithmeticError`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve spent a lot of time discussing how and when to use exceptions and error
    handling. This is a vast topic, yet the syntax itself boils down to the structure
    of `try`, `except`, `else`, `finally`, and the `raise` keyword.
  prefs: []
  type: TYPE_NORMAL
