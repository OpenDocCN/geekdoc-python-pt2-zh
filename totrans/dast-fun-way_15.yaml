- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Graphs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Graphs are one of the fundamental data structures in computer science. They
    arise throughout numerous problems and programming tasks. Unlike the other data
    structures in this book, designed to optimize certain computations, the structure
    of *graphs* arises naturally from the data itself. In other words, graphs mirror
    the data they represent. Examining graph algorithms gives us insight into how
    we can define algorithms to utilize the inherent structure of the data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图是计算机科学中最基本的数据结构之一。它们出现在许多问题和编程任务中。与本书中其他旨在优化特定计算的数据结构不同，*图*的结构自然地来源于数据本身。换句话说，图反映了它们所表示的数据。研究图算法让我们深入了解如何定义算法以利用数据的固有结构。
- en: 'Previous chapters focused on the problem of structuring the data to aid the
    algorithms; high-level problems, such as searching for a value, motivated and
    drove the design of the facilitating data structures. This chapter covers the
    opposite problem: graphs show us how the structure of the data can drive the development
    of new algorithms. In other words, given data in the form of a graph, we examine
    how to create algorithms that will use it. This chapter examines three graph algorithms
    that use different aspects of the graph’s structure: Dijkstra’s algorithm for
    shortest paths, Prim’s algorithm for minimum-cost spanning trees, and Kahn’s algorithm
    for topological sort.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节集中讨论了如何构造数据以辅助算法的实现；高层次的问题，如查找某个值，推动并驱动了相关数据结构的设计。本章讨论的是相反的问题：图展示了数据的结构如何推动新算法的发展。换句话说，给定以图的形式呈现的数据，我们将探讨如何创建能够使用这些数据的算法。本章将研究三种图算法，它们利用了图的不同结构特性：用于最短路径的迪杰斯特拉算法、用于最小成本生成树的普里姆算法，以及用于拓扑排序的卡恩算法。
- en: Introducing Graphs
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入图
- en: Graphs are composed of a set of *nodes* and a set of *edges*. As shown in [Figure
    15-1](#figure15-1), each edge connects a pair of nodes. This structure is similar
    to a large number of real-world systems, including social networks (nodes are
    people and edges are their connections), transportation networks (nodes are cities
    and edges represent paths), and computer networks (nodes are computers and edges
    represent the connections between them). This variety of real-world analogs makes
    graph algorithms fun to visualize, as simple searches transform into careful exploration
    of castles or frantic sprints through a city’s crowded alleys.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图由一组*节点*和一组*边*组成。如[图 15-1](#figure15-1)所示，每条边连接一对节点。这种结构与许多现实世界的系统相似，包括社交网络（节点是人，边是他们的连接）、交通网络（节点是城市，边代表路径）和计算机网络（节点是计算机，边表示它们之间的连接）。这种现实世界的类比使得图算法在可视化时充满乐趣，因为简单的搜索转变为对城堡的细致探索或在城市拥挤小巷中疯狂奔跑。
- en: '![A graph with nodes labeled A through H and lines between the linked nodes.](image_fi/502604c15/f15001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![带有节点A到H标记和节点间连接线的图。](image_fi/502604c15/f15001.png)'
- en: 'Figure 15-1: A graph with undirected edges'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-1：带有无向边的图
- en: 'A graph’s edges can have additional properties to capture the real-world complexities
    of the data such as whether or not the edges are directional. *Undirected edges*,
    like those in the graph in [Figure 15-1](#figure15-1), represent two-way relationships
    such as most roads and happy friendships. *Directed edges*, as illustrated in
    [Figure 15-2](#figure15-2),are like one-way streets and indicate a flow in a single
    direction. To represent undirected access, we use a pair of directed edges—one
    in each direction—between nodes. In a social context, directed edges could represent
    romantic interest in a television teen drama: an edge from Alice to Bob indicates
    Alice likes Bob, while the lack of an edge from Bob to Alice illustrates the devastating
    lack of reciprocity.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图的边可以具有额外的属性，以捕捉数据的现实复杂性，例如边是否是有向的。*无向边*，如[图 15-1](#figure15-1)中的图所示，表示双向关系，如大多数道路和美好的友谊。*有向边*，如[图
    15-2](#figure15-2)中所示，类似单行道，表示单向流动。为了表示无向连接，我们使用一对有向边——每个方向一条——在节点之间连接。在社交背景下，有向边可以代表电视剧中的浪漫兴趣：从爱丽丝到鲍勃的边表示爱丽丝喜欢鲍勃，而鲍勃到爱丽丝的边缺失则表现出缺乏互惠的致命困境。
- en: '![A graph with nodes labeled A through H and arrows between the linked nodes.
    Some nodes are connected by two arrows, pointing in both directions, and some
    nodes have only one arrow. ](image_fi/502604c15/f15002.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![带有节点A到H标记和节点间箭头的图。某些节点之间由两个箭头连接，指向相反的方向，其他节点只有一个箭头。](image_fi/502604c15/f15002.png)'
- en: 'Figure 15-2: A graph with directed edges'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-2：一个带有有向边的图
- en: In addition to allowing us to model one-way streets or unrequited love, directed
    edges allow us to model more abstract problems, such as task dependence. We can
    specify a set of tasks as nodes and use directed edges to indicate the order dependency
    between tasks. In this way, we could create a graph to represent the tasks required
    for brewing the perfect cup of coffee, as shown in [Figure 15-3](#figure15-3).
    Nodes include such steps as heating the water, measuring out the beans, grinding
    the beans, and adding water to the grounds. The edges represent dependencies between
    these steps. We need to add a directed edge from the node for “grinding beans”
    to the node for “putting the grounds in the filter” to indicate that we must grind
    the beans first. The order of these two steps is critical, as anyone who has tried
    brewing unground beans can attest. However, we wouldn’t need an edge between “heating
    the water” and “grinding the beans” in either direction. We can perform those
    tasks in parallel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让我们建模单行道或单相思外，有向边还允许我们建模更抽象的问题，如任务依赖关系。我们可以将一组任务指定为节点，并使用有向边表示任务之间的顺序依赖关系。通过这种方式，我们可以创建一个图来表示酿造完美咖啡所需的任务，如[图
    15-3](#figure15-3)所示。节点包括加热水、称量咖啡豆、研磨咖啡豆和将水加入咖啡粉等步骤。边表示这些步骤之间的依赖关系。我们需要在“研磨咖啡豆”节点和“将咖啡粉放入滤纸”节点之间添加一条有向边，表示我们必须先研磨咖啡豆。这两个步骤的顺序至关重要，任何尝试过直接用未研磨咖啡豆酿咖啡的人都能证明这一点。然而，我们不需要在“加热水”和“研磨咖啡豆”之间建立边，两个步骤可以并行进行。
- en: '![Six tasks involved in making coffee such as Measure beans, Fill Kettle, Heat
    Water, and so forth. An arrow from Measure Beans pointing to Grind Beans indicates
    the necessary ordering. ](image_fi/502604c15/f15003.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![制作咖啡时涉及的六个任务，如称量咖啡豆、加水、加热水等。一个从“称量咖啡豆”指向“研磨咖啡豆”的箭头表示必要的顺序。](image_fi/502604c15/f15003.png)'
- en: 'Figure 15-3: Using a graph to represent the order of operations for a task'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-3：使用图表示任务的操作顺序
- en: Edge weights further increase the modeling power of graphs. *Weighted edges*
    capture not only the link between nodes but also the cost of that link. For example,
    we could weight the edges in a transportation graph by the distance between locations.
    We could augment our social network with a measure of closeness, such as a count
    of how many times two nodes have spoken in the last month. [Figure 15-4](#figure15-4)
    shows our example graph with weighted edges.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 边的权重进一步增强了图的建模能力。*加权边*不仅捕捉了节点之间的连接，还捕捉了该连接的成本。例如，我们可以根据位置之间的距离给运输图中的边加权。我们还可以在社交网络中加入亲密度度量，比如计算过去一个月两个节点之间交流的次数。[图
    15-4](#figure15-4)展示了我们带有加权边的示例图。
- en: '![A graph contains nodes labeled A through H with lines between the linked
    nodes. Each line is labeled with a number. For example, the edge between A and
    C has weight 0.5.](image_fi/502604c15/f15004.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个图包含标记为 A 到 H 的节点，节点之间有连线。每条线都有一个数字标签。例如，A 和 C 之间的边的权重为 0.5。](image_fi/502604c15/f15004.png)'
- en: 'Figure 15-4: A graph with weighted edges'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-4：一个带有加权边的图
- en: Using a combination of weighted and directed edges allows us to capture complex
    interrelations among the nodes. Entire social dramas can be represented and played
    out through the nodes and edges of a well-constructed graph.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加权和有向边的组合可以帮助我们捕捉节点之间复杂的相互关系。通过一个精心构建的图，整个社会剧本可以通过节点和边来表示并演绎出来。
- en: Representing Graphs
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图的表示
- en: While the abstract structure of a graph is relatively simple, there are multiple
    ways to represent nodes and edges in the computer’s memory. Two of the most common
    representations are *adjacency matrices* and *adjacency lists*. Both representations
    can handle directed, undirected, weighted, and unweighted edges. As with all the
    other data structures in this book, the difference between these structures lies
    in how the data is stored in memory and thus how different algorithms can access
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图的抽象结构相对简单，但有多种方法可以在计算机的内存中表示节点和边。两种最常见的表示方法是*邻接矩阵*和*邻接表*。这两种表示方法都可以处理有向、无向、加权和非加权边。与本书中的其他数据结构一样，这些结构的差异在于数据如何存储在内存中，从而影响不同算法如何访问这些数据。
- en: 'The adjacency list formulation stores a separate list of neighbors for each
    node. We could use an array or linked list of neighbors within the node composite
    data structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接表表示法为每个节点存储一个单独的邻居列表。我们可以在节点的复合数据结构中使用数组或链表来存储邻居：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or we could even create a separate edge data structure to store auxiliary information
    about the edges, such as their directionality or weights. For the examples below,
    we also provide a single numerical ID for each of the nodes, corresponding to
    the node’s index in the parent graph data structure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们甚至可以创建一个单独的边数据结构来存储关于边的辅助信息，如它们的方向性或权重。对于下面的示例，我们还为每个节点提供了一个单一的数字ID，表示该节点在父图数据结构中的索引。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In either case, the graph itself would contain an array of nodes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，图本身都会包含一个节点数组：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Regardless of the exact implementation, we can access the neighbors of any given
    node through a list linked from the node itself. [Figure 15-5](#figure15-5) shows
    an example of this structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论具体实现如何，我们都可以通过从节点本身链接的列表访问任何给定节点的邻居。[图15-5](#figure15-5)展示了这种结构的一个示例。
- en: In the case of directed edges, a node’s list of edges or neighboring nodes contains
    only those that can be accessed when *leaving* the node. For example, node A may
    contain an edge to node B while B does not contain an edge to A.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向边的情况下，节点的边或邻接节点列表仅包含那些在*离开*该节点时可以访问的节点。例如，节点A可能包含指向节点B的边，而节点B则不包含指向A的边。
- en: Adjacency lists provide a localized view of neighbor relationships that mirrors
    real-world cases such as social networks. Each node tracks only the node to which
    it has connections. Similarly, in a social network, each person determines who
    qualifies as their friend, thus maintaining a list of their own connections. We
    don’t need a separate central repository to tell us who our friends are, and we
    might not have a full view into anyone else’s friends. Arguably, we might not
    even know which of our friends (outgoing edge) actually consider us a friend in
    return (incoming edge). We know only about our own outgoing connections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接列表提供了一种本地化的邻居关系视图，反映了像社交网络这样的现实世界情况。每个节点只跟踪它连接的节点。类似地，在社交网络中，每个人会确定谁是他们的朋友，从而保持自己的连接列表。我们不需要一个单独的中央存储库来告诉我们谁是我们的朋友，而且我们可能并不完全了解其他人的朋友。可以说，我们甚至不知道我们的哪些朋友（出边）实际上把我们当做朋友（入边）。我们只知道自己发出的连接。
- en: '![On the left is a graph with nodes represented as circles and edges as lines.
    On the right is the same graph represented as an array of nodes with a list of
    edges. For example, node A has a list of neighbors B, C, and D.](image_fi/502604c15/f15005b.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![左侧是一个图，节点表示为圆圈，边表示为线条。右侧是相同的图，以节点数组和边列表的形式表示。例如，节点A有一个邻居节点B、C和D的列表。](image_fi/502604c15/f15005b.png)'
- en: 'Figure 15-5: A graph (left) and its adjacency list representation (right).
    Each node stores a list of neighboring nodes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-5：一个图（左）及其邻接列表表示（右）。每个节点存储一个邻接节点的列表。
- en: In contrast, an adjacency matrix represents a graph as a matrix, as shown in
    [Figure 15-6](#figure15-6), with one row and one column for each node. The value
    in row *i*, column *j* represents the weight of the edge from node *i* to node
    *j*. A value of zero indicates that no such edge exists. This representation allows
    us to directly look up whether an edge exists between any two nodes from a single
    central data source.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，邻接矩阵将图表示为一个矩阵，如[图15-6](#figure15-6)所示，每个节点都有一行和一列。第*i*行，第*j*列的值表示从节点*i*到节点*j*的边的权重。零值表示没有这样的边。此表示法允许我们直接查找是否存在任意两个节点之间的边，从单一的中央数据源中获取信息。
- en: '![The graph from Figure 15‐5 shown as a matrix. The row for node A is all zeros
    except entries of 1 for the columns B, C, and D.](image_fi/502604c15/f15006.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图15-5中的图表示为一个矩阵。节点A的行除了B、C和D列为1外，其他列均为0。](image_fi/502604c15/f15006.png)'
- en: 'Figure 15-6: The adjacency matrix representation of a graph'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-6：图的邻接矩阵表示
- en: This global view of the graph arises in real-world situations where a single
    planner is viewing the entire network. For instance, an airline company may use
    a global view of flight routes, where nodes are airports and edges indicate flights
    between them, to plan new service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图的全局视图出现在现实世界中，当一个单一的规划者需要查看整个网络时。例如，航空公司可能会使用航线的全局视图，其中节点是机场，边表示机场之间的航班，用于规划新服务。
- en: While the adjacency graph representation is useful in some cases, we will focus
    on the adjacency list representation for the remainder of this chapter. The list
    representation fits naturally with the pointer-based approach we’ve been using
    for other data structures. Further, the use of individual node data structures
    allows additional flexibility in terms of storing auxiliary data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然邻接图表示法在某些情况下非常有用，但本章剩余部分我们将重点讨论邻接列表表示法。列表表示法与我们在其他数据结构中使用的基于指针的方法自然契合。此外，使用独立的节点数据结构允许在存储辅助数据方面提供更多的灵活性。
- en: Searching Graphs
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索图
- en: If we look back to our web-crawling example from Chapter 4, where we explored
    our favorite online encyclopedia for information related to coffee grinders, we
    can immediately see how the links in our favorite online encyclopedia form a graph
    of topics, with each page representing a node and each hyperlink representing
    a directed edge. We can progressively explore topics, diving deeper and deeper
    into the world of coffee grinders, by iteratively exploring each node and adding
    new nodes onto our list of topics to explore in the future. This type of exploration
    forms the basis of a graph search.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下第4章中的网页爬行示例，当时我们为寻找与咖啡研磨机相关的信息而探索我们最喜欢的在线百科全书，我们可以立刻看到我们最喜欢的在线百科全书中的链接如何形成一个话题图，每个页面代表一个节点，每个超链接代表一个有向边。我们可以通过迭代地探索每个节点，并将新的节点添加到未来要探索的话题列表中，从而逐渐探索话题，深入了解咖啡研磨机的世界。这种探索方式构成了图搜索的基础。
- en: Imagine that we are interested in finding a specific node in the graph. Perhaps
    we are conducting online research and looking for a coffee brand whose name we
    have long forgotten. We explore the relevant web pages (graph nodes) one at a
    time, reading the information on one page before moving to another. As we saw
    in Chapter 4, the order in which we explore the nodes greatly influences our search
    pattern. By using a stack data structure to track our future exploration options,
    we conduct a depth-first search over the graph. We pursue individual paths deeper
    and deeper until we hit a dead end. Then we backtrack and try other options we
    skipped along the way. If we instead use a queue to track our future search states,
    we perform a breadth-first search over the nodes. We check the nodes closer to
    our starting location before venturing further and further into the graph. Of
    course, there are a variety of other ways we could order our search. For example,
    best-first search orders the future nodes according to a ranking function, focusing
    on exploring high-scoring nodes first. In our search for nearby coffee shops in
    a new city, this prioritization of nodes can keep us from wasting hours wandering
    through residential neighborhoods instead of focusing on commercial areas.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们希望在图中找到一个特定的节点。也许我们正在进行在线研究，寻找一个我们早已忘记名字的咖啡品牌。我们一次浏览相关网页（图节点），在阅读完一页的信息后才移动到下一页。正如我们在第4章中看到的，我们探索节点的顺序会极大地影响我们的搜索模式。通过使用栈数据结构来跟踪我们未来的探索选项，我们在图中执行深度优先搜索。我们深入追寻每一条路径，直到遇到死胡同。然后我们回溯并尝试在过程中跳过的其他选项。如果我们改用队列来跟踪未来的搜索状态，我们将对节点执行广度优先搜索。我们会先检查离起始位置较近的节点，然后再逐步深入图中。当然，还有许多其他方法可以排序我们的搜索。例如，最佳优先搜索根据排名函数对未来的节点进行排序，首先集中探索高分节点。在我们寻找新城市附近的咖啡店时，这种对节点的优先级排序可以帮助我们避免浪费几个小时在住宅区闲逛，而是集中在商业区。
- en: Regardless of the order, the concept of searching a graph by exploring one node
    at a time illustrates the impact of the data’s structure on the algorithm. We
    use the links between nodes (edges) to constrain and guide the exploration. In
    the next few sections, we look at common useful algorithms that do exactly this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论顺序如何，通过一次探索一个节点来搜索图的概念都体现了数据结构对算法的影响。我们利用节点之间的连接（边）来限制并引导探索。在接下来的几节中，我们将介绍一些常用的有用算法，它们正是这样做的。
- en: Finding Shortest Paths with Dijkstra’s Algorithm
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dijkstra 算法寻找最短路径
- en: Probably the single most common task when dealing with real-world graphs is
    to find the shortest distance between two nodes. Imagine we’re visiting a new
    city for the first time. As morning dawns, we stumble out of our hotel room, jetlagged
    and in search of refreshment. As good travelers, we’ve done copious research on
    the city’s coffee scene and created a list of four coffee shops to sample while
    in town. As the elevator reaches the lobby, we pull out a street map of the city,
    carefully marked with the location of the hotel and those coffee shops. It’s time
    to determine how to get to the shops on our list.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 处理实际图形时，可能最常见的任务就是找到两个节点之间的最短距离。假设我们第一次访问一个新城市。清晨时分，我们从酒店房间里走出来，时差困扰着我们，正在寻找一处可以提神的地方。作为优秀的旅行者，我们做了大量关于城市咖啡文化的研究，并列出了四家咖啡店，计划在此期间品尝。随着电梯到达大堂，我们拿出了一张城市街道地图，地图上仔细标出了酒店和这些咖啡店的位置。现在是时候决定如何前往我们清单上的咖啡店了。
- en: '*Dijkstra’s algorithm*, invented by the computer scientist Edsger W. Dijkstra,
    finds the shortest path from any given starting node to all other nodes in the
    graph. It can work on directed, undirected, weighted, or unweighted graphs. The
    only constraint is that all the edge weights must be non-negative. You can never
    decrease the total path length by adding an edge. In our coffee-themed sightseeing
    example, we search for the shortest path from the hotel to each of the coffee
    shops. As shown in [Figure 15-7](#figure15-7), nodes represent either street intersections
    or shops along the street. Weighted, undirected edges represent the distance along
    the roads between these points.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dijkstra 算法*由计算机科学家 Edsger W. Dijkstra 发明，用于找到从任何给定起始节点到图中所有其他节点的最短路径。它可以在有向图、无向图、加权图或无权图上运行。唯一的限制是所有的边权重必须是非负的。你无法通过添加一条边来减少总路径长度。在我们的咖啡主题观光示例中，我们在搜索从酒店到每个咖啡店的最短路径。如图
    [Figure 15-7](#figure15-7) 所示，节点表示街道交叉口或街道上的商店。加权的无向边表示这些点之间沿道路的距离。'
- en: '![The top shows a map with one hotel, four coffee shops, and four street intersections.
    The figure at the bottom shows the graph representation. The weight of the edge
    between the hotel (a) and the first intersection (b) is 11 to indicate the distance.](image_fi/502604c15/f15007b.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![顶部展示了一张包含一个酒店、四家咖啡店和四个街道交叉口的地图。底部的图形展示了图形表示。酒店（a）和第一个交叉口（b）之间的边权重为 11，表示距离。](image_fi/502604c15/f15007b.png)'
- en: 'Figure 15-7: Points along a map with corresponding distances (top) can be represented
    as a weighted graph (bottom).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-7：地图上的各个点及其对应的距离（上图）可以表示为一个加权图（下图）。
- en: Our goal is to find the shortest path from the starting node to each of the
    coffee shop nodes. The intersection nodes aren’t goals in their own right but
    allow our path to branch over different streets.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到从起始节点到每个咖啡店节点的最短路径。交叉口节点本身并不是目标，而是允许我们的路径在不同街道之间分支。
- en: Dijkstra’s algorithm operates by maintaining a set of unvisited nodes and continually
    updating the *tentative* distance to each unvisited node. At each iteration, we
    visit the closest unvisited node. Upon doing so, we remove this new node from
    our unvisited set and update the distances to each of its unvisited neighbors.
    Specifically, we examine the new node’s neighbors and ask whether we have found
    a better path to each neighbor. We compute the length of the new proposed path
    by taking the distance to the current node and adding the distance (edge weight)
    to the neighbor. If this new distance is less than the best distance seen so far,
    we update the distance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法通过维护一组未访问的节点，并不断更新每个未访问节点的*暂定*距离来进行操作。在每次迭代中，我们访问最近的未访问节点。这样做后，我们将此新节点从未访问节点集合中移除，并更新其未访问邻居的距离。具体来说，我们检查新节点的邻居，询问是否找到了通向每个邻居的更短路径。我们通过计算到当前节点的距离并加上到邻居的距离（边权重），来计算新提议路径的长度。如果这个新距离小于目前为止看到的最短距离，我们就更新该距离。
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code starts by creating a series of helper data structures ❶, including
    an array of distances to each node (`distance`), an array indicating the last
    node visited before a given node (`last`), and a set of unvisited nodes (`unvisited`).
    The code then processes the unvisited nodes one by one. A `WHILE` loop iterates
    until the set of unvisited nodes is empty ❷. In each iteration, the code chooses
    the node with the minimal distance and removes it from the unvisited set ❸. A
    `FOR` loop iterates over each of the node’s neighbors ❹, computing the distance
    to that neighbor through the current node ❺ and updating the `distance` and `last`
    arrays if the code has found a better path ❻.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建一系列辅助数据结构❶，包括到每个节点的距离数组（`distance`）、指示给定节点前一个访问节点的数组（`last`）和未访问节点的集合（`unvisited`）。然后，代码逐个处理未访问的节点。`WHILE`循环迭代，直到未访问的节点集合为空❷。在每次迭代中，代码选择具有最小距离的节点，并将其从未访问集合中移除❸。`FOR`循环迭代每个节点的邻居❹，计算通过当前节点到达该邻居的距离❺，并在代码发现更好的路径时更新`distance`和`last`数组❻。
- en: '[Figure 15-8](#figure15-8) shows an example shortest-path search from node
    A in [Figure 15-4](#figure15-4)’s weighted graph. The circled node is the one
    currently being examined. The grayed-out nodes and list entries represent nodes
    that have been removed from the unvisited list and thus are no longer available
    for consideration.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-8](#figure15-8)展示了从[图15-4](#figure15-4)中节点A出发的最短路径搜索示例。被圈出的节点是当前正在检查的节点。灰色的节点和列表条目表示已从未访问列表中移除的节点，因此不再考虑。'
- en: For the search in [Figure 15-8](#figure15-8), we start Dijkstra’s algorithm
    with all distances at infinity except for node A, which is set to zero ([Figure
    15-8](#figure15-8)(1)). This starting configuration corresponds to our initial
    knowledge about the best paths. We are already at node A, so the best path there
    is trivial. Since we have not found paths to any of the other nodes, they could
    be any distance away. We also maintain information for each node of which node
    precedes it in our search. The `Last` column indicates the preceding node. This
    information allows us to trace paths backward. While not all uses will need to
    reconstruct the path, our coffee search certainly does. It is pointless to find
    the shortest distance to coffee if we don’t also find the actual path. To construct
    the path to node F, we follow the last pointers back until we reach node A.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图15-8](#figure15-8)中的搜索中，我们从所有距离初始化为无穷大开始执行Dijkstra算法，除了节点A，它的距离设置为零（[图15-8](#figure15-8)(1)）。这种初始配置对应了我们关于最佳路径的初步知识。我们已经处于节点A，所以到达那里最短路径是显而易见的。由于我们尚未找到通往其他任何节点的路径，它们可能距离我们很远。我们还会维护每个节点的前驱节点信息。`Last`列表示前驱节点。这些信息使我们能够追溯路径。并非所有情况都需要重建路径，但我们的咖啡搜索显然需要。找到到达咖啡的最短距离是没有意义的，如果我们没有找到实际路径的话。为了构建到节点F的路径，我们沿着前驱指针向回追溯，直到到达节点A。
- en: Our search starts, as shown in [Figure 15-8](#figure15-8)(2), by selecting the
    node with the smallest distance (node A), removing it from the unvisited list,
    and examining its neighbors. For each of A’s neighbors, we test whether traveling
    to that neighbor through A is shorter than any path seen so far. Since the distance
    to Node A is zero, the distance through A to each of its neighbors will be equal
    to the corresponding edge weights. Each time we update the distance to an unvisited
    node, we also update the back pointer to reflect the best path so far. Three nodes
    now point to A ([Figure 15-8](#figure15-8)(2)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索开始，如[图15-8](#figure15-8)(2)所示，选择具有最小距离的节点（节点A），将其从未访问列表中移除，并检查其邻居。对于A的每个邻居，我们测试通过A到达该邻居是否比目前为止发现的任何路径都要短。由于到节点A的距离为零，通过A到达每个邻居的距离将等于相应的边权重。每次我们更新到未访问节点的距离时，也会更新回指针，以反映到目前为止的最佳路径。目前有三个节点指向A（[图15-8](#figure15-8)(2)）。
- en: 'The search progresses, choosing the next closest, unvisited node. In this case,
    it could be either C or D. We break the tie using the node’s order in our list:
    node C wins! Again, we consider C’s neighbors and update their best distances
    ([Figure 15-8](#figure15-8)(3)). Remember the distances represent the best total
    distance from our starting node. The new distances are the sum of the distance
    to C and the distance from C to each neighbor.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续进行，选择下一个最接近的未访问节点。在这种情况下，它可以是C或D。我们通过节点在列表中的顺序打破平局：节点C获胜！接着，我们再次考虑C的邻居，并更新它们的最佳距离（[图15-8](#figure15-8)(3)）。请记住，这些距离表示从起始节点到达每个节点的最佳总距离。新的距离是从A到C的距离加上从C到每个邻居的距离。
- en: '![Nine subfigures show each step of Dijkstra’s algorithm. In subfigure 2, node
    A is grayed out and circled. The table to the right of each graph shows the current
    best distance from each node and the last node along that path.](image_fi/502604c15/f15008.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![九个子图展示了 Dijkstra 算法的每个步骤。在子图 2 中，节点 A 被灰色标记并圈出。每个图形右侧的表格显示了从每个节点到达当前最佳距离及沿该路径的最后一个节点。](image_fi/502604c15/f15008.png)'
- en: 'Figure 15-8: An example of Dijkstra’s algorithm on a weighted graph'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-8：加权图上 Dijkstra 算法的一个例子
- en: The search progresses to node D—the new unvisited node with the minimum distance
    ([Figure 15-8](#figure15-8)(4)). While examining node D’s neighbors, we find new
    shortest distances to both nodes E and F. Node E is particularly interesting,
    as we already had a candidate path to E through C. We can travel from A to C to
    E with a distance of 1.0\. However, this is not the best possible path. Our search
    revealed a new path, through D, that is slightly shorter with a total distance
    of 0.9\. We update both the potential distance and the backward pointer. Our best
    path to E now goes through D. On to the next closest node in our unvisited set,
    node F!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索进展到节点 D——新的未访问节点，且其具有最小距离（[图 15-8](#figure15-8)(4)）。在检查节点 D 的邻居时，我们发现了通往节点
    E 和 F 的新最短路径。节点 E 特别有趣，因为我们已经有了一条通过 C 到 E 的候选路径。我们可以从 A 到 C 再到 E，总距离为 1.0。然而，这并不是最佳路径。我们的搜索发现了一条新的路径，通过
    D，比原路径稍短，总距离为 0.9。我们更新了潜在距离和回溯指针。现在我们通往 E 的最佳路径是通过 D。接下来，前往我们的下一个未访问节点 F！
- en: The search continues through the remaining nodes, but nothing else interesting
    occurs. The remaining nodes are all at the end of the shortest paths and don’t
    offer opportunities for shorter paths. For example, when considering node E’s
    neighbors ([Figure 15-8](#figure15-8)(6)), we examine both nodes C and D. The
    distance to either node when traveling through E would be 1.4, longer than the
    paths we’ve already discovered. In fact, both C and D have already been visited,
    so we wouldn’t even consider them. Similar logic applies when considering nodes
    B, H, and G as shown in [Figure 15-8](#figure15-8)(7), 15-8(8), and 15-8(9). Since
    those nodes’ neighbors have all been visited, we do not consider them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续遍历剩余的节点，但没有发生其他有趣的事情。剩下的节点都位于最短路径的末尾，无法提供更短的路径。例如，当考虑节点 E 的邻居时（[图 15-8](#figure15-8)(6)），我们检查了节点
    C 和 D。从 E 路径到这两个节点的距离为 1.4，长于我们已发现的路径。事实上，C 和 D 都已经被访问过，所以我们根本不会再考虑它们。类似的逻辑适用于考虑节点
    B、H 和 G，如 [图 15-8](#figure15-8)(7)、15-8(8) 和 15-8(9) 所示。由于这些节点的邻居已经被访问过，因此我们不再考虑它们。
- en: In examining how Dijkstra’s algorithm traverses a graph while finding the shortest
    path, we can see the clear interrelation between the structure of the data and
    the algorithm itself. Shortest-path algorithms like Dijkstra’s are only necessary
    because of the structure of the problem. If we could effortlessly hop from any
    node to any other node, there would be no need to find a path along the edges.
    This is the real-world equivalent of teleporting from our hotel lobby to the target
    coffeeshop—convenient, but not allowed by the structure of the physical world.
    Thus, while searching for these shortest paths, we need to obey the structure
    of the graph itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 Dijkstra 算法如何遍历图形并找到最短路径时，我们可以清楚地看到数据结构与算法本身之间的紧密联系。像 Dijkstra 这样的最短路径算法之所以必要，是因为问题的结构本身。如果我们能轻松地从任何节点跳跃到其他节点，就不需要沿着边寻找路径。这就像是从酒店大堂瞬移到目标咖啡店——方便，但却不符合物理世界的结构。因此，在寻找最短路径时，我们需要遵循图本身的结构。
- en: Finding Minimum Spanning Trees with Prim’s Algorithm
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Prim 算法寻找最小生成树
- en: 'The problem of finding the *minimum spanning tree* of a graph provides another
    example of how the structure of graph data enables us to ask new questions and
    thus create new algorithms suited to answering these questions. The minimum spanning
    tree of an undirected graph is the smallest set of edges such that all of the
    nodes are connected (if possible). We can think of these trees in terms of a budget-conscious
    city planner, trying to determine which roads to pave. What is the absolute minimal
    set of roads needed in order to ensure that anyone can get from one place (node)
    to any other place (node) on a paved road? If the edges are weighted, such as
    by the distance or the cost of paving a road, we extend the concept to finding
    the set that minimizes the total weight: the *minimum-cost spanning tree* is the
    set of edges with the minimum total weight that connect all the nodes.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 求解图的*最小生成树*问题提供了另一个例子，说明图数据的结构如何使我们能够提出新的问题，从而创造出适合回答这些问题的新算法。无向图的最小生成树是能够连接所有节点的最小边集（如果可能的话）。我们可以将这些树看作是一个精打细算的城市规划师，试图决定铺设哪些道路。为了确保每个人都能通过铺设的道路从一个地方（节点）到达任何其他地方（节点），需要铺设哪些最少的道路？如果边有权重，比如按距离或铺设道路的成本来计算，我们可以扩展这个概念，找到最小化总权重的边集：*最小成本生成树*是一个边集，其总权重最小，能够连接所有节点。
- en: One method of finding the minimum spanning tree is *Prim’s algorithm*, which
    was independently proposed by multiple people, including computer scientist R.
    C. Prim and mathematician Vojtˇech Jarník. The algorithm operates very similarly
    to Dijkstra’s algorithm in the previous section, working through an unvisited
    set and building up a minimum spanning tree one node at a time. We start with
    an unvisited set of all nodes and randomly choose one to visit. This visited node
    forms the start of our minimum spanning tree. Then, on each iteration, we find
    the unvisited node with the minimum edge weight when compared to *any* of the
    nodes that we’ve previously visited. We are asking, “Which node is closest to
    our set’s periphery and thus can be added with the least cost?” We remove this
    new node from the unvisited set and add the corresponding edge to our minimum-cost
    spanning tree. We keep adding nodes and edges, one per iteration, until every
    node has been visited.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找最小生成树的一种方法是*普里姆算法*，该算法由包括计算机科学家R.C.普里姆和数学家Vojtˇech Jarník在内的多位研究者独立提出。该算法的工作方式与前一节中的迪杰斯特拉算法非常相似，都是通过一个未访问的节点集，一次处理一个节点，逐步构建最小生成树。我们从一个包含所有节点的未访问集开始，随机选择一个节点进行访问。这个被访问的节点成为我们最小生成树的起点。然后，在每次迭代中，我们找到一个未访问的节点，其与我们已访问节点中*任何*一个的边权重最小。我们在问：“哪个节点离我们集合的边缘最近，因此可以以最小的成本加入？”我们将这个新节点从未访问集移除，并将对应的边添加到我们的最小成本生成树中。我们继续在每次迭代中添加一个节点和一条边，直到每个节点都被访问过。
- en: We can picture Prim’s algorithm as a construction company hired to build bridges
    between islands in an archipelago. The builders start at a single island and work
    outward, connecting more and more islands. At each step, they choose the closest
    island to the ones in the currently connected set. One end of the bridge sits
    on an island in the connected set and one end sits on an island outside the connected
    set (bringing the new island into the connected set). By always starting new bridges
    from an island in the connected set, the builders are able to move their equipment
    to the starting island using the existing bridges. And by always ending bridges
    on islands outside the connected set, the builders increase the coverage of the
    connected set at every stage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把普里姆算法想象成一家公司，受雇建造连接群岛之间的桥梁。建设者从一个岛屿开始，逐渐向外扩展，连接更多的岛屿。在每一步，他们选择离当前已连接岛屿集最近的岛屿。桥的一端位于已连接岛屿集中的岛屿上，另一端位于未连接岛屿集中的岛屿上（将新岛屿加入已连接集）。通过始终从已连接集中的岛屿开始建造新桥，建设者能够利用现有的桥梁将设备运送到起始岛屿。并且通过始终将桥梁的另一端建在未连接集中的岛屿上，建设者能够在每一步扩大已连接集的覆盖范围。
- en: We can simplify the algorithm’s code by tracking additional information. At
    each step, we maintain a list of the best edge (including weight) that we have
    encountered to each node. Every time we remove a new node from the unvisited set,
    we examine that node’s unvisited neighbors and check whether there are better
    (i.e., lower-cost) edges to any of its neighbors. If there are, we update the
    neighbor’s entry in the list with the new edge and weight.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过跟踪更多信息来简化算法的代码。在每一步中，我们保持一份到每个节点的最佳边（包括权重）列表。每次从未访问集合中移除新节点时，我们检查该节点的未访问邻居，并检查是否有更好的（即，低成本的）边通向任何邻居。如果有，我们将该邻居的条目更新为新的边和权重。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code starts by creating a series of helper data structures ❶, including
    an array of distances to each node (`distance`), an array indicating the last
    node visited before a given node (`last`), a set of unvisited nodes (`unvisited`),
    and the final set of edges for the minimal spanning tree (`mst_edges`). As with
    Dijkstra’s algorithm, the pseudocode (and the figures we’ll discuss in a moment)
    use a combination of lists and sets for the sake of illustration. We can more
    efficiently implement the algorithm by storing the unvisited nodes in a min-heap
    keyed by the distance. For now, we will list all the values in order to explicitly
    illustrate what is happening.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建一系列辅助数据结构 ❶，包括到每个节点的距离数组（`distance`），一个指示在访问给定节点之前访问的最后一个节点的数组（`last`），未访问节点的集合（`unvisited`）和最小生成树的最终边集合（`mst_edges`）。与
    Dijkstra 算法一样，伪代码（以及我们稍后将讨论的图示）使用列表和集合的组合来进行说明。我们可以通过将未访问节点存储在一个以距离为键的最小堆中来更高效地实现算法。目前，为了明确展示发生的过程，我们将按顺序列出所有值。
- en: The code then proceeds like Dijkstra’s algorithm, processing the unvisited nodes
    one at a time. A `WHILE` loop iterates until the set of unvisited nodes is empty
    ❷. During each iteration, the node with the minimal distance to any of the visited
    nodes is chosen and removed from the unvisited set ❸. The code checks whether
    an incoming edge to the node exists, which is necessary because the first node
    visited will not have an incoming edge ❹, and adds the corresponding edges to
    the minimum spanning tree. After adding the new node, a `FOR` loop iterates over
    each of the node’s neighbors ❺, checking whether the neighbor is unvisited and,
    if so, checking its distance to the current node. In this case, the distance is
    simply the weight of the edge. The code finishes by returning the set of edges
    making up the minimum spanning tree.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码像 Dijkstra 算法一样，逐一处理未访问的节点。`WHILE` 循环迭代，直到未访问的节点集合为空 ❷。在每次迭代中，选择与任何已访问节点的距离最小的节点，并将其从未访问节点集合中移除
    ❸。代码检查是否存在通往该节点的入边，这是必要的，因为第一个被访问的节点不会有入边 ❹，并将相应的边加入到最小生成树中。添加新节点后，`FOR` 循环遍历该节点的每个邻居
    ❺，检查邻居是否未被访问，如果是，则检查其与当前节点的距离。在这种情况下，距离就是边的权重。代码最后返回构成最小生成树的边集合。
- en: Consider what happens when we run Prim’s algorithm on the weighted graph from
    [Figure 15-4](#figure15-4), as illustrated in [Figure 15-9](#figure15-9). We start
    with all last edges set to null (we have not found any yet) and all “best” distances
    to infinity. For simplicity’s sake, we’ll break ties in alphabetical order of
    the nodes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当我们在加权图上运行 Prim 算法时会发生什么，参考[图 15-4](#figure15-4)和[图 15-9](#figure15-9)中的示例。我们从将所有最后的边设置为
    null（我们还没有找到任何边）以及所有“最佳”距离设置为无穷大开始。为了简单起见，我们将按照节点的字母顺序打破平局。
- en: 'To begin, we remove the first node A from our unvisited set. We then consider
    all of A’s neighbors and check whether there is a lower-cost edge from A to that
    neighbor. Given that all our current best distances are infinity, this isn’t difficult.
    We find lower-cost edges for all of A’s neighbors: (A, B), (A, C), and (A, D).
    [Figure 15-9](#figure15-9)(1) shows this new state.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从未访问集合中移除第一个节点 A。然后，我们考虑 A 的所有邻居，并检查是否存在从 A 到该邻居的低成本边。由于我们当前所有的最佳距离都是无穷大，这一点并不难。我们找到所有
    A 的邻居的低成本边： (A, B)、(A, C) 和 (A, D)。[图 15-9](#figure15-9)(1) 显示了这种新状态。
- en: 'During the second iteration, we find two potential nodes in our unvisited set
    to use: C and D. Using alphabetical order to break the tie, we select C. We remove
    C from the unvisited set and add the edge (A, C) to our minimum-cost spanning
    tree. Examining C’s unvisited neighbors, we find better candidate edges to nodes
    E and G ([Figure 15-9](#figure15-9)(2)).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次迭代中，我们发现未访问集合中有两个潜在的节点可以使用：C和D。通过字母顺序来打破平局，我们选择了C。我们将C从未访问集合中移除，并将边（A, C）添加到最小成本生成树中。检查C的未访问邻居时，我们发现连接节点E和G的更好候选边（[图15-9](#figure15-9)(2)）。
- en: The next closest node is D. We remove that from our unvisited set and add the
    edge (A, D) to the minimum-cost spanning tree. When we examine D’s unvisited neighbors,
    we find new, lower-cost edges to both nodes E and F ([Figure 15-9](#figure15-9)(3)).
    Our best candidate edge to node E now originates from node D instead of node C.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最近的节点是D。我们将其从未访问集合中移除，并将边（A, D）添加到最小成本生成树中。当我们检查D的未访问邻居时，我们发现连接节点E和F的新低成本边（[图15-9](#figure15-9)(3)）。我们现在从节点D而不是节点C获得指向节点E的最佳候选边。
- en: 'The algorithm progresses through the remaining nodes in our unvisited set.
    Next, we visit node F, adding the edge (D, F), as shown in [Figure 15-9](#figure15-9)(4).
    Then, as shown in [Figure 15-9](#figure15-9)(5), we add node E and edge (D, E).
    The algorithm completes by adding nodes H, B, and G in that order. At each step,
    we add the corresponding best edge seen so far: (F, H), (F, B), and (C, G). The
    final three steps are shown in [Figure 15-9](#figure15-9)(6), [Figure 15-9](#figure15-9)(7),
    and [Figure 15-9](#figure15-9)(8), respectively.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 算法通过我们未访问节点集合中的其余节点进行处理。接下来，我们访问节点F，添加边（D, F），如[图15-9](#figure15-9)(4)所示。然后，如[图15-9](#figure15-9)(5)所示，我们添加节点E和边（D,
    E）。算法通过按顺序添加节点H、B和G来完成。在每一步中，我们添加迄今为止看到的对应最佳边：（F, H）、（F, B）和（C, G）。最后三个步骤分别显示在[图15-9](#figure15-9)(6)、[图15-9](#figure15-9)(7)和[图15-9](#figure15-9)(8)中。
- en: '![Eight subfigures show each step of Prim’s algorithm. In subfigure 1, node
    A is grayed out. The table to the right of each graph shows the current best distance
    to each remaining node and the corresponding edge.](image_fi/502604c15/f15009.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![八个子图展示了普里姆算法的每一步。在子图1中，节点A被灰色显示。每个图旁边的表格显示了到每个剩余节点的当前最佳距离及其对应的边。](image_fi/502604c15/f15009.png)'
- en: 'Figure 15-9: An example of Prim’s algorithm on a weighted graph'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-9：普里姆算法在加权图上的一个示例
- en: Prim’s algorithm doesn’t care about the total path lengths from our starting
    node. We’re only interested in the cost of adding the new node to our connected
    set—the edge weight that will link that node to any other node in the visited
    set. We are not optimizing for final drive times between nodes, just for minimizing
    the cost of paving roads or building new bridges.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法不关心从起始节点到最终节点的总路径长度。我们关心的只是将新节点添加到已连接集合中的成本——将该节点连接到已访问集合中任何其他节点的边的权重。我们并不是在优化节点之间的最终行驶时间，只是在最小化铺设道路或建造新桥梁的成本。
- en: What if we had broken ties randomly instead of by alphabetical order? When deciding
    between choosing nodes D or E from our unvisited set after [Figure 15-9](#figure15-9)(2),
    we could have used either one. If we had chosen E instead of D, we would have
    found a lower-cost edge weight linking D into our graph. The algorithm would link
    in node D through E rather than through A. This means that we can find different
    minimum-cost spanning trees for the same graph. Multiple different trees may have
    the same cost. Prim’s algorithm only guarantees that we find one of the trees
    with the minimal cost.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们随机打破平局，而不是按字母顺序来处理会怎样？在[图15-9](#figure15-9)(2)之后，决定在未访问集合中选择节点D或E时，我们可以选择任何一个。如果我们选择了E而不是D，我们会发现一个更低成本的边权，将D连接到图中。算法将通过E而不是通过A来连接节点D。这意味着我们可以为同一图找到不同的最小成本生成树。多个不同的树可能有相同的成本。普里姆算法仅保证我们找到其中一个具有最小成本的树。
- en: Topological Sort with Kahn’s Algorithm
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用卡恩算法进行拓扑排序
- en: Our final example of a graph algorithm uses the edges of a *directed acyclic
    graph* *(DAG)* to sort the nodes. A directed acyclic graph is a graph with directed
    edges arranged such that the graph contains no *cycles*, or paths that return
    to the same node, as shown in [Figure 15-10](#figure15-10). Cycles are critical
    in real-world road networks. It would be terrible if roads were constructed such
    that we could get from our apartment to our favorite coffee shop but could never
    navigate back. Yet this is exactly what happens in an acyclic graph—the path out
    of any node will never return to that same node.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个图算法示例使用*有向无环图*（*DAG*）的边来排序节点。一个有向无环图是一个具有有向边的图，这些边的排列方式确保图中没有*循环*，即没有回到同一节点的路径，如[图
    15-10](#figure15-10)所示。循环在现实世界的道路网络中至关重要。如果道路的建设方式是，我们可以从公寓到达最喜欢的咖啡店，但却永远无法返回，那将是非常糟糕的。然而，这正是无环图的特点——任何节点的出口路径都不会返回到该节点。
- en: '![The graph has nodes labeled A through F with arrows between linked nodes.
    Node A is linked to nodes C and D.](image_fi/502604c15/f15010.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![该图有标记为A到F的节点，节点之间有箭头连接。节点A连接到节点C和D。](image_fi/502604c15/f15010.png)'
- en: 'Figure 15-10: A directed acyclic graph'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-10：有向无环图
- en: 'We can use directed edges to indicate an ordering of the nodes. If the graph
    has an edge from A to B, node A must come before node B. We ordered nodes in this
    way in our coffee-brewing example at the beginning of the chapter: each node represented
    a step in the process, and each edge indicated one step’s dependency on the next.
    The person brewing the coffee has to perform a given step before they can perform
    any of the following steps. These types of dependencies arise throughout both
    computer science and the rest of life. An algorithm that sorts the nodes in order
    of their edges is called a *topological sort*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用有向边表示节点的排序。如果图中有一条从A到B的边，则节点A必须在节点B之前。我们在本章开始时的咖啡冲泡示例中以这种方式对节点进行了排序：每个节点代表一个步骤，每条边表示一个步骤对下一个步骤的依赖。冲泡咖啡的人必须在执行任何后续步骤之前先完成某个特定步骤。这种依赖关系在计算机科学和现实生活中随处可见。将节点按边的顺序排序的算法称为*拓扑排序*。
- en: Computer scientist Arthur B. Kahn developed one approach, now called *Kahn’s
    algorithm,* to perform topological sort on a directed acyclic graph representing
    events. This algorithm operates by finding the nodes with no incoming edges, removing
    them from our list of pending nodes, adding them to our sorted list, and then
    removing the outbound edges from that node. The algorithm repeats until we have
    added every node to our sorted list. Intuitively, this sort mirrors how we might
    perform a complex task in the real world. We start with a subtask that we can
    accomplish—one with no dependencies. We perform that subtask and then chose another
    to do. Any subtask that requires us to have performed a yet uncompleted task needs
    to wait on our list until we have finished all its dependencies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家亚瑟·B·卡恩开发了一种方法，现在被称为*卡恩算法*，用于对表示事件的有向无环图执行拓扑排序。该算法通过找到没有入度的节点，移除它们在待处理节点列表中的位置，将它们添加到排序后的列表中，然后删除该节点的出边来工作。算法重复这个过程，直到所有节点都添加到排序列表中。从直觉上讲，这种排序类似于我们在现实世界中完成复杂任务的方式。我们从一个可以完成的子任务开始——一个没有依赖关系的任务。完成这个子任务后，我们选择下一个任务。任何要求我们先完成其他任务的子任务，必须等待，直到我们完成所有依赖关系。
- en: When implementing Kahn’s algorithm, we don’t need to actually remove edges from
    our graph. It’s sufficient to keep an auxiliary array counting the number of incoming
    edges to each node and modifying those counts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现卡恩算法时，我们不需要实际从图中删除边。只需保持一个辅助数组，统计每个节点的入度，并修改这些计数即可。
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code starts by creating several helper data structures ❶, including an array
    to hold the sorted list of nodes (`sorted`), an array storing the count of incoming
    edges for each node (`count`), and a stack of the next node to add to `sorted`
    (`next`). The code uses a pair of nested `FOR` loops over the nodes (outer loop)
    and each node’s edges (inner loop) to count the number of incoming edges for each
    node ❷. Then a `FOR` loop over the `count` array finds nodes that have no incoming
    edges and inserts them into `next` ❸.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建几个辅助数据结构 ❶，包括一个数组用于存储排序后的节点列表（`sorted`），一个数组用于存储每个节点的入度（`count`），以及一个栈用于存储下一个要添加到`sorted`的节点（`next`）。代码使用一对嵌套的`FOR`循环遍历节点（外循环）和每个节点的边（内循环），以计算每个节点的入度
    ❷。然后，一个`FOR`循环遍历`count`数组，找到没有入度的节点并将它们插入到`next`中 ❸。
- en: The code then uses a `WHILE` loop to process the `next` stack until it is empty
    ❹. During each iteration, the code pops a node off the stack and adds it to the
    end of the `sorted` array. A `FOR` loop iterates over the node’s edges and reduces
    the count (effectively removing the incoming edge) for each neighbor ❺. Any neighbor
    with an incoming count of zero is added to `next` ❻. Finally, the code returns
    the array of sorted nodes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: If our graph does contain cycles, our sorted list will be incomplete. We may
    want to add an additional check at the end of the function to test that the number
    of elements in our sorted list equals the number of nodes in the graph.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Consider running this algorithm on the graph from [Figure 15-10](#figure15-10),
    as is illustrated in [Figure 15-11](#figure15-11). We start off by counting the
    number of incoming edges (shown as the number adjacent to each node) and determining
    that node A is the only node without any incoming edges ([Figure 15-11](#figure15-11)(1)).
    Kahn’s algorithm then adds A to the sorted list and removes its outgoing edges
    (by decreasing the corresponding counts), as shown in [Figure 15-11](#figure15-11)(2).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Seven subfigures show each step of a topological sort. In subfigure 2, node
    A is grayed out. The next list contains node C and the sorted list contains node
    A.](image_fi/502604c15/f15011.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-11: A topological sort on a directed acyclic graph'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We continue the algorithm on node C ([Figure 15-11](#figure15-11)(3)), which
    no longer has any incoming edges. We removed the only such edge when we processed
    node A. We remove C from our list of nodes under consideration (our stack `next`),
    remove its edges from the graph, and add it to the end of our sorted list. In
    the process, we’ve left node E without any incoming neighbors. E goes onto our
    stack.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The sort progresses through the remainder of the list. While processing node
    E, we remove the last incoming edges to node D, making it the next up for the
    algorithm ([Figure 15-11](#figure15-11)(4)). The sort then adds D, then F, then
    B to our sorted list as shown in [Figure 15-11](#figure15-11)(5), [Figure 15-11](#figure15-11)(6),
    and [Figure 15-11](#figure15-11)(7), respectively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Kahn’s algorithm presents an example of both the usefulness of directed edges
    in a graph and how we can design an algorithm to operate on them. The directionality
    of the edges further constrains how we explore nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Why This Matters
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphs are pervasive throughout computer science. Their structure allows them
    to mirror a large variety of real-world phenomena, from streets to social or computer
    networks to sets of complex tasks. Graphs are useful for tasks like path planning
    and determining the order in which to compile a program’s source code. There are
    a myriad of algorithms designed to operate over these data structures, performing
    such tasks as searching the graph, determining the minimum spanning tree, or determining
    the maximum flow through a graph. We could devote an entire book to this single
    vastly impactful data structure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图（Graph）在计算机科学中无处不在。它们的结构使得它们能够映射许多现实世界的现象，从街道到社交网络或计算机网络，再到复杂任务的集合。图在路径规划和确定编译程序源代码顺序等任务中非常有用。为这些数据结构设计了大量的算法，执行诸如图的搜索、确定最小生成树或计算图的最大流等任务。我们可以为这个极具影响力的数据结构写一本书。
- en: For the purposes of this chapter, however, we focus on the tight coupling between
    the structure of the data and the algorithms that operate on it. The graph structure
    of data drives new problems, such as finding the minimum spanning tree, and thus
    new algorithms. In turn, the algorithms use the graph structure of the data, traversing
    the edges and exploring from node to node. This interplay demonstrates the importance
    of understanding the structure of data when defining both problems and new solutions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们专注于数据结构与操作它的算法之间的紧密耦合。数据的图结构会驱动新问题的产生，例如寻找最小生成树，从而引发新的算法。反过来，这些算法利用数据的图结构，遍历边缘并从一个节点探索到另一个节点。这种相互作用展示了在定义问题和新解决方案时理解数据结构的重要性。
