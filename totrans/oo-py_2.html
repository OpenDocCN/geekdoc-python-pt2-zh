<html><head></head><body>
<p class="calibre1">method, passing in the new text to display. The setValue() method has an opti-</p>
<p class="calibre1">mization, too: it remembers the last text that it rendered, and before doing </p>
<p class="calibre1">anything else, it checks if the new text is the same as the previous text. If the </p>
<p class="calibre1">text has not changed, there is nothing to do and the method just returns. If </p>
<p class="calibre1">there is new text, it renders the new text into a surface to be drawn. </p>
<p class="calibre1">The draw() method 5 draws the image contained in the self.textSurface </p>
<p class="calibre1">instance variable into the window at the given location. This method should </p>
<p class="calibre1">be called in every frame. </p>
<p class="calibre1">There are multiple advantages to this approach:</p>
<p class="calibre1">•  The class hides all the details of pygame’s rendering of text, so the user </p>
<p class="calibre1">of this class never needs to know what pygame-specific calls are needed </p>
<p class="calibre1">to show text. </p>
<p class="calibre1"><b class="calibre3">134</b>   Chapter 6</p>
<p class="calibre1"><a id="p164"/>•  Each SimpleText object remembers the window that it draws into, the location where the text should be placed, and the text color. Therefore, </p>
<p class="calibre1">you only need to specify these values once, when you instantiate a </p>
<p class="calibre1">SimpleText object, typically before the main loop starts. </p>
<p class="calibre1">•  Each SimpleText object is also optimized to remember both the text that </p>
<p class="calibre1">it was last told to draw and the image (self.textSurface) that it made </p>
<p class="calibre1">from the current text. It only needs to render a new surface when the </p>
<p class="calibre1">text changes. </p>
<p class="calibre1">•  To show multiple pieces of text in a window, you only need to instanti-</p>
<p class="calibre1">ate multiple SimpleText objects. This is a key concept of object-oriented </p>
<p class="calibre1">programming. </p>
<p class="calibre1"><b class="calibre3">Demo Ball with SimpleText and SimpleButton </b></p>
<p class="calibre1">To cap this off, we’ll modify Listing 6-2 to use the SimpleText and SimpleButton </p>
<p class="calibre1">classes. The updated program in Listing 6-7 keeps track of the number of </p>
<p class="calibre1">times it goes through the main loop and reports that information at the top </p>
<p class="calibre1">of the window. Clicking the Restart button resets the counter. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo8_SimpleTextDisplay/Main_Bal TextAndButton.py</b></p>
<p class="calibre1"># pygame demo 8 - SimpleText, SimpleButton, and Ball</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import random</p>
<p class="calibre1">1 from Ball import *  # bring in the Ball class code</p>
<p class="calibre1">from SimpleText import *</p>
<p class="calibre1">from SimpleButton import *</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">BLACK = (0, 0, 0)</p>
<p class="calibre1">WHITE = (255, 255, 255)</p>
<p class="calibre1">WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30 </p>
<p class="calibre1"/>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()  </p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)</p>
<p class="calibre1">oFrameCountLabel = SimpleText(window, (60, 20), </p>
<p class="calibre1">'Program has run through this many loops: ', WHITE)</p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">135</b></p>
<p class="calibre1"><a id="p165"/>oFrameCountDisplay = SimpleText(window, (500, 20), '', WHITE)</p>
<p class="calibre1">oRestartButton = SimpleButton(window, (280, 60), </p>
<p class="calibre1">'images/restartUp.png', 'images/restartDown.png')</p>
<p class="calibre1">frameCounter = 0</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"/>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"/>
<p class="calibre1">3 if oRestartButton.handleEvent(event):</p>
<p class="calibre1">frameCounter = 0  # clicked button, reset counter</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">4 oBall.update()  # tell the ball to update itself</p>
<p class="calibre1">frameCounter = frameCounter + 1  # increment each frame</p>
<p class="calibre1">5 oFrameCountDisplay.setValue(str(frameCounter))</p>
<p class="calibre1"># 9 - Clear the window before drawing it again</p>
<p class="calibre1">window.fill(BLACK)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw the window elements</p>
<p class="calibre1">6 oBall.draw()  # tell the ball to draw itself</p>
<p class="calibre1">oFrameCountLabel.draw()</p>
<p class="calibre1">oFrameCountDisplay.draw()</p>
<p class="calibre1">oRestartButton.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND) </p>
<p class="calibre1"> <i class="calibre4">Listing 6-7:  An example main program to show Ball, SimpleText, and SimpleButton</i> At the top of the program, we import the code of the Ball, SimpleText, </p>
<p class="calibre1">and SimpleButton classes 1. Before our main loop starts, we create an instance </p>
<p class="calibre1">of the Ball 2, two instances of the SimpleText class (oFrameCountLabel for the </p>
<p class="calibre1">unchanging message label and oFrameCountDisplay for the changing dis-</p>
<p class="calibre1">play of frames), and an instance of the SimpleButton class that we store in </p>
<p class="calibre1">oRestartButton. We also initialize a variable frameCounter to zero, which we will </p>
<p class="calibre1">increment every time through the main loop. </p>
<p class="calibre1">In the main loop, we check if the user pressed the Restart button 3. If </p>
<p class="calibre1">True, we reset the frame counter. </p>
<p class="calibre1">We tell the ball to update its position 4. We increment the frame coun-</p>
<p class="calibre1">ter, then call the setValue() method of the text field to show the new count </p>
<p class="calibre1">of frames 5. Finally, we tell the ball to draw itself tell the text fields to draw </p>
<p class="calibre1">themselves, and tell the Restart button to draw itself, by calling the draw() </p>
<p class="calibre1">method of each object 6. </p>
<p class="calibre1"><b class="calibre3">136</b>   Chapter 6</p>
<p class="calibre1"><a id="p166"/>In the instantiation of the SimpleText objects, the last argument is a text color, and we specified that the objects should be rendered in WHITE so </p>
<p class="calibre1">they can be seen against a BLACK background. In the next chapter, I’ll show </p>
<p class="calibre1">how to expand the SimpleText class to incorporate more attributes, without </p>
<p class="calibre1">complicating the interface of the class. We’ll build a more full-featured text </p>
<p class="calibre1">object that has reasonable default values for each of these attributes, but </p>
<p class="calibre1">allows you to override those defaults. </p>
<p class="calibre1"><b class="calibre3">Interface vs. Implementation </b></p>
<p class="calibre1">The SimpleButton and SimpleText examples bring up the important topic of </p>
<p class="calibre1">interface versus implementation. As mentioned i<a href="index_split_001.html#p86">n Chapter 4, t</a>he interface refers to how something is used, while the implementation refers to how </p>
<p class="calibre1">something works (internally). </p>
<p class="calibre1">In an OOP environment, the interface is the set of methods in a class and </p>
<p class="calibre1">their related parameters—also known as the  <i class="calibre4">application programming interface </i></p>
<p class="calibre1"> <i class="calibre4">(API)</i>. The implementation is the actual code of all the methods in the class. </p>
<p class="calibre1">An external package such as pygame will most likely come with docu-</p>
<p class="calibre1">mentation of the API that explains the calls that are available and the </p>
<p class="calibre1">arguments you are expected to pass with each call. The full pygame API </p>
<p class="calibre1">documentation is available at <a href="https://www.pygame.org/docs/"> <i class="calibre4">https://www.pygame.org/docs/</i></a>. </p>
<p class="calibre1">When you write code that makes calls to pygame, you don’t need to worry </p>
<p class="calibre1">about the implementation of the methods you are using. For example, </p>
<p class="calibre1">when you make a call to blit() to draw image, you really don’t care  <i class="calibre4">how</i> </p>
<p class="calibre1">blit() does what it does; you just need to know  <i class="calibre4">what</i> the call does and what arguments need to be passed in. On the other side, you can trust that the </p>
<p class="calibre1">implementer(s) who wrote the blit() method have thought extensively </p>
<p class="calibre1">about how to make blit() work most efficiently. </p>
<p class="calibre1">In the programming world, we often wear two hats as both the imple-</p>
<p class="calibre1">menter and the application developer, so we need to make an effort to design </p>
<p class="calibre1">APIs that not only make sense in the current situation, but also are general </p>
<p class="calibre1">enough to be used by future programs of our own and by programs written </p>
<p class="calibre1">by other people. Our SimpleButton and SimpleText classes are good examples, </p>
<p class="calibre1">as they are written in a general way so that they can be reused easily. I’ll talk </p>
<p class="calibre1">more about interface versus implementation i<a href="#p192">n Chapter 8, w</a>hen we look at encapsulation. </p>
<p class="calibre1"><b class="calibre3">Callbacks</b></p>
<p class="calibre1">When using a SimpleButton object, we handle checking for and reacting to a </p>
<p class="calibre1">button click like this:</p>
<p class="calibre1">if oButton.handleEvent(event):</p>
<p class="calibre1">print('The button was clicked')</p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">137</b></p>
<p class="calibre1"><a id="p167"/>This approach to handling events works well with the SimpleButton class. </p>
<p class="calibre1">However, some other Python packages and many other programming lan-</p>
<p class="calibre1">guages handle events in a different way: with a  <i class="calibre4">callback</i>. </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">callback</b> </p>
<p class="calibre1">A function or method of an object that is cal ed when a particular action, event, or condition happens . </p>
<p class="calibre1">An easy way to understand this is to think about the 1984 hit movie </p>
<p class="calibre1"> <i class="calibre4">Ghostbusters</i>. The tagline for the movie is “Who you gonna call?” In the </p>
<p class="calibre1">movie, the Ghostbusters ran an ad on TV that told people that if they saw </p>
<p class="calibre1">a ghost (that’s the event to look for), they should call the Ghostbusters (the </p>
<p class="calibre1">callback) to get rid of it. Upon receiving the call, the Ghostbusters take the </p>
<p class="calibre1">appropriate actions to eliminate the ghost. </p>
<p class="calibre1">As an example, consider a button object that is initialized to have a </p>
<p class="calibre1">callback. When the user clicks the button, the button will call the callback </p>
<p class="calibre1">function or method. That function or method executes whatever code is </p>
<p class="calibre1">needed to react to the button click. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating a Cal back</b></i></p>
<p class="calibre1">To set up a callback, when you create an object or call one of an object’s </p>
<p class="calibre1">methods, you pass the name of a function or a method of an object to be </p>
<p class="calibre1">called. As an example, there is a standard GUI package for Python called </p>
<p class="calibre1">tkinter. The code needed to create a button with this package is very differ-</p>
<p class="calibre1">ent from what I have shown—here’s an example:</p>
<p class="calibre1">import tkinter</p>
<p class="calibre1"/>
<p class="calibre1">def myFunction():</p>
<p class="calibre1">print('myCallBackFunction was called')</p>
<p class="calibre1">oButton = tkinter.Button(text='Click me', command=myFunction) </p>
<p class="calibre1">When you create a button with tkinter, you must pass in a function (or </p>
<p class="calibre1">a method of an object), which will be called back when the user clicks the </p>
<p class="calibre1">button. Here, we are passing myFunction as the function to be called back. </p>
<p class="calibre1">(This call is using keyword parameters, which will be discussed at length </p>
<p class="calibre1">in <a href="#p172">Chapter 7.) T</a>he tkinter button remembers that function as the callback, and when the user clicks the resulting button, it calls the function </p>
<p class="calibre1">myFunction(). </p>
<p class="calibre1">You can also use a callback when you initiate some action that may </p>
<p class="calibre1">take some time. Instead of waiting for the action to finish and causing the </p>
<p class="calibre1">program appear to freeze for a period of time, you provide a callback to be </p>
<p class="calibre1">called when the action is completed. For example, imagine that you want to </p>
<p class="calibre1">make a request across the internet. Rather than making a call and waiting </p>
<p class="calibre1">for that call to return data, which may take a long time, there are packages </p>
<p class="calibre1">that allow you to use the approach of making the call and setting a callback. </p>
<p class="calibre1">That way, the program can continue running, and the user is not locked </p>
<p class="calibre1"><b class="calibre3">138</b>   Chapter 6</p>
<p class="calibre1"><a id="p168"/>out of it. This often involves multiple Python threads and is beyond the scope of this book, but the technique of using a callback is the general way </p>
<p class="calibre1">that it is done. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using a Cal back with SimpleButton</b></i></p>
<p class="calibre1">To demonstrate this concept, we’ll make a minor modification to the </p>
<p class="calibre1">SimpleButton class to allow it to accept a callback. As an additional optional </p>
<p class="calibre1">parameter, the caller can provide a function or method of an object to be </p>
<p class="calibre1">called back when a click on a SimpleButton object happens. Each instance of </p>
<p class="calibre1">SimpleButton remembers the callback in an instance variable. When the user </p>
<p class="calibre1">completes a click, the instance of SimpleButton calls the callback. </p>
<p class="calibre1">The main program in Listing 6-8 creates three instances of the </p>
<p class="calibre1">SimpleButton class, each of which handles the button click in a different way. </p>
<p class="calibre1">The first button, oButtonA, provides no callback; oButtonB provides a callback </p>
<p class="calibre1">to a function; and oButtonC specifies a callback to a method of an object. </p>
<p class="calibre1"><b class="calibre3">File: PygameDemo9_SimpleButtonWithCallback/Main_SimpleButtonCallback.py</b></p>
<p class="calibre1">#  pygame demo 9 - 3-button test with callbacks</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">from SimpleButton import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1"># #2 - Define constants</p>
<p class="calibre1">GRAY = (200, 200, 200)</p>
<p class="calibre1">WINDOW_WIDTH = 400</p>
<p class="calibre1">WINDOW_HEIGHT = 100</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1"># Define a function to be used as a "callback" </p>
<p class="calibre1">def myCallBackFunction(): 1</p>
<p class="calibre1">print('User pressed Button B, called myCallBackFunction')</p>
<p class="calibre1"># Define a class with a method to be used as a "callback" </p>
<p class="calibre1">class CallBackTest(): 2</p>
<p class="calibre1">--- snipped any other methods in this class ---</p>
<p class="calibre1">def myMethod(self):</p>
<p class="calibre1">print('User pressed ButtonC, called myMethod of the CallBackTest object')</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">clock = pygame.time.Clock()  </p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">139</b></p>
<p class="calibre1"><a id="p169"/>oCallBackTest = CallBackTest() 3 </p>
<p class="calibre1"># Create instances of SimpleButton</p>
<p class="calibre1"># No call back</p>
<p class="calibre1">oButtonA = SimpleButton(window, (25, 30), 4 </p>
<p class="calibre1">'images/buttonAUp.png', </p>
<p class="calibre1">'images/buttonADown.png')  </p>
<p class="calibre1"># Specifying a function to call back</p>
<p class="calibre1">oButtonB = SimpleButton(window, (150, 30), </p>
<p class="calibre1">'images/buttonBUp.png', </p>
<p class="calibre1">'images/buttonBDown.png', </p>
<p class="calibre1">callBack=myCallBackFunction)  </p>
<p class="calibre1"># Specifying a method of an object to call back</p>
<p class="calibre1">oButtonC = SimpleButton(window, (275, 30), </p>
<p class="calibre1">'images/buttonCUp.png', </p>
<p class="calibre1">'images/buttonCDown.png', </p>
<p class="calibre1">callBack=oCallBackTest.myMethod) </p>
<p class="calibre1">counter = 0</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># Pass the event to the button, see if it has been clicked on</p>
<p class="calibre1">if oButtonA.handleEvent(event): 5 </p>
<p class="calibre1">print('User pressed button A, handled in the main loop')</p>
<p class="calibre1"># oButtonB and oButtonC have callbacks, </p>
<p class="calibre1"># no need to check result of these calls</p>
<p class="calibre1">oButtonB.handleEvent(event) 6 </p>
<p class="calibre1">oButtonC.handleEvent(event) 7 </p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">counter = counter + 1</p>
<p class="calibre1"/>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(GRAY)</p>
<p class="calibre1"/>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">oButtonA.draw()</p>
<p class="calibre1">oButtonB.draw()</p>
<p class="calibre1">oButtonC.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 6-8: A version of the main program that handles but on clicks three different ways</i> <b class="calibre3">140</b>   Chapter 6</p>
<p class="calibre1"><a id="p170"/>We start with a simple function, myCallBackFunction() 1, that just prints a message to announce that it has been called. Next, we have a CallBackTest </p>
<p class="calibre1">class that contains the method myMethod() 2, which prints its own message </p>
<p class="calibre1">to announce that it’s been called. We create an oCallBackTest object from </p>
<p class="calibre1">the CallBackTest class 3. We need this object so we can set up a callback to </p>
<p class="calibre1">oCallBack.myMethod(). </p>
<p class="calibre1">Then we create three SimpleButton objects, each using a different </p>
<p class="calibre1">approach 4. The first, oButtonA, has no callback. The second, oButtonB, sets </p>
<p class="calibre1">its callback to the function myCallBackFunction(). The third, oButtonC, sets its </p>
<p class="calibre1">callback to oCallBack.myMethod(). </p>
<p class="calibre1">In the main loop, we check for the user clicking on any of the three </p>
<p class="calibre1">buttons by calling the handleEvent() method of each button. Since oButtonA  </p>
<p class="calibre1">has no callback, we must check if the value returned is True 5 and, if so, </p>
<p class="calibre1">perform an action. When oButtonB is clicked 6, the myCallBackFunction()  </p>
<p class="calibre1">function will be called and will print its message. When oButtonC is clicked 7, </p>
<p class="calibre1">the myMethod() method of the oCallBackTest object will be called and will </p>
<p class="calibre1">print its message. </p>
<p class="calibre1">Some programmers prefer using a callback approach, because the tar-</p>
<p class="calibre1">get to be called is set up when you create the object. It’s important to under-</p>
<p class="calibre1">stand this technique, especially if you are using a package that requires </p>
<p class="calibre1">it. However, I will use the original approach of checking for the value </p>
<p class="calibre1">returned by a call to handleEvent() in all my demonstration code. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, I showed how you can start with a procedural program and </p>
<p class="calibre1">extract related code to build a class. We created a Ball class to demonstrate </p>
<p class="calibre1">this, then modified the main code of our demo program from the previous </p>
<p class="calibre1">chapter to call methods of the class to tell the Ball object  <i class="calibre4">what</i> to do, without worrying about  <i class="calibre4">how</i> it achieves the outcome. With all the related code in a separate class, it’s easy to create a list of objects and instantiate and manage as many objects as we want to. </p>
<p class="calibre1">We then built a SimpleButton class and a SimpleText class that hide com-</p>
<p class="calibre1">plexity inside their implementation and create highly reusable code. In the </p>
<p class="calibre1">next chapter, I’ll build on these classes to develop “professional-strength” </p>
<p class="calibre1">button and text display classes. </p>
<p class="calibre1">Finally, I introduced the concept of a callback, where you pass in a func-</p>
<p class="calibre1">tion or method in a call to an object. The callback is later called back when </p>
<p class="calibre1">an event happens or an action completes. </p>
<p class="calibre1">Object-Oriented Pygame   <b class="calibre3">141</b></p>
<p class="calibre1"><a id="p171"/>
<a id="p172"/><b class="calibre3">7</b></p>
<p class="calibre1"><b class="calibre3">P Y G A M E   G U I   W I D G E T S</b></p>
<p class="calibre1">Pygame allows programmers to take the </p>
<p class="calibre1">text-based language of Python and use it </p>
<p class="calibre1">to build GUI-based programs. Windows, </p>
<p class="calibre1">pointing devices, clicking, dragging, and </p>
<p class="calibre1">sounds have all become standard parts of our expe-</p>
<p class="calibre1">rience using computers. Unfortunately, the pygame </p>
<p class="calibre1">package doesn’t come with built-in basic user inter-</p>
<p class="calibre1">face elements, so we need to build them ourselves. </p>
<p class="calibre1">We’ll do so with pygwidgets, a library of GUI widgets. </p>
<p class="calibre1">This chapter explains how standard widgets such as images, buttons, </p>
<p class="calibre1">and input or output fields can be built as classes and how client code uses </p>
<p class="calibre1">them. Building each element as a class allows programmers to incorporate </p>
<p class="calibre1">multiple instances of each element when creating a GUI. Before we get </p>
<p class="calibre1">started building these GUI widgets, however, I first need to discuss one </p>
<p class="calibre1">more Python feature: passing data in a call to a function or method. </p>
<p class="calibre1"><a id="p173"/><b class="calibre3">Passing Arguments into a Function or Method</b></p>
<p class="calibre1">The arguments in a call to a function and the parameters defined in the </p>
<p class="calibre1">function have a one-to-one relationship, so that the value of the first argu-</p>
<p class="calibre1">ment is given to the first parameter, the value of the second argument is </p>
<p class="calibre1">given to the second parameter, and so on. </p>
<p class="calibre1">Figure 7-1, duplicated fro<a href="index_split_001.html#p76">m Chapter 3, s</a>hows that the same is true when you make a call to a method of an object. We can see that the first parameter, which is always self, is set to the object in the call. </p>
<p class="calibre1">def someMethod(self,  <i class="calibre4">&lt;any other parameters&gt; </i>):</p>
<p class="calibre1">oSomeObject.someMethod( <i class="calibre4">&lt;any other arguments&gt; </i>)</p>
<p class="calibre1"> <i class="calibre4">Figure 7-1: How arguments passed into a method match up with its parameters </i></p>
<p class="calibre1">However, Python (and some other languages) allows you to make some </p>
<p class="calibre1">of the arguments optional. If an optional argument isn’t provided in a call, </p>
<p class="calibre1">we can provide a default value to use in the function or method instead. I’ll </p>
<p class="calibre1">explain by means of a real-world analogy. </p>
<p class="calibre1">If you order a hamburger at a Burger King restaurant, your burger will </p>
<p class="calibre1">come with ketchup, mustard, and pickles. But Burger King is famous for </p>
<p class="calibre1">saying, “You can have it your way.” If you want some other combination of </p>
<p class="calibre1">condiments, you must say what you want (or don’t want) when you make </p>
<p class="calibre1">your order. </p>
<p class="calibre1">We’ll start by writing an orderBurgers() function that simulates making </p>
<p class="calibre1">a burger order in the regular way we’ve been defining functions, without </p>
<p class="calibre1">implementing default values:</p>
<p class="calibre1">def orderBurgers(nBurgers, ketchup, mustard, pickles):</p>
<p class="calibre1">You must specify the number of hamburgers you want to order, but </p>
<p class="calibre1">ideally, if you want the defaults of True for adding ketchup, mustard, and </p>
<p class="calibre1">pickles, you shouldn’t need to pass in any more arguments. So, to order two </p>
<p class="calibre1">hamburgers with the standard defaults, you might think your call should </p>
<p class="calibre1">look like this:</p>
<p class="calibre1">orderBurgers(2)  # with ketchup, mustard, and pickles</p>
<p class="calibre1">However, in Python, this will trigger an error because there is a mis-</p>
<p class="calibre1">match between the number of arguments in the call and the number of </p>
<p class="calibre1">parameters specified in the function:</p>
<p class="calibre1">TypeError: orderBurgers() missing 3 required positional arguments: 'ketchup', </p>
<p class="calibre1">'mustard', and 'pickles' </p>
<p class="calibre1">Let’s see how Python allows us to set up optional parameters that can </p>
<p class="calibre1">be given default values if nothing is specified. </p>
<p class="calibre1"><b class="calibre3">144</b>   Chapter 7</p>
<p class="calibre1"><a id="p174"/> <i class="calibre4"><b class="calibre3">Positional and Keyword Parameters</b></i></p>
<p class="calibre1">Python has two different types of parameters: positional parameters and </p>
<p class="calibre1">keyword parameters.  <i class="calibre4">Positional parameters</i> are the type that we’re already </p>
<p class="calibre1">familiar with, where each argument in a call has a matching parameter in </p>
<p class="calibre1">the function or method definition. </p>
<p class="calibre1">A  <i class="calibre4">keyword parameter </i> allows you to specify a default value. You write a keyword parameter as a variable name, an equal sign, and a default value, like this:</p>
<p class="calibre1">def someFunction( <i class="calibre4">&lt;keywordParameter&gt; </i>= <i class="calibre4">&lt;default value&gt; </i>): You can have multiple keyword parameters, each with a name and a </p>
<p class="calibre1">default value. </p>
<p class="calibre1">A function or method can have both positional parameters and key-</p>
<p class="calibre1">word parameters, in which case you must specify all positional parameters </p>
<p class="calibre1"> <i class="calibre4">before</i> any keyword parameters: </p>
<p class="calibre1">def someOtherFunction(positionalParam1, positionalParam2, ... </p>
<p class="calibre1"> <i class="calibre4">&lt;keywordParameter1&gt; </i>= <i class="calibre4">&lt;default value 1&gt; </i>, </p>
<p class="calibre1"> <i class="calibre4">&lt;keywordParameter2&gt; </i>= <i class="calibre4">&lt;default value 2&gt; </i>, ...):</p>
<p class="calibre1">Let’s rewrite orderBurgers() to use one positional parameter and three </p>
<p class="calibre1">keyword parameters with default values, like this:</p>
<p class="calibre1">def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):</p>
<p class="calibre1">When we make a call to this function, nBurgers is a positional parameter </p>
<p class="calibre1">and therefore must be specified as an argument in every call. The other three </p>
<p class="calibre1">are keyword parameters. If no values are passed for ketchup, mustard, and pick-</p>
<p class="calibre1">les, the function will use the default value of True for each of those parameter </p>
<p class="calibre1">variables. Now we can order two burgers with all the condiments like this:</p>
<p class="calibre1">orderBurgers(2)</p>
<p class="calibre1">If we want something other than a default value, we can specify the name </p>
<p class="calibre1">of the keyword parameter and a different value in our call. For example, if we </p>
<p class="calibre1">only want ketchup on our two burgers, we can make the call this way:</p>
<p class="calibre1">orderBurgers(2, mustard=False, pickles=False)</p>
<p class="calibre1">When the function runs, the values of the mustard and pickles variables </p>
<p class="calibre1">are set to False. Since we did not specify a value for ketchup, it is given the </p>
<p class="calibre1">default of True. </p>
<p class="calibre1">You can also make the call specifying all arguments positionally, includ-</p>
<p class="calibre1">ing those written as keyword parameters. Python will use the ordering of </p>
<p class="calibre1">your arguments to assign each parameter the correct value:</p>
<p class="calibre1">orderBurgers(2, True, False, False)</p>
<p class="calibre1">In this call, we are again specifying two burgers with ketchup, no mus-</p>
<p class="calibre1">tard, and no pickles. </p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">145</b></p>
<p class="calibre1"><a id="p175"/> <i class="calibre4"><b class="calibre3">Additional Notes on Keyword Parameters</b></i></p>
<p class="calibre1">Let’s quickly go over a few conventions and tips for using keyword param-</p>
<p class="calibre1">eters. As a Python convention, when you use keyword parameters and key-</p>
<p class="calibre1">words with arguments, the equal sign between the keyword and the value </p>
<p class="calibre1">should  <i class="calibre4">not</i> have spaces around it, to show that these are not typical assignment statements. These lines are properly formatted:</p>
<p class="calibre1">def orderBurgers(nBurgers, ketchup=True, mustard=True, pickles=True):</p>
<p class="calibre1">orderBurgers(2, mustard=False)</p>
<p class="calibre1">These lines will also work fine, but they don’t follow the formatting con-</p>
<p class="calibre1">vention and are less readable:</p>
<p class="calibre1">def orderBurgers(nBurgers, ketchup = True, mustard = True, pickles = True):</p>
<p class="calibre1">orderBurgers(2, mustard = False)</p>
<p class="calibre1">When calling a function that has both positional parameters and key-</p>
<p class="calibre1">word parameters, you must provide values for all the positional parameters </p>
<p class="calibre1">first, before any optional keyword parameters. </p>
<p class="calibre1">Keyword arguments in calls can be specified in any order. Calls to our  </p>
<p class="calibre1">orderBurgers() function could be made in various ways, such as:</p>
<p class="calibre1">orderBurgers(2, mustard=False, pickles=False)  # only ketchup</p>
<p class="calibre1">or:</p>
<p class="calibre1">orderBurgers(2, pickles=False, mustard=False, ketchup=False)  # plain</p>
<p class="calibre1">All keyword parameters will be given the appropriate values, indepen-</p>
<p class="calibre1">dent of the order of the arguments. </p>
<p class="calibre1">While all the default values in the orderBurgers() example were Boolean </p>
<p class="calibre1">values, a keyword parameter can have a default value of any data type. For </p>
<p class="calibre1">example, we could write a function to allow a customer to make an ice </p>
<p class="calibre1">cream order like this:</p>
<p class="calibre1">def orderIceCream(flavor, nScoops=1, coneOrCup='cone', sprinkles=False):</p>
<p class="calibre1">The caller must specify a flavor, but by default will get one scoop in a </p>
<p class="calibre1">cone with no sprinkles. The caller could override these defaults with differ-</p>
<p class="calibre1">ent keyword values. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using None as a Default Value</b></i></p>
<p class="calibre1">It’s sometimes helpful to know whether the caller passed in a value for a </p>
<p class="calibre1">keyword parameter or not. For this example, the caller orders a pizza. At </p>
<p class="calibre1">a minimum, the caller must specify a size. The second parameter will be a </p>
<p class="calibre1">style that defaults to 'regular' but could be 'deepdish'. As a third parameter, </p>
<p class="calibre1"><b class="calibre3">146</b>   Chapter 7</p>
<p class="calibre1"><a id="p176"/>the caller can optionally pass in a single desired topping. If the caller wants a topping, we must charge them extra. </p>
<p class="calibre1">In Listing 7-1, we’ll use a positional parameter for the size and key-</p>
<p class="calibre1">word parameters for the style and topping. The default for style is the string </p>
<p class="calibre1">'regular'. Since the topping choice is optional, we’ll use the special Python </p>
<p class="calibre1">value of None as the default, but the caller may pass in the topping of their </p>
<p class="calibre1">choice. </p>
<p class="calibre1"><b class="calibre3">File: OrderPizzaWithNone.py</b></p>
<p class="calibre1">def orderPizza(size, style='regular', topping=None):</p>
<p class="calibre1"># Do some calculations based on the size and style</p>
<p class="calibre1"># Check if a topping was specified</p>
<p class="calibre1">PRICE_OF_TOPPING = 1.50  # price for any topping</p>
<p class="calibre1">if size == 'small':</p>
<p class="calibre1">price = 10.00</p>
<p class="calibre1">elif size == 'medium':</p>
<p class="calibre1">price = 14.00</p>
<p class="calibre1">else: # large</p>
<p class="calibre1">price = 18.00</p>
<p class="calibre1">if style == 'deepdish':</p>
<p class="calibre1">price = price + 2.00 # charge extra for deepdish</p>
<p class="calibre1">line = 'You have ordered a ' + size + ' ' + style + ' pizza with ' </p>
<p class="calibre1">1 if topping is None:  # check if no topping was passed in</p>
<p class="calibre1">print(line + 'no topping')</p>
<p class="calibre1">else:</p>
<p class="calibre1">print(line + topping)</p>
<p class="calibre1">price = price + PRICE_OF_TOPPING</p>
<p class="calibre1"/>
<p class="calibre1">print('The price is $', price)</p>
<p class="calibre1">print()</p>
<p class="calibre1"># You could order a pizza in the following ways: </p>
<p class="calibre1">2 orderPizza('large')   # large, defaults to regular, no topping</p>
<p class="calibre1">orderPizza('large', style='regular')  # same as above</p>
<p class="calibre1">3 orderPizza('medium', style='deepdish', topping='mushrooms')</p>
<p class="calibre1">orderPizza('small', topping='mushrooms') # style defaults to regular</p>
<p class="calibre1"> <i class="calibre4">Listing 7-1: A function with a keyword parameter defaulting to None  </i></p>
<p class="calibre1">The first and second calls would be seen as the same, with the value of </p>
<p class="calibre1">the variable topping set to None 2. In the third and fourth calls, the value of </p>
<p class="calibre1">topping is set to 'mushrooms' 3. Because 'mushrooms' is not None, in these calls </p>
<p class="calibre1">the code would add in an extra charge for a topping on the pizzas 1. </p>
<p class="calibre1">Using None as a default value for a keyword parameter gives you a way to </p>
<p class="calibre1">see if the caller provided a value in the call. This may be a very subtle use of </p>
<p class="calibre1">keyword parameters, but it will be very useful in our upcoming discussion. </p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">147</b></p>
<p class="calibre1"><a id="p177"/> <i class="calibre4"><b class="calibre3">Choosing Keywords and Default Values</b></i></p>
<p class="calibre1">Using default values makes calling functions and methods simpler, but </p>
<p class="calibre1">there is a downside. Your choice of each keyword for keyword parameters </p>
<p class="calibre1">is very important. Once programmers start making calls that override </p>
<p class="calibre1">default values, it’s very difficult to change the name of a keyword parameter </p>
<p class="calibre1">because that name must be changed in  <i class="calibre4">all</i> calls to the function or method </p>
<p class="calibre1">in lockstep. Otherwise, code that was working will break. For more widely </p>
<p class="calibre1">distributed code, this can potentially cause a great deal of pain to program-</p>
<p class="calibre1">mers using your code. Bottom line, don’t change the name of a keyword </p>
<p class="calibre1">parameter unless it is absolutely necessary. So, choose wisely! </p>
<p class="calibre1">It’s also very important to use default values that should suit the widest </p>
<p class="calibre1">possible range of users. (On a personal note, I  <i class="calibre4">hate</i> mustard! Whenever I go to Burger King, I have to remember to specify no mustard or I’ll get what I consider to be an inedible hamburger. I think they made a bad default choice.)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Default Values in GUI Widgets</b></i></p>
<p class="calibre1">In the next section, I’ll present a collection of classes that you can use to </p>
<p class="calibre1">easily create GUI elements such as buttons and text fields within pygame. </p>
<p class="calibre1">These classes will each be initialized using a few positional parameters but </p>
<p class="calibre1">will also have assorted optional keyword parameters, all with reasonable </p>
<p class="calibre1">defaults to allow programmers to create GUI widgets by specifying only a </p>
<p class="calibre1">few positional arguments. More precise control can be obtained by specify-</p>
<p class="calibre1">ing values to overwrite the default values of keyword parameters. </p>
<p class="calibre1">For an in-depth example, we’ll look at a widget to display text in the </p>
<p class="calibre1">application’s window. Text can be shown in a variety of fonts, font sizes, col-</p>
<p class="calibre1">ors, background colors, and so on. We’ll build a DisplayText class that will </p>
<p class="calibre1">have default values for all of these attributes but will give client code the </p>
<p class="calibre1">option of specifying different values. </p>
<p class="calibre1"><b class="calibre3">The pygwidgets Package</b></p>
<p class="calibre1">The rest of this chapter will focus on the pygwidgets (pronounced “pig </p>
<p class="calibre1">wijits”) package, which was written with two goals in mind:</p>
<p class="calibre1">1.  To demonstrate many different object-oriented programming techniques</p>
<p class="calibre1">2.  To allow programmers to easily create and use GUI widgets in pygame </p>
<p class="calibre1">programs</p>
<p class="calibre1">The pygwidgets package contains the following classes:</p>
<p class="calibre1"><b class="calibre3">TextButton</b></p>
<p class="calibre1">Button built with standard art, using a text string</p>
<p class="calibre1"><b class="calibre3">CustomButton </b></p>
<p class="calibre1">Button with custom artwork</p>
<p class="calibre1"><b class="calibre3">148</b>   Chapter 7</p>
<p class="calibre1"><a id="p178"/><b class="calibre3">TextCheckBox </b></p>
<p class="calibre1">Checkbox with standard art, built from a text string</p>
<p class="calibre1"><b class="calibre3">CustomCheckBox </b></p>
<p class="calibre1">Checkbox with custom artwork</p>
<p class="calibre1"><b class="calibre3">TextRadioButton </b></p>
<p class="calibre1">Radio buttons with standard art, built from a text string</p>
<p class="calibre1"><b class="calibre3">CustomRadioButton </b></p>
<p class="calibre1">Radio buttons with custom artwork</p>
<p class="calibre1"><b class="calibre3">DisplayText </b></p>
<p class="calibre1">Field used to display output text</p>
<p class="calibre1"><b class="calibre3">InputText </b></p>
<p class="calibre1">Field where the user can type text</p>
<p class="calibre1"><b class="calibre3">Dragger </b></p>
<p class="calibre1">Allows the user to drag an image</p>
<p class="calibre1"><b class="calibre3">Image </b></p>
<p class="calibre1">Displays an image at a location</p>
<p class="calibre1"><b class="calibre3">ImageCollection </b></p>
<p class="calibre1">Displays one of a collection of images at a location</p>
<p class="calibre1"><b class="calibre3">Animation </b></p>
<p class="calibre1">Displays a sequence of images</p>
<p class="calibre1"><b class="calibre3">SpriteSheetAnimation </b></p>
<p class="calibre1">Displays a sequence of images from a single larger image</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Setting Up</b></i></p>
<p class="calibre1">To install pygwidgets, open the command line and enter the following:</p>
<p class="calibre1">python3 -m pip install -U pip --user</p>
<p class="calibre1">python3 -m pip install -U pygwidgets --user</p>
<p class="calibre1">These commands download and install the latest version of pygwidgets </p>
<p class="calibre1">from the Python Package Index (PyPI). It is placed into a folder (named </p>
<p class="calibre1"> <i class="calibre4">site-packages</i>) that is available to all your Python programs. Once installed, you can use pygwidgets by including the following statement at the beginning of your programs:</p>
<p class="calibre1">import pygwidgets </p>
<p class="calibre1">This imports the entire package. After importing, you can instantiate </p>
<p class="calibre1">objects from its classes and call the methods of those objects. </p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">149</b></p>
<p class="calibre1"><a id="p179"/>The most current documentation of pygwidgets is a<a href="https://pygwidgets.readthedocs.io/en/latest/">t  <i class="calibre4">https://pygwidgets </i></a></p>
<p class="calibre1"><a href="https://pygwidgets.readthedocs.io/en/latest/"> <i class="calibre4">.readthedocs.io/en/latest/</i></a>. If you’d like to view the source code for the package, it’s available via my GitHub repository at <a href="https://github.com/IrvKalb/pygwidgets/"> <i class="calibre4">https://github.com/IrvKalb/pygwidgets/</i>. </a></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Overall Design Approach</b></i></p>
<p class="calibre1">As shown i<a href="index_split_002.html#p118">n Chapter 5, o</a>ne of the first things you do in every pygame program is to define the window of the application. The following line creates </p>
<p class="calibre1">an application window and saves a reference to it in a variable named window:</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1">As we will soon see, whenever we instantiate any widget, we will need to </p>
<p class="calibre1">pass in the window variable so the widget can draw itself in the application’s </p>
<p class="calibre1">window. </p>
<p class="calibre1">Most widgets in pygwidgets work in a similar way, typically involving </p>
<p class="calibre1">these three steps:</p>
<p class="calibre1">1.  Before the main while loop starts, create an instance of the widget, pass-</p>
<p class="calibre1">ing in any initialization arguments. </p>
<p class="calibre1">2.  In the main loop, whenever any event happens, call the handleEvent() </p>
<p class="calibre1">method of the widget (passing in the event object). </p>
<p class="calibre1">3.  At the bottom of the main loop, call the draw() method of the widget. </p>
<p class="calibre1">Step 1 in using any widget is to instantiate one with a line like this:</p>
<p class="calibre1">oWidget = pygwidgets.  <i class="calibre4">&lt;SomeWidgetClass&gt; </i>(window, loc,  <i class="calibre4">&lt;other arguments as needed&gt; </i>) The first argument is always the window of the application. The second </p>
<p class="calibre1">argument is always the location in the window at which to display the wid-</p>
<p class="calibre1">get, given as a tuple: (x, y). </p>
<p class="calibre1">Step 2 is to handle any event that could affect the widget by calling the </p>
<p class="calibre1">object’s handleEvent() method inside the event loop. If any event (like a mouse </p>
<p class="calibre1">click or button press) happens and the widget handles the event, this call will </p>
<p class="calibre1">return True. The code at the top of the main while loop generally looks like this:</p>
<p class="calibre1">while True:</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if oWidget.handleEvent(event):  </p>
<p class="calibre1"># The user has done something to oWidget that we should respond to</p>
<p class="calibre1"># Add code here</p>
<p class="calibre1">Step 3 is to add a line near the bottom of the while loop to call the </p>
<p class="calibre1">draw() method of the widget, to make it appear it in the window:</p>
<p class="calibre1">oWidget.draw()</p>
<p class="calibre1"><b class="calibre3">150</b>   Chapter 7</p>
<p class="calibre1"><a id="p180"/>Since we specified the window to draw into, the location, and any </p>
<p class="calibre1">details that affect the appearance of the widget in step 1, we don’t pass any-</p>
<p class="calibre1">thing in the call to draw(). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Adding an Image</b></i></p>
<p class="calibre1">Our first example will be the simplest widget: we’ll use the Image class to dis-</p>
<p class="calibre1">play an image in a window. When you instantiate an Image object, the only </p>
<p class="calibre1">required arguments are the window, the location in the window to draw </p>
<p class="calibre1">the image, and the path to the image file. Create the Image object before the </p>
<p class="calibre1">main loop starts, like so:</p>
<p class="calibre1">oImage = pygwidgets.Image(window, (100, 200), 'images/SomeImage.png')</p>
<p class="calibre1">The path used here assumes that the project folder containing the </p>
<p class="calibre1">main program also contains a folder named  <i class="calibre4">images</i>, inside which is the </p>
<p class="calibre1"> <i class="calibre4">SomeImage.png</i> file. Then, in the main loop you just need to call the object’s draw() method:</p>
<p class="calibre1">oImage.draw()</p>
<p class="calibre1">The draw() method of the Image class contains a call to blit() to actu-</p>
<p class="calibre1">ally draw the image, so you never need to call blit() directly. To move the </p>
<p class="calibre1">image, you can call its setLoc() method (short for set location), specifying </p>
<p class="calibre1">the new x- and y-coordinates as a tuple:</p>
<p class="calibre1">oImage.setLoc((newX, newY))</p>
<p class="calibre1">The next time the image is drawn, it will show up at the new coordi-</p>
<p class="calibre1">nates. The documentation lists many additional methods that you can call </p>
<p class="calibre1">to flip, rotate, scale, get the image’s location and rectangle, and so on. </p>
<p class="calibre1"><b class="calibre3">THE SPRITE MODULE</b></p>
<p class="calibre1">Pygame has a built-in module to show images in a window, cal ed the  <i class="calibre4">sprite </i></p>
<p class="calibre1"> <i class="calibre4">module</i> . Such images are cal ed  <i class="calibre4">sprites</i> . The sprite module provides a Sprite class for handling individual sprites and a Group class for handling multiple </p>
<p class="calibre1">Sprite objects . Together, these classes provide excel ent functionality, and if </p>
<p class="calibre1">you intend to do heavy-duty pygame programming, it is probably worth your </p>
<p class="calibre1">time to look into them . However, in order to explain the underlying OOP con-</p>
<p class="calibre1">cepts, I have chosen not to use those classes . Instead, I will proceed with gen-</p>
<p class="calibre1">eral GUI elements so that they can be used in any environment and language . </p>
<p class="calibre1">If you want to learn more about the sprite module, see the tutorial a<a href="https://www.pygame.org/docs/tut/SpriteIntro.html">t  <i class="calibre4">ht ps://</i></a></p>
<p class="calibre1"><a href="https://www.pygame.org/docs/tut/SpriteIntro.html"> <i class="calibre4">www.pygame.org/docs/tut/SpriteIntro.html</i> . </a></p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">151</b></p>
<p class="calibre1"><a id="p181"/> <i class="calibre4"><b class="calibre3">Adding Buttons, Checkboxes, and Radio Buttons</b></i></p>
<p class="calibre1">When you instantiate a button, checkbox, or radio button widget in  pygwidgets, </p>
<p class="calibre1">you have two options: instantiate a text version that draws its own art and </p>
<p class="calibre1">adds a text label based on a string you pass in, or instantiate a custom ver-</p>
<p class="calibre1">sion where you supply the art. Table 7-1 shows the different button classes </p>
<p class="calibre1">that are available. </p>
<p class="calibre1"><b class="calibre3">Table 7-1:</b> Text and Custom Button Classes in pygwidgets</p>
<p class="calibre1"><b class="calibre3">Text version (builds art on  </b></p>
<p class="calibre1"><b class="calibre3">Custom version (uses  </b></p>
<p class="calibre1"><b class="calibre3"> </b></p>
<p class="calibre1"><b class="calibre3">the fly)</b></p>
<p class="calibre1"><b class="calibre3">your artwork)</b></p>
<p class="calibre1">Button</p>
<p class="calibre1">TextButton</p>
<p class="calibre1">CustomButton</p>
<p class="calibre1">Checkbox</p>
<p class="calibre1">TextCheckBox</p>
<p class="calibre1">CustomCheckBox</p>
<p class="calibre1">Radio button</p>
<p class="calibre1">TextRadioButton</p>
<p class="calibre1">CustomRadioButton</p>
<p class="calibre1">The differences between the text and custom versions of these classes </p>
<p class="calibre1">are only relevant during instantiation. Once you create an object from </p>
<p class="calibre1">a text or custom button class, all the remaining methods of the pair of </p>
<p class="calibre1">classes are identical. To make this clear, let’s take a look at the TextButton </p>
<p class="calibre1">and CustomButton classes. </p>
<p class="calibre1"><b class="calibre3">TextButtons</b></p>
<p class="calibre1">Here is the actual definition of the __init__() method of the TextButton class </p>
<p class="calibre1">in pygwidgets:</p>
<p class="calibre1">def __init__(self, window, loc, text, </p>
<p class="calibre1">width=None, </p>
<p class="calibre1">height=40, </p>
<p class="calibre1">textColor=PYGWIDGETS_BLACK, </p>
<p class="calibre1">upColor=PYGWIDGETS_NORMAL_GRAY, </p>
<p class="calibre1">overColor=PYGWIDGETS_OVER_GRAY, </p>
<p class="calibre1">downColor=PYGWIDGETS_DOWN_GRAY, </p>
<p class="calibre1">fontName=DEFAULT_FONT_NAME, </p>
<p class="calibre1">fontSize=DEFAULT_FONT_SIZE, </p>
<p class="calibre1">soundOnClick=None, </p>
<p class="calibre1">enterToActivate=False, </p>
<p class="calibre1">callback=None</p>
<p class="calibre1">nickname=None):</p>
<p class="calibre1">However, rather than reading through the code of a class, a programmer </p>
<p class="calibre1">will typically refer to its documentation. As mentioned earlier, you can find </p>
<p class="calibre1">the complete documentation for pygwidgets at <a href="https://pygwidgets.readthedocs.io/en/latest/"> <i class="calibre4">https://pygwidgets.readthedocs.io/</i></a></p>
<p class="calibre1"><a href="https://pygwidgets.readthedocs.io/en/latest/"> <i class="calibre4">en/latest/</i></a>. </p>
<p class="calibre1">You can also view documentation of a class by calling the built-in help() </p>
<p class="calibre1">function in the Python shell like so:</p>
<p class="calibre1">&gt;&gt;&gt; help(pygwidgets.TextButton)</p>
<p class="calibre1"><b class="calibre3">152</b>   Chapter 7</p>
<p class="calibre1"><a id="p182"/><img src="index-182_1.png" alt="Image 24" class="calibre2"/></p>
<p class="calibre1"><img src="index-182_2.png" alt="Image 25" class="calibre2"/></p>
<p class="calibre1">When you create an instance of a TextButton, you are only required to pass </p>
<p class="calibre1">in the window, the location in the window, and the text to be shown on the </p>
<p class="calibre1">button. If you only specify these positional parameters, your button will use </p>
<p class="calibre1">reasonable defaults for the width and height, the background colors for the </p>
<p class="calibre1">four states of the button (different shades of gray), the font, and the font size. </p>
<p class="calibre1">By default, no sound effect will be played when the user clicks on the button. </p>
<p class="calibre1">The code to create a TextButton using all the defaults looks like this:</p>
<p class="calibre1">oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button')</p>
<p class="calibre1">The code in the __init__() method of the TextButton class uses the </p>
<p class="calibre1">pygame drawing methods to construct its own art for all four states (up, </p>
<p class="calibre1">down, over, and disabled). The preceding line creates an “up” version of a </p>
<p class="calibre1">button that looks like Figure 7-2. </p>
<p class="calibre1"> <i class="calibre4">Figure 7-2: A TextButton  </i></p>
<p class="calibre1"> <i class="calibre4">using defaults </i></p>
<p class="calibre1">You can override any or all of the default parameters with keyword val-</p>
<p class="calibre1">ues like so:</p>
<p class="calibre1">oButton = pygwidgets.TextButton(window, (50, 50), 'Text Button', </p>
<p class="calibre1">width=200, </p>
<p class="calibre1">height=30, </p>
<p class="calibre1">textColor=(255, 255, 128), </p>
<p class="calibre1">upColor=(128, 0, 0), </p>
<p class="calibre1">fontName='Courier', </p>
<p class="calibre1">fontSize=14, </p>
<p class="calibre1">soundOnClick='sounds/blip.wav', </p>
<p class="calibre1">enterToActivate=True)</p>
<p class="calibre1">This instantiation will create a button that looks like Figure 7-3. </p>
<p class="calibre1"> <i class="calibre4">Figure 7-3: A TextButton using keyword  </i></p>
<p class="calibre1"> <i class="calibre4">arguments for font, size, colors, and so on </i></p>
<p class="calibre1">The image-switching behavior of these two buttons would work exactly </p>
<p class="calibre1">the same way; the only differences would be in the appearance of the images. </p>
<p class="calibre1"><b class="calibre3">CustomButtons</b></p>
<p class="calibre1">The CustomButton class allows you to use your own art for a button. To instan-</p>
<p class="calibre1">tiate a CustomButton, you need only pass in a window, a location, and a path </p>
<p class="calibre1">to the image of the up state of the button. Here is an example:</p>
<p class="calibre1">restartButton = pygwidgets.CustomButton(window, (100, 430), </p>
<p class="calibre1">'images/RestartButtonUp.png')</p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">153</b></p>
<p class="calibre1"><a id="p183"/>The down, over, and disabled states are optional keyword arguments, and for any of these where no value is passed in, CustomButton will use a copy of </p>
<p class="calibre1">the up image. It’s more typical (and strongly suggested) to pass in paths for </p>
<p class="calibre1">the optional images, like so: </p>
<p class="calibre1">restartButton = pygwidgets.CustomButton(window, (100, 430), </p>
<p class="calibre1">'images/RestartButtonUp.png', </p>
<p class="calibre1">down='images/RestartButtonDown.png', </p>
<p class="calibre1">over='images/RestartButtonOver.png', </p>
<p class="calibre1">disabled='images/RestartButtonDisabled.png', </p>
<p class="calibre1">soundOnClick='sounds/blip.wav', </p>
<p class="calibre1">nickname='restart')</p>
<p class="calibre1">Here we also specified a sound effect that should be played when </p>
<p class="calibre1">the user clicks the button, and we provided an internal nickname we can </p>
<p class="calibre1">use later. </p>
<p class="calibre1"><b class="calibre3">Using Buttons</b></p>
<p class="calibre1">After instantiation, here’s some typical code to use a button object, oButton, </p>
<p class="calibre1">independent of it being a TextButton or a CustomButton:</p>
<p class="calibre1">while True:</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if oButton.handleEvent(event):  </p>
<p class="calibre1"># User has clicked this button</p>
<p class="calibre1"> <i class="calibre4">&lt;Any code you want to run here when the button is clicked&gt; </i></p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">oButton.draw()  # at the bottom of the while loop, tell it to draw</p>
<p class="calibre1">Every time we detect an event, we need to call the handleEvent() method </p>
<p class="calibre1">of the button to allow it to react to the user’s actions. This call normally </p>
<p class="calibre1">returns False but will return True when the user completes a click on the </p>
<p class="calibre1">button. At the bottom of the main while loop, we need to call the draw() </p>
<p class="calibre1">method of the button to allow it to draw itself. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Text Output and Input</b></i></p>
<p class="calibre1">As we saw in <a href="index_split_002.html#p150">Chapter 6, h</a>andling text input and output in pygame is tricky, but here I’ll introduce new classes for a text display field and an input text </p>
<p class="calibre1">field. Both of these classes have minimal required (positional) parameters, </p>
<p class="calibre1">and they have reasonable defaults for other attributes (font, font size, </p>
<p class="calibre1">color, and so on) that are easily overridden. </p>
<p class="calibre1"><b class="calibre3">Text Output </b></p>
<p class="calibre1">The pygwidgets package contains a DisplayText class for showing text that is a </p>
<p class="calibre1">more full-featured version of the SimpleText class fro<a href="index_split_002.html#p150">m Chapter 6</a>. When you <b class="calibre3">154</b>   Chapter 7</p>
<p class="calibre1"><a id="p184"/>instantiate a DisplayText field, the only required arguments are the window and the location. The first keyword parameter is value, which may be specified with a string as starting text to be shown in the field. This is typically </p>
<p class="calibre1">used for a default end user value or for text that never changes, like a label </p>
<p class="calibre1">or instructions. Since value is the first keyword parameter, it can be given as </p>
<p class="calibre1">either a positional or a keyword argument. For example, this:</p>
<p class="calibre1">oTextField = pygwidgets.DisplayText(window, (10, 400), 'Hello World')</p>
<p class="calibre1">will work the same way as this:</p>
<p class="calibre1">oTextField = pygwidgets.DisplayText(window, (10, 400), value='Hello World')</p>
<p class="calibre1">You can also customize the look of the output text by specifying any or </p>
<p class="calibre1">all of the optional keyword parameters. For example:</p>
<p class="calibre1">oTextField = pygwidgets.DisplayText(window, (10, 400), </p>
<p class="calibre1">value='Some title text', </p>
<p class="calibre1">fontName='Courier', </p>
<p class="calibre1">fontSize=40, </p>
<p class="calibre1">width=150, </p>
<p class="calibre1">justified='center', </p>
<p class="calibre1">textColor=(255, 255, 0))</p>
<p class="calibre1">The DisplayText class has a number of additional methods, the most </p>
<p class="calibre1">important of which is setValue(), which you call to change the text drawn </p>
<p class="calibre1">in the field:</p>
<p class="calibre1">oTextField.setValue('Any new text you want to see')</p>
<p class="calibre1">At the bottom of the main while loop, you need to call the object’s </p>
<p class="calibre1">draw() method:</p>
<p class="calibre1">oTextField.draw()</p>
<p class="calibre1">And of course, you can create as many DisplayText objects as you wish, </p>
<p class="calibre1">each displaying different text and each with its own font, size, color, and so on. </p>
<p class="calibre1"><b class="calibre3">Text Input</b></p>
<p class="calibre1">In a typical text-based Python program, to get input from the user you </p>
<p class="calibre1">would make a call to the input() function, which stops the program until </p>
<p class="calibre1">the user enters text in the shell window. But in the world of event-driven </p>
<p class="calibre1">GUI programs, the main loop never stops. Therefore, we must use a differ-</p>
<p class="calibre1">ent approach. </p>
<p class="calibre1">For text input from the user, a GUI program typically presents a field </p>
<p class="calibre1">that the user can type in. An input field must deal with all keyboard keys, </p>
<p class="calibre1">some of which show while others are used for editing or cursor movement </p>
<p class="calibre1">within the field. It must also allow for the user holding down a key to repeat </p>
<p class="calibre1">it. The pygwidgets InputText class provides all this functionality. </p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">155</b></p>
<p class="calibre1"><a id="p185"/>The only required arguments to instantiate an InputText object are the window and a location:</p>
<p class="calibre1">oInputField = pygwidgets.InputText(window, (10, 100))</p>
<p class="calibre1">However, you can customize the text attributes of an InputText object by </p>
<p class="calibre1">specifying optional keyword arguments:</p>
<p class="calibre1">oInputField = pygwidgets.InputText(window, (10, 400), </p>
<p class="calibre1">value='Starting Text', </p>
<p class="calibre1">fontName='Helvetica', </p>
<p class="calibre1">fontSize=40, </p>
<p class="calibre1">width=150, </p>
<p class="calibre1">textColor=(255, 255, 0))</p>
<p class="calibre1">After instantiating an InputText field, the typical code in the main loop </p>
<p class="calibre1">would look like this:</p>
<p class="calibre1">while True:</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if oInputField.handleEvent(event):  </p>
<p class="calibre1"># User has pressed Enter or Return</p>
<p class="calibre1">userText = oInputField.getValue()  # get the text the user entered</p>
<p class="calibre1"> <i class="calibre4">&lt;Any code you want to run using the user's input&gt; </i></p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">oInputField.draw()  # at the bottom of the main while loop</p>
<p class="calibre1">For every event, we need to call the handleEvent() method of the InputText </p>
<p class="calibre1">field to allow it to react to keystrokes and mouse clicks. This call normally </p>
<p class="calibre1">returns False, but when the user presses ENTER or RETURN, it returns True. </p>
<p class="calibre1">We can then retrieve the text that the user entered by calling the getValue() </p>
<p class="calibre1">method of the object. </p>
<p class="calibre1">At the bottom of the main while loop, we need to call the draw() method </p>
<p class="calibre1">to allow the field to draw itself. </p>
<p class="calibre1">If a window contains multiple input fields, key presses are handled by </p>
<p class="calibre1">the field with current keyboard focus, which is changed when a user clicks </p>
<p class="calibre1">in a different field. If you want to allow a field to have initial keyboard focus, </p>
<p class="calibre1">then you can set the initialFocus keyword parameter to True in the InputText </p>
<p class="calibre1">object of your choice when you create that object. Further, if you have mul-</p>
<p class="calibre1">tiple InputText fields in a window, a typical user interface design approach is </p>
<p class="calibre1">to include an OK or Submit button. When this button is clicked, you could </p>
<p class="calibre1">then call the getValue() method of each field. </p>
<p class="calibre1"><b class="calibre3">156</b>   Chapter 7</p>
<p class="calibre1"><a id="p186"/><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">At the time of writing, the InputText class does not handle highlighting multiple</i> <i class="calibre4">characters by dragging the mouse. If this functionality is added in a later version,</i> <i class="calibre4">no change will be required to programs that use InputText because the code will be</i> <i class="calibre4">entirely within that class. Any new behavior will be supported automatically in all</i> <i class="calibre4">InputText objects. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Other pygwidgets Classes</b></i></p>
<p class="calibre1">As you saw at the beginning of this section, pygwidgets contains a number of </p>
<p class="calibre1">other classes. </p>
<p class="calibre1">The ImageCollection class allows you to show any single image from a </p>
<p class="calibre1">collection of images. For example, suppose you have images of a character </p>
<p class="calibre1">facing front, left, back, and right. To represent all the potential images, you </p>
<p class="calibre1">can build a dictionary like this:</p>
<p class="calibre1">imageDict = {'front':'images/front.png', 'left':'images/left.png', </p>
<p class="calibre1">'back':'images/back.png', 'right':'images/right.png'}</p>
<p class="calibre1">You can then create an ImageCollection object, specifying this dictionary </p>
<p class="calibre1">and the key of the image you want to start with. To change to a different </p>
<p class="calibre1">image, you call the replace() method and pass in a different key. Calling the </p>
<p class="calibre1">draw() method at the bottom of the loop always shows the current image. </p>
<p class="calibre1">The Dragger class displays a single image but allows the user to drag the </p>
<p class="calibre1">image anywhere in the window. You must call its handleEvent() method in </p>
<p class="calibre1">the event loop. When the user finishes dragging, handleEvent() returns True, </p>
<p class="calibre1">and you can call the Dragger object’s getMouseUpLoc() method to get the loca-</p>
<p class="calibre1">tion where the user released the mouse button. </p>
<p class="calibre1">The Animation and SpriteSheetAnimation classes handle building and </p>
<p class="calibre1">showing an animation. Both require a set of images to iterate through. </p>
<p class="calibre1">The Animation class gets the images from individual files, while the </p>
<p class="calibre1">SpriteSheetAnimation class requires a single image with evenly spaced internal </p>
<p class="calibre1">images. We’ll explore these classes more fully i<a href="index_split_005.html#p324">n Chapter 14. </a></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">pygwidgets Example Program</b></i></p>
<p class="calibre1">Figure 7-4 shows a screenshot of a sample program that demonstrates </p>
<p class="calibre1">objects instantiated from many of the classes in pygwidgets, including Image, </p>
<p class="calibre1">DisplayText, InputText, TextButton, CustomButton, TextRadioButton, CustomRadioButton, TextCheckBox, CustomCheckBox, ImageCollection, and Dragger. </p>
<p class="calibre1">The source of this example program can be found in the  <i class="calibre4">pygwidgets_test</i> </p>
<p class="calibre1">folder in my GitHub repository, <a href="https://github.com/IrvKalb/pygwidgets/"> <i class="calibre4">https://github.com/IrvKalb/pygwidgets/</i>. </a></p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">157</b></p>
<p class="calibre1"><a id="p187"/><img src="index-187_1.png" alt="Image 26" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 7-4: The window of a program that demonstrates objects instantiated  </i></p>
<p class="calibre1"> <i class="calibre4">from a variety of pygwidgets classes </i></p>
<p class="calibre1"><b class="calibre3">The Importance of a Consistent API</b></p>
<p class="calibre1">One final note about building an API for a set of classes: whenever possible, </p>
<p class="calibre1">it’s a very good idea to build consistency into the parameters of methods in </p>
<p class="calibre1">different, but similar, classes. As a good example, the first two parameters </p>
<p class="calibre1">to the __init__() method of every class in pygwidgets are window and loc, in </p>
<p class="calibre1">that order. If these had been in a different order in some calls, using the </p>
<p class="calibre1">package as a whole would be much more difficult. </p>
<p class="calibre1">Additionally, if different classes implement the same functionality, it’s a </p>
<p class="calibre1">good idea to use the same method names. For example, many of the classes </p>
<p class="calibre1">in pygwidgets have a method named setValue() and another named getValue(). </p>
<p class="calibre1">I’ll talk more about why this type of consistency is so important in the next </p>
<p class="calibre1">two chapters. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">This chapter provided an introduction to the object-oriented pygwidgets </p>
<p class="calibre1">package of graphical user interface widgets. We began by discussing default </p>
<p class="calibre1">values for parameters in methods, and I explained that a keyword param-</p>
<p class="calibre1">eter allows for a default value to be used if no matching argument value is </p>
<p class="calibre1">specified in a call. </p>
<p class="calibre1"><b class="calibre3">158</b>   Chapter 7</p>
<p class="calibre1"><a id="p188"/>I then introduced you to the pygwidgets module, which contains a number of prebuilt GUI widget classes, and showed you how to use several of </p>
<p class="calibre1">these. Finally, I showed a sample program that provides examples of most of </p>
<p class="calibre1">these widgets. </p>
<p class="calibre1">There are two key advantages to writing classes like those in pygwidgets. </p>
<p class="calibre1">First, classes can hide complexity in methods. Once you have your class </p>
<p class="calibre1">working correctly, you never have to worry about the internal details again. </p>
<p class="calibre1">Second, you can reuse the code by creating as many instances of a class as </p>
<p class="calibre1">you need. Your classes can provide basic functionality by including keyword </p>
<p class="calibre1">parameters with well-chosen default values. However, the default values can </p>
<p class="calibre1">easily be overwritten to allow for customization. </p>
<p class="calibre1">You can publish the interfaces of your classes for other programmers </p>
<p class="calibre1">(and yourself) to take advantage of in different projects. Good documen-</p>
<p class="calibre1">tation and consistency go a long way toward making these types of classes </p>
<p class="calibre1">highly usable. </p>
<p class="calibre1">Pygame GUI Widgets   <b class="calibre3">159</b></p>
<p class="calibre1"><a id="p189"/>
<a id="p190"/><b class="calibre3">PART III</b></p>
<p class="calibre1"><b class="calibre3">E N C A P S U L A T I O N , </b></p>
<p class="calibre1"><b class="calibre3">P O LY M O R P H I S M ,   A N D </b></p>
<p class="calibre1"><b class="calibre3">I N H E R I T A N C E</b></p>
<p class="calibre1">The three main tenets of object-oriented program-</p>
<p class="calibre1">ming are encapsulation, polymorphism, and inheri-</p>
<p class="calibre1">tance. The next three chapters will explain each of </p>
<p class="calibre1">these in turn, describing the underlying concepts and </p>
<p class="calibre1">showing examples of how they are implemented in </p>
<p class="calibre1">Python. In order for a programming language to call </p>
<p class="calibre1">itself an OOP language, it must support all three of </p>
<p class="calibre1">these central requirements. (If you’re ever asked in an </p>
<p class="calibre1">interview about the requirements for a language to be </p>
<p class="calibre1">object-oriented, here’s an easy way to remember them: </p>
<p class="calibre1">it’s as easy as PIE!)</p>
<p class="calibre1"><a href="#p192">Chapter 8 e</a>xplains encapsulation: hiding the details and keeping everything in one place. </p>
<p class="calibre1"><a href="#p212">Chapter 9 d</a>iscusses polymorphism: how multiple classes can have methods with the same names. </p>
<p class="calibre1"><a href="index_split_004.html#p240">Chapter 10 c</a>overs inheritance: building on code that already exists. </p>
<p class="calibre1">Finally<a href="index_split_004.html#p270">, Chapter 11 g</a>oes into detail on a number of topics (mostly dealing with memory management) that do not logically fit into the previous </p>
<p class="calibre1">three chapters but are useful and important to OOP. </p>
<p class="calibre1"><a id="p191"/>
<a id="p192"/><b class="calibre3">8</b></p>
<p class="calibre1"><b class="calibre3">E N C A P S U L A T I O N</b></p>
<p class="calibre1">The first of the three main tenets of object-</p>
<p class="calibre1">oriented programming is  <i class="calibre4">encapsulation</i>. This </p>
<p class="calibre1">word might conjure up an image of a space </p>
<p class="calibre1">capsule, a cell wall, or a medicine gelcap, where </p>
<p class="calibre1">the precious cargo inside is protected from the outside </p>
<p class="calibre1">environment. In programming, encapsulation has a </p>
<p class="calibre1">similar but even more detailed meaning: hiding inter-</p>
<p class="calibre1">nal details of state and behavior from any external </p>
<p class="calibre1">code and having all code in one place. </p>
<p class="calibre1">In this chapter, we’ll see how encapsulation works with functions, then </p>
<p class="calibre1">with methods of objects. I’ll discuss different interpretations of encapsu-</p>
<p class="calibre1">lation: using direct access versus using getters and setters. I’ll show how </p>
<p class="calibre1">Python allows you to mark an instance variable as private, indicating that </p>
<p class="calibre1">it should not be accessed by code external to a class, and I’ll touch on the </p>
<p class="calibre1">Python property decorator. Finally, I’ll discuss the concept of abstraction in </p>
<p class="calibre1">the design of classes. </p>
<p class="calibre1"><a id="p193"/><b class="calibre3">Encapsulation with Functions</b></p>
<p class="calibre1">Functions are a prime example of encapsulation because when you call a </p>
<p class="calibre1">function, you generally don’t care  <i class="calibre4">how</i> the function works internally. A well-written function contains a series of steps that make up a larger single task, </p>
<p class="calibre1">which you do care about. The name of the function should describe the </p>
<p class="calibre1">action that its code embodies. Consider the built-in len() function from the </p>
<p class="calibre1">Python Standard Library, used to find the number of characters in a string </p>
<p class="calibre1">or elements in a list. You pass in a string or list, and it returns the count. </p>
<p class="calibre1">When you write code that calls this function, you don’t care how len() does </p>
<p class="calibre1">what it does. You don’t stop to think about whether the code of the function </p>
<p class="calibre1">contains two lines or two thousand lines, whether it uses one local variable </p>
<p class="calibre1">or a hundred. You just need to know what argument to pass in and how to </p>
<p class="calibre1">use the result that’s returned. </p>
<p class="calibre1">The same is true of functions that you write, like this function that cal-</p>
<p class="calibre1">culates and returns the average of a list of numbers:</p>
<p class="calibre1">def calculateAverage(numbersList):</p>
<p class="calibre1">total = 0.0</p>
<p class="calibre1">for number in numbersList:</p>
<p class="calibre1">total = total + number</p>
<p class="calibre1">nElements = len(numbersList)</p>
<p class="calibre1">average = total / nElements</p>
<p class="calibre1">return average</p>
<p class="calibre1">Once you’ve tested a function like this and found that it works, you </p>
<p class="calibre1">no longer have to worry about the details of the implementation. You </p>
<p class="calibre1">only need to know what argument(s) to send into the function and what it </p>
<p class="calibre1">returns. </p>
<p class="calibre1">However, if one day you find that there is a much simpler or faster algo-</p>
<p class="calibre1">rithm to calculate an average, you could rewrite the function in a new way. </p>
<p class="calibre1">As long as the interface (the inputs and outputs) does not change, there is </p>
<p class="calibre1">no need to change any calls to the function. This type of modularization </p>
<p class="calibre1">makes the code more maintainable. </p>
<p class="calibre1"><b class="calibre3">Encapsulation with Objects</b></p>
<p class="calibre1">Unlike variables used in regular functions, instance variables in objects per-</p>
<p class="calibre1">sist across different method calls. To keep the remaining discussion clear, </p>
<p class="calibre1">I’ll introduce a new term:  <i class="calibre4">client</i>. (I don’t want to use the term  <i class="calibre4">user</i> here since that typically refers to the human user of the final program.)</p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">client</b> </p>
<p class="calibre1">Any software that creates an object from a class and makes calls to the methods of </p>
<p class="calibre1">that object . </p>
<p class="calibre1">We must also consider the duality of  <i class="calibre4">inside</i> versus  <i class="calibre4">outside</i> an object or class. When you’re working inside a class (writing the code of the methods </p>
<p class="calibre1">in a class), you need to concern yourself with how the different methods of </p>
<p class="calibre1"><b class="calibre3">164</b>   Chapter 8</p>
<p class="calibre1"><a id="p194"/>the class share the instance variables. You consider the efficiency of your algorithms. You think about what the interface should look like: what methods you should provide, what the parameters for each are, and what should </p>
<p class="calibre1">be used as default values. In short, you are concerned with the design and </p>
<p class="calibre1">implementation of the methods. </p>
<p class="calibre1">From the outside, as a client programmer, you need to know the inter-</p>
<p class="calibre1">face of the class. You’re concerned with what the class methods do, what </p>
<p class="calibre1">arguments should be passed in, and what data is passed back from each </p>
<p class="calibre1">method. </p>
<p class="calibre1">A class therefore provides encapsulation by:</p>
<p class="calibre1">•  Hiding all details of implementation in its methods and instance </p>
<p class="calibre1">variables  </p>
<p class="calibre1">•  Providing all the functionality a client needs from an object through its </p>
<p class="calibre1">interface (the methods defined in the class)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Objects Own Their Data</b></i></p>
<p class="calibre1">In object-oriented programming, we say that the data inside an object is </p>
<p class="calibre1"> <i class="calibre4">owned</i> by the object. OOP programmers generally agree that, as a good </p>
<p class="calibre1">design principle, client code should only be concerned with the interface </p>
<p class="calibre1">of a class and should not care about the implementation of the methods. </p>
<p class="calibre1">Consider the example of a simple Person class in Listing 8-1. </p>
<p class="calibre1">class Person():</p>
<p class="calibre1">def __init__(self, name, salary):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">self.salary = salary</p>
<p class="calibre1"> <i class="calibre4">Listing 8-1: Data ownership in the Person class</i></p>
<p class="calibre1">The values of the instance variables self.name and self.salary are set </p>
<p class="calibre1">whenever we instantiate new Person objects, like this:</p>
<p class="calibre1">oPerson1 = Person('Joe Schmoe', 90000)</p>
<p class="calibre1">oPerson2 = Person('Jane Smith', 99000)</p>
<p class="calibre1">Each Person object owns its own set of the two instance variables. </p>
<p class="calibre1"><b class="calibre3">Interpretations of Encapsulation</b></p>
<p class="calibre1">Here is where things get a little controversial. Different programmers </p>
<p class="calibre1">have different views about the accessibility of an instance variable. Python </p>
<p class="calibre1">provides for a loose interpretation of encapsulation by allowing direct </p>
<p class="calibre1">access to instance variables using simple dot syntax. Client code can </p>
<p class="calibre1">legally access an instance variable of an object by name using the syntax  </p>
<p class="calibre1"> <i class="calibre4">&lt;object&gt; </i>.  <i class="calibre4">&lt;instanceVariableName&gt; </i>. </p>
<p class="calibre1">Encapsulation   <b class="calibre3">165</b></p>
<p class="calibre1"><a id="p195"/>However, a  <i class="calibre4">strict</i> interpretation of encapsulation says that client software should never be able to retrieve or change the value of an instance variable </p>
<p class="calibre1">directly. Instead, the only way that a client can retrieve or change a value </p>
<p class="calibre1">held in an object is to use a method provided by the class for this purpose. </p>
<p class="calibre1">Let’s look at both approaches. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Direct Access and Why You Should Avoid It</b></i></p>
<p class="calibre1">As mentioned, Python does allow direct access to instance variables. Listing 8-2 </p>
<p class="calibre1">instantiates the same two objects from the Person class in Listing 8-1 as in the </p>
<p class="calibre1">previous section, but then accesses their self.salary instance variables directly. </p>
<p class="calibre1"><b class="calibre3">File: PersonGettersSettersAndDirectAccess/Main_PersonDirectAccess.py</b></p>
<p class="calibre1"># Person example main program using direct access</p>
<p class="calibre1">from Person import *</p>
<p class="calibre1">oPerson1 = Person('Joe Schmoe', 90000)</p>
<p class="calibre1">oPerson2 = Person('Jane Smith', 99000)</p>
<p class="calibre1"># Get the values of the salary variable directly</p>
<p class="calibre1">1 print(oPerson1.salary)</p>
<p class="calibre1">print(oPerson2.salary)</p>
<p class="calibre1"># Change the salary variable directly</p>
<p class="calibre1">2 oPerson1.salary = 100000</p>
<p class="calibre1">oPerson2.salary = 111111</p>
<p class="calibre1"># Get the updated salaries and print again</p>
<p class="calibre1">print(oPerson1.salary)</p>
<p class="calibre1">print(oPerson2.salary)</p>
<p class="calibre1"> <i class="calibre4">Listing 8-2: Example main code using direct access to an instance variable</i></p>
<p class="calibre1">Python allows you to write code like this that reaches into an object to </p>
<p class="calibre1">directly get 1 and set 2 any instance variable using standard dot syntax. </p>
<p class="calibre1">Most Python programmers feel that this technique is perfectly acceptable. </p>
<p class="calibre1">In fact, Guido van Rossum (the creator of Python) famously said in refer-</p>
<p class="calibre1">ence to this issue, “We are all adults here,” meaning that programmers </p>
<p class="calibre1">should know what they are doing, and the risks involved, when they attempt </p>
<p class="calibre1">to access instance variables directly. </p>
<p class="calibre1">However, I strongly believe that directly accessing an instance variable </p>
<p class="calibre1">of an object is an extremely dangerous practice, as it breaks the core idea </p>
<p class="calibre1">of encapsulation. To illustrate why this is the case, let’s take a look at a few </p>
<p class="calibre1">example scenarios where direct access can be problematic. </p>
<p class="calibre1"><b class="calibre3">Changing the Name of an Instance Variable</b></p>
<p class="calibre1">The first problem with direct access is that changing the name of an </p>
<p class="calibre1">instance variable will break any client code that uses the original name </p>
<p class="calibre1"><b class="calibre3">166</b>   Chapter 8</p>
<p class="calibre1"><a id="p196"/>directly. This can happen when the developer of a class decides that the initial choice of the name of the variable was not optimal, for reasons such as </p>
<p class="calibre1">the following: </p>
<p class="calibre1">•  The name doesn’t describe the data it represents clearly enough. </p>
<p class="calibre1">•  The variable is a Boolean, and they want to swap what True and False </p>
<p class="calibre1">represent by renaming the variable (for example, closed to open, allowed </p>
<p class="calibre1">to disallowed, active to disabled). </p>
<p class="calibre1">•  There was a spelling or capitalization mistake in the original name. </p>
<p class="calibre1">•  The variable was originally a Boolean, but they later realize that they </p>
<p class="calibre1">need to represent more than two values. </p>
<p class="calibre1">In any of these cases, if the developer changes the name of an instance </p>
<p class="calibre1">variable in the class from self.  <i class="calibre4">&lt;originalName&gt; </i> to self.  <i class="calibre4">&lt;newName&gt; </i>, then any client software that uses the original name directly will break. </p>
<p class="calibre1"><b class="calibre3">Changing an Instance Variable into a Calculation</b></p>
<p class="calibre1">A second situation where direct access is problematic is when the code of </p>
<p class="calibre1">a class needs to change to meet new requirements. Suppose that when </p>
<p class="calibre1">writing a class, you use an instance variable to represent a piece of data, </p>
<p class="calibre1">but the functionality changes so that you need an algorithm to compute a </p>
<p class="calibre1">value instead. Take our Account class fro<a href="index_split_001.html#p86">m Chapter 4, f</a>or example. To make our bank accounts more realistic, we might want to add an interest rate. </p>
<p class="calibre1">You might think this is a simple matter of adding an instance variable for </p>
<p class="calibre1">the interest rate named self.interestRate. Then, using the direct access </p>
<p class="calibre1">approach, client software could access this value of an Account object using:</p>
<p class="calibre1">oAccount.interestRate</p>
<p class="calibre1">This would work, for a while. But later the bank might decide on a new </p>
<p class="calibre1">policy—say that the interest rate will depend on the amount of money in </p>
<p class="calibre1">the account. The interest rate might be calculated like this:</p>
<p class="calibre1">def calculateInterestRate(self):</p>
<p class="calibre1"># Assuming self.balance has been set in another method</p>
<p class="calibre1">if self.balance &lt; 1000:</p>
<p class="calibre1">self.interestRate = 1.0</p>
<p class="calibre1">elif self.balance &lt; 5000:</p>
<p class="calibre1">self.interestRate = 1.5</p>
<p class="calibre1">else:</p>
<p class="calibre1">self.interestRate = 2.0</p>
<p class="calibre1">Rather than just relying on a single interest rate value in self.interestRate, </p>
<p class="calibre1">the calculateInterestRate() method determines the current rate based on the </p>
<p class="calibre1">account balance. </p>
<p class="calibre1">Any client software that directly accesses oAccount.interestRate and </p>
<p class="calibre1">uses the value of the instance variable might then get an outdated value, </p>
<p class="calibre1">depending on the last time calculateInterestRate() was called. And any </p>
<p class="calibre1">Encapsulation   <b class="calibre3">167</b></p>
<p class="calibre1"><a id="p197"/>client software that  <i class="calibre4">sets</i> a new interestRate may find that the new value is mysteriously changed by some other code that calls calculateInterestRate() </p>
<p class="calibre1">or when the bank account owner makes a deposit or withdrawal. </p>
<p class="calibre1">If, however, the interest calculation method was named getInterestRate() </p>
<p class="calibre1">and client software called that instead, the interest rate would always be cal-</p>
<p class="calibre1">culated on the fly and there would be no potential error. </p>
<p class="calibre1"><b class="calibre3">Validating Data</b></p>
<p class="calibre1">The third reason to avoid direct access when setting a value is that client </p>
<p class="calibre1">code can too easily set an instance variable to an invalid value. A better </p>
<p class="calibre1">approach is to call a method in the class, whose job is to set the value. As </p>
<p class="calibre1">the developer, you can include validation code in that method to ensure </p>
<p class="calibre1">that the value being set is appropriate. Consider the code in Listing 8-3, </p>
<p class="calibre1">whose purpose is to manage the members of a club. </p>
<p class="calibre1"><b class="calibre3">File: ValidatingData_ClubExample/Club.py</b></p>
<p class="calibre1"># Club class </p>
<p class="calibre1">class Club():</p>
<p class="calibre1">def __init__(self, clubName, maxMembers):</p>
<p class="calibre1">self.clubName = clubName 1</p>
<p class="calibre1">self.maxMembers = maxMembers</p>
<p class="calibre1">self.membersList = []</p>
<p class="calibre1">def addMember(self, name): 2</p>
<p class="calibre1"># Make sure that there is enough room left</p>
<p class="calibre1">if len(self.membersList) &lt; self.maxMembers:</p>
<p class="calibre1">self.membersList.append(name)</p>
<p class="calibre1">print('OK.', name, 'has been added to the', self.clubName, 'club')</p>
<p class="calibre1">else:</p>
<p class="calibre1">print('Sorry, but we cannot add', name, 'to the', self.clubName, 'club.')</p>
<p class="calibre1">print('This club already has the maximum of', self.maxMembers, 'members.') </p>
<p class="calibre1">def report(self): 3</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('Here are the', len(self.membersList), 'members of the', self.clubName, </p>
<p class="calibre1">'club:')</p>
<p class="calibre1">for name in self.membersList:</p>
<p class="calibre1">print('   ' + name)</p>
<p class="calibre1">print()</p>
<p class="calibre1"> <i class="calibre4">Listing 8-3: An example of a Club class</i></p>
<p class="calibre1">The Club code keeps track of the name of the club, the maximum num-</p>
<p class="calibre1">ber of members, and the list of members, all in instance variables 1. Once </p>
<p class="calibre1">instantiated, you can call methods to add a member to the club 2 and to </p>
<p class="calibre1">report the members of the club 3. (We could easily add more methods to </p>
<p class="calibre1"><b class="calibre3">168</b>   Chapter 8</p>
<p class="calibre1"><a id="p198"/>remove members, change names, and so on, but these two are good enough the make the point.) </p>
<p class="calibre1">Here is some test code that uses the Club class. </p>
<p class="calibre1"><b class="calibre3">File: ValidatingData_ClubExample/Main_Club.py</b></p>
<p class="calibre1"># Club example main program</p>
<p class="calibre1">from Club import *</p>
<p class="calibre1"># Create a club with at most 5 members</p>
<p class="calibre1">oProgrammingClub = Club('Programming', 5)</p>
<p class="calibre1">oProgrammingClub.addMember('Joe Schmoe')</p>
<p class="calibre1">oProgrammingClub.addMember('Cindy Lou Hoo')</p>
<p class="calibre1">oProgrammingClub.addMember('Dino Richmond')</p>
<p class="calibre1">oProgrammingClub.addMember('Susie Sweetness')</p>
<p class="calibre1">oProgrammingClub.addMember('Fred Farkle')</p>
<p class="calibre1">oProgrammingClub.report()</p>
<p class="calibre1">We create a Programming club that allows a maximum of five members </p>
<p class="calibre1">and then we add five members. The code runs well and reports the mem-</p>
<p class="calibre1">bers added to the club:</p>
<p class="calibre1">OK. Joe Schmoe has been added to the Programming club</p>
<p class="calibre1">OK. Cindy Lou Hoo has been added to the Programming club</p>
<p class="calibre1">OK. Dino Richmond has been added to the Programming club</p>
<p class="calibre1">OK. Susie Sweetness has been added to the Programming club</p>
<p class="calibre1">OK. Fred Farkle has been added to the Programming club</p>
<p class="calibre1">Now let’s try to add a sixth member:</p>
<p class="calibre1"># Attempt to add additional member</p>
<p class="calibre1">oProgrammingClub.addMember('Iwanna Join')</p>
<p class="calibre1">This attempt to add a member is rejected, and we see an appropriate </p>
<p class="calibre1">error message:</p>
<p class="calibre1">Sorry, but we cannot add Iwanna Join to the Programming club. </p>
<p class="calibre1">This club already has the maximum of 5 members. </p>
<p class="calibre1">The code of addMember() does all the validation needed to ensure that </p>
<p class="calibre1">a call to add a new member works correctly or generates an error message. </p>
<p class="calibre1">However, with direct access, a client could change the fundamental nature </p>
<p class="calibre1">of the Club class. For example, a client could maliciously or accidentally </p>
<p class="calibre1">change the maximum number of members:</p>
<p class="calibre1">oProgrammingClub.maxMembers = 300</p>
<p class="calibre1">Further, suppose you know that the Club class represents the members </p>
<p class="calibre1">as a list, and you know the name of the instance variable that represents the </p>
<p class="calibre1">Encapsulation   <b class="calibre3">169</b></p>
<p class="calibre1"><a id="p199"/>members. In that case you can write client code to add to the list of members directly, without making the method call, like so:</p>
<p class="calibre1">oProgrammingClub.memberList.append('Iwanna Join')</p>
<p class="calibre1">This line would push the membership over the intended limit because </p>
<p class="calibre1">it avoids the code that ensures that the request to add the member is valid. </p>
<p class="calibre1">Client code using direct access could even cause an error inside the </p>
<p class="calibre1">Club object. For example, the instance variable self.maxMembers is intended </p>
<p class="calibre1">to be an integer. Using direct access, client code could change its value to a </p>
<p class="calibre1">string. Any subsequent call to addMember() would crash at the first line of that </p>
<p class="calibre1">method, where it attempts to compare the length of the list of members </p>
<p class="calibre1">against the maximum number of members, because Python cannot com-</p>
<p class="calibre1">pare an integer to a string. </p>
<p class="calibre1">Allowing direct access to instance variables from outside an object can </p>
<p class="calibre1">be dangerous, bypassing safeguards that were designed to protect the data </p>
<p class="calibre1">of an object. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Strict Interpretation with Getters and Setters</b></i></p>
<p class="calibre1">The strict approach to encapsulation says that client code  <i class="calibre4">never</i> accesses an instance variable directly. If a class wants to allow client software to access </p>
<p class="calibre1">the information held inside an object, the standard approach is to include a </p>
<p class="calibre1"> <i class="calibre4">getter</i> and a  <i class="calibre4">setter</i> method in the class. </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">getter</b> </p>
<p class="calibre1">A method that retrieves data from an object instantiated from a class . </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">setter</b> </p>
<p class="calibre1">A method that assigns data into an object instantiated from a class . </p>
<p class="calibre1">Getter and setter methods are designed to allow writers of client soft-</p>
<p class="calibre1">ware to get data from and set data in an object, without needing explicit </p>
<p class="calibre1">knowledge of the implementation of a class—specifically, without having </p>
<p class="calibre1">to know or use the name of any instance variable. The Person class code </p>
<p class="calibre1">in Listing 8-1 has an instance variable self.salary. In Listing 8-4 we add a </p>
<p class="calibre1">getter and a setter to the Person class to allow the caller to get and set the </p>
<p class="calibre1">salary, without providing direct access to the Person’s self.salary instance </p>
<p class="calibre1">variable. </p>
<p class="calibre1"><b class="calibre3">File: PersonGettersSettersAndDirectAccess/Person.py</b></p>
<p class="calibre1">class Person():</p>
<p class="calibre1">def __init__(self, name, salary):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">self.salary = salary</p>
<p class="calibre1"># Allow the caller to retrieve the salary</p>
<p class="calibre1">1 def getSalary(self):  </p>
<p class="calibre1"><b class="calibre3">170</b>   Chapter 8</p>
<p class="calibre1"><a id="p200"/>        return self.salary</p>
<p class="calibre1"># Allow the caller to set a new salary</p>
<p class="calibre1">2 def setSalary(self, salary): </p>
<p class="calibre1">self.salary = salary</p>
<p class="calibre1"> <i class="calibre4">Listing 8-4: An example of a Person class with a get er and a set er</i></p>
<p class="calibre1">The get 1 and set 2 portions of these method names are not required </p>
<p class="calibre1">but are used by convention. You generally follow these words with a descrip-</p>
<p class="calibre1">tion of the data being accessed, in this case Salary. While it is typical to </p>
<p class="calibre1">use the name of the instance variable being accessed, this is also not a </p>
<p class="calibre1">requirement. </p>
<p class="calibre1">Listing 8-5 shows some test code that instantiates two Person objects, </p>
<p class="calibre1">then gets and sets their salaries using these getter and setter methods. </p>
<p class="calibre1"><b class="calibre3">File: PersonGettersSettersAndDirectAccess/Main_PersonGetterSetter.py</b></p>
<p class="calibre1"># Person example main program using getters and setters</p>
<p class="calibre1">from Person import *</p>
<p class="calibre1">1 oPerson1 = Person('Joe Schmoe', 90000)</p>
<p class="calibre1">oPerson2 = Person('Jane Smith', 99000)</p>
<p class="calibre1"># Get the salaries using getter and print</p>
<p class="calibre1">2 print(oPerson1.getSalary())</p>
<p class="calibre1">print(oPerson2.getSalary())</p>
<p class="calibre1"># Change the salaries using setter</p>
<p class="calibre1">3 oPerson1.setSalary(100000)</p>
<p class="calibre1">oPerson2.setSalary(111111)</p>
<p class="calibre1"># Get the salaries and print again</p>
<p class="calibre1">print(oPerson1.getSalary())</p>
<p class="calibre1">print(oPerson2.getSalary())</p>
<p class="calibre1"> <i class="calibre4">Listing 8-5: Example main code using get er and set er methods</i></p>
<p class="calibre1">First we create two Person objects from the Person class 1. Then we use </p>
<p class="calibre1">the getter and setter methods to retrieve 2 and change 3 the salaries in </p>
<p class="calibre1">the Person objects. </p>
<p class="calibre1">Getters and setters provide a formal way to get and set values in an </p>
<p class="calibre1">object. They enforce a layer of protection that only allows access to instance </p>
<p class="calibre1">variables if the class writer wants to allow it. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">Some Python literature uses the terms </i> accessor <i class="calibre4"> for a getter method and </i> mutator <i class="calibre4"> for</i> <i class="calibre4">the setter method. These are just different names for the same things. I will use the</i> <i class="calibre4">more generic terms </i> getter <i class="calibre4"> and </i> setter <i class="calibre4">. </i></p>
<p class="calibre1">Encapsulation   <b class="calibre3">171</b></p>
<p class="calibre1"><a id="p201"/> <i class="calibre4"><b class="calibre3">Safe Direct Access</b></i></p>
<p class="calibre1">There are certain circumstances where it seems reasonable to access </p>
<p class="calibre1">instance variables directly: when it is absolutely clear what the instance vari-</p>
<p class="calibre1">able means, little or no validation of the data is needed, and there is no </p>
<p class="calibre1">chance that the name will ever change. A good example of this is the Rect </p>
<p class="calibre1">(rectangle) class in the pygame package. A rectangle in pygame is defined </p>
<p class="calibre1">using four values—x, y, width, and height—like this:</p>
<p class="calibre1">oRectangle = pygame.Rect(10, 20, 300, 300)</p>
<p class="calibre1">After creating that rectangle object, using oRectangle.x, oRectangle.y, </p>
<p class="calibre1">oRectangle.width, and oRectangle.height directly as variables seems acceptable. </p>
<p class="calibre1"><b class="calibre3">Making Instance Variables More Private</b></p>
<p class="calibre1">In Python, all instance variables are public (that is, can be accessed by code </p>
<p class="calibre1">external to the class). But what if you want to allow access to some of your </p>
<p class="calibre1">class’s instance variables, but not all of them? Some OOP languages allow </p>
<p class="calibre1">you to explicitly mark certain instance variables as public or private, but </p>
<p class="calibre1">Python doesn’t have those keywords. However, there are two ways that pro-</p>
<p class="calibre1">grammers who develop classes in Python can indicate that their instance </p>
<p class="calibre1">variables and methods are intended to be private. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Implicitly Private</b></i></p>
<p class="calibre1">To mark an instance variable as one that should never be accessed exter-</p>
<p class="calibre1">nally, by convention you start the name of your instance variable with one </p>
<p class="calibre1">leading underscore:</p>
<p class="calibre1">self._name </p>
<p class="calibre1">self._socialSecurityNumber</p>
<p class="calibre1">self._dontTouchThis</p>
<p class="calibre1">Instance variables with names like these are intended to represent pri-</p>
<p class="calibre1">vate data, and client software should never attempt to access them directly. </p>
<p class="calibre1">The code may still work if the instance variables are accessed, but it is not </p>
<p class="calibre1">guaranteed. </p>
<p class="calibre1">The same convention is used for method names:</p>
<p class="calibre1">def _internalMethod(self):</p>
<p class="calibre1">def _dontCallMeFromClientSoftware(self):</p>
<p class="calibre1">Again, this is only a convention; there is no enforcement. If any client </p>
<p class="calibre1">software makes a call to a method with a name beginning with an under-</p>
<p class="calibre1">score, Python will allow it, but there is a good chance that doing so will  </p>
<p class="calibre1">lead to unexpected errors. </p>
<p class="calibre1"><b class="calibre3">172</b>   Chapter 8</p>
<p class="calibre1"><a id="p202"/> <i class="calibre4"><b class="calibre3">More Explicitly Private</b></i></p>
<p class="calibre1">Python does allow for a more explicit level of privatization. To disallow client </p>
<p class="calibre1">software from directly accessing your data, you create an instance variable </p>
<p class="calibre1">name that starts with two underscores. </p>
<p class="calibre1">Suppose we create a class named PrivatePerson with an instance variable </p>
<p class="calibre1">self.__privateData that should never be accessed from outside an object:</p>
<p class="calibre1"># PrivatePerson class </p>
<p class="calibre1">class PrivatePerson():</p>
<p class="calibre1">def __init__(self, name, privateData):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">1 self.__privateData = privateData</p>
<p class="calibre1">def getName(self):</p>
<p class="calibre1">return self.name</p>
<p class="calibre1">def setName(self, name):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">We can then create a PrivatePerson object, passing in some data that we </p>
<p class="calibre1">wish to keep private 1. Attempting to access the __privateData instance vari-</p>
<p class="calibre1">able directly from client software, like this: </p>
<p class="calibre1">usersPrivateData = oPrivatePerson.__privateData</p>
<p class="calibre1">will generate an error:</p>
<p class="calibre1">AttributeError: 'PrivatePerson' object has no attribute '__privateData' </p>
<p class="calibre1">Similarly, if you create a method name that starts with two underscores, </p>
<p class="calibre1">any attempt by client software to call the method will generate an error. </p>
<p class="calibre1">Python provides this ability by performing  <i class="calibre4">name mangling</i>. Behind </p>
<p class="calibre1">the scenes, Python changes any name that starts with two underscores by </p>
<p class="calibre1">prepending it with an underscore and the name of the class, so __ <i class="calibre4">&lt;name&gt; </i> </p>
<p class="calibre1">becomes _ <i class="calibre4">&lt;className&gt; </i> __ <i class="calibre4">&lt;name&gt; </i>. For example, in the PrivatePerson class, Python will change self.__privateData to self._PrivatePerson__privateData. Therefore, </p>
<p class="calibre1">if a client tries to use the name oPrivatePerson.__privateData, that name won’t </p>
<p class="calibre1">be recognized. </p>
<p class="calibre1">This is a subtle change designed as a deterrent to using direct </p>
<p class="calibre1">access, but you should note that it doesn’t absolutely guarantee privacy. </p>
<p class="calibre1">If the client programmer knows how this works, they can still access the </p>
<p class="calibre1">instance variable with  <i class="calibre4">&lt;object&gt; </i>._ <i class="calibre4">&lt;className&gt; </i> __ <i class="calibre4">&lt;name&gt; </i> (or, in our example, oPrivatePerson._PrivatePerson__privateData). </p>
<p class="calibre1">Encapsulation   <b class="calibre3">173</b></p>
<p class="calibre1"><a id="p203"/><b class="calibre3">Decorators and @property</b></p>
<p class="calibre1">At a high level, a decorator is a method that takes another method as an </p>
<p class="calibre1">argument and extends the way the original method works. (Decorators can </p>
<p class="calibre1">also be functions that decorate functions or methods, but I’ll concentrate </p>
<p class="calibre1">on methods.) Decorators are an advanced topic and are generally beyond </p>
<p class="calibre1">the scope of this book. However, there is a set of built-in decorators that </p>
<p class="calibre1">provide a compromise between direct access and the use of getters and set-</p>
<p class="calibre1">ters in a class. </p>
<p class="calibre1">A decorator is written as a line that starts with the @ symbol followed </p>
<p class="calibre1">by a decorator name and is placed directly before the def statement of a </p>
<p class="calibre1">method. This applies the decorator to a method to add to its behavior: </p>
<p class="calibre1">@ <i class="calibre4">&lt;decorator&gt; </i></p>
<p class="calibre1">def  <i class="calibre4">&lt;someMethod&gt; </i>(self,  <i class="calibre4">&lt;parameters&gt; </i>)  </p>
<p class="calibre1">We’ll use two built-in decorators and apply them to two methods in a </p>
<p class="calibre1">class to implement a  <i class="calibre4">property</i>. </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">property</b> </p>
<p class="calibre1">An attribute of a class that appears to client code to be an instance variable, but instead causes a method to be called when it is accessed . </p>
<p class="calibre1">A property allows class developers to use indirection, the way that </p>
<p class="calibre1">a magician uses misdirection—the audience thinks they are seeing one </p>
<p class="calibre1">thing, while behind the scenes something very different is happening. </p>
<p class="calibre1">When writing a class to use property decorators, the developer writes a get-</p>
<p class="calibre1">ter and a setter method and adds a distinct built-in decorator to each one. </p>
<p class="calibre1">The first method is a getter and is preceded with the built-in @property deco-</p>
<p class="calibre1">rator. The name of the method defines a name of a property to be used by </p>
<p class="calibre1">client code. The second method is a setter and is preceded with the @ <i class="calibre4">&lt;name </i></p>
<p class="calibre1"> <i class="calibre4">of the property&gt; </i>.setter decorator. Here is a minimal sample class:</p>
<p class="calibre1">class Example():</p>
<p class="calibre1">def __init__(self, startingValue):</p>
<p class="calibre1">self._x = startingValue</p>
<p class="calibre1">@property</p>
<p class="calibre1">def x(self):  # this is the decorated getter method</p>
<p class="calibre1">return self._x</p>
<p class="calibre1">@x.setter</p>
<p class="calibre1">def x(self, value):  # this is the decorated setter method</p>
<p class="calibre1">self._x = value</p>
<p class="calibre1">In the Example class, x is the name of the property. After the standard </p>
<p class="calibre1">__init__() method, the unusual thing is that we have two methods that both </p>
<p class="calibre1">have the same name: the name of the property. The first method is a get-</p>
<p class="calibre1">ter, while the second is a setter. The setter method is optional, and if it’s not </p>
<p class="calibre1">present, the property will be read-only. </p>
<p class="calibre1"><b class="calibre3">174</b>   Chapter 8</p>
<p class="calibre1"><a id="p204"/>Given the Example class, here is some sample client code:</p>
<p class="calibre1">oExample = Example(10)</p>
<p class="calibre1">print(oExample.x)</p>
<p class="calibre1">oExample.x = 20</p>
<p class="calibre1">In this code we create an instance of the Example class, make a call to </p>
<p class="calibre1">print(), and execute a simple assignment. From the client’s point of view, </p>
<p class="calibre1">this code is highly readable. When we write oExample.x, it looks like we are </p>
<p class="calibre1">using direct access to an instance variable. However, when client code </p>
<p class="calibre1">accesses the value of an object’s property (on the right side of an assign-</p>
<p class="calibre1">ment statement or as an argument in a call to a function or method), </p>
<p class="calibre1">Python translates it into a call to the getter method of the object. When an </p>
<p class="calibre1">object dot property appears on the left side of an assignment statement, </p>
<p class="calibre1">Python calls the setter method. The getter and setter methods affect the </p>
<p class="calibre1">real instance variable, self._x. </p>
<p class="calibre1">Here is a more realistic example that should help make this clear. </p>
<p class="calibre1">Listing 8-6 shows a Student class that includes a property grade, properly dec-</p>
<p class="calibre1">orated getter and setter methods, and a private instance variable __grade. </p>
<p class="calibre1"><b class="calibre3">File: PropertyDecorator/Student.py</b></p>
<p class="calibre1"># Using a property to (indirectly) access data in an object</p>
<p class="calibre1">class Student():</p>
<p class="calibre1">def __init__(self, name, startingGrade=0):</p>
<p class="calibre1">self.__name = name</p>
<p class="calibre1">self.grade = startingGrade 1</p>
<p class="calibre1">@property 2</p>
<p class="calibre1">def grade(self): 3</p>
<p class="calibre1">return self.__grade</p>
<p class="calibre1">@grade.setter 4</p>
<p class="calibre1">def grade(self, newGrade): 5</p>
<p class="calibre1">try:</p>
<p class="calibre1">newGrade = int(newGrade)</p>
<p class="calibre1">except (TypeError, ValueError) as e:</p>
<p class="calibre1">raise type(e)('New grade: ' + str(newGrade) + ', is an invalid type.')</p>
<p class="calibre1">if (newGrade &lt; 0) or (newGrade &gt; 100):</p>
<p class="calibre1">raise ValueError('New grade: ' + str(newGrade) + ', must be between 0 and 100.')</p>
<p class="calibre1">self.__grade = newGrade</p>
<p class="calibre1"> <i class="calibre4">Listing 8-6: The Student class with property decorators</i></p>
<p class="calibre1">The __init__() method has a little trick to it, so let’s examine the </p>
<p class="calibre1">other methods first. Notice we have two methods with the name grade(). </p>
<p class="calibre1">Preceding the definition of the first grade() method, we add an @property </p>
<p class="calibre1">decorator 2. This defines the name grade as a property of any object cre-</p>
<p class="calibre1">ated from this class. The first method 3 is a getter that just returns the </p>
<p class="calibre1">Encapsulation   <b class="calibre3">175</b></p>
<p class="calibre1"><a id="p205"/>value of the current grade, kept in the private self.__grade instance variable, but could include any code that might be needed to calculate a value and </p>
<p class="calibre1">return it. </p>
<p class="calibre1">Preceding the second grade() method is an @grade.setter decorator 4. </p>
<p class="calibre1">This second method 5 accepts a new value as a parameter, does a num-</p>
<p class="calibre1">ber of checks to ensure that value is valid, then sets the new value into </p>
<p class="calibre1">self.__grade. </p>
<p class="calibre1">The __init__() method first stores the student’s name in an instance </p>
<p class="calibre1">variable. The next line 1 seems straightforward but is a little unusual. As </p>
<p class="calibre1">we have seen, we typically store the values of parameters into instance vari-</p>
<p class="calibre1">ables. Therefore, we might be tempted to write this line as:</p>
<p class="calibre1">self.__grade = startingGrade</p>
<p class="calibre1">But instead, we are storing the starting grade into the property grade. </p>
<p class="calibre1">Since grade is a property, Python translates this assignment statement into a </p>
<p class="calibre1">call to the setter method 5, which has the advantage of validating the input </p>
<p class="calibre1">before storing the value in the instance variable self.__grade. </p>
<p class="calibre1">Listing 8-7 provides some test code that uses the Student class. </p>
<p class="calibre1"><b class="calibre3">File: PropertyDecorator/Main_Property.py</b></p>
<p class="calibre1"># Main Student property example</p>
<p class="calibre1">1 oStudent1= Student('Joe Schmoe')</p>
<p class="calibre1">oStudent2= Student ('Jane Smith')</p>
<p class="calibre1"># Get the students' grades using the 'grade' property and print</p>
<p class="calibre1">2 print(oStudent1.grade)</p>
<p class="calibre1">print(oStudent2.grade)</p>
<p class="calibre1">print()</p>
<p class="calibre1"># Set new values using the 'grade' property</p>
<p class="calibre1">3 oStudent1.grade = 85</p>
<p class="calibre1">oStudent2.grade = 92</p>
<p class="calibre1">4 print(oStudent1.grade)</p>
<p class="calibre1">print(oStudent2.grade)</p>
<p class="calibre1"> <i class="calibre4">Listing 8-7: The main code that creates Student objects and accesses a property</i> In the test code, we first create two Student objects 1 and print the </p>
<p class="calibre1">grade of each 2. It looks like we’re reaching into each object directly to get </p>
<p class="calibre1">the grade values, but since grade is a property Python turns these lines into </p>
<p class="calibre1">calls to the getter method and returns the value of the private instance vari-</p>
<p class="calibre1">able self.__grade for each object. </p>
<p class="calibre1">We then set new grade values for each Student object 3. Here it looks </p>
<p class="calibre1">like we’re setting values directly into each object’s data, but again, because </p>
<p class="calibre1">grade is a property, Python turns these lines into calls to the setter method. </p>
<p class="calibre1">That method validates each value before doing the assignment. The test </p>
<p class="calibre1">code ends by printing the new values of the grades 4. </p>
<p class="calibre1"><b class="calibre3">176</b>   Chapter 8</p>
<p class="calibre1"><a id="p206"/>When we run the test code, we get this output, as we expect:</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">85</p>
<p class="calibre1">92</p>
<p class="calibre1">Using the @property and @ <i class="calibre4">&lt;property_name&gt; </i>.setter decorators gives you the best of both the direct access and getter-and-setter worlds. Client software </p>
<p class="calibre1">can be written in a way that  <i class="calibre4">appears</i> to access instance variables directly, but as the class programmer, your decorated methods get and set the actual </p>
<p class="calibre1">instance variables owned by the object and even allow for validation of </p>
<p class="calibre1">inputs. This approach supports encapsulation because the client code is not </p>
<p class="calibre1">accessing an instance variable directly. </p>
<p class="calibre1">While this technique is used by many professional Python developers, </p>
<p class="calibre1">I personally find it a little ambiguous, because when I read other develop-</p>
<p class="calibre1">ers’ code that uses this approach, it is not immediately apparent whether it’s </p>
<p class="calibre1">using direct accesses to instance variables or using properties that Python </p>
<p class="calibre1">translates into calls to decorated methods. I prefer to use standard getter </p>
<p class="calibre1">and setter methods and will use them in the rest of this book. </p>
<p class="calibre1"><b class="calibre3">Encapsulation in pygwidgets Classes</b></p>
<p class="calibre1">The definition of encapsulation at the start of this chapter focused on two </p>
<p class="calibre1">areas: hiding internal details and having all related code in one place. All </p>
<p class="calibre1">the classes in pygwidgets were designed with these considerations in mind. </p>
<p class="calibre1">As examples, consider the TextButton and CustomButton classes. </p>
<p class="calibre1">The methods of these two classes encapsulate all the functionality of </p>
<p class="calibre1">GUI buttons. While the source code of these classes is available, there is no </p>
<p class="calibre1">need for a client programmer to look at it to use them effectively. There’s </p>
<p class="calibre1">also no need for client code to attempt to access any of their instance vari-</p>
<p class="calibre1">ables: all button functionality is available through calling the methods of </p>
<p class="calibre1">these classes. This adheres to the strict interpretation of encapsulation, </p>
<p class="calibre1">meaning that the  <i class="calibre4">only</i> way that client software should access an object’s data is by calling that object’s methods. A client programmer can think of these </p>
<p class="calibre1">classes as black boxes, since there is no reason to look at how they accom-</p>
<p class="calibre1">plish their tasks. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">A whole </i> black box testing <i class="calibre4"> industry has developed around the idea of a test programmer being given a class to test without being allowed to see the code of the class. </i></p>
<p class="calibre1"> <i class="calibre4">The tester is only supplied with documentation of the interfaces, and with that writes</i> <i class="calibre4">code that tests all the interfaces under many different cases to ensure that all methods</i> <i class="calibre4">work as described. The set of tests not only ensures that the code and documentation</i> <i class="calibre4">match, but is used again whenever code is added or modified in the class to ensure</i> <i class="calibre4">that the changes have not broken anything. </i></p>
<p class="calibre1">Encapsulation   <b class="calibre3">177</b></p>
<p class="calibre1"><a id="p207"/><b class="calibre3">A Story from the Real World</b></p>
<p class="calibre1">A number of years ago, I was involved in the design and development of </p>
<p class="calibre1">a very large educational project that was built in an environment called </p>
<p class="calibre1"> <i class="calibre4">Director</i> from Macromedia (later Adobe), using the object-oriented  <i class="calibre4">Lingo</i> language. Director was designed to be extended through  <i class="calibre4">XTRAs</i> that could </p>
<p class="calibre1">add functionality, similar to the way plug-ins are added to browsers. These </p>
<p class="calibre1">XTRAs were developed and sold by a number of third-party vendors. In the </p>
<p class="calibre1">design, we planned on storing navigational and other course-related infor-</p>
<p class="calibre1">mation in a database. I looked at all the different database XTRAs that </p>
<p class="calibre1">were available and purchased a particular XTRA, which I’ll call XTRA1. </p>
<p class="calibre1">Each XTRA came with documentation of its API, which showed how to </p>
<p class="calibre1">make queries to the database using Structured Query Language (SQL). I </p>
<p class="calibre1">decided to create a Database class that incorporated all the functionality of </p>
<p class="calibre1">accessing the database using XTRA1’s API. That way, all code that commu-</p>
<p class="calibre1">nicated with the XTRA directly was in the Database class. Figure 8-1 shows </p>
<p class="calibre1">the overall architecture. </p>
<p class="calibre1">Requests</p>
<p class="calibre1">info</p>
<p class="calibre1">Builds</p>
<p class="calibre1">SQL</p>
<p class="calibre1">Accesses</p>
<p class="calibre1">database</p>
<p class="calibre1">Main</p>
<p class="calibre1">Database</p>
<p class="calibre1">Database</p>
<p class="calibre1">program</p>
<p class="calibre1">object</p>
<p class="calibre1">XTRA</p>
<p class="calibre1">Returns</p>
<p class="calibre1">results</p>
<p class="calibre1">Returns</p>
<p class="calibre1">Database</p>
<p class="calibre1">Returns</p>
<p class="calibre1">results</p>
<p class="calibre1">results</p>
<p class="calibre1"> <i class="calibre4">Figure 8-1: The architecture of accessing a database using an object and an XTRA</i> When the program started, it created a single instance of the Database </p>
<p class="calibre1">class. The main code was a client of the Database object. Whenever the main </p>
<p class="calibre1">code wanted information from the database, rather than formatting a SQL </p>
<p class="calibre1">query itself, it called a method of the Database object, supplying details about </p>
<p class="calibre1">what information it wanted. The methods in the Database object translated </p>
<p class="calibre1">each request into a SQL query made to XTRA1 to get data from the data-</p>
<p class="calibre1">base. That way, only the code of the Database object knew how to access the </p>
<p class="calibre1">XTRA using its API. </p>
<p class="calibre1">The program worked well, and the customers enjoyed using the prod-</p>
<p class="calibre1">uct. But every once in a while, we would run into errors in the data we got </p>
<p class="calibre1">back from the database. I contacted the XTRA1 developer and gave many </p>
<p class="calibre1">easily reproducible examples of the problems. Unfortunately, the developer </p>
<p class="calibre1">never addressed these issues. </p>
<p class="calibre1">Because of the lack of response, we eventually decided to purchase a </p>
<p class="calibre1">different database XTRA, XTRA2, to serve this purpose. XTRA2 worked in </p>
<p class="calibre1"><b class="calibre3">178</b>   Chapter 8</p>
<p class="calibre1"><a id="p208"/>a similar way but had some subtle differences in how it was initialized and required some minor changes in the way that SQL queries were built. </p>
<p class="calibre1">Because the Database class encapsulated all the details of communicat-</p>
<p class="calibre1">ing with the XTRA, we were able to make all the necessary changes to work </p>
<p class="calibre1">with XTRA2 only in the Database class. We did not change a single line in </p>
<p class="calibre1">the main program (the client code). </p>
<p class="calibre1">In this case, I was both the Database class developer and the client soft-</p>
<p class="calibre1">ware developer. If my client code had used the names of instance variables </p>
<p class="calibre1">in the class, I would have had to crawl through the program, modifying </p>
<p class="calibre1">each line of relevant code. Using encapsulation with a class saved me from </p>
<p class="calibre1">countless hours of reworking and testing. </p>
<p class="calibre1">As a follow-up to the story, while XTRA2 worked well, that company </p>
<p class="calibre1">eventually went out of business and I had to go through the same process </p>
<p class="calibre1">again. Once again, because of encapsulation, only the code of the Database </p>
<p class="calibre1">class was modified to work with XTRA3. </p>
<p class="calibre1"><b class="calibre3">Abstraction</b></p>
<p class="calibre1">Abstraction is another OOP concept closely related to encapsulation; many </p>
<p class="calibre1">developers consider it to be the fourth tenet of OOP. </p>
<p class="calibre1">Whereas encapsulation is about implementation, hiding the details of </p>
<p class="calibre1">the code and data that make up a class,  <i class="calibre4">abstraction</i> is about the client’s view of a class. It’s about the perception of a class from the outside. </p>
<p class="calibre1"><b class="calibre3">abstraction</b> </p>
<p class="calibre1">Handling complexity by hiding unnecessary details . </p>
<p class="calibre1">Essentially, abstraction is a reminder to make sure that the user’s view </p>
<p class="calibre1">of a system is as simple as possible. </p>
<p class="calibre1">Abstraction is extremely common in consumer products. Many people </p>
<p class="calibre1">use TVs, computers, microwave ovens, cars, and so on every day. We become </p>
<p class="calibre1">comfortable with the user interface that these products extend to us. Through </p>
<p class="calibre1">their controls, they provide an abstraction of their functionality. You press </p>
<p class="calibre1">the accelerator pedal in a car to make it go forward. With a microwave, you </p>
<p class="calibre1">set an amount of time and press Start to heat up some food. But few of us </p>
<p class="calibre1">really know how these products work internally. </p>
<p class="calibre1">Here’s an example of abstraction from the world of computer science. </p>
<p class="calibre1">In programming, a  <i class="calibre4">stack</i> is a mechanism for remembering data in a  <i class="calibre4">last in,</i> <i class="calibre4">first out</i>  <i class="calibre4">(LIFO)</i> order. Think of a pile of plates, where clean plates are added to the top and users take one from the top when they need a plate. A stack </p>
<p class="calibre1">has two standard operations: push adds an item to the top of the stack, and </p>
<p class="calibre1">pop removes the topmost item from the stack. </p>
<p class="calibre1">A stack is particularly useful whenever your program does any naviga-</p>
<p class="calibre1">tion because it can be used to leave a trail of breadcrumbs for finding your </p>
<p class="calibre1">way back. This is how programming languages keep track of the execution </p>
<p class="calibre1">of function and method calls in code: when you call a function or method, </p>
<p class="calibre1">the return point is pushed onto a stack, and when the function or method </p>
<p class="calibre1">Encapsulation   <b class="calibre3">179</b></p>
<p class="calibre1"><a id="p209"/>returns, the place to return to is discovered by popping the most recent information off the top of the stack. In this way, code can make as many </p>
<p class="calibre1">levels of calls as you need, and it always unwinds correctly. </p>
<p class="calibre1">As an abstraction, suppose a client program required the functional-</p>
<p class="calibre1">ity of a stack that would be simple to create and would provide the ability </p>
<p class="calibre1">to push and pop information. If this were written as a class, the client code </p>
<p class="calibre1">would create a stack like this:</p>
<p class="calibre1">oStack = Stack()</p>
<p class="calibre1">A client would add information by calling a push() method like this:</p>
<p class="calibre1">oStack.push( <i class="calibre4">&lt;someData&gt; </i>)</p>
<p class="calibre1">And it would retrieve the most recent data by calling a pop() method </p>
<p class="calibre1">like this:</p>
<p class="calibre1"> <i class="calibre4">&lt;someVariable&gt; </i> = oStack.pop()</p>
<p class="calibre1">The client would not need to know or care how these methods were </p>
<p class="calibre1">implemented or how the data was stored. The implementation of the Stack </p>
<p class="calibre1">would be handled completely by the methods of the Stack. </p>
<p class="calibre1">While the client code could view a Stack class as a black box, writing </p>
<p class="calibre1">such a class in Python is fairly trivial. Listing 8-8 shows how it could be </p>
<p class="calibre1">implemented. </p>
<p class="calibre1"><b class="calibre3">File: Stack/Stack.py</b></p>
<p class="calibre1"># Stack class</p>
<p class="calibre1">class Stack():</p>
<p class="calibre1">''' Stack class implements a last in first out LIFO algorithm''' </p>
<p class="calibre1">def __init__(self, startingStackAsList=None):</p>
<p class="calibre1">if startingStackAsList is None:</p>
<p class="calibre1">1 self.dataList = [ ]</p>
<p class="calibre1">else:</p>
<p class="calibre1">self.dataList = startingStackAsList[:] # make a copy</p>
<p class="calibre1"/>
<p class="calibre1">2 def push(self, item):       </p>
<p class="calibre1">self.dataList.append(item)</p>
<p class="calibre1">3 def pop(self):</p>
<p class="calibre1">if len(self.dataList) == 0:</p>
<p class="calibre1">raise IndexError</p>
<p class="calibre1">element = self.dataList.pop()</p>
<p class="calibre1">return element</p>
<p class="calibre1"><b class="calibre3">180</b>   Chapter 8</p>
<p class="calibre1"><a id="p210"/>  4 def peek(self):</p>
<p class="calibre1"># Retrieve the top item, without removing it</p>
<p class="calibre1">item = self.dataList[-1]</p>
<p class="calibre1">return item</p>
<p class="calibre1">5 def getSize(self):</p>
<p class="calibre1">nElements = len(self.dataList)</p>
<p class="calibre1">return nElements</p>
<p class="calibre1">6 def show(self):</p>
<p class="calibre1"># Show the stack in a vertical orientation</p>
<p class="calibre1">print('Stack is:')</p>
<p class="calibre1">for value in reversed(self.dataList):</p>
<p class="calibre1">print('   ', value)</p>
<p class="calibre1"> <i class="calibre4">Listing 8-8: A stack as a Python class</i></p>
<p class="calibre1">The Stack class keeps track of all the data using a list instance variable </p>
<p class="calibre1">named self.dataList 1. The client doesn’t need to know this level of detail, </p>
<p class="calibre1">but push() 2 just adds an item to the internal list using the Python append() </p>
<p class="calibre1">operation, while pop() 3 pops the last element from the internal list. Because </p>
<p class="calibre1">it is easy to do, this implementation of the Stack class also implements three </p>
<p class="calibre1">additional methods:   </p>
<p class="calibre1">•  peek() 4 allows the caller to obtain the data at the top of the stack with-</p>
<p class="calibre1">out removing it from the stack. </p>
<p class="calibre1">•  getSize() 5 returns the number of items on the stack. </p>
<p class="calibre1">•  show() 6 prints the contents of the stack in the way that the client </p>
<p class="calibre1">thinks of a stack: the data is displayed vertically, with the most recent </p>
<p class="calibre1">data pushed shown at the top. This can be helpful in debugging client </p>
<p class="calibre1">code that involves multiple calls to push() and pop(). </p>
<p class="calibre1">This was an extremely simple example, but as you gain more experience </p>
<p class="calibre1">writing classes, your classes will typically become more complex. Along the </p>
<p class="calibre1">way, you may find cleaner and more efficient ways of writing some methods </p>
<p class="calibre1">and perhaps rewrite them. Because objects provide both encapsulation and </p>
<p class="calibre1">abstraction, as the writer of a class, you should feel free to modify its code </p>
<p class="calibre1">and data, as long as the published interfaces do not change. Changes to the </p>
<p class="calibre1">implementation of methods should have no ill effects on client software but </p>
<p class="calibre1">rather should allow you to make improvements without affecting any client </p>
<p class="calibre1">code. In fact, if you find ways to make your code more efficient and publish a </p>
<p class="calibre1">new version, client code may appear to speed up, with zero changes required </p>
<p class="calibre1">to that code. </p>
<p class="calibre1">A property is an excellent example of abstraction. As you saw earlier, </p>
<p class="calibre1">with properties the client programmer can use a syntax that makes their </p>
<p class="calibre1">intent clear (to get and set a value in an object). The implementation in the </p>
<p class="calibre1">methods that are called as a result can be much more complicated, but is </p>
<p class="calibre1">totally hidden from the client code. </p>
<p class="calibre1">Encapsulation   <b class="calibre3">181</b></p>
<p class="calibre1"><a id="p211"/><b class="calibre3">Summary</b></p>
<p class="calibre1">Encapsulation is the first major tenet of object-oriented programming, </p>
<p class="calibre1">allowing classes to hide their implementation and data from client code </p>
<p class="calibre1">and ensuring that a class provides all the functionality that a client needs </p>
<p class="calibre1">in a single place. </p>
<p class="calibre1">A key concept of OOP is that objects own their data, and that’s why </p>
<p class="calibre1">I recommend that you provide getter and setter methods if you want cli-</p>
<p class="calibre1">ent code to access the data held in an instance variable. Python does </p>
<p class="calibre1">allow direct access to instance variables using dot syntax, but I strongly </p>
<p class="calibre1">encourage you to stay away from this syntax for the reasons laid out in </p>
<p class="calibre1">this chapter. </p>
<p class="calibre1">There are conventions for marking instance variables and methods as </p>
<p class="calibre1">private, using a leading underscore or double underscore depending on the </p>
<p class="calibre1">level of privatization you require. As a compromise, Python also allows the </p>
<p class="calibre1">use of the @property decorator. This makes it appear as if the client code is </p>
<p class="calibre1">able to access an instance variable directly, while behind the scenes Python </p>
<p class="calibre1">turns such references into calls to the decorated getter and setter methods </p>
<p class="calibre1">in the class. </p>
<p class="calibre1">The pygwidgets package provides many good examples of encapsulation. </p>
<p class="calibre1">As a client programmer, you see a class from the outside and work with the </p>
<p class="calibre1">interfaces that the class provides. As a class designer, abstraction—handling </p>
<p class="calibre1">complexity by hiding details—helps you design a good interface by consid-</p>
<p class="calibre1">ering the interface of the class from the client’s point of view. However, in </p>
<p class="calibre1">Python, you often have the source code available so that you can look at the </p>
<p class="calibre1">implementation if you wish. </p>
<p class="calibre1"><b class="calibre3">182</b>   Chapter 8</p>
<p class="calibre1"><a id="p212"/><b class="calibre3">9</b></p>
<p class="calibre1"><b class="calibre3">P O LY M O R P H I S M</b></p>
<p class="calibre1">This chapter is about the second major </p>
<p class="calibre1">tenet of OOP:  <i class="calibre4">polymorphism</i>. Its component </p>
<p class="calibre1">parts are from the Greek: the prefix  <i class="calibre4">poly</i> </p>
<p class="calibre1">means “much” or “many,” and  <i class="calibre4">morphism</i> means </p>
<p class="calibre1">“shape,” “form,” or “structure.” </p>
<p class="calibre1">So,  <i class="calibre4">polymorphism</i> essentially means  <i class="calibre4">many forms</i>. I’m not talking about a <i class="calibre4">Star Trek</i>–style shape-shifting alien—in fact, it’s quite the opposite. Rather than one thing taking on many shapes, polymorphism in OOP is about </p>
<p class="calibre1">how multiple classes can have methods with the exact same names. This </p>
<p class="calibre1">will eventually give us a highly intuitive way to act on a collection of objects, </p>
<p class="calibre1">independent of what class each came from. </p>
<p class="calibre1">OOP programmers often use the term “send a message” when we talk </p>
<p class="calibre1">about client code calling a method of an object. What the object should do </p>
<p class="calibre1">when it receives the message is up to the object. With polymorphism, we can </p>
<p class="calibre1">send the same message to multiple objects, and each object will react differ-</p>
<p class="calibre1">ently depending on what it’s designed to do and the data available to it. </p>
<p class="calibre1">In this chapter, I’ll discuss how this ability allows you to build pack-</p>
<p class="calibre1">ages of classes that are easily extensible and predictable. We’ll also use </p>
<p class="calibre1"><a id="p213"/>polymorphism with operators to make the same operators perform different operations depending on the data types they are working with. Finally, </p>
<p class="calibre1">I’ll show you how to use the print() function to get valuable debugging </p>
<p class="calibre1">information from objects. </p>
<p class="calibre1"><b class="calibre3">Sending Messages to Real-World Objects</b></p>
<p class="calibre1">Let’s look at polymorphism in the real world, using cars as an example. All </p>
<p class="calibre1">cars have an accelerator pedal. When the driver presses that pedal, they’re </p>
<p class="calibre1">sending the “accelerate” message to the car. The car they’re driving could </p>
<p class="calibre1">have an internal combustion engine or an electric motor, or be a hybrid. </p>
<p class="calibre1">Each of these types of cars has its own implementation of what happens </p>
<p class="calibre1">when it receives the accelerate message, and each behaves accordingly. </p>
<p class="calibre1">Polymorphism allows for easier adoption of new technology. If some-</p>
<p class="calibre1">one were to develop a nuclear-powered car, the user interface of the car </p>
<p class="calibre1">would remain the same—the driver would still press the accelerator pedal </p>
<p class="calibre1">to send the same message—but a very different mechanism would make the </p>
<p class="calibre1">nuclear-powered car go faster. </p>
<p class="calibre1">As another real-world example, imagine you enter a large room with a </p>
<p class="calibre1">bank of light switches that control a variety of different lights. Some of the </p>
<p class="calibre1">bulbs are old-style incandescent bulbs, some are fluorescent, and some are </p>
<p class="calibre1">newer LED bulbs. When you flip all the switches up, you are sending the </p>
<p class="calibre1">“turn on” message to all the bulbs. The underlying mechanisms that cause </p>
<p class="calibre1">incandescent, fluorescent, and LED bulbs to emit light are wildly different, </p>
<p class="calibre1">but each achieves the user’s intended goal. </p>
<p class="calibre1"><b class="calibre3">A Classic Example of Polymorphism in Programming</b></p>
<p class="calibre1">In terms of OOP, polymorphism is about how client code can call a method </p>
<p class="calibre1">with the exact same name in different objects, and each object will do what-</p>
<p class="calibre1">ever it needs to do to implement the meaning of that method for that object. </p>
<p class="calibre1">The classic example of polymorphism is to consider code that repre-</p>
<p class="calibre1">sents different types of pets. Let’s say you have a collection of dogs, cats, and </p>
<p class="calibre1">birds, and each understands some basic commands. If you ask these pets </p>
<p class="calibre1">to speak (that is, you send the “speak” message to each), the dogs will say </p>
<p class="calibre1">“bark,” the cats will say “meow,” and the birds will say “tweet.”  Listing 9-1 </p>
<p class="calibre1">shows how we might implement this in code. </p>
<p class="calibre1"><b class="calibre3">File: PetsPolymorphism.py</b></p>
<p class="calibre1"># Pets polymorphism</p>
<p class="calibre1"># Three classes, all with a different "speak" method</p>
<p class="calibre1">class Dog():</p>
<p class="calibre1">def __init__(self, name):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1"><b class="calibre3">184</b>   Chapter 9</p>
<p class="calibre1"><a id="p214"/>  1 def speak(self):</p>
<p class="calibre1">print(self.name, 'says bark, bark, bark!')</p>
<p class="calibre1">class Cat():</p>
<p class="calibre1">def __init__(self, name):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">2 def speak(self):</p>
<p class="calibre1">print(self.name, 'says meeeoooow')</p>
<p class="calibre1">class Bird():</p>
<p class="calibre1">def __init__(self, name):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">3 def speak(self):</p>
<p class="calibre1">print(self.name, 'says tweet')</p>
<p class="calibre1">oDog1 = Dog('Rover')</p>
<p class="calibre1">oDog2 = Dog('Fido')</p>
<p class="calibre1">oCat1 = Cat('Fluffy')</p>
<p class="calibre1">oCat2 = Cat('Spike')</p>
<p class="calibre1">oBird = Bird('Big Bird')</p>
<p class="calibre1">4 petsList = [oDog1, oDog2, oCat1, oCat2, oBird]</p>
<p class="calibre1"># Send the same message (call the same method) of all pets</p>
<p class="calibre1">for oPet in petsList:</p>
<p class="calibre1">5 oPet.speak()</p>
<p class="calibre1"> <i class="calibre4">Listing 9-1: Sending the “speak” message to objects instantiated from different classes</i> Each class has a speak() method, but the content of each method </p>
<p class="calibre1">is different 1 2 3. Each class does whatever it needs to do in its ver-</p>
<p class="calibre1">sion of this method; the method name is the same, but it has different </p>
<p class="calibre1">implementations. </p>
<p class="calibre1">To make things easy to deal with, we put all the pet objects into a list 4. </p>
<p class="calibre1">To make them all speak, we then loop through all the objects and send </p>
<p class="calibre1">the same message by calling a method with the exact same name in each </p>
<p class="calibre1">object 5, without worrying about the type of the object. </p>
<p class="calibre1"><b class="calibre3">Example Using Pygame Shapes</b></p>
<p class="calibre1">Next, we’ll look at a demonstration of polymorphism using pygame. In </p>
<p class="calibre1"><a href="index_split_002.html#p118">Chapter 5 w</a>e used pygame to draw primitive shapes such as rectangles, circles, polygons, ellipses, and lines. Here we’ll build a demonstration </p>
<p class="calibre1">program that will randomly create and draw different shapes in a window. </p>
<p class="calibre1">The user can then click on any shape, and the program will report the </p>
<p class="calibre1">type and area of the shape that was clicked. Because the shapes are ran-</p>
<p class="calibre1">domly created, each time the program runs, the size, location, number, </p>
<p class="calibre1">and position of the shapes will be different. Figure 9-1 shows some sample </p>
<p class="calibre1">output from the demonstration program. </p>
<p class="calibre1">Polymorphism   <b class="calibre3">185</b></p>
<p class="calibre1"><a id="p215"/><img src="index-215_1.png" alt="Image 27" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 9-1: A pygame-based example of using polymorphism to draw different shapes</i> We’ll implement the program with a class for each of three different shapes: Square, Circle, and Triangle. The key thing to note here is that </p>
<p class="calibre1">all three shape classes contain methods with the same names, __init__(), </p>
<p class="calibre1">draw(), getType(), getArea(), and clickedInside(), that perform the same tasks. </p>
<p class="calibre1">However, the implementation of each method is different because each </p>
<p class="calibre1">class deals with a different shape. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The Square Shape Class</b></i></p>
<p class="calibre1">I’ll start with the simplest shape. Listing 9-2 shows the code of the Square </p>
<p class="calibre1">class. </p>
<p class="calibre1"><b class="calibre3">File: Shapes/Square.py</b></p>
<p class="calibre1"># Square class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import random</p>
<p class="calibre1"># Set up the colors</p>
<p class="calibre1">RED = (255, 0, 0)</p>
<p class="calibre1">GREEN = (0, 255, 0)</p>
<p class="calibre1">BLUE = (0, 0, 255)</p>
<p class="calibre1">class Square():</p>
<p class="calibre1"><b class="calibre3">186</b>   Chapter 9</p>
<p class="calibre1"><a id="p216"/>  1 def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.widthAndHeight = random.randrange(10, 100)</p>
<p class="calibre1">self.color = random.choice((RED, GREEN, BLUE))</p>
<p class="calibre1">self.x = random.randrange(1, maxWidth - 100)</p>
<p class="calibre1">self.y = random.randrange(25, maxHeight - 100)</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, self.widthAndHeight, </p>
<p class="calibre1">self.widthAndHeight)</p>
<p class="calibre1">self.shapeType = 'Square' </p>
<p class="calibre1">2 def clickedInside(self, mousePoint):</p>
<p class="calibre1">clicked = self.rect.collidepoint(mousePoint)</p>
<p class="calibre1">return clicked</p>
<p class="calibre1">3 def getType(self):</p>
<p class="calibre1">return self.shapeType</p>
<p class="calibre1">4 def getArea(self):</p>
<p class="calibre1">theArea = self.widthAndHeight * self.widthAndHeight</p>
<p class="calibre1">return theArea</p>
<p class="calibre1">5 def draw(self):</p>
<p class="calibre1">pygame.draw.rect(self.window, self.color, </p>
<p class="calibre1">(self.x, self.y, self.widthAndHeight, </p>
<p class="calibre1">self.widthAndHeight))</p>
<p class="calibre1"> <i class="calibre4">Listing 9-2: The Square class</i></p>
<p class="calibre1">In the __init__() method 1, we set up a number of instance variables to </p>
<p class="calibre1">use in the methods of the class. That lets us keep the code of the methods </p>
<p class="calibre1">very simple. Since the __init__() method saved the rectangle of the Square, </p>
<p class="calibre1">the clickedInside() method 2 just checks if the location of a mouse click was </p>
<p class="calibre1">inside that rectangle, returning True or False. </p>
<p class="calibre1">The getType() method 3 simply returns the information that the item </p>
<p class="calibre1">clicked is a square. The getArea() method 4 multiplies the width by the </p>
<p class="calibre1">height and returns the resulting area. The draw() method 5 uses pygame’s </p>
<p class="calibre1">draw.rect() to draw the shape in the randomly chosen color. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The Circle and Triangle Shape Classes</b></i></p>
<p class="calibre1">Next, let’s take a look at the code of the Circle and the Triangle classes. </p>
<p class="calibre1">The important thing to notice is that these classes have methods with the </p>
<p class="calibre1">same names as the Square class, but the code in these methods (especially </p>
<p class="calibre1">clickedInside() and getArea()) is very different. Listing 9-3 shows the Circle </p>
<p class="calibre1">class. Listing 9-4 shows the Triangle class that creates randomly sized right </p>
<p class="calibre1">triangles whose edges are parallel to the x- and y-axes, with the right angle </p>
<p class="calibre1">in the upper-left corner. </p>
<p class="calibre1">Polymorphism   <b class="calibre3">187</b></p>
<p class="calibre1"><a id="p217"/><b class="calibre3">File: Shapes/Circle.py</b></p>
<p class="calibre1"># Circle class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import random</p>
<p class="calibre1">import math</p>
<p class="calibre1"># Set up the colors</p>
<p class="calibre1">RED = (255, 0, 0)</p>
<p class="calibre1">GREEN = (0, 255, 0)</p>
<p class="calibre1">BLUE = (0, 0, 255)</p>
<p class="calibre1">class Circle():</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.color = random.choice((RED, GREEN, BLUE))</p>
<p class="calibre1">self.x = random.randrange(1, maxWidth - 100)</p>
<p class="calibre1">self.y = random.randrange(25, maxHeight - 100)</p>
<p class="calibre1">self.radius = random.randrange(10, 50)</p>
<p class="calibre1">self.centerX = self.x + self.radius</p>
<p class="calibre1">self.centerY = self.y + self.radius</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, </p>
<p class="calibre1">self.radius * 2, self.radius * 2)</p>
<p class="calibre1">self.shapeType = 'Circle' </p>
<p class="calibre1"/>
<p class="calibre1">1 def clickedInside(self, mousePoint):</p>
<p class="calibre1">distance = math.sqrt(((mousePoint[0] - self.centerX) ** 2) +</p>
<p class="calibre1">((mousePoint[1] - self.centerY) ** 2)) </p>
<p class="calibre1">if distance &lt;= self.radius:</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1">2 def getArea(self):</p>
<p class="calibre1">theArea = math.pi * (self.radius ** 2) squared</p>
<p class="calibre1">return theArea</p>
<p class="calibre1">def getType(self):</p>
<p class="calibre1">return self.shapeType</p>
<p class="calibre1">3 def draw(self):</p>
<p class="calibre1">pygame.draw.circle(self.window, self.color, </p>
<p class="calibre1">(self.centerX, self.centerY), </p>
<p class="calibre1">self.radius, 0)</p>
<p class="calibre1"> <i class="calibre4">Listing 9-3: The Circle class</i></p>
<p class="calibre1"><b class="calibre3">188</b>   Chapter 9</p>
<p class="calibre1"><a id="p218"/><b class="calibre3">File: Shapes/Triangle.py</b></p>
<p class="calibre1"># Triangle class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import random</p>
<p class="calibre1"># Set up the colors</p>
<p class="calibre1">RED = (255, 0, 0)</p>
<p class="calibre1">GREEN = (0, 255, 0)</p>
<p class="calibre1">BLUE = (0, 0, 255)</p>
<p class="calibre1">class Triangle():</p>
<p class="calibre1">def __init__(self, window, maxWidth, maxHeight):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.width = random.randrange(10, 100)</p>
<p class="calibre1">self.height = random.randrange(10, 100)</p>
<p class="calibre1">self.triangleSlope = -1 * (self.height / self.width)</p>
<p class="calibre1">self.color = random.choice((RED, GREEN, BLUE))</p>
<p class="calibre1">self.x = random.randrange(1, maxWidth - 100)</p>
<p class="calibre1">self.y = random.randrange(25, maxHeight - 100)</p>
<p class="calibre1">self.rect = pygame.Rect(self.x, self.y, </p>
<p class="calibre1">self.width, self.height)</p>
<p class="calibre1">self.shapeType = 'Triangle' </p>
<p class="calibre1"/>
<p class="calibre1">4 def clickedInside(self, mousePoint):</p>
<p class="calibre1">inRect = self.rect.collidepoint(mousePoint)</p>
<p class="calibre1">if not inRect:</p>
<p class="calibre1">return False</p>
<p class="calibre1"># Do some math to see if the point is inside the triangle</p>
<p class="calibre1">xOffset = mousePoint[0] - self.x</p>
<p class="calibre1">yOffset = mousePoint[1] - self.y</p>
<p class="calibre1">if xOffset == 0:</p>
<p class="calibre1">return True</p>
<p class="calibre1"># Calculate the slope (rise over run)</p>
<p class="calibre1">pointSlopeFromYIntercept = (yOffset - self.height) / xOffset</p>
<p class="calibre1">if pointSlopeFromYIntercept &lt; self.triangleSlope:</p>
<p class="calibre1">return True</p>
<p class="calibre1">else:</p>
<p class="calibre1">return False</p>
<p class="calibre1">def getType(self):</p>
<p class="calibre1">return self.shapeType</p>
<p class="calibre1">5 def getArea(self):</p>
<p class="calibre1">theArea = .5 * self.width * self.height</p>
<p class="calibre1">return theArea</p>
<p class="calibre1">Polymorphism   <b class="calibre3">189</b></p>
<p class="calibre1"><a id="p219"/>  6 def draw(self):</p>
<p class="calibre1">pygame.draw.polygon(self.window, self.color, </p>
<p class="calibre1">((self.x, self.y + self.height), </p>
<p class="calibre1">(self.x, self.y), </p>
<p class="calibre1">(self.x + self.width, self.y)))</p>
<p class="calibre1"> <i class="calibre4">Listing 9-4: The Triangle class</i></p>
<p class="calibre1">To understand the polymorphism at work here, let’s look at the </p>
<p class="calibre1">codeof the clickedInside() method for each shape. The clickedInside() </p>
<p class="calibre1">method of the Square class was very simple: a check to see if the mouse </p>
<p class="calibre1">click occurred inside the rectangle of the Square. The details of the cal-</p>
<p class="calibre1">culations for  clickedInside() in the Circle and Triangle classes are not par-</p>
<p class="calibre1">ticularly important, but they clearly are doing different calculations. The </p>
<p class="calibre1">clickedInside() method of the Circle class 1 only reports a click if the user </p>
<p class="calibre1">clicks on a colored pixel of the shape. That is, it detects a click that is within </p>
<p class="calibre1">the bounding rectangle of the circle, but the click must also be within the </p>
<p class="calibre1">radius of the circle for it to count as a click. The clickedInside() method of </p>
<p class="calibre1">the Triangle class 4 must determine if the user has clicked on a pixel inside </p>
<p class="calibre1">the colored triangular portion of the rectangle. The methods in all three </p>
<p class="calibre1">classes accept a mouse click as a parameter and return either True or False </p>
<p class="calibre1">as a result. </p>
<p class="calibre1">The getArea() 2 5 and draw() methods 3 6 of these classes have names </p>
<p class="calibre1">that are identical to methods of the Square class, but they do different work </p>
<p class="calibre1">internally. There’s a different calculation for area, and they draw different </p>
<p class="calibre1">shapes. </p>
</body></html>