<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_427"/><span class="big">16</span><br/>STRUCTURE RESOLUTION</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">In the previous chapter, we defined the classes for the structure model: <span class="literal">StrNode</span>, <span class="literal">StrBar</span>, and <span class="literal">Structure</span>. We also wrote the classes for the structure’s solution: <span class="literal">StrNodeSolution</span>, <span class="literal">StrBarSolution</span>, and <span class="literal">StructureSolution</span>. We use the first three to define a structure and the other three to model the solution, including the nodes’ displacements and bars’ stresses and strains. The question is, how do we go from the definition model to the solution model?</p>&#13;
<p class="indent">In this chapter, we’ll answer that question by developing the resolution algorithm, the link between the original and solution structure models. We’ll revise the structure’s resolution process, where we assemble the structure’s stiffness matrix [<em>k</em>] based on the individual bar’s matrices and assemble the load vector {<img class="inline" src="../images/fvictorit.jpg" alt="Image"/>} based on the individual node’s loads. Resolving the <img class="inline" src="../images/f00427-p1.jpg" alt="Image"/> system of equations yields the displacements of the nodes in the structure in global coordinates: <img class="inline" src="../images/f00427-p2.jpg" alt="Image"/>. To solve the system of equations, we’ll use our Cholesky’s implementation.</p>&#13;
<p class="indent">This chapter will also introduce an advanced unit testing technique: test doubles. Test doubles help us isolate a piece of the code by replacing the <span epub:type="pagebreak" id="page_428"/>functions or classes it relies on with “fake” implementations so that when we run the test, we’re testing only one piece of the code.</p>&#13;
<h3 class="h3" id="ch00lev1sec96"><strong>Structure Resolution</strong></h3>&#13;
<p class="noindent">In the previous chapter we studied the system of equations that relates the forces applied in each of the degrees of freedom of a bar with its displacements. A bar has two nodes, each with two degrees of freedom:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><em>u</em> The displacement in the x direction</p>&#13;
<p class="noindentin"><em>v</em> The displacement in the y direction</p>&#13;
</div>&#13;
<p class="noindent">This makes a total of four degrees of freedom per bar: <em>u</em><sub>1</sub> and <em>v</em><sub>1</sub> for node 1 and <em>u</em><sub>2</sub> and <em>v</em><sub>2</sub> for node 2. The forces applied to the nodes—let’s call them <img class="inline" src="../images/f1victorit.jpg" alt="Image"/> and <img class="inline" src="../images/f2victorit.jpg" alt="Image"/>—can each be decomposed into their two projections. Thus, <img class="inline" src="../images/f1victorit.jpg" alt="Image"/> can be decomposed into <em>F</em><sub>1<em>x</em></sub> and <em>F</em><sub>1<em>y</em></sub>, and the same goes for <img class="inline" src="../images/f2victorit.jpg" alt="Image"/> (see <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>).</p>&#13;
<div class="image"><img src="../images/16fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch16fig1"><em>Figure 16-1: A bar’s degrees of freedom</em></p>&#13;
<p class="indent">The system of equations relating these forces and the node displacements is repeated here from section “Stiffness Matrices in Global Coordinates” on <a href="ch15.xhtml#ch00lev1sec92">page 397</a>:</p>&#13;
<div class="equationc"><img src="../images/f0428-01.jpg" alt="Image"/></div>&#13;
<p class="indent">It’s important to note that these forces and displacements, as well as the stiffness matrix [<em>k</em>], are all based on the global system of coordinates, which is the one represented on the bottom left of <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>. Each bar has its own local coordinate system, as you may recall from <a href="ch15.xhtml#ch15fig18">Figure 15-18</a>, but to build the structure’s global system of equations, we want the forces and displacements referred to this global coordinate system.</p>&#13;
<p class="indent">Before we move on, let’s briefly touch on what each term in the stiffness matrix means.</p>&#13;
<h4 class="h4" id="ch00lev2sec168"><span epub:type="pagebreak" id="page_429"/><strong><em>Interpreting the Stiffness Matrix Terms</em></strong></h4>&#13;
<p class="noindent">The stiffness matrix terms relate the force in a given degree of freedom with the displacement produced in another degree of freedom. They are ordered in a well-defined way:</p>&#13;
<div class="equationc"><img src="../images/f0429-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Here, for example, <img class="inline" src="../images/f00429-p1.jpg" alt="Image"/> can be read as “the relation between the force in the first node’s x direction (<img class="inline" src="../images/f00429-p2.jpg" alt="Image"/>) and the displacement it produces in the second node’s y direction (<img class="inline" src="../images/f00429-p3.jpg" alt="Image"/>).” With this is mind, we can discern a pattern.</p>&#13;
<p class="indent">Each row contains the stiffness terms relating the force in one degree of freedom with the displacements in every degree of freedom. For example, the first row includes the terms that relate the force in the x-axis of the start node <img class="inline" src="../images/f00429-p2.jpg" alt="Image"/> with all possible displacements: <img class="inline" src="../images/f00429-p5.jpg" alt="Image"/>, <img class="inline" src="../images/f00429-p6.jpg" alt="Image"/>, <img class="inline" src="../images/f00429-p7.jpg" alt="Image"/>, and <img class="inline" src="../images/f00429-p3.jpg" alt="Image"/>.</p>&#13;
<p class="indent">Each of the columns contains the stiffness terms relating the forces in every degree of freedom with the displacement in a given degree of freedom. For example, the first column includes the terms that relate the forces in every degree of freedom—<img class="inline" src="../images/f00429-p2.jpg" alt="Image"/>, <img class="inline" src="../images/f1yvictorit.jpg" alt="Image"/>, <img class="inline" src="../images/f2xvictorit.jpg" alt="Image"/>, and <img class="inline" src="../images/f2yvictorit.jpg" alt="Image"/>—with the start node’s displacement in the x-axis.</p>&#13;
<p class="indent">Remember this interpretation of the stiffness terms; we’ll use this knowledge later when we assemble the structure’s global stiffness matrix. Let’s continue revising the resolution process and write the code for it one step at a time.</p>&#13;
<h4 class="h4" id="ch00lev2sec169"><strong><em>Structure Initialization</em></strong></h4>&#13;
<p class="noindent">As part of the structure’s resolution process there will be some intermediate results we want to save in the <span class="literal">Structure</span> class as private attributes. Let’s initialize these attributes before we dive into the main algorithm.</p>&#13;
<p class="indent">Open your <em>model/structure.py</em> file and edit the class so that it includes the new attributes we’re adding in the <span class="literal">__init__</span> method, as shown in <a href="ch16.xhtml#ch16lis1">Listing 16-1</a>.</p>&#13;
<pre>  from functools import reduce&#13;
&#13;
<span class="ent">➊</span> <span class="codestrong1">from</span> <span class="codestrong1">eqs</span> <span class="codestrong1">import</span> <span class="codestrong1">Matrix</span><span class="codestrong1">,</span> <span class="codestrong1">Vector</span> <span class="codestrong1">as</span> <span class="codestrong1">EqVector</span>&#13;
  from .node import StrNode&#13;
  from .bar import StrBar&#13;
&#13;
&#13;
  class Structure:&#13;
   <span class="ent">➋</span> __DOF_PER_NODE = 2&#13;
&#13;
     def __init__(self, nodes: [StrNode], bars: [StrBar]):&#13;
        <span epub:type="pagebreak" id="page_430"/>self.__bars = bars&#13;
        self.__nodes = nodes&#13;
&#13;
      <span class="ent">➌</span> <span class="codestrong1">self</span><span class="codestrong1">.</span><span class="codestrong1">__dofs_dict</span> <span class="codestrong1">=</span> <span class="codestrong1">None</span>&#13;
        <span class="codestrong1">self</span><span class="codestrong1">.</span><span class="codestrong1">__system_matrix</span><span class="codestrong1">:</span> <span class="codestrong1">Matrix</span> <span class="codestrong1">=</span> <span class="codestrong1">None</span>&#13;
        <span class="codestrong1">self</span><span class="codestrong1">.</span><span class="codestrong1">__system_vector</span><span class="codestrong1">:</span> <span class="codestrong1">EqVector</span> <span class="codestrong1">=</span> <span class="codestrong1">None</span>&#13;
        <span class="codestrong1">self</span><span class="codestrong1">.</span><span class="codestrong1">__global_displacements</span><span class="codestrong1">:</span> <span class="codestrong1">EqVector</span> <span class="codestrong1">=</span> <span class="codestrong1">None</span>&#13;
&#13;
    <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch16lis1"/><em>Listing 16-1: Initializing the structure</em></p>&#13;
<p class="indent">We need to add two new imports, <span class="literal">Matrix</span> and <span class="literal">Vector</span>, from the <span class="literal">eqs</span> package <span class="ent">➊</span>. Because we’ll later need to import the other <span class="literal">Vector</span> class, the one defined in the <span class="literal">geom2d</span> package, we alias <span class="literal">Vector</span> from the <span class="literal">eqs</span> package to be named <span class="literal">EqVector</span> instead. Notice the aliasing syntax in Python:</p>&#13;
<pre>from <span class="codeitalic1">&lt;module&gt;</span> import <span class="codeitalic1">&lt;identifier&gt;</span> as <span class="codeitalic1">&lt;alias&gt;</span></pre>&#13;
<p class="indent">Next, we define a constant called <span class="literal">__DOF_PER_NODE</span> <span class="ent">➋</span>, which is set to <span class="literal">2</span>. We’ll use this constant in our code instead of directly using the number. Its clear name should give a good hint as to what the number actually means. We’ll avoid using <em>magic numbers</em> in our code, that is, numbers that appear in the code where it isn’t clear what they represent. Well-named constants tell the readers of our code what the number actually stands for.</p>&#13;
<p class="indent">Lastly, we define four new private attributes and initialize all of them to <span class="literal">None</span> <span class="ent">➌</span>.</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">__dofs_dict</span> A dictionary where the keys are IDs of the nodes, and the values are the lists of degrees of freedom numbers assigned to the node. We’ll see what this means in a minute.</p>&#13;
<p class="noindentin"><span class="codestrong">__system_matrix</span> The stiffness matrix for the structure’s global system of equations.</p>&#13;
<p class="noindentin"><span class="codestrong">__system_vector</span> The load vector for the structure’s global system of equations.</p>&#13;
<p class="noindentin"><span class="codestrong">__global_displacements</span> The list of a node’s global displacements, where the indices of each displacement are the same as their degrees of freedom numbers.</p>&#13;
</div>&#13;
<p class="indent">Don’t worry if you don’t fully understand what each of these new attributes mean; we’ll explain each in detail in the following sections.</p>&#13;
<h4 class="h4" id="ch00lev2sec170"><strong><em>The Main Structure Resolution Algorithm</em></strong></h4>&#13;
<p class="noindent">The structure resolution algorithm can be broken down into three big steps:</p>&#13;
<p class="indent"/>&#13;
<ol>&#13;
<li class="noindent">Assign each degree of freedom a number.</li>&#13;
<li class="noindent">Assemble and resolve the structure’s system of equations.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_431"/>Use the system’s resulting vector to build the solution model.</li>&#13;
</ol>&#13;
<p class="indent">Let’s try to quickly understand what each of these steps is about; we’ll fill in the remaining details later. The first step, numbering the degrees of freedom, is a process that assigns every DOF in the structure a unique number. Let’s take the structure in <a href="ch16.xhtml#ch16fig2">Figure 16-2</a> as an example.</p>&#13;
<div class="image"><img src="../images/16fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch16fig2"><em>Figure 16-2: Our example structure</em></p>&#13;
<p class="indent">The structure in <a href="ch16.xhtml#ch16fig2">Figure 16-2</a> has three nodes (N1, N2, and N3), and each node has two degrees of freedom. Assigning numbers to the degrees of freedom is as simple as it sounds: we take each DOF and associate a unique number with it. <a href="ch16.xhtml#ch16tab1">Table 16-1</a> shows a possible DOF number assignment that uses the natural ordering of the nodes.</p>&#13;
<p class="tabcap" id="ch16tab1"><strong>Table 16-1:</strong> Assigning Degrees of Freedom Numbers</p>&#13;
<table class="all">&#13;
<tbody><tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Node</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>DOF numbers</strong></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">N1</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">0, 1</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">N2</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">2, 3</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">N3</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">4, 5</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As you can see, we assign DOF numbers starting from zero. We could have chosen any other set of numbers, including a numbering scheme starting at any number we like, but as we’ll use these numbers to refer to positions in the system’s matrix and vector, it’ll be more convenient to have numbers that directly refer to indices. Otherwise, we’d need a mapping between the DOF numbers and indices in the system.</p>&#13;
<p class="indent">With the DOF numbers assigned, the next step is to assemble the global system of equations. This system has the same structure as the bar’s system of equations: <img class="inline" src="../images/f00431-p1.jpg" alt="Image"/>. When we solve this system of equations, we obtain the global displacements for all DOFs. Using these displacements, we can create the structure solution model using the classes we defined in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<p class="indent">Let’s implement this three-step algorithm in a new method in the <span class="literal">Structure</span> class (from the <em>model</em> package). Enter the new method in <a href="ch16.xhtml#ch16lis2">Listing 16-2</a>.<span epub:type="pagebreak" id="page_432"/></p>&#13;
<pre>class Structure:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def solve_structure(self):&#13;
        self.__assign_degrees_of_freedom()&#13;
        self.__solve_system_of_equations()&#13;
        return self.__make_structure_solution()</pre>&#13;
<p class="caption"><a id="ch16lis2"/><em>Listing 16-2: Structure resolution</em></p>&#13;
<p class="indent">The <span class="literal">solve_structure</span> method will compute the solution and return an instance of <span class="literal">StructureSolution</span>. This method outlines the three steps we just described. None of the three private methods exist yet, but we’ll implement them in the following sections one by one.</p>&#13;
<h4 class="h4" id="ch00lev2sec171"><strong><em>Numbering Degrees of Freedom</em></strong></h4>&#13;
<p class="noindent">The first step of the resolution process is to assign a number to each of the structure’s degrees of freedom. Remember that each node has two degrees of freedom, so the <span class="literal">__assign_degrees_of_freedom</span> method will assign two numbers to each of the structure’s nodes and save them in the <span class="literal">__dofs_dict</span> dictionary we initialized in <a href="ch16.xhtml#ch16lis1">Listing 16-1</a>. With the DOF numbers assigned, the structure we saw in <a href="ch16.xhtml#ch16fig2">Figure 16-2</a> could now look like <a href="ch16.xhtml#ch16fig3">Figure 16-3</a>.</p>&#13;
<div class="image"><img src="../images/16fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch16fig3"><em>Figure 16-3: Our structure nodes’ degrees of freedom, with number labels</em></p>&#13;
<p class="indent">Let’s implement the method. Enter the code in <a href="ch16.xhtml#ch16lis3">Listing 16-3</a>.</p>&#13;
<pre>class Structure:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __assign_degrees_of_freedom(self):&#13;
        self.__dofs_dict = {}&#13;
        for i, node in enumerate(self.__nodes):&#13;
            self.__dofs_dict[node.id] = (2 * i, 2 * i + 1)</pre>&#13;
<p class="caption"><a id="ch16lis3"/><em>Listing 16-3: Degrees of freedom assignment</em></p>&#13;
<p class="indent">The method first initializes the <span class="literal">__dofs_dict</span> attribute, setting it to an empty dictionary to make sure that we use a fresh new dictionary each time <span epub:type="pagebreak" id="page_433"/>we run the method. Then, we iterate over the enumeration of all the nodes in the structure (<span class="literal">self.__nodes</span>), adding each node’s <span class="literal">id</span> as the key in the dictionary associated with a tuple of two numbers: the node’s DOFs.</p>&#13;
<p class="indent">The <span class="literal">enumerate</span> function in Python returns an iterable sequence of the elements that we pass the function, together with their indices. This function is convenient for when the logic of what we’re doing requires the index of the items in a list. Here, we use the index of the node to compute its DOF numbers, which for a given index <em>i</em> are 2<em>i</em> and 2<em>i</em> + 1.</p>&#13;
<p class="indent">The first node, at index 0, will therefore get the degrees of freedom 0 and 1. The node at index 1 will get 2 and 3, and so on and so forth.</p>&#13;
<p class="indent">For a structure with three nodes whose IDs are 1, 2, and 3, the degrees of freedom dictionary could look like the following:</p>&#13;
<pre>dofs_dict = {&#13;
    1: (0, 1),&#13;
    2: (2, 3),&#13;
    3: (4, 5)&#13;
}</pre>&#13;
<p class="indent">Let’s move on to the next step, where the heavy lifting happens.</p>&#13;
<h4 class="h4" id="ch00lev2sec172"><strong><em>Assembling and Resolving the System of Equations</em></strong></h4>&#13;
<p class="noindent">To find the displacements of the structure’s nodes, we need to assemble and solve the structure’s global <img class="inline" src="../images/f00433-p1.jpg" alt="Image"/> system of equations. This system consists of the bar’s individual systems of equations assembled together. The same way a bar’s <img class="inline" src="../images/f00433-p1.jpg" alt="Image"/> system relates the external forces and displacements on both its nodes, the structure’s global system of equations relates the forces and displacements of every node in the structure.</p>&#13;
<p class="indent">Let’s break this down a bit more so we understand all the details. As always, doing a small example by hand will help us understand the process better.</p>&#13;
<h5 class="h5" id="ch00lev3sec84"><strong>An Example by Hand</strong></h5>&#13;
<p class="noindent">Before we begin, a quick note on nomenclature: we’ll label each bar using the numbers of the nodes it lies on, separated with an arrow. So, 1 → 2 is the bar going from node 1 to node 2. The nomenclature</p>&#13;
<div class="equationc"><img src="../images/f0433-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">refers to the <img class="inline" src="../images/f00397-p1.jpg" alt="Image"/> quantity for the bar 1 → 2: <em>E</em> refers to the bar’s material Young’s modulus, <em>A</em> is the bar’s cross section, and <em>l</em> is the bar’s length.</p>&#13;
<p class="indent">Now let’s look at the structure in <a href="ch16.xhtml#ch16fig3">Figure 16-3</a>. This structure has three nodes, three bars, and an external load applied to node 3. Let’s derive the system of equations for each of the three bars using the degrees of freedom numbering we’ve defined (see <a href="ch16.xhtml#ch16fig4">Figure 16-4</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_434"/><img src="../images/16fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch16fig4"><em>Figure 16-4: Our structure’s nodes and bars, labeled</em></p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Bar</strong> 1 → 2 This horizontal bar goes from node 1 to node 2. Its local x- and y-axes are aligned with the global coordinate system; thus, in this case, <em>θ</em> = 0°, and therefore cos0<em>°</em> = 1 and sin0<em>°</em> = 0. The bar’s system of equations is as follows:</p>&#13;
</div>&#13;
<div class="equationc"><img src="../images/f0434-01.jpg" alt="Image"/></div>&#13;
<p class="indent">If you need a refresher on how this system of equations is derived, refer to section “Stiffness Matrices in Global Coordinates” on <a href="ch15.xhtml#ch00lev1sec92">page 397</a>.</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Bar</strong> 1 → 3 This bar going from node 1 to node 3 forms an angle of 30° with the global x-axis; therefore, <img class="inline" src="../images/f00434-p1.jpg" alt="Image"/> and <img class="inline" src="../images/f00434-p2.jpg" alt="Image"/>. The bar’s system of equations is as follows:</p>&#13;
</div>&#13;
<div class="equationc"><img src="../images/f0434-02.jpg" alt="Image"/></div>&#13;
<p class="indent"/>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Bar</strong> 2 → 3 This vertical bar going from node 2 to node 3 makes an angle <em>θ</em> equal to 90°, so cos90° = 0 and sin90° = 1. The bar’s system of equations is as follows:</p>&#13;
</div>&#13;
<div class="equationc"><img src="../images/f0434-03.jpg" alt="Image"/></div>&#13;
<p class="indent">Now that we have each bar’s system of equations, we need to assemble the structure’s global system. The structure has a total of three nodes, and each node has two degrees of freedom, so the size of the system is 3 × 2 = 6. In this system, the forces and displacements need to appear in the position given by their DOF number. To make this clear, let’s make a table with the DOF numbers and the forces and displacements associated with them (<a href="ch16.xhtml#ch16tab2">Table 16-2</a>).</p>&#13;
<p class="tabcap" id="ch16tab2"><span epub:type="pagebreak" id="page_435"/><strong>Table 16-2:</strong> DOF Numbers for Each Force and Displacement</p>&#13;
<table class="all">&#13;
<tbody><tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>DOF</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Associated force</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Associated displacement</strong></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>F</em><sub>1<em>x</em></sub> = 0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>u</em><sub>1</sub></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">1</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>F</em><sub>1<em>y</em></sub> = 0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>v</em><sub>1</sub></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">2</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>F</em><sub>2<em>x</em></sub> = 0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>u</em><sub>2</sub></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">3</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>F</em><sub>2<em>y</em></sub> = 0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>v</em><sub>2</sub></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">4</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>F</em><sub>3<em>x</em></sub></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>u</em><sub>3</sub></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">5</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba"><em>F</em><sub>3<em>y</em></sub></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba"><em>v</em><sub>3</sub></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">If the DOF numbering gives us the position in the system of equations that each force or displacement term needs to occupy, we can start constructing the system like so:</p>&#13;
<div class="equationc"><img src="../images/f0435-01.jpg" alt="Image"/></div>&#13;
<p class="indent">Note that if we decided to number the degrees of freedom differently, the order of the force and displacement terms would be different but perfectly valid nevertheless.</p>&#13;
<p class="indent">In this system of equations, we have yet to compute the stiffness terms. The general stiffness term <em>k</em><sub><em>ij</em></sub> relates the force applied in the <em>i</em><sup>th</sup> degree of freedom with the displacement in the <em>j</em><sup>th</sup> degree of freedom (the same as we saw earlier in the “Interpreting the Stiffness Matrix Terms” on <a href="ch16.xhtml#ch00lev2sec168">page 429</a>).</p>&#13;
<p class="indent">As you can imagine, if the <em>i</em><sup>th</sup> and <em>j</em><sup>th</sup> degrees of freedom don’t belong to the same node or to nodes not joined by a bar, the <em>k</em><sub><em>ij</em></sub> stiffness term will be zero: there can’t be any relation between a force applied in <em>i</em> with a displacement in <em>j</em>. In our example structure, all the nodes are connected, so there won’t be zero values in the global matrix (except for those already in the bar’s individual matrices). In big structures where a node is connected with only a few others, the resulting stiffness matrices tend to have many zeros.</p>&#13;
<p class="indent">To compute each of the <em>k</em><sub><em>ij</em></sub> terms, we need to add all the stiffness values in the bar’s stiffness matrices that relate the <em>i</em><sup>th</sup> and <em>j</em><sup>th</sup> degrees of freedom. For example, to compute <em>k</em><sub>00</sub>, we have to account for the stiffness of bars 1 → 2 and 1 → 3, because those bars add a stiffness relation between the force applied in the DOF 0 and the displacement in the same DOF. To simplify the notation of the <img class="inline" src="../images/f00397-p1.jpg" alt="Image"/> terms a bit, let’s use the following aliases:</p>&#13;
<div class="equationc"><img src="../images/f0435-02.jpg" alt="Image"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_436"/>With this, let’s assemble the system’s matrix and vector by adding each of the stiffness terms and loads:</p>&#13;
<div class="equationc"><img src="../images/f0436-01.jpg" alt="Image"/></div>&#13;
<p class="indent">There’s one last step required to make this system of equations solvable: applying the external constraint conditions, that is, setting the constrained displacements as zero. This system of equations so far represents the structure without external constraints, but there are some imposed displacements of zero, and we have to force these conditions into its solution. In this case, node N1 has both its x and y displacements constrained, which can be expressed mathematically as follows:</p>&#13;
<p class="noindentc"><em>u</em><sub>1</sub> = 0 and <em>v</em><sub>1</sub> = 0</p>&#13;
<p class="noindent">The N2 node has its y displacement constrained. Thus,</p>&#13;
<p class="noindentc"><em>v</em><sub>2</sub> = 0</p>&#13;
<p class="indent">To introduce these conditions in our system of equations so that they appear in the solution, we have to set both the row and columns of the given DOF number as the identity in the system’s matrix and a zero in the system’s force vector. In this case, the displacements <em>u</em><sub>1</sub>, <em>v</em><sub>1</sub>, and <em>v</em><sub>2</sub> have the 0, 1, and 3 DOFs assigned to them; let’s make those rows and columns the identity vector:</p>&#13;
<div class="equationc"><img src="../images/f0436-02.jpg" alt="Image"/></div>&#13;
<p class="indent">The force vector values at the constrained indices were already zero (there’s no force applied in those degrees of freedom), but if they weren’t, we’d have to zero them out as well. With this little algebraic trick, we force <em>u</em><sub>1</sub>, <em>v</em><sub>1</sub>, and<span epub:type="pagebreak" id="page_437"/> <em>v</em><sub>2</sub> to be equal to zero in the system’s solution. The resulting system matrix is positive definite; thus, the Cholesky numerical method we implemented in <a href="ch14.xhtml#ch14">Chapter 14</a> is a good candidate to solve this system.</p>&#13;
<p class="indent">The structure’s system of equations is now assembled and ready to be solved. If we use a linear system resolution procedure, such as Cholesky’s factorization, we’ll obtain the values for the displacements.</p>&#13;
<p class="indent">Now that we understand this procedure, let’s put it in code.</p>&#13;
<h5 class="h5" id="ch00lev3sec85"><strong>The Algorithm</strong></h5>&#13;
<p class="noindent">In the <span class="literal">Structure</span> class, enter the method in <a href="ch16.xhtml#ch16lis4">Listing 16-4</a>. This method defines our resolution algorithm step-by-step.</p>&#13;
<pre>from functools import reduce&#13;
&#13;
from eqs import Matrix, Vector as EqVector, <span class="codestrong1">cholesky_solve</span>&#13;
from .node import StrNode&#13;
from .bar import StrBar&#13;
&#13;
&#13;
class Structure:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __solve_system_of_equations(self):&#13;
        size = self.nodes_count * self.__DOF_PER_NODE&#13;
        self.__assemble_system_matrix(size)&#13;
        self.__assemble_system_vector(size)&#13;
        self.__apply_external_constraints()&#13;
        self.__global_displacements = cholesky_solve(&#13;
            self.__system_matrix,&#13;
            self.__system_vector&#13;
        )</pre>&#13;
<p class="caption"><a id="ch16lis4"/><em>Listing 16-4: Solving the system of equations</em></p>&#13;
<p class="indent">We called <span class="literal">__solve_system_of_equations</span> in <a href="ch16.xhtml#ch16lis2">Listing 16-2</a>, but we hadn’t yet defined it. This now complete method outlines the main steps to assemble and resolve the structure’s system of equations. Note that we’re using many methods we have yet to define; we’ll do so in later sections.</p>&#13;
<p class="indent">We first compute the size of the system by multiplying the number of nodes in the structure by the degrees of freedom for each node, a value we stored in the constant <span class="literal">__DOF_PER_NODE</span> in the class.</p>&#13;
<p class="indent">Then we assemble both the system’s matrix and vector using two private methods we’ll write later: <span class="literal">__assemble_system_matrix</span> and <span class="literal">__assemble_system_vector</span>.</p>&#13;
<p class="indent">The next method we call, <span class="literal">__apply_external_constraints</span>, applies the conditions that force the constrained displacements to be zero, similar to the example we did by hand shown earlier.</p>&#13;
<p class="indent">The last step uses the recently computed system matrix and force vector to find the solution using our Cholesky’s solver function: <span class="literal">cholesky_solve</span>. <span epub:type="pagebreak" id="page_438"/>This function needs to be imported from the <span class="literal">eqs</span> package. The result we get is the displacement vector in global coordinates.</p>&#13;
<h5 class="h5" id="ch00lev3sec86"><strong>Assembling the System’s Matrix</strong></h5>&#13;
<p class="noindent">Let’s write the <span class="literal">__assemble_system_matrix</span> method. This is probably the most complex piece of code involved in the structural analysis algorithm, but don’t worry, I’ll walk you through it. First, enter the code in <a href="ch16.xhtml#ch16lis5">Listing 16-5</a>.</p>&#13;
<pre>class Structure:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __assemble_system_matrix(self, size: int):&#13;
        matrix = Matrix(size, size)&#13;
&#13;
        for bar in self.__bars:&#13;
         <span class="ent">➊</span> bar_matrix = bar.global_stiffness_matrix()&#13;
         <span class="ent">➋</span> dofs = self.__bar_dofs(bar)&#13;
&#13;
           for row, row_dof in enumerate(dofs):&#13;
               for col, col_dof in enumerate(dofs):&#13;
                   matrix.add_to_value(&#13;
                    <span class="ent">➌</span> bar_matrix.value_at(row, col),&#13;
                      row_dof,&#13;
                      col_dof&#13;
                   )&#13;
&#13;
     <span class="ent">➍</span> self.__system_matrix = matrix&#13;
&#13;
    def __bar_dofs(self, bar: StrBar):&#13;
        start_dofs = self.__dofs_dict[bar.start_node.id]&#13;
        end_dofs = self.__dofs_dict[bar.end_node.id]&#13;
        return start_dofs + end_dofs</pre>&#13;
<p class="caption"><a id="ch16lis5"/><em>Listing 16-5: Assembling the system of equations matrix</em></p>&#13;
<p class="indent">We start by creating a new <span class="literal">Matrix</span> instance with as many rows and columns as the passed-in <span class="literal">size</span> parameter. Then, we have a <span class="literal">for</span> loop that iterates over the bars in the structure. In the loop, we call the <span class="literal">global_stiffness_matrix</span> method on each bar and store the resulting stiffness matrix in the <span class="literal">bar_matrix</span> variable <span class="ent">➊</span>.</p>&#13;
<p class="indent">Next, we create a list of all the degrees of freedom numbers included in the nodes of the bar: <span class="literal">dofs</span> <span class="ent">➋</span>. To do this without adding too much noise in the <span class="literal">__assemble_system_matrix</span> method, we’ve implemented another private method: <span class="literal">__bar_dofs</span>.</p>&#13;
<p class="indent">This <span class="literal">__bar_dofs</span> method uses the <span class="literal">id</span>s of the passed-in bar nodes to extract its DOF numbers from the <span class="literal">__dofs_dict</span>. After extracting the start and end nodes’ DOF numbers, we create a new tuple by concatenating the two DOF tuples. Note that we can concatenate tuples using the <span class="literal">+</span> operator.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_439"/>Now we have a tuple containing the DOF numbers for a given bar’s nodes. Recall that this gives us the bar’s stiffness term’s position in the structure’s system of equations matrix: the DOF number is also the index in the system’s matrix. Back in <span class="literal">__assemble_system_matrix</span>, we use two <span class="literal">for</span> loops to cover all the terms in the bar’s stiffness matrix. These loops iterate over the matrix’s rows and columns and add every visited stiffness value to the structure’s global matrix <span class="ent">➌</span>. We use the indices from the enumerations to access the bar’s stiffness matrix and the DOF numbers to know the position in the structure’s matrix. To make sure you understand this process, take a look at <a href="ch16.xhtml#ch16fig5">Figure 16-5</a>.</p>&#13;
<div class="image"><img src="../images/16fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch16fig5"><em>Figure 16-5: Assembling the stiffness matrix</em></p>&#13;
<p class="indent">In the figure, we’ve taken bar 1 → 3, whose first node, N1, has the DOFs 0 and 1, and whose second node, N2, has the DOFs 4 and 5. We’ve annotated the side and top of the bar’s stiffness matrix with the degrees of freedom numbers. The stiffness terms in the matrix relate these degrees of freedom. For example, the term <em>k</em><sub>21</sub> is in the row that corresponds to DOF 4 and the column that corresponds to DOF 1; this term relates the force applied in DOF 4 with the displacement in DOF 1. These DOF numbers are the indices in the structure’s stiffness matrix. The <em>k</em><sub>21</sub> term, for instance, is located in the 4<sup>th</sup> row and 1<sup>st</sup> column in this matrix.</p>&#13;
<p class="indent">The last step in <a href="ch16.xhtml#ch16lis5">Listing 16-5</a> is to assign the computed matrix to the instance’s <span class="literal">__system_matrix</span> attribute <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec87"><strong>Assembling the System’s Vector</strong></h5>&#13;
<p class="noindent">We assemble the system’s external-force vector using a similar procedure to what we just did with the stiffness matrix. This time, instead of iterating over the bars of the structure, we’ll iterate over the nodes: we want to collect the external forces on each of them.</p>&#13;
<p class="indent">In your file, enter the new private method in <a href="ch16.xhtml#ch16lis6">Listing 16-6</a>.</p>&#13;
<pre>class Structure:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __assemble_system_vector(self, size: int):&#13;
        <span epub:type="pagebreak" id="page_440"/>vector = EqVector(size)&#13;
&#13;
        for node in self.__nodes:&#13;
            net_load = node.net_load&#13;
            (dof_x, dof_y) = self.__dofs_dict[node.id]&#13;
&#13;
            vector.add_to_value(net_load.u, dof_x)&#13;
            vector.add_to_value(net_load.v, dof_y)&#13;
&#13;
        self.__system_vector = vector</pre>&#13;
<p class="caption"><a id="ch16lis6"/><em>Listing 16-6: Assembling the system of equations vector</em></p>&#13;
<p class="indent">We first create a new <span class="literal">Vector</span> sized according to the <span class="literal">size</span> parameter (don’t forget we’ve aliased this class to be named <span class="literal">EqVector</span> now).</p>&#13;
<p class="indent">Next, we have a <span class="literal">for</span> loop that iterates over the nodes. For each node we save its net load in the <span class="literal">net_load</span> variable. Then we extract the node’s DOF numbers from <span class="literal">__dofs_dict</span> into the <span class="literal">dof_x</span> and <span class="literal">dof_y</span> variables. Note that we’re destructuring the tuple into these variables; take a look at “Destructuring” on <a href="ch01.xhtml#ch00lev1sec15">page 20</a> if you need a refresher on destructuring.</p>&#13;
<p class="indent">We then add each of the net load components into the <span class="literal">vector</span> variable: the x component (<span class="literal">net_load.u</span>) in the position given by <span class="literal">dof_x</span> and the y component (<span class="literal">net_load.v</span>) in the position given by <span class="literal">dof_y</span>.</p>&#13;
<p class="indent">Lastly, we assign the vector we’ve computed to the instance’s <span class="literal">__system_vector</span> attribute.</p>&#13;
<h5 class="h5" id="ch00lev3sec88"><strong>Applying the External Constraints</strong></h5>&#13;
<p class="noindent">Lastly, we need to include the external constraints in the structure’s stiffness matrix and force vector. This means that we want those displacements that are externally constrained to be zero in the final solution vector; if they’re constrained, they can’t move. To accomplish this, we can use the algebraic trick we explored earlier, which consisted of setting the rows and columns of the associated degrees of freedom as identity rows and columns in the stiffness matrix and as zero in the force vector.</p>&#13;
<p class="indent">This is easier done than said, so, without further ado, let’s see what the code looks like. Enter the code in <a href="ch16.xhtml#ch16lis7">Listing 16-7</a>.</p>&#13;
<pre>class Structure:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __apply_external_constraints(self):&#13;
        for node in self.__nodes:&#13;
         <span class="ent">➊</span> (dof_x, dof_y) = self.__dofs_dict[node.id]&#13;
&#13;
         <span class="ent">➋</span> if node.dx_constrained:&#13;
                self.__system_matrix.set_identity_row(dof_x)&#13;
                self.__system_matrix.set_identity_col(dof_x)&#13;
                self.__system_vector.set_value(0, dof_x)&#13;
&#13;
         <span epub:type="pagebreak" id="page_441"/><span class="ent">➌</span> if node.dy_constrained:&#13;
                self.__system_matrix.set_identity_row(dof_y)&#13;
                self.__system_matrix.set_identity_col(dof_y)&#13;
                self.__system_vector.set_value(0, dof_y)</pre>&#13;
<p class="caption"><a id="ch16lis7"/><em>Listing 16-7: Applying the external constraints</em></p>&#13;
<p class="indent">To check the existing external constraints, we iterate over the nodes of the structure. For each node, we extract its DOF numbers into the <span class="literal">dof_x</span> and <span class="literal">dof_y</span> variables <span class="ent">➊</span>. Then we check whether the node has its displacement in the x direction constrained <span class="ent">➋</span>, in which case we do three things:</p>&#13;
<p class="indent"/>&#13;
<ol>&#13;
<li class="noindent">Set the stiffness matrix <span class="literal">dof_x</span> row to the identity.</li>&#13;
<li class="noindent">Set the stiffness matrix <span class="literal">dof_x</span> column to the identity.</li>&#13;
<li class="noindent">Set the force vector <span class="literal">dof_x</span> value to zero.</li>&#13;
</ol>&#13;
<p class="noindent">We do the same for the displacement in the y direction constraint <span class="ent">➌</span>.</p>&#13;
<p class="indent">The system is now ready to be solved. Once we have the system’s solution in the form of the displacement vector, we can create the structure’s solution model.</p>&#13;
<h4 class="h4" id="ch00lev2sec173"><strong><em>Creating the Solution</em></strong></h4>&#13;
<p class="noindent">Let’s do a quick recap to remind ourselves where we are. We’ve written a lot of code split among a couple private methods. <a href="ch16.xhtml#ch16fig6">Figure 16-6</a> shows a hierarchy of the methods involved in solving the structure.</p>&#13;
<div class="image"><img src="../images/16fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch16fig6"><em>Figure 16-6: Structure resolution code split into a hierarchy</em></p>&#13;
<p class="indent">The nodes in this diagram are the methods ordered from left to right according to their execution order. The <span class="literal">solve_structure</span> method is the public method defining the main algorithm. If you recall, that method consists of three steps, which are written as private methods:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="literal">__assign_degrees_of_freedom</span></p>&#13;
<p class="noindentin"><span class="literal"><span epub:type="pagebreak" id="page_442"/>__solve_system_of_equations</span></p>&#13;
<p class="noindentin"><span class="literal">__make_structure_solution</span></p>&#13;
</div>&#13;
<p class="indent">The second private method, <span class="literal">__solve_system_of_equations</span>, is the one with the most submethods, as you can observe in the diagram.</p>&#13;
<p class="indent">So far we’ve written all but the <span class="literal">__make_structure_solution</span> method, the third and last step in <span class="literal">solve_structure</span>. Let’s write this method now. It uses the solution to the system of equations (the node’s global displacements) to build the structure solution model.</p>&#13;
<p class="indent">In the <em>model/structure.py</em> file, enter the code in <a href="ch16.xhtml#ch16lis8">Listing 16-8</a>.</p>&#13;
<pre>from functools import reduce&#13;
&#13;
from eqs import Matrix, Vector as EqVector, cholesky_solve&#13;
<span class="codestrong1">from geom2d import Vector</span>&#13;
<span class="codestrong1">from structures.solution.bar import StrBarSolution</span>&#13;
<span class="codestrong1">from structures.solution.node import StrNodeSolution</span>&#13;
<span class="codestrong1">from structures.solution.structure import StructureSolution</span>&#13;
from .bar import StrBar&#13;
from .node import StrNode&#13;
&#13;
class Structure:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __make_structure_solution(self) -&gt; StructureSolution:&#13;
        nodes = [&#13;
         <span class="ent">➊</span> self.__node_to_solution(node)&#13;
            for node in self.__nodes&#13;
        ]&#13;
&#13;
     <span class="ent">➋</span> nodes_dict = {}&#13;
        for node in nodes:&#13;
            nodes_dict[node.id] = node&#13;
        bars = [&#13;
         <span class="ent">➌</span> StrBarSolution(&#13;
                bar,&#13;
                nodes_dict[bar.start_node.id],&#13;
                nodes_dict[bar.end_node.id]&#13;
            )&#13;
            for bar in self.__bars&#13;
        ]&#13;
&#13;
     <span class="ent">➍</span> return StructureSolution(nodes, bars)&#13;
&#13;
    def __node_to_solution(self, node: StrNode) -&gt; StrNodeSolution:&#13;
     <span class="ent">➎</span> (dof_x, dof_y) = self.__dofs_dict[node.id]&#13;
     <span class="ent">➏</span> disp = Vector(&#13;
            <span epub:type="pagebreak" id="page_443"/>self.__global_displacements.value_at(dof_x),&#13;
            self.__global_displacements.value_at(dof_y)&#13;
        )&#13;
     <span class="ent">➐</span> return StrNodeSolution(node, disp)</pre>&#13;
<p class="caption"><a id="ch16lis8"/><em>Listing 16-8: Creating the solution model</em></p>&#13;
<p class="indent">The first thing we need to do is add a few imports from the <span class="literal">structures.solution</span> package. We also import the <span class="literal">Vector</span> class from the <span class="literal">geom2d</span> package.</p>&#13;
<p class="indent">Note how we add a type hint for the method’s returned object. These type hints are preceded by an arrow (<span class="literal">-&gt;</span>) and go between the method or function name and the colon.</p>&#13;
<p class="indent">Then, using a list comprehension, we map each of the original <span class="literal">__nodes</span> to the node solution model <span class="ent">➊</span>. We use a private method we have to write: <span class="literal">__node_to_solution</span>. Given a node, this method looks for its degrees of freedom numbers <span class="ent">➎</span>, creates a vector with the two displacements associated with those DOF numbers <span class="ent">➏</span>, and returns an instance of <span class="literal">StrNodeSolution</span> using the original node and the vector of global displacements <span class="ent">➐</span>.</p>&#13;
<p class="indent">Back in <span class="literal">__make_structure_solution</span>, the next step is an intermediate computation that will simplify the construction of the solution bars. We’ll create a dictionary of solution nodes where the key is the <span class="literal">id</span> of the node and the value is the node itself <span class="ent">➋</span>.</p>&#13;
<p class="indent">With the help of <span class="literal">nodes_dict</span>, computing the solution bar model becomes simpler. Using a list comprehension, we map each of the original bars to a <span class="literal">StrBarSolution</span> instance <span class="ent">➌</span>. To instantiate this class, we need to pass it the original bar and the two solution nodes; thanks to the dictionary we just created, this is a piece of cake. If we hadn’t created the dictionary of nodes by ID, we’d need to search the list of solution nodes for a node with a given ID. Performance-wise, this isn’t ideal. For each bar, we may need to iterate over the whole list of nodes twice. Creating the dictionary to find nodes by ID is a much wiser option; it allows for a constant-time search of the nodes. This means that, no matter the size of the dictionary, looking up the value associated with a key takes the same amount of time. If the structure has a large number of nodes, this improvement can noticeably decrease the execution time.</p>&#13;
<p class="indent">Lastly, we instantiate <span class="literal">StructureSolution</span>, passing it the solution nodes and bars <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec174"><strong><em>The Result</em></strong></h4>&#13;
<p class="noindent">Resolving the structure required quite a lot of code, so we better bring it all together in a single listing for clarity. <a href="ch16.xhtml#ch16lis9">Listing 16-9</a> is the complete <span class="literal">Structure</span> class’s code, including the <span class="literal">solve_structure</span> implementation and every private method we wrote.</p>&#13;
<pre>from functools import reduce&#13;
&#13;
from eqs import Matrix, Vector as EqVector, cholesky_solve&#13;
from geom2d import Vector&#13;
<span epub:type="pagebreak" id="page_444"/>from structures.solution.bar import StrBarSolution&#13;
from structures.solution.node import StrNodeSolution&#13;
from structures.solution.structure import StructureSolution&#13;
from .bar import StrBar&#13;
from .node import StrNode&#13;
&#13;
&#13;
class Structure:&#13;
    __DOF_PER_NODE = 2&#13;
&#13;
    def __init__(self, nodes: [StrNode], bars: [StrBar]):&#13;
        self.__bars = bars&#13;
        self.__nodes = nodes&#13;
&#13;
        self.__dofs_dict = None&#13;
        self.__system_matrix: Matrix = None&#13;
        self.__system_vector: EqVector = None&#13;
        self.__global_displacements: EqVector = None&#13;
&#13;
    @property&#13;
    def nodes_count(self):&#13;
        return len(self.__nodes)&#13;
&#13;
    @property&#13;
    def bars_count(self):&#13;
        return len(self.__bars)&#13;
&#13;
    @property&#13;
    def loads_count(self):&#13;
        return reduce(&#13;
            lambda count, node: count + node.loads_count,&#13;
            self.__nodes,&#13;
            0&#13;
        )&#13;
&#13;
    def solve_structure(self) -&gt; StructureSolution:&#13;
        self.__assign_degrees_of_freedom()&#13;
        self.__solve_system_of_equations()&#13;
        return self.__make_structure_solution()&#13;
&#13;
    def __assign_degrees_of_freedom(self):&#13;
        self.__dofs_dict = {}&#13;
        for i, node in enumerate(self.__nodes):&#13;
            self.__dofs_dict[node.id] = (2 * i, 2 * i + 1)&#13;
&#13;
    def __solve_system_of_equations(self):&#13;
        size = self.nodes_count * self.__DOF_PER_NODE&#13;
        <span epub:type="pagebreak" id="page_445"/>self.__assemble_system_matrix(size)&#13;
        self.__assemble_system_vector(size)&#13;
        self.__apply_external_constraints()&#13;
        self.__global_displacements = cholesky_solve(&#13;
            self.__system_matrix,&#13;
            self.__system_vector&#13;
        )&#13;
&#13;
    def __assemble_system_matrix(self, size: int):&#13;
        matrix = Matrix(size, size)&#13;
&#13;
        for bar in self.__bars:&#13;
            bar_matrix = bar.global_stiffness_matrix()&#13;
            dofs = self.__bar_dofs(bar)&#13;
&#13;
            for row, row_dof in enumerate(dofs):&#13;
                for col, col_dof in enumerate(dofs):&#13;
                    matrix.add_to_value(&#13;
                        bar_matrix.value_at(row, col),&#13;
                        row_dof,&#13;
                        col_dof&#13;
                    )&#13;
&#13;
        self.__system_matrix = matrix&#13;
&#13;
    def __bar_dofs(self, bar: StrBar):&#13;
        start_dofs = self.__dofs_dict[bar.start_node.id]&#13;
        end_dofs = self.__dofs_dict[bar.end_node.id]&#13;
        return start_dofs + end_dofs&#13;
&#13;
    def __assemble_system_vector(self, size: int):&#13;
        vector = EqVector(size)&#13;
&#13;
        for node in self.__nodes:&#13;
            net_load = node.net_load&#13;
            (dof_x, dof_y) = self.__dofs_dict[node.id]&#13;
&#13;
            vector.add_to_value(net_load.u, dof_x)&#13;
            vector.add_to_value(net_load.v, dof_y)&#13;
&#13;
        self.__system_vector = vector&#13;
&#13;
    def __apply_external_constraints(self):&#13;
        for node in self.__nodes:&#13;
            (dof_x, dof_y) = self.__dofs_dict[node.id]&#13;
&#13;
            if node.dx_constrained:&#13;
                <span epub:type="pagebreak" id="page_446"/>self.__system_matrix.set_identity_row(dof_x)&#13;
                self.__system_matrix.set_identity_col(dof_x)&#13;
                self.__system_vector.set_value(0, dof_x)&#13;
&#13;
            if node.dy_constrained:&#13;
                self.__system_matrix.set_identity_row(dof_y)&#13;
                self.__system_matrix.set_identity_col(dof_y)&#13;
                self.__system_vector.set_value(0, dof_y)&#13;
&#13;
    def __make_structure_solution(self) -&gt; StructureSolution:&#13;
        nodes = [&#13;
            self.__node_to_solution(node)&#13;
            for node in self.__nodes&#13;
        ]&#13;
&#13;
        nodes_dict = {}&#13;
        for node in nodes:&#13;
            nodes_dict[node.id] = node&#13;
&#13;
        bars = [&#13;
            StrBarSolution(&#13;
                bar,&#13;
                nodes_dict[bar.start_node.id],&#13;
                nodes_dict[bar.end_node.id]&#13;
            )&#13;
            for bar in self.__bars&#13;
        ]&#13;
&#13;
        return StructureSolution(nodes, bars)&#13;
&#13;
    def __node_to_solution(self, node: StrNode) -&gt; StrNodeSolution:&#13;
        (dof_x, dof_y) = self.__dofs_dict[node.id]&#13;
        disp = Vector(&#13;
            self.__global_displacements.value_at(dof_x),&#13;
            self.__global_displacements.value_at(dof_y)&#13;
        )&#13;
        return StrNodeSolution(node, disp)</pre>&#13;
<p class="caption"><a id="ch16lis9"/><em>Listing 16-9: The final <span class="codeitalic">Structure class</span></em></p>&#13;
<p class="indent">With this code ready, the only missing thing is some unit tests. We need to make sure all the logic we’ve just written is bug-free. But the code we’ve written in the previous two chapters has become more complex and requires the interaction of several different classes to work. How do we isolate the parts of the code we want to test?</p>&#13;
<h3 class="h3" id="ch00lev1sec97"><span epub:type="pagebreak" id="page_447"/><strong>Advanced Unit Testing: Test Doubles</strong></h3>&#13;
<p class="noindent">As our classes get more complex, they’ll often rely on other classes and external functions. Here’s where unit testing becomes trickier. Unit testing is about isolating a small portion of the logic in the class or function we want to test so that there’s one single reason for a test to fail. Testing that things run correctly when they’re put to work together is known as <em>integration testing</em>. Integration tests are meant to test bigger chunks of the system; with integration tests, we’re interested in knowing whether the smaller pieces of a system still work when they interact with each other. We won’t be integration testing here, but I encourage you to try it on your own.</p>&#13;
<p class="indent">Going back to unit tests, let’s take our <span class="literal">StructureSolution</span> class from the previous chapter. Let’s say we want to test its <span class="literal">bounds_rect</span> method.</p>&#13;
<pre>def bounds_rect(self, margin, scale=1):&#13;
    d_pos = [&#13;
        node.displaced_pos_scaled(scale)&#13;
        for node in self.nodes&#13;
    ]&#13;
    return make_rect_containing_with_margin(d_pos, margin)</pre>&#13;
<p class="indent">This method delegates most of its logic to <span class="literal">make_rect_containing_with_margin</span> and also depends on <span class="literal">StrNodeSolution</span> instances to correctly compute their displaced position. If we tested this method as is, we’d be testing <span class="literal">make_rect_containing_with_margin</span> and the <span class="literal">Node</span> class’s <span class="literal">displaced_pos_scaled</span> method. Those should both already be unit tested somewhere else. The test could fail for several reasons that are unrelated to the logic in <span class="literal">bounds_rect</span>. In this case, we’d be doing an integration test, but we first want to make sure our method works well in isolation using unit tests.</p>&#13;
<p class="indent">We can test this method without relying on other classes’ implementation using test doubles.</p>&#13;
<h4 class="h4" id="ch00lev2sec175"><strong><em>Test Doubles</em></strong></h4>&#13;
<p class="noindent">A <em>test double</em> replaces a real implementation used in a test. This test double may replace a function, an entire class, or just parts of it. To do the unit test, we replace all the parts of the code that are not being directly tested by the unit test with test doubles. What exactly the test double does depends on what type of test double it is. There are a few flavors.</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Dummy</strong> This is the simplest test double. The <em>dummy</em> replaces an object whose presence is required but that is never actually used in the test. This could be a parameter to the function, for example.</p>&#13;
<p class="noindentin"><strong>Fake</strong> A <em>fake</em> test double replaces some part of the code; it has a working implementation but takes some shortcuts or is greatly simplified. Say, for example, we have a function that reads a text file and parses a structure model from it. If this function was used in another part of the code we wanted to test, we could create a fake version of it that pretends <span epub:type="pagebreak" id="page_448"/>to read a file, although it really doesn’t and creates a structure to return it.</p>&#13;
<p class="noindentin"><strong>Stub</strong> A <em>stub</em> replaces some part of the code and always returns the same value or behaves in a specific way. For example, we could stub our <span class="literal">are_close_enough</span> function (that compares floating-point numbers) to always return <span class="literal">False</span> in a given test.</p>&#13;
<p class="noindentin"><strong>Mock</strong> This is a test double that records the way it’s being used so that it can be used to make assertions. <em>Mocks</em> are probably the most sophisticated and versatile type of test doubles. We can mock entire objects, pass them to our code in place of the real implementation, and then explore how our code interacted with the mock to make sure the right interactions took place. We’ll look at a real example of a mock briefly.</p>&#13;
</div>&#13;
<p class="indent">Let’s now explore how Python allows us to create test doubles. We’ll focus on mocking, as mocks are so versatile that we can use them in almost every case where a test double is required.</p>&#13;
<h4 class="h4" id="ch00lev2sec176"><strong><em>The unittest.mock Package</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">unittest</span> package in the Python standard library includes its own mocking mechanism, found in the <span class="literal">unittest.mock</span> package. You can read the package’s documentation at <a href="http://docs.python.org/3/library/unittest.mock.html"><em>docs.python.org/3/library/unittest.mock.html</em></a>, and I recommend you do, as it contains detailed explanations that will help you understand how best to use it. Let’s take a quick look at how to use the <span class="literal">unittest.mock</span> package’s main functionalities.</p>&#13;
<h5 class="h5" id="ch00lev3sec89"><strong>The Mock Object</strong></h5>&#13;
<p class="noindent"><span class="literal">Mock</span> is the main class in the <span class="literal">unittest.mock</span> package. This class’s instances record every interaction they have and provide us with assertions to check those interactions. You can call any method you want in a mock object; if the method doesn’t exist, it will be created so we can inspect how many times this method was called or what parameters were passed in. As stated in the documentation,</p>&#13;
<p class="indent"/>&#13;
<div class="quote">&#13;
<p class="noindent">Mocks are callable and create attributes as new mocks when you access them. Accessing the same attribute will always return the same mock. Mocks record how you use them, allowing you to make assertions about what your code has done to them.</p>&#13;
</div>&#13;
<p class="indent">Let’s break that documentation down. An instance of the <span class="literal">Mock</span> class being “callable” means that you can “call” it the same way you call a function. Those calls you make on the instance are recorded by the mock. This suggests we can use <span class="literal">Mock</span> instances to replace functions.</p>&#13;
<p class="indent">The documentation also says that mocks “create attributes as new mocks when you access them.” This means that when you call a method on a <span class="literal">Mock</span> instance, Python will create a new <span class="literal">Mock</span> for that method, if it doesn’t exist yet, and append it as a new attribute of the instance. Don’t forget that mocks <span epub:type="pagebreak" id="page_449"/>are callable: you can call these attributes as if they were methods, and their interactions will be recorded.</p>&#13;
<p class="indent">Let’s take a look at a quick example in Python’s shell to start making these concepts a bit more concrete:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from unittest.mock import Mock</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">mock = Mock()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">mock()</span>&#13;
&lt;Mock name='mock()' id='4548720456'&gt;&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">mock.some_method('foo', 23)</span>&#13;
&lt;Mock name='mock.some_method()' id='4436512848'&gt;</pre>&#13;
<p class="indent">In this code we create a new instance of the <span class="literal">Mock</span> class and call it like a function. We also call a method named <span class="literal">some_method</span> on our mock and pass it two arguments: the string ’<span class="literal">foo</span>’ and the number <span class="literal">23</span>. Calling <span class="literal">some_method</span> has no side effects: it does nothing except for record the call to it; this is because mock methods have no implementation by default. We’ll learn later how to make mock methods return something or perform some kind of side effect, but for now just keep in mind that, by default, mocks do nothing but record their usage.</p>&#13;
<p class="indent">If we call a method from a <span class="literal">Mock</span> object that we haven’t configured to return anything or perform any kind of side effect, by default it’ll return another <span class="literal">Mock</span> instance. This is the instance that’s stored in the original mock as an attribute.</p>&#13;
<p class="indent">We can ask this mock whether <span class="literal">some_method</span> has been called or not, and with what arguments:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">mock.some_method.assert_called()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">mock.some_method.assert_called_once()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">mock.some_method.assert_called_with('foo', 23)</span></pre>&#13;
<p class="indent">All three calls succeed (don’t raise an assertion error), but if we asked for arguments that were not passed to <span class="literal">some_method</span>,</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">mock.some_method.assert_called_with('bar', 577)</span></pre>&#13;
<p class="noindent">we’d get an <span class="literal">AssertionError</span> with a helpful message, which would make a test fail and give us the reason why:</p>&#13;
<pre>Traceback (most recent call last):&#13;
<span class="codeitalic1">--snip--</span>&#13;
AssertionError: Expected call: some_method('bar', 577)&#13;
Actual call: some_method('foo', 123)</pre>&#13;
<p class="indent">Likewise, if we asked for the calls of a method that was never called,</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">mock.foo.assert_called()</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_450"/>we’d also get an error:</p>&#13;
<pre>Traceback (most recent call last):&#13;
<span class="codeitalic1">--snip--</span>&#13;
AssertionError: Expected 'foo' to have been called.</pre>&#13;
<p class="indent">Let’s not forget that the mock itself is a callable object that records the interactions made with it. Therefore, the following also succeeds:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">mock.assert_called()</span></pre>&#13;
<h5 class="h5" id="ch00lev3sec90"><strong>Mocking Classes</strong></h5>&#13;
<p class="noindent">A common use case for mocks is creating a mock instance of a given class. These mocks let us inspect how the class they’re mocking was used and what methods were called on it; we can also use the mock to provide return values for the mocked methods to use in the tests.</p>&#13;
<p class="indent">To mock a class, we pass it to the <span class="literal">spec</span> parameter of the <span class="literal">Mock</span> constructor. Let’s create a mock for our <span class="literal">Vector</span> class:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from unittest.mock import Mock</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from geom2d import Vector</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock = Mock(spec=Vector)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">isinstance(vector_mock, Vector)</span>&#13;
True</pre>&#13;
<p class="indent">This mock object has its <span class="literal">__class__</span> attribute set to <span class="literal">Vector</span> so that it looks like a real <span class="literal">Vector</span> instance. It even passes the <span class="literal">isinstance</span> test! This mock can be effectively used to replace a real <span class="literal">Vector</span>. All of the methods in the <span class="literal">Vector</span> class are also defined in this test double. We can call any of them as we normally would:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">vector_mock.rotated_radians(0.25)</span>&#13;
&lt;Mock name='mock.rotated_radians()' id='4498122344'&gt;</pre>&#13;
<p class="indent">This time, <span class="literal">rotated_radians</span> didn’t return a new instance of <span class="literal">Vector</span>, as we’d expect. Instead, it returned a <span class="literal">Mock</span> instance. Since a mocked class’s methods have no implementation, there is no code to perform the rotating operation and return the resulting vector. We can program mock methods to return a predefined value using the mock’s <span class="literal">side_effect</span> and <span class="literal">return_value</span> attributes.</p>&#13;
<p class="indent">But before we get to that, there’s one more thing that’s important about class mocks: if we try to call a method that doesn’t exist in the class, we’ll get an <span class="literal">AttributeError</span>. New attributes can be added to a generic mock, but not to a mock of a class. The code</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">vector_mock.defrangulate()</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_451"/>yields this:</p>&#13;
<pre>Traceback (most recent call last):&#13;
<span class="codeitalic1">--snip--</span>&#13;
AttributeError: Mock object has no attribute 'defrangulate'</pre>&#13;
<p class="indent">This is good: we can be sure that if some part of our code tries to call methods that don’t exist in the original class, we’ll get an error.</p>&#13;
<p class="indent">Let’s now take a look at how we can go about adding a stub implementation or simply a predefined return value for mocks.</p>&#13;
<h5 class="h5" id="ch00lev3sec91"><strong>Setting Return Values and Side Effects</strong></h5>&#13;
<p class="noindent">By setting a mock’s <span class="literal">return_value</span>, we can make it return something when called:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">vector_mock.rotated_radians.return_value = Vector(0, 0)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock.rotated_radians(0.25)</span>&#13;
&lt;geom2d.vector.Vector object at 0x10bbaa4a8&gt;</pre>&#13;
<p class="indent">Calling <span class="literal">rotated_radians</span> now returns an instance of the <span class="literal">Vector</span> class: exactly the instance we programmed it to return. From now on, every time this method is called on the mock, it will return the same <span class="literal">Vector</span> instance.</p>&#13;
<p class="indent">Mocks can also execute side effects when called. According to the documentation, a <span class="literal">side_effect</span></p>&#13;
<p class="indent"/>&#13;
<div class="quote">&#13;
<p class="noindent">can either be a function to be called when the mock is called, an iterable or an exception (class or instance) to be raised.</p>&#13;
</div>&#13;
<p class="indent">Let’s first take a look at how a mock can raise an exception. For example, if we needed the <span class="literal">cosine</span> method to raise a <span class="literal">ValueError</span>, we could do the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">vector_mock.cosine.side_effect = ValueError</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock.cosine()</span>&#13;
Traceback (most recent call last):&#13;
<span class="codeitalic1">--snip--</span>&#13;
ValueError</pre>&#13;
<p class="indent">Note that we’re setting the <span class="literal">ValueError</span> class itself as the <span class="literal">side_effect</span>, but as the documentation states, we can also use a concrete instance, like this:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">vector_mock.cosine.side_effect = ValueError('Oops')</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock.cosine()</span>&#13;
Traceback (most recent call last):&#13;
<span class="codeitalic1">--snip--</span>&#13;
ValueError: Oops</pre>&#13;
<p class="noindent">In this case, every time we call <span class="literal">cosine</span>, we get the same <span class="literal">ValueError</span> instance. In the previous example, every call produces a new instance of the error.</p>&#13;
<p class="indent">We can also assign a function to a mock’s <span class="literal">side_effect</span> attribute. This function receives the parameters passed to the <span epub:type="pagebreak" id="page_452"/>mock function and might return a value. For example, in our <span class="literal">Vector</span> mock, we could decide to have the <span class="literal">scaled_by</span> method return the passed-in <span class="literal">factor</span> parameter:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">vector_mock.scaled_by.side_effect = lambda factor: factor</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock.scaled_by(45)</span>&#13;
45</pre>&#13;
<p class="indent">In this case, the <span class="literal">scaled_by</span> method was passed a <span class="literal">45</span> as the scaling factor, and this parameter was forwarded to the function defined as the mock’s <span class="literal">side_effect</span> attribute.</p>&#13;
<p class="indent">This function can perform its own side effect, like saving the parameters it received or printing something to the shell. We can use this function together with <span class="literal">return_value</span>. If we use the function to perform a side effect but still want to return whatever is set in the <span class="literal">return_value</span> attribute, the function should return <span class="literal">DEFAULT</span> (defined in <span class="literal">unittest.mock</span>):</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from unittest.mock import DEFAULT</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">def side_effect(factor):</span>&#13;
...    <span class="codestrong1">print(f'mock called with factor: {factor}')</span>&#13;
...    <span class="codestrong1">return DEFAULT</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock.scaled_by.side_effect = side_effect</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock.scaled_by.return_value = Vector(1, 2)</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">vector_mock.scaled_by(2)</span>&#13;
mock called with factor: 2&#13;
&lt;geom2d.vector.Vector object at 0x10c4a7f28&gt;</pre>&#13;
<p class="indent">As you can see, the <span class="literal">side_effect</span> function was called, but as it returned the <span class="literal">DEFAULT</span> value, the call to <span class="literal">scaled_by</span> returned the vector we set as <span class="literal">return_value</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec92"><strong>The patch Decorator</strong></h5>&#13;
<p class="noindent">The <em>mock</em> package includes a <span class="literal">unittest.mock.patch</span> decorator we can use to mock objects in a test function. The <span class="literal">@patch</span> decorator has the ability to mock objects instantiated in the test function they decorate. The mocks created by the decorator are cleared for us automatically once the function returns, so the mocking is only effective in the context of the function. We have to pass the <span class="literal">@patch</span> decorator the target we want to mock using the format ’<span class="literal">package.module.name</span>’ (this is a string, so don’t forget the quotation marks), where <span class="literal">name</span> can be the name of a class or a function. The decorated function will be passed the mocked target as a new argument:</p>&#13;
<pre>from unittest.mock import patch&#13;
&#13;
@patch('geom2d.circles.make_circle_from_points')&#13;
def test_something(make_circle_mock):&#13;
    make_circle_mock(1, 2, 3)&#13;
    make_circle_mock.assert_called_with(1, 2, 3)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_453"/>In this test we’re replacing the <span class="literal">make_circle_from_points</span> function defined in the <em>geom2d</em> package’s <em>circles</em> module. We have to include the mocked function, <span class="literal">make_circle_mock</span>, as an argument to the function. Then, in the context of the <span class="literal">test_something</span> function, we can refer to the mocked function and assert it was called like we do with any other mock.</p>&#13;
<p class="indent">The <span class="literal">@patch</span> decorator’s main use case is replacing functions or classes that are imported by our test subjects. By using a patch, we force them to import a mock instead of the real dependency.</p>&#13;
<p class="indent">There is no other easy way of mocking the dependencies of the modules we want to unit test: if the module imports their dependencies, we need a way of replacing that dependency in Python’s importing mechanism. The <span class="literal">@patch</span> decorator does this for us in an elegant manner.</p>&#13;
<p class="indent">Now let’s apply all this knowledge to test our code in isolation: there’s no better way of learning how to use test doubles than using them in real use cases. If you’re new to using test doubles, you may be a bit confused at this point; that’s perfectly normal. As we see mocks in action a couple times, you’ll start to grasp the concepts.</p>&#13;
<h3 class="h3" id="ch00lev1sec98"><strong>Testing the Structure Solution Class</strong></h3>&#13;
<p class="noindent">Following the example we introduced earlier of the <span class="literal">bounds_rect</span> method in the <span class="literal">StructureSolution</span> class, let’s see how we can go about testing it. Remember, the method we want to test is defined as follows:</p>&#13;
<pre>def bounds_rect(self, margin, scale=1):&#13;
    d_pos = [&#13;
        node.displaced_pos_scaled(scale)&#13;
        for node in self.nodes&#13;
    ]&#13;
    return make_rect_containing_with_margin(d_pos, margin)</pre>&#13;
<p class="indent">The method requires that the <span class="literal">StrNodeSolution</span> class correctly computes its displaced position using a scale and that the <span class="literal">make_rect_containing_with_margin</span> function returns the correct rectangle using the given margin. We don’t need to test those behaviors; that should have been done somewhere else. What we want to do is replace their real implementations with test doubles so that they don’t interfere in our tests.</p>&#13;
<p class="indent">Without further ado, let’s create a new file in <em>structures/tests</em> named <em>structure_solution_test.py</em>. In the file, enter the test setup code, as in <a href="#ch16lis10">Listing 16-10</a>.</p>&#13;
<pre>import unittest&#13;
from unittest.mock import patch, Mock&#13;
&#13;
from geom2d import Point&#13;
from structures.solution.node import StrNodeSolution&#13;
from structures.solution.structure import StructureSolution&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_454"/>class StructureSolutionTest(unittest.TestCase):&#13;
&#13;
    p_one = Point(2, 3)&#13;
    p_two = Point(5, 1)&#13;
&#13;
    def setUp(self):&#13;
        self.n_one = Mock(spec=StrNodeSolution)&#13;
        self.n_one.displaced_pos_scaled.return_value = self.p_one&#13;
        self.n_two = Mock(spec=StrNodeSolution)&#13;
        self.n_two.displaced_pos_scaled.return_value = self.p_two</pre>&#13;
<p class="caption"><a id="ch16lis10"/><em>Listing 16-10: Structure solution class test: the setup</em></p>&#13;
<p class="indent">In this test setup, we’re defining two points: <span class="literal">p_one</span> and <span class="literal">p_two</span>; these are the positions for the mock nodes we create in the <span class="literal">setUp</span> method. This <span class="literal">setUp</span> method is executed by the <span class="literal">unittest</span> framework before each test, which ensures that each test gets fresh mocks; otherwise, mocks would continue to record throughout the tests, breaking the independence between tests.</p>&#13;
<p class="indent">We define two nodes: <span class="literal">n_one</span> and <span class="literal">n_two</span>. Then we instantiate node mocks using the <span class="literal">StrNodeSolution</span> class as the value for the <span class="literal">spec</span> parameter. Each of the node mocks defines one of the defined points as the return value for its <span class="literal">displaced_pos_scaled</span> method.</p>&#13;
<p class="indent">Next, let’s write the first test, which will ensure that the two nodes get the <span class="literal">displaced_pos_scaled</span> called with the correct value for the <span class="literal">scale</span> parameter. After the <span class="literal">setUp</span> method, enter the test in <a href="ch16.xhtml#ch16lis11">Listing 16-11</a>.</p>&#13;
<pre>class StructureSolutionTest(unittest.TestCase):&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_node_displaced_scaled_positions_called(self):&#13;
        solution = StructureSolution([self.n_one, self.n_two], [])&#13;
        solution.bounds_rect(margin=10, scale=4)&#13;
&#13;
        self.n_one.displaced_pos_scaled.assert_called_once_with(4)&#13;
        self.n_two.displaced_pos_scaled.assert_called_once_with(4)</pre>&#13;
<p class="caption"><a id="ch16lis11"/><em>Listing 16-11: Structure solution class test: first test</em></p>&#13;
<p class="indent">We create a <span class="literal">StructureSolution</span> instance with a list containing the two nodes defined in the <span class="literal">setUp</span> and no bars: we don’t need them to test the <span class="literal">bounds_rect</span> method, and the <span class="literal">StructureSolution</span> doesn’t complain if we instantiate it with an empty bars list. If the <span class="literal">StructureSolution</span> class initializer complained about getting an empty list of bars, this would have been the perfect case for using the dummy test double: we’d pass the constructor a list of dummy bars. Dummies are used to fill in required parameters, but dummies don’t actually do anything or interfere with the test in any way.</p>&#13;
<p class="indent">Once we’ve instantiated our <span class="literal">StructureSolution</span>, we call the <span class="literal">bounds_rect</span> method, our test subject, with values for the margin and scale. Lastly, we <span epub:type="pagebreak" id="page_455"/>assert that <span class="literal">displaced_pos_scaled</span> was called once with the correct value for the scale in both nodes.</p>&#13;
<p class="indent">This test ensures that we use the node’s displaced positions with the corresponding scale applied to compute the structure solution bounds. Imagine that, by mistake, we confused the <span class="literal">margin</span> and <span class="literal">scale</span> parameters when implementing the method:</p>&#13;
<pre>def bounds_rect(self, margin, scale=1):&#13;
    d_pos = [&#13;
        # wrong! used 'margin' instead of 'scale'&#13;
        node.displaced_pos_scaled(margin)&#13;
        for node in self.nodes&#13;
    ]&#13;
    # wrong! used 'scale' instead of 'margin'&#13;
    return make_rect_containing_with_margin(d_pos, scale)</pre>&#13;
<p class="noindent">Our unit test would have warned us:</p>&#13;
<pre>Expected call: make_rect_containing_with_margin([&#13;
    &lt;geom2d.point.Point object at 0x10575a630&gt;,&#13;
    &lt;geom2d.point.Point object at 0x10575a6a0&gt;], <span class="codestrong1">10</span>)&#13;
Actual call: make_rect_containing_with_margin([&#13;
    &lt;geom2d.point.Point object at 0x10575a630&gt;,&#13;
    &lt;geom2d.point.Point object at 0x10575a6a0&gt;], <span class="codestrong1">4</span>)</pre>&#13;
<p class="indent">Congratulations! You’ve written your first unit test using test doubles. Let’s now write a second test that ensures the right usage of the function that computes the rectangle. Enter the code in <a href="ch16.xhtml#ch16lis12">Listing 16-12</a>.</p>&#13;
<pre>class StructureSolutionTest(unittest.TestCase):&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @patch('structures.solution.structure.make_rect_containing_with_margin')&#13;
    def test_make_rect_called(self, make_rect_mock):&#13;
        solution = StructureSolution([self.n_one, self.n_two], [])&#13;
        solution.bounds_rect(margin=10, scale=4)&#13;
&#13;
        make_rect_mock.assert_called_once_with(&#13;
            [self.p_one, self.p_two],&#13;
            10&#13;
        )</pre>&#13;
<p class="caption"><a id="ch16lis12"/><em>Listing 16-12: Structure solution class test: second test</em></p>&#13;
<p class="indent">This test is a bit trickier because the <span class="literal">make_rect_containing_with_margin</span> function is imported by the <span class="literal">StructureSolution</span> class. To make this class import our mock instead of the real implementation, we have to patch the function’s path: ’<span class="literal">package.module.name</span>’, which is, in this case, as follows:</p>&#13;
<p class="pre2">'structures.solution.structure.make_rect_containing_with_margin'</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_456"/>But, wait: isn’t <span class="literal">make_rect_containing_with_margin</span> defined in the <em>geom2d</em> package? So why are we patching it as if it were in the <em>structures.solution</em> package and the <em>structure</em> module?</p>&#13;
<p class="indent">The <span class="literal">@patch</span> decorator has some rules that define how the path should be given to mock a given object. In the “Where to patch” section, the documentation states</p>&#13;
<div class="quote">&#13;
<p class="indent"><span class="literal">patch()</span> works by (temporarily) changing the object that a <em>name</em> points to with another one. There can be many names pointing to any individual object, so for patching to work you must ensure that you patch the name used by the system under test.</p>&#13;
<p class="indent">The basic principle is that you patch where an object is <em>looked up</em>, which is not necessarily the same place as where it is defined.</p>&#13;
</div>&#13;
<p class="indent">That second paragraph gives us the key: objects have to be patched where they’re looked up. In the case of our test, the function we want to replace is looked up in the <span class="literal">structures.solution</span> package, in the <em>structure</em> module. This may sound a bit complicated in the beginning, but it’ll start to make sense after you’ve done it a few times.</p>&#13;
<p class="indent">Moving on with our test, the first two lines are identical to the previous one: they create the structure solution and call the function under test. Then comes the assertion, which is done on the parameter passed to the test function: <span class="literal">make_rect_mock</span>. Remember, the <span class="literal">@patch</span> decorator passes the patched entity to the decorated function. We assert that the mock was called only once with the list of positions the mocked nodes return and the value for the margin.</p>&#13;
<p class="indent">You can run these tests using PyCharm, by clicking the green play button to the left of the test class name. Alternatively, you can run them from the shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/structure_solution_test.py</span></pre>&#13;
<p class="indent"><a href="ch16.xhtml#ch16lis13">Listing 16-13</a> shows the resulting code for your reference.</p>&#13;
<pre>import unittest&#13;
from unittest.mock import patch, Mock&#13;
&#13;
from geom2d import Point&#13;
from structures.solution.node import StrNodeSolution&#13;
from structures.solution.structure import StructureSolution&#13;
&#13;
&#13;
class StructureSolutionTest(unittest.TestCase):&#13;
&#13;
    p_one = Point(2, 3)&#13;
    p_two = Point(5, 1)&#13;
&#13;
    def setUp(self):&#13;
        <span epub:type="pagebreak" id="page_457"/>self.n_one = Mock(spec=StrNodeSolution)&#13;
        self.n_one.displaced_pos_scaled.return_value = self.p_one&#13;
        self.n_two = Mock(spec=StrNodeSolution)&#13;
        self.n_two.displaced_pos_scaled.return_value = self.p_two&#13;
&#13;
    def test_node_displaced_scaled_positions_called(self):&#13;
        solution = StructureSolution([self.n_one, self.n_two], [])&#13;
        solution.bounds_rect(margin=10, scale=4)&#13;
&#13;
        self.n_one.displaced_pos_scaled.assert_called_once_with(4)&#13;
        self.n_two.displaced_pos_scaled.assert_called_once_with(4)&#13;
&#13;
    @patch('structures.solution.structure.make_rect_containing_with_margin')&#13;
    def test_make_rect_called(self, make_rect_mock):&#13;
        solution = StructureSolution([self.n_one, self.n_two], [])&#13;
        solution.bounds_rect(margin=10, scale=4)&#13;
&#13;
        make_rect_mock.assert_called_once_with(&#13;
            [self.p_one, self.p_two],&#13;
            10&#13;
        )</pre>&#13;
<p class="caption"><a id="ch16lis13"/><em>Listing 16-13: Structure solution class test: the result</em></p>&#13;
<p class="indent">Before we move on, there’s one important gotcha we need to take into account. If you take a look at both tests, you may be tempted to remove the duplicated lines,</p>&#13;
<pre>solution = StructureSolution([self.n_one, self.n_two], [])&#13;
solution.bounds_rect(margin=10, scale=4)</pre>&#13;
<p class="noindent">by moving them to the <span class="literal">setUp</span>. That seems a reasonable thing to do so that the tests don’t need to repeat those lines, but if you want to go ahead and do the refactor, you’ll find that the second test now fails. Why?</p>&#13;
<p class="indent">The answer has to do with how the <span class="literal">@patch</span> decorator works. It has to decorate the function where the dependency it’s patching gets resolved, and in our case, the <span class="literal">make_rect_containing_with_margin</span> function is imported when the <span class="literal">StructureSolution</span> class is instantiated. Therefore, at least for the second test, the instantiation of this class needs to happen in the test method, which is annotated with the <span class="literal">@patch</span> decorator.</p>&#13;
<h3 class="h3" id="ch00lev1sec99"><strong>Testing the Structure Resolution Process</strong></h3>&#13;
<p class="noindent">Let’s now add a few tests to ensure the structure resolution process yields the correct results. For these tests, we’ll define the structure in <a href="ch16.xhtml#ch16fig7">Figure 16-7</a> in code.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_458"/><img src="../images/16fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch16fig7"><em>Figure 16-7: Structure for the unit tests</em></p>&#13;
<p class="indent">Create a new file in the <em>structures/tests</em> directory named <em>structure_test.py</em>. In the file, enter the code in <a href="ch16.xhtml#ch16lis14">Listing 16-14</a>.</p>&#13;
<pre>import unittest&#13;
from unittest.mock import patch&#13;
&#13;
from eqs import Matrix&#13;
from geom2d import Point, Vector&#13;
from eqs.vector import Vector as EqVector&#13;
from structures.model.node import StrNode&#13;
from structures.model.bar import StrBar&#13;
from structures.model.structure import Structure&#13;
&#13;
&#13;
class StructureTest(unittest.TestCase):&#13;
&#13;
    def setUp(self):&#13;
        section = 5&#13;
        young = 10&#13;
        load = Vector(500, -1000)&#13;
&#13;
        self.n_1 = StrNode(1, Point(0, 0))&#13;
        self.n_2 = StrNode(2, Point(0, 200))&#13;
        self.n_3 = StrNode(3, Point(400, 200), [load])&#13;
        self.b_12 = StrBar(1, self.n_1, self.n_2, section, young)&#13;
        self.b_23 = StrBar(2, self.n_2, self.n_3, section, young)&#13;
        self.b_13 = StrBar(3, self.n_1, self.n_3, section, young)&#13;
&#13;
     <span class="ent">➊</span> self.structure = Structure(&#13;
            [self.n_1, self.n_2, self.n_3],&#13;
            [self.b_12, self.b_23, self.b_13]&#13;
        )&#13;
&#13;
    def test_nodes_count(self):&#13;
     <span class="ent">➋</span> self.assertEqual(3,  self.structure.nodes_count)&#13;
&#13;
    def test_bars_count(self):&#13;
     <span epub:type="pagebreak" id="page_459"/><span class="ent">➌</span> self.assertEqual(3, self.structure.bars_count)&#13;
&#13;
    def test_loads_count(self):&#13;
     <span class="ent">➍</span> self.assertEqual(1, self.structure.loads_count)</pre>&#13;
<p class="caption"><a id="ch16lis14"/><em>Listing 16-14: Structure resolution test</em></p>&#13;
<p class="indent">This listing defines the <span class="literal">StructureTest</span> test class. In the <span class="literal">setUp</span> method, which is called before every test, we define the structure in <a href="ch16.xhtml#ch16fig7">Figure 16-7</a>. The structure has three nodes: <span class="literal">n_1</span>, <span class="literal">n_2</span>, and <span class="literal">n_3</span>. The last one, <span class="literal">n_3</span>, has a load applied to it. We’re not adding the external constraints to nodes 1 and 2 yet; we’ll see why this is in a minute. Then, we create the bars <span class="literal">b_12</span>, <span class="literal">b_23</span>, and <span class="literal">b_13</span> between the nodes we just defined; we use the values 5 and 10 for the cross section and Young’s modulus. With all these nodes and bars, the structure is finally instantiated <span class="ent">➊</span>.</p>&#13;
<p class="indent">Next come three simple tests. The first ensures that the structure counts how many nodes it has <span class="ent">➋</span>. The second does the same thing but with bars <span class="ent">➌</span>. The third also does the same, this time with the number of loads applied to the structure <span class="ent">➍</span>.</p>&#13;
<p class="indent">One of the most complex operations in solving the structure is assembling the stiffness matrix, so let’s add a test to check this matrix is properly assembled before we apply the external constraint conditions. Since we haven’t yet added external constraints to the structure, the matrix that is passed to the <span class="literal">cholesky_solve</span> function is the system’s matrix we’re looking for. If we mock the <span class="literal">cholesky_solve</span> function, the arguments passed to it are the system’s stiffness matrix and load vector, which we can capture to make assertions. By mocking this function, our code won’t execute the Cholesky’s method original code, which is fine because that logic shouldn’t interfere with our test. Enter the new test in <a href="ch16.xhtml#ch16lis15">Listing 16-15</a>.</p>&#13;
<pre>class StructureTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
 <span class="ent">➊</span> @patch('structures.model.structure.cholesky_solve')&#13;
    def test_assemble_system_matrix(self, cholesky_mock):&#13;
        eal3 = 0.1118033989&#13;
        c2_eal3 = .8 * eal3&#13;
        s2_eal3 = .2 * eal3&#13;
        cs_eal3 = .4 * eal3&#13;
     <span class="ent">➋</span> expected_mat = Matrix(6, 6).set_data([&#13;
            c2_eal3, cs_eal3, 0, 0, -c2_eal3, -cs_eal3,&#13;
            cs_eal3, .25 + s2_eal3, 0, -.25, -cs_eal3, -s2_eal3,&#13;
            0, 0, .125, 0, -.125, 0,&#13;
            0, -.25, 0, .25, 0, 0,&#13;
            -c2_eal3, -cs_eal3, -.125, 0, .125 + c2_eal3, cs_eal3,&#13;
            -cs_eal3, -s2_eal3, 0, 0, cs_eal3, s2_eal3&#13;
        ])&#13;
&#13;
        self.structure.solve_structure()&#13;
     <span epub:type="pagebreak" id="page_460"/><span class="ent">➌</span> [actual_mat, _] = cholesky_mock.call_args[0]&#13;
&#13;
     <span class="ent">➍</span> cholesky_mock.assert_called_once()&#13;
     <span class="ent">➎</span> self.assertEqual(expected_mat, actual_mat)</pre>&#13;
<p class="caption"><a id="ch16lis15"/><em>Listing 16-15: System’s stiffness matrix assembly test</em></p>&#13;
<p class="indent">We first want the <span class="literal">cholesky_solve</span> function mocked, so we’ve added an <span class="literal">@patch</span> decorator with the path to where this function is looked up: the <span class="literal">structures/model/structure</span> package’s <em>cholesky_solve</em> module <span class="ent">➊</span>. Notice how we pass <span class="literal">cholesky_mock</span> as an argument to the test method.</p>&#13;
<p class="indent">Next, we define the expected structure’s stiffness matrix: <span class="literal">expected_mat</span>. This is a 6 × 6 matrix (three nodes with two degrees of freedom each). I’ve done the math and assembled the matrix by hand; I suggest you do this as well to make sure you understand the process. There are some auxiliary variables defined for bar 1 → 3:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">eal3</span> is the <img class="inline" src="../images/f00397-p1.jpg" alt="Image"/>&#13;
 amount</li>&#13;
<li class="noindent"><span class="literal">c2_eal3</span> is <img class="inline" src="../images/f00460-p1.jpg" alt="Image"/></li>&#13;
<li class="noindent"><span class="literal">s2_eal3</span> is <img class="inline" src="../images/f00460-p2.jpg" alt="Image"/></li>&#13;
<li class="noindent"><span class="literal">cs_eal3</span> is <img class="inline" src="../images/f00460-p3.jpg" alt="Image"/></li>&#13;
</ul>&#13;
<p class="indent">The numbers in the stiffness matrices for bars 1 → 2 and 2 → 3 are straightforward because their angles are <img class="inline" src="../images/f00460-p4.jpg" alt="Image"/> and 0 radians, respectively. After assembling the global matrix using the three bars’ matrices, the result is <span class="ent">➋</span>.</p>&#13;
<p class="indent">To run the resolution code, we have to call the <span class="literal">solve_structure</span> method. After executing the solve method, we’re interested in knowing which arguments were passed to the <span class="literal">cholesky_mock</span> function. Mocks have an attribute, <span class="literal">call_args</span>, a list containing the arguments passed to each of the calls to the mock. Our mock function was called only once, so we want the arguments to this first call.</p>&#13;
<p class="indent">We destructured <span class="literal">cholesky_mock</span>’s <span class="literal">call_args</span> for the first call (<span class="literal">call_args[0]</span>) and only kept the first one in a variable named <span class="literal">actual_mat</span> <span class="ent">➌</span>. As you can see, the second element in the left-side list (<span class="literal">[actual_mat, _]</span>) is an underscore, meaning there is a value for that position in the right-side list (<span class="literal">cholesky_mock.call_args[0]</span>), but we’re not interested in saving it.</p>&#13;
<p class="indent">Then come two assertions. The first one checks that <span class="literal">cholesky_mock</span> was called only once <span class="ent">➍</span>, and the second compares the expected stiffness matrix with the actual stiffness matrix passed to the <span class="literal">cholesky_mock</span> resolution function <span class="ent">➎</span>.</p>&#13;
<p class="indent">In this test, we’re ensuring that the Cholesky resolution function gets passed the right structure’s stiffness matrix assembled without external constraint conditions applied. Let’s now write a new test with these constraints to check that the stiffness matrix is correctly modified to include them. Enter the test in <a href="ch16.xhtml#ch16lis16">Listing 16-16</a>.<span epub:type="pagebreak" id="page_461"/></p>&#13;
<pre>class StructureTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
 <span class="ent">➊</span> @patch('structures.model.structure.cholesky_solve')&#13;
    def test_system_matrix_constraints(self, cholesky_mock):&#13;
     <span class="ent">➋</span> self._set_external_constraints()&#13;
&#13;
        eal3 = 0.1118033989&#13;
        c2_eal3 = .8 * eal3&#13;
        s2_eal3 = .2 * eal3&#13;
        cs_eal3 = .4 * eal3&#13;
     <span class="ent">➌</span> expected_mat = Matrix(6, 6).set_data([&#13;
            1, 0, 0, 0, 0, 0,&#13;
            0, 1, 0, 0, 0, 0,&#13;
            0, 0, 1, 0, 0, 0,&#13;
            0, 0, 0, 1, 0, 0,&#13;
            0, 0, 0, 0, .125 + c2_eal3, cs_eal3,&#13;
            0, 0, 0, 0, cs_eal3, s2_eal3&#13;
        ])&#13;
&#13;
        self.structure.solve_structure()&#13;
        [actual_mat, _] = cholesky_mock.call_args[0]&#13;
&#13;
        cholesky_mock.assert_called_once()&#13;
     <span class="ent">➍</span> self.assertEqual(expected_mat, actual_mat)</pre>&#13;
<p class="caption"><a id="ch16lis16"/><em>Listing 16-16: System’s stiffness matrix constraints test</em></p>&#13;
<p class="indent">This test is similar to the previous one. The <span class="literal">cholesky_solve</span> function is patched the same way <span class="ent">➊</span>, and the new mock argument, <span class="literal">cholesky_mock</span>, is passed to the test method. Then, we call a private method to add the external constraints to nodes 1 and 2, like they appear in <a href="ch16.xhtml#ch16fig7">Figure 16-7</a> <span class="ent">➋</span>. We’ll have to write this method after the test.</p>&#13;
<p class="indent">Then comes the definition of the expected matrix, this time with the external constraints applied <span class="ent">➌</span>. The only terms that are not zero, apart from the ones in the main diagonal, are those that belong to node 3: degrees of freedom 4 and 5. For this reason, only the terms in those row and column indices are nonzero.</p>&#13;
<p class="indent">The rest of the test is exactly the same as before: we call the <span class="literal">solve_structure</span> method on the <span class="literal">structure</span> instance. Then we save the matrix argument extracted from the call to <span class="literal">cholesky_mock</span> into a variable named <span class="literal">actual_mat</span>. Note that we’re using a list unpacking for this, where the second item, which is the system’s load vector, is ignored by using an underscore. There’s the assertion that checks if the Cholesky mock function has been called only once, and the check comparing the actual and expected system matrices <span class="ent">➍</span>.</p>&#13;
<p class="indent">Lastly, we need to write the <span class="literal">_set_external_constraints</span> function that applies the external constraints to nodes 1 and 2. After the method we’ve just written, enter the code in <a href="ch16.xhtml#ch16lis17">Listing 16-17</a>.</p>&#13;
<pre>class StructureTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    <span epub:type="pagebreak" id="page_462"/>def _set_external_constraints(self):&#13;
        self.n_1.dx_constrained = True&#13;
        self.n_1.dy_constrained = True&#13;
        self.n_2.dx_constrained = True&#13;
        self.n_2.dy_constrained = True</pre>&#13;
<p class="caption"><a id="ch16lis17"/><em>Listing 16-17: Setting external constraints to nodes</em></p>&#13;
<p class="indent">Let’s try one last test to check the load vector assembly process. The idea is to follow the structure of the last two tests, but this time checking the load vector. Enter the test in <a href="ch16.xhtml#ch16lis18">Listing 16-18</a>.</p>&#13;
<pre>class StructureTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
 <span class="ent">➊</span> @patch('structures.model.structure.cholesky_solve')&#13;
    def test_assemble_system_vector(self, cholesky_mock):&#13;
     <span class="ent">➋</span> expected_vec = EqVector(6).set_data([&#13;
            0, 0, 0, 0, 500, -1000&#13;
        ])&#13;
&#13;
        self.structure.solve_structure()&#13;
     <span class="ent">➌</span> [_, actual_vec] = cholesky_mock.call_args[0]&#13;
&#13;
     <span class="ent">➍</span> self.assertEqual(expected_vec, actual_vec)</pre>&#13;
<p class="caption"><a id="ch16lis18"/><em>Listing 16-18: System’s load vector assembly test</em></p>&#13;
<p class="indent">We patch the <span class="literal">cholesky_solve</span> function the same way as before <span class="ent">➊</span>. Then we declare the expected load vector <span class="ent">➋</span>, which this time is easy, as there’s only one load applied to node 3.</p>&#13;
<p class="indent">The rest of the test is similar. The major difference is that this time we’re destructuring the second argument of the first call to the <span class="literal">cholesky_mock</span> <span class="ent">➌</span>, which is the passed-in vector, the load vector that our code produced. This time we’re not asserting that the mock was called once, as we’ve done in the last two tests; we could, but that condition is already tested. There’s no need to repeat the same assertion. What we do want to check is that the <span class="literal">actual_vec</span> equals the <span class="literal">expected_vec</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">We may now run our tests. To do so from the shell, run the following command:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/structure_test.py</span></pre>&#13;
<p class="indent">This should produce the following output, if all of your tests passed:</p>&#13;
<pre>Ran 6 tests in 0.004s&#13;
&#13;
OK</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_463"/>We could write a few more unit tests, but we won’t be doing so for brevity reasons. Nevertheless, I suggest you come up with more tests and exercise your test doubles skills.</p>&#13;
<h3 class="h3" id="ch00lev1sec100"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we developed the structure’s resolution algorithm, a complex piece of logic that we split among a few private methods. This resolution process does all the heavy lifting in assembling the structure’s global stiffness matrix and vector, applying the external constraints, and solving the resulting system of equations using the Cholesky’s procedure we implemented earlier. Once the node global displacements are obtained, they are used to construct the structure solution model. We’ll see in <a href="ch18.xhtml#ch18">Chapter 18</a> how to produce a graphic result for this solution model.</p>&#13;
<p class="indent">We also introduced the concept of test doubles, a key technique to write good unit tests by isolating a small part of the code from its collaborators. There are a few different test doubles; Python’s <em>unittest</em> implementation basically provides us with one: the mock. Nevertheless, this mock implementation is so flexible that it can also be used as a stub or spy. We learned how to use this class and the <span class="literal">@patch</span> decorator by using them to test our latest code.</p>&#13;
<p class="indent">It’s now time to focus on reading and parsing structures from text files so we can feed our resolution algorithm with some fine structure definitions. Let’s go for it!<span epub:type="pagebreak" id="page_464"/></p>&#13;
</body></html>