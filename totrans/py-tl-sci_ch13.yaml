- en: '**13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OBJECT-ORIENTED PROGRAMMING**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far in this primer, you’ve been writing code using procedural programming
    techniques built around performing actions and evaluating logic. You’ve learned
    how to organize code using functions and modules, and you’ve used built-in data
    types to organize data. In this chapter, you’ll learn how to use object-oriented
    programming to define your own types to organize both code and data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented programming (OOP)* is a language model that lets you bundle
    together related data with functionality that acts on that data. The data consists
    of *attributes* (akin to variables) that are manipulated by *methods* (akin to
    functions). These “bundles” form custom data types called *classes*. Classes help
    you split your program into different sections that deal with different pieces
    of information rather than letting it all blend into an unstructured mess.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes let you create individual *objects* with specific properties and behaviors.
    Using a class template, you can efficiently “stamp out” multiple objects, just
    as a set of blueprints lets you build multiple versions of the same car. Each
    car will start off with the same attributes, such as color and mileage, and have
    the same methods, such as for accelerating and braking, but after they leave the
    factory, these can change. Some cars may be repainted, others can lose wheel alignment
    and pull to the left, their mileage will vary, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to define classes that create objects, write
    attributes and methods for the objects, and then instantiate those objects. You’ll
    also write classes that inherit attributes and methods from other classes and
    use dataclasses to reduce code redundancy. This introduction to the topic should
    give you an understanding of the basics of OOP and an appreciation for how you
    can benefit from it as a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use OOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OOP is easier to appreciate when you’re writing large, complex programs because
    it helps you to structure your code into smaller parts that are easier to understand.
    It also reduces code duplication and makes code easier to maintain, update, and
    reuse. As a result, most commercial software is now built using OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Because Python is an object-oriented programming language, you’ve already been
    using objects and methods defined by other people. But unlike languages such as
    Java, Python doesn’t force you to use OOP for your own programs. It provides ways
    to encapsulate and separate abstraction layers using other approaches such as
    procedural or functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Having this choice is important. If you implement OOP in small programs, most
    of them will feel overengineered. To quote computer scientist Joe Armstrong, “The
    problem with object-oriented languages is they’ve got all this implicit environment
    that they carry around with them. You wanted a banana, but what you got was a
    gorilla holding the banana and the entire jungle!”
  prefs: []
  type: TYPE_NORMAL
- en: As a scientist or engineer, you can get a lot done without OOP, but that doesn’t
    mean you should ignore it. OOP makes it easy to simulate many objects at a time,
    such as a flock of birds or a cluster of galaxies. It’s also important when things
    that are manipulated, like a GUI button or window, must persist for a long time
    in the computer’s memory. And because most of the scientific packages you’ll encounter
    are built using OOP, you’ll want more than a passing familiarity with the paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a New Spyder Project**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s make a new Spyder project to use in this chapter. If you need a refresher
    on Spyder projects, see “Using Project Files and Folders” on [page 68](ch04.xhtml#ch00lev1sec25).
  prefs: []
  type: TYPE_NORMAL
- en: Start by launching Spyder from your *base* (root) environment (either from the
    Start menu or from Anaconda Navigator). In the Start window, this may show as
    Spyder (anaconda3). For a refresher on conda environments see [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Next, on the top toolbar, click **Projects** ▸ **New Project**. In the Create
    New Project dialog that opens ([Figure 13-1](ch13.xhtml#ch013fig1)), make sure
    the Location box includes your home directory, set the Project name to **oop**,
    and then click the **Create** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The Spyder Create New Project dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: You should now see this new folder in Spyder’s File Explorer pane.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, we’ll use the default conda environments folder that’s located
    within the *anaconda3* folder to hold third-party libraries. If you want to use
    an environments folder tied to this project, see the instructions in “Specifying
    an Environment’s Location” on [page 37](ch02.xhtml#ch00lev2sec20).
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Frigate Class**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s a lot easier to demonstrate OOP than it is to talk about it, so let’s build
    some ship objects that might be used in a (very) simple war game simulator. Each
    unique type of ship will need its own class that can generate multiple versions
    of that ship type. We then can track and manipulate each of these objects independently.
    With OOP, the relationships among the ship class, the ship objects, and the methods
    that act on those objects will be clear, logical, and compact.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by defining a class to build the most common type of warship, known
    as a “frigate” ([Figure 13-2](ch13.xhtml#ch013fig2)). Designed to be fast, maneuverable,
    and versatile, frigates escort and protect larger vessels from air, surface, and
    underwater threats.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: Brazilian Tamandaré-class frigate*'
  prefs: []
  type: TYPE_NORMAL
- en: To build the frigates, you’ll need a virtual shipyard, so, in your *oop* project,
    open up Spyder’s text editor and create a new file named *ships.py*. Save it wherever
    you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: 'To serve as a blueprint for the frigates, define a `Frigate` class using a
    `class` statement. After the `class` keyword, enter a name for the class followed
    by parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: According to the PEP 8 Style Guide, class names should be capitalized. If you
    need to use multiple words, use the *CapWords* convention, where each new word
    is capitalized without spaces between them (also called *CamelCase*).
  prefs: []
  type: TYPE_NORMAL
- en: The `Frigate` class uses a single parameter, `object`. This `object` parameter
    represents the base class of all types in Python. Because `object` is the default
    parameter, you can omit stating it explicitly when defining a class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign the string `USS`, for “United States Ship,” to an attribute named
    `designation` ➊. This is the ship’s name prefix. You can also use HMS (“Her Majesty’s
    Ship”), INS (“Indian Naval Ship”), or whatever you’d prefer. In Python, an attribute
    is any variable associated with an object. Like in a function, a class makes a
    fresh local namespace for the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are objects, too, so they can have their own attributes. *Class attributes*
    are common to all objects made from the class and behave sort of like global variables.
    In this case, all the frigates you build will have the “USS” designation, such
    as the “USS Saratoga.” Class attributes are efficient, as they let you store a
    shared attribute in a single location.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you define an *initialization* method ➋ that sets up the initial attribute
    values for an object. Methods are just functions that are defined within classes.
    The `__init__()` method is a special built-in method that Python automatically
    invokes as soon as a new object is created. In this case, it takes two parameters,
    `self` and the `name` of the object, which will be whatever you want to call the
    ship.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The __init__() method is a dunder (double underscore) method, meaning its
    name is preceded and followed by double underscores. Also called magic or special
    methods, they let you create classes that behave like native Python data structures
    such as lists, tuples, and sets. They’re also the magic behind operator overloading
    and behavior customization of other functions. When you call the built-in len()
    function, for example, a __len__ method is called behind the scenes.*'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of every class method, including `__init__()`, is always
    a reference to the current instance of the class, called `self` by convention.
    (A new object is known as an *instance* of a class, and the process of setting
    the initial values and behaviors of the instance is called *instantiation*.)
  prefs: []
  type: TYPE_NORMAL
- en: You can think of `self` as a placeholder for the actual name you’ll give an
    object. If you create a ship object and name it “Intrepid,” `self` will become
    `Intrepid`. The `self.speed` attribute will become a reference to “Intrepid’s
    speed.” If you instantiate another ship object named “Indefatigable,” `self` for
    that object will become `Indefatigable`. This way, the scope of the `Intrepid`
    object’s `speed` attribute is kept separate from that of the `Indefatigable` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to list some attributes for a frigate. You’ll want to give each
    ship a name so that you can distinguish one ship from another. You’ll also want
    to specify the value of key operational and combat characteristics, like fuel,
    heading, and speed. Because these are associated with an instance of the class,
    they’re called *instance attributes*, and are assigned inside the `__init__()`
    method (with code such as `self.name = name`).
  prefs: []
  type: TYPE_NORMAL
- en: Some of these attributes, like the number of guns and the length of the ship,
    represent values common to each ship that shouldn’t change over time. It’s best
    not to make these *class* attributes, however, because they *could* change. For
    example, an individual ship could be outfitted with an extra experimental gun,
    or its helicopter pad could be extended off the stern. Other attributes such as
    the heading and speed represent placeholders that are *expected* to change. In
    general, you should set attributes to good default values, such as filling the
    fuel tank to capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*While it’s possible to use methods to assign new attributes later, it’s best
    to initialize them all within the __init__ method. This way, all the available
    attributes are conveniently listed in an easy-to-find location.*'
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to look through the list of attributes in the initialization method.
    For brevity, I’ve left off some that you might need in a true simulation, like
    the ship’s current location, it’s current “health,” and a maximum limit for reverse
    speed. You might even want “cost” attributes for building and operating ships,
    forcing you to stay in budget.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that you can use expressions when assigning attributes, just as you
    can with variables. For example, we’ve assumed the ship carries 300 rounds of
    ammunition for each of its big guns ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s define some methods for piloting the ship and firing its guns.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Instance Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *instance method* accesses or modifies the state of an object. They must
    have a `self` parameter to refer to the current object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a `helm()` method to set the ship’s heading and speed, and clip
    the speed to a maximum value. In the text editor, enter the following (the `def`
    statements should be indented four spaces relative to the class definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `self` parameter, you’ll also pass the method a heading (between
    0 and 359 degrees) and a speed (in knots).
  prefs: []
  type: TYPE_NORMAL
- en: The code within the method definition updates the object’s existing attributes
    using the values passed to it as arguments. To access and change an attribute,
    use dot notation. You’ve used this syntax before to call methods in modules such
    as `os` and `random`. To override the heading and speed attributes initially assigned
    in the `__init__()` method, simply set them as equal to the values passed to the
    method ➊.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ll want to validate the user inputs. To make sure the speed
    value doesn’t exceed the ship’s maximum speed. Compare the `self.speed` attribute
    to the `self.max_speed` attribute. If it’s greater, set it equal to `self.max_speed`
    ➋. Complete the method by printing the heading and speed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define a method called `fire_guns()` that fires all the big guns
    at once. You won’t need to pass this method any arguments other than `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, check that you’re not out of ammunition ➌. If you’re not, print “BOOM!”
    Then, decrement the `self.ammo` attribute by the number of guns (`self.guns`)
    ➍ and display the number of rounds left. Otherwise, print a message that you’re
    out of ammunition.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note here is that the methods we’ve defined are not returning anything.
    Instead, they’re changing attribute values in place. This behavior is very similar
    to the ill-advised technique of altering global variables within functions (see
    [Chapter 12](ch12.xhtml)). What makes these methods acceptable, however, is that
    the attributes exist under the class umbrella rather than in the global namespace.
    Because changes are confined to the local namespace of the class, it’s easier
    to track and debug issues than if you used global variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***Instantiating Objects and Calling Instance Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve defined a `Frigate` class and some methods for working with a `Frigate`
    object. Now, let’s instantiate a ship and start using it. Add the following code,
    unindented, to *ships.py* and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code first instantiates a new `Frigate` object named “Garcia” and assigns
    it to the `garcia` variable. It then prints the name of the ship, calling the
    built-in `upper()` method to print in uppercase characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this code prints the “USS” designation by accessing the designation
    class attribute using the class name (`Frigate.designation`). You might have noticed
    that it would be easier to type “USS” here rather than access the `designation`
    attribute. We’re using this attribute to demonstrate how class attributes work,
    but also to highlight a common problem with class attributes: in many cases, you
    can find an equally good alternative to avoid using them.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code prints the crew complement, using dot notation to access the
    `crew` attribute. Finally, it fires the guns twice and then changes the ship’s
    direction and speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the file, you should get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our `Frigate` class template, we can create as many ships as we want.
    Let’s make another one named “Boone.” In the text editor, enter the following
    and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run it to see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You now have two ships that use similar code but have different speeds and headings.
    With the `Frigate` class and OOP, you can easily create and track hundreds of
    ships with dozens of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  OOP makes code easier to read, maintain, and update by:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Removing the need for functions
  prefs: []
  type: TYPE_NORMAL
- en: b.  Reducing code duplication
  prefs: []
  type: TYPE_NORMAL
- en: c.  Using methods instead of functions
  prefs: []
  type: TYPE_NORMAL
- en: d.  Providing bananas to gorillas
  prefs: []
  type: TYPE_NORMAL
- en: '2.  What is the name of an object created from a class:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Child
  prefs: []
  type: TYPE_NORMAL
- en: b.  Attribute
  prefs: []
  type: TYPE_NORMAL
- en: c.  Instance
  prefs: []
  type: TYPE_NORMAL
- en: d.  Method
  prefs: []
  type: TYPE_NORMAL
- en: '3.  True or False: A method is a function defined in a class and called with
    dot notation.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.  In OOP, you can think of the `self` parameter as:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  a placeholder for the name of the class being invoked
  prefs: []
  type: TYPE_NORMAL
- en: b.  a placeholder for the name of the method being called
  prefs: []
  type: TYPE_NORMAL
- en: c.  a placeholder for the name of the object being created
  prefs: []
  type: TYPE_NORMAL
- en: d.  All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Write a `Parrot` class with name, color, and age attributes and methods
    for squawking and “parroting” (repeating) input.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining a Guided-Missile Frigate Class Using Inheritance**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today, guns on warships have largely been replaced by missile systems ([Figure
    13-3](ch13.xhtml#ch013fig3)). We can easily build new guided-missile frigates
    by simply refitting the existing `Frigate` class using the technique of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: The frigate HMS Iron Duke, firing her Harpoon anti-ship missile
    system*'
  prefs: []
  type: TYPE_NORMAL
- en: A key concept in OOP, *inheritance* lets you define a new child class based
    on an existing parent or ancestor class. (Technically, the original class is called
    a *base class* or *superclass*. The new class is called a *derived class* or *subclass*.)
    The new subclass inherits all of the attributes and methods of the existing superclass.
    This makes it easy to copy and extend an existing base class by adding new attributes
    and methods specific to the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a new guided-missile class called `GMFrigate` that inherits from
    and modifies our current `Frigate` class. Enter the following at the bottom of
    your *ships.py* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To create a child class, pass the `class` statement the name of the parent,
    or superclass, which in this case is `Frigate`. Remember that, when you first
    defined `Frigate`, you passed it `object`. This means `Frigate` inherited from
    the `object` class, which is the root of all Python objects. The `object` class
    provides the default implementation of common methods that all derived classes
    might need. By now passing `Frigate` instead of `object`, you get the attributes
    and methods under `object` as well as the new ones you added to the `Frigate`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Guided-missile frigates will have the same “USS” designation as frigates, so
    assign a `designation` class attribute to the same `Frigate` class attribute,
    referenced using dot notation ➊. You could skip doing this and just use the `Frigate.designation`
    attribute when you need it, but by explicitly reassigning the class attribute,
    you add clarity to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the `__init__()` initialization method for the `GMFrigate` class,
    which, like the `Frigate` class, has a `self` and `name` parameter. Immediately
    beneath it, we call the initialization method from the `Frigate` class ➋ and pass
    it `Frigate` instead of `self`, along with a `name` parameter. Passing in the
    `Frigate` class gives you access to all the attributes in the `Frigate.__init__()`method,
    so you don’t need to duplicate any code, such as for crew, tonnage, guns, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t define an `__init__()` method for a child class, it will use the
    `__init__()` method from the parent class. If you want to override some of the
    attribute values in the parent class, or add new attributes, you’ll need to include
    an `__init__()` method for the child class, as we did in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Our original frigate class did not allow for missiles, so add a new `self.missile`
    attribute ➌. Set the complement of missiles to `100`. Because these missiles take
    up space, you have less room for other ammunition, so *override* the `self.ammo`
    attribute by setting it to 100x the number of guns rather than 300x, as we used
    before. Note that this won’t affect the ammunition count for ships instantiated
    directly from the original `Frigate` class; they will use the superclass’s ammunition
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: Your ship will need a way to fire the missiles, so define a new method called
    `fire_missile()`, which will behave much like the `fire_guns()` that you defined
    earlier, but fires only one missile at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '***Instantiating a New Guided-Missile Frigate Object***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can now instantiate a new guided-missile frigate. Let’s name it “Ticonderoga”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By having your new class inherit attributes and methods from the `Frigate` class,
    you were able to follow the *DRY* (“don’t repeat yourself”) principle of software
    development, aimed at reducing the repetition of software patterns. You’ll need
    to be careful not to make any changes to the `Frigate` class, however, unless
    you want those changes to be reflected in the `GMFrigate` class, as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python permits the use of multiple inheritance, by which a child class inherits
    from more than one parent class. This is accomplished by passing the names of
    the parent classes, separated by commas, to the class definition. Using multiple
    parents is straightforward if none of the method names in the parent classes overlap.
    When they do, Python uses a process called Method Resolution Order (MRO) to sort
    them out. This can be tricky, so in most cases, you’ll want to stick to single
    inheritance, no inheritance, or cases where all parent classes contain distinct
    attribute and method names.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the super() Function for Inheritance***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `super()` built-in function removes the need for an explicit call to a
    base class name when invoking base class methods. It works with both single and
    multiple inheritance. For example, in the `GMFrigate` class definition, you called
    the `Frigate` class’s `__init__()` method within the `GMFrigate` class’s `__init__()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets the `GMFrigate` class inherit from `Frigate`. Alternatively, you
    could have used the `super()` function, which returns a proxy object that allows
    access to methods of the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `super()` removes the need for an explicit call to the `Frigate`
    class. When using single inheritance, `super()` is just a fancier way to refer
    to the base type. It makes the code a bit more maintainable. For example, if you
    are using `super()` everywhere and want to change the name of the base class (such
    as from `Frigate` to `Type26Frigate`) you need to change the name only once, when
    defining the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use for `super()` is for accessing inherited methods that have been
    overridden in a new class. Let’s look at an example in which we define a `Destroyer`
    class that includes the guns found on a smaller corvette (another class of warship),
    plus some larger guns. Start a new *super_destroyer.py* file in the text editor
    and then enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a `Corvette` class with a method for firing its guns. Because
    these guns are relatively small, they make a lowercase “boom.” Next, we define
    a `Destroyer` class that inherits from `Corvette` class ➊. It has its own `fire_guns()`
    method that prints “BOOM!” for its large guns.
  prefs: []
  type: TYPE_NORMAL
- en: To fire the small guns available on the destroyer, use the `super()` function
    ➋. Because “super” refers to the *base* class, it calls the `Corvette` class’s
    `fire_guns()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s instantiate a corvette and destroyer object and fire their guns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output. Notice that both versions of “boom” are printed by the destroyer
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The use of super() is somewhat controversial. On one hand, it makes code more
    maintainable. On the other, it makes it less explicit, which violates the Zen
    of Python edict “Explicit is better than implicit.”*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects Within Objects: Defining the Fleet Class**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Returning to our wargame simulation, let’s create a `Fleet` class for manipulating
    all the ship objects we’ve been instantiating. That’s right: using OOP, objects
    can control other objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, add the following code to the bottom of your *ships.py* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The initialization method for this class looks a lot like the one for the `Frigate`
    class, except now it has a parameter for a list of ships. This will be a list
    data type whose items are previously instantiated ship objects, like `garcia`
    and `boone`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now define some methods for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A fleet can travel no faster than its slowest ship, so define a method for setting
    the fleet’s maximum speed, just as we did earlier for individual ships. The first
    step is to use list comprehension to loop through the ships in the `self.ships`
    list and append their maximum speeds, as found in the `ship.max_speed` attribute,
    to a new list named `max_speeds` ➊.
  prefs: []
  type: TYPE_NORMAL
- en: When the list is complete, you print it and then set the `self.fleet_max_speed`
    attribute to the maximum speed of the slowest ship, found by calling the built-in
    `min()` function on the list ➋. End the method by printing the fleet’s maximum
    speed attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a method for setting the heading and speed of the fleet. Again,
    this is similar to the technique we used for setting these values on an individual
    ship. As before, we clip the speed to the maximum speed limit, in the event that
    the user inputs an invalid speed ➌. We then print the information and loop through
    each ship in the `self.ships` list, setting its heading and speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test the `Fleet` class by instantiating a “Seventh” fleet comprising
    the Garcia, Boone, and Ticonderoga ship objects created earlier. Enter the following
    and then save and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As all the ships are frigates, there’s no difference in their maximum speeds,
    but if you had destroyers, aircraft carriers, and so on, you would see a mix of
    values in the `max_speeds` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Fleet` class and its `fleet_helm()` method, you can simultaneously
    assign your ships the same heading and speed. You can also override these settings
    if you want by calling the `self.helm()` method of individual ships, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the Garcia’s heading is different than those of the rest of the fleet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Reducing Code Redundancy with Dataclasses**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The built-in `dataclass` module introduced in Python 3.7 provides a convenient
    way to make classes less verbose. Although primarily designed for classes that
    store data, data classes work just like regular classes and can include methods
    that interact with the data. Some use cases include classes for bank accounts,
    the content of scientific articles, and employee information.
  prefs: []
  type: TYPE_NORMAL
- en: A dataclass comes with basic “boilerplate” functionality already implemented.
    You can instantiate, print, and compare dataclass instances straight out of the
    box, and many of the common things you do in a class, like instantiating properties
    based on the arguments passed to the class, can be reduced to a few basic instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code linters will typically complain if you use more than seven or so instance
    attributes in a class. This seems to contradict the purpose of a dataclass, which
    is to store data. In addition, this limit can be difficult to honor in the scientific
    domain, where many attributes are often needed. Although the linter recommendations
    can be ignored, you should still strive to limit the number of instance attributes
    per class to reduce complexity. You might be able to treat some as class attributes,
    move others into parent classes, merge some into a single attribute, and so on.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Decorators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dataclasses are implemented using a helpful and powerful Python tool called
    a *decorator*. A decorator is a function designed to wrap around (encapsulate)
    another function or class to alter or enhance the wrapped object’s behavior. It
    lets you modify the behavior without permanently changing the object. Decorators
    also let you avoid duplicating code when you’re running the same process on multiple
    functions, such as checking memory use, adding logging, or testing performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorator Basics**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To see how decorators work, let’s define a function that squares a number.
    Then, we’ll define a decorator function that squares that result. Enter the following
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `square_it()`, takes a number, represented by `x`, and returns
    its square. The second function, `square_it_again()`, will serve as a decorator
    to the first function and is a little more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator function has a `func` parameter, representing a function. Because
    functions are objects, you can pass a function to another function as an argument
    and even define a function within a function. When we call this decorator function,
    we’ll pass it the `square_it()` function as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define an inner function, which we’ll call `wrapper()`. Because `square_it()`
    takes an argument, we need to set up the inner function to handle arguments by
    using the special positional and keyword arguments `*args` and `**kwargs`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `wrapper()` function, we call the function we passed to the decorator
    (`func`), square its output, assign the resulting number to the `result` variable,
    and return `result`. Finally, we return the `wrapper()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `square_it_again()` decorator, call it, pass it the function that
    you want to decorate (`square_it()`), and assign the result to a variable (`square`),
    which also represents a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now call the new function and pass it an appropriate argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we manually called the decorator function. This demonstrated
    how decorators work, but it’s a bit verbose and contorted. In the next section,
    we’ll look at a more convenient method for using a decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorator Syntactic Sugar**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In computer science, *syntactic sugar* is clear, concise syntax that simplifies
    the language and makes it “sweeter” for human use. The syntactic sugar for a decorator
    is the `@` symbol, which must be immediately followed by the name of the decorator
    function. The next line must be the definition statement for the function or class
    being wrapped, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `decorator_func_name` represents the decorator function, and `new_func()`
    is the function being wrapped. A class definition can be substituted for the `def`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: To see how it works, let’s re-create our number-squaring example. Use the arrow
    key to bring up the previously defined `square_it_again()` function in the console.
    Because we must invoke the decorator *before* defining the function to be wrapped,
    we must rewrite the code in the reverse order compared to the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the decorator and define the `square_it()` function in the next line.
    Note that, when using the `@` symbol, you use the decorator function name with
    no parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the decorated function, simply call it and pass it a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that with the `@` decorator we didn’t need to use the `square` function,
    as in line `In [3]`.
  prefs: []
  type: TYPE_NORMAL
- en: If decorators make your head spin a little, don’t worry. If you can type `@dataclass`,
    you can use dataclasses. This decorator modifies regular Python classes so that
    you can define them using shorter and sweeter syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Ship Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To see the benefits of dataclasses, let’s define a regular class and then repeat
    the exercise using a dataclass. Our goal will be to make generic ship objects
    that we can track on a simulation grid. For each ship, we’ll need to supply a
    name, a classification (like “frigate”), a country of registry, and a location.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Ship as a Regular Class**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To define a regular class called `Ship`, in the text editor, enter the following
    and then save it as *ship_tracker.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code looks a lot like the `Frigate` class we defined earlier. This time,
    however, the `__init__()` method includes more parameters ➊. All this data will
    need to be passed as arguments when instantiating an object based on this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how we’re forced to duplicate code by repeating each parameter name, like
    `classification`, three times: once as a parameter and twice when assigning the
    instance attribute. The more data you need to pass to the method, the greater
    this redundancy.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the parameters passed to the initialization method, the `Ship`
    class includes two “fixed” attributes representing the object type ➋ and color.
    These are assigned using an equal sign, as with a regular class. Because these
    attributes are always the same for a given object, there’s no need to pass them
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s instantiate a new ship object. Enter the following, save the file,
    and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This created a US frigate named `garcia` at grid location (20, 15). But when
    you print the object, the output isn’t very helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The issue here is that printing information on an object requires you to define
    additional dunder methods, like `__str__` and `__repr__`, that return string representations
    of objects for informational and debugging purposes. Another useful method is
    `__eq__`, which lets you compare instances of a class. The list of special methods
    in Python is long, but a few basic examples are listed in [Table 13-1](ch13.xhtml#ch013tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1:** Basic Special Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Special Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `__init__(self)` | Called when initializing an object from a class. |'
  prefs: []
  type: TYPE_TB
- en: '| `__del__(self)` | Called to destroy an object. |'
  prefs: []
  type: TYPE_TB
- en: '| `__repr__(self)` | Returns a printable string for the object to use in debugging.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `__str__(self)` | Returns a string for pretty-printing useful information
    about an object. If not implemented, `__repr__` is used instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `__eq__(self, other)` | Performs an equal to (`==`) comparison of two objects.
    |'
  prefs: []
  type: TYPE_TB
- en: Defining these methods for each class you write can become a burden, which is
    where dataclasses come in. Dataclasses automatically handle the redundancy issues
    around attributes and dunder methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Ship as a Dataclass**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now, let’s define the `Ship` class again as a dataclass. Do this in a new file
    named *ship_tracker_dc.py* (for “ship tracker dataclass”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Start by importing the `math` and `dataclass` modules. We’ll use the `dist`
    method from `math` to calculate the distance between ships, and `dataclass` to
    decorate our `Ship` class. To use `dist`, you’ll need Python 3.8 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Next, prefix `dataclass` with the `@` symbol to make it a decorator. Define
    the `Ship` class on the following line to let the decorator know it’s wrapping
    this class ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the next step would be to define the `__init__()` method with `self`
    and other parameters, but dataclasses don’t need this. The initialization is handled
    behind the scenes, removing the need for this code. You’ll still need to list
    the attributes, however, but with a lot less redundancy than before.
  prefs: []
  type: TYPE_NORMAL
- en: For each attribute that must be passed as an argument, enter the attribute name,
    followed by a colon, followed by a *type hint* ➋. A type hint, or type *annotation*,
    tells people reading your code what types of data to expect. Static analysis tools
    can use type hints to check your code for errors. Type hints were introduced in
    PEP 484 (*[https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)*).
  prefs: []
  type: TYPE_NORMAL
- en: A class variable with a type hint is called a *field*. The `@dataclass` decorator
    examines classes to find fields. Without a type hint, the attribute won’t become
    a field in the dataclass. In this example, all the fields in the `Ship` class
    use the string data type (`str`), except for `location`, which uses a `tuple`
    (for a pair of x, y coordinates). For a reminder of some common data types see
    [Table 7-5](ch07.xhtml#ch07tab5) on [page 184](ch07.xhtml#ch07tab5).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can use default values with the type annotations. For example, location:
    tuple = (0, 0) will place new Ship objects at coordinates x = 0, y = 0 if none
    are specified when the object is created. When you use a default parameter, however,
    all subsequent parameters must have default values.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because we don’t need to pass the `obj_type` and `obj_color` attributes as arguments
    when creating a new object, we define them using an equal sign rather than a colon,
    and with no type hints ➌. By assigning them as we would in a regular class, every
    `Ship` object will, by default, be designated a “ship” and have a consistent color
    attribute for plotting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dataclasses can have methods, just like regular classes. Let’s define a method
    that calculates the Euclidian distance between two ships. The `def` statement
    should be indented four spaces relative to the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `distance_to()` method takes the current ship object and another ship object
    as arguments. It then uses the built-in `dist` method to get the distance between
    them. This method returns the Euclidean distance between two points (x and y),
    where x and y are the coordinates of that point. The distance is returned as a
    string, so we can include a reference to kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the global scope with no indentation, create three ship objects, passing
    them the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you began entering the `Ship()` class arguments, a window should
    have appeared in the Spyder text editor, prompting you on the proper inputs ([Figure
    13-4](ch13.xhtml#ch013fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: The Spyder text editor pop-up, showing the names and data types
    for the parameters in the Ship class.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because classes you create are legitimate datatypes in Python, they behave like
    built-in datatypes. As a result, the Spyder editor will use the type hints to
    guide you when creating the ship objects. In the next chapter, we’ll look at how
    to properly document classes so that the “No documentation available” message
    in [Figure 13-4](ch13.xhtml#ch013fig4) is replaced with a one-line summary of
    the class, such as “Object for tracking a ship on a grid.”
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also worth noting that you don’t need to use the correct data type for
    a parameter. Because Python is a *dynamically* typed language (see [page 184](ch07.xhtml#ch00lev1sec52)
    in [Chapter 7](ch07.xhtml)), you can assign an integer as the `classification`
    argument, and the program will still run. Here’s an example with the incorrect
    parameter highlighted in gray (don’t add this to your code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Even though the Python interpreter ignores type hints, you can use third-party
    static type-checking tools, like Mypy ([https://mypy.readthedocs.io/](https://mypy.readthedocs.io/)),
    to analyze your code and check for errors before the program runs.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@dataclass` decorator is a code generator that automatically adds methods
    under the hood. This includes the `__repr__` method. This means that you now get
    useful information when you call `print(garcia)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s check that our data is there and the method works. Add the following
    lines and rerun the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By putting the ship objects in a list, we can loop through the list, access
    attributes using dot notation, and print the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `Ship` dataclass lets you instantiate a ship object and store data such
    as the ship’s name and location in type-annotated fields. By reducing redundancy
    and automatically generating required class methods such as `__init__()` and `__repr__()`,
    the `@dataclass` decorator lets you produce code that’s easier to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The @classmethod and @staticmethod decorators let you define methods inside
    a class namespace that are not connected to a particular instance of that class.
    Neither of these are commonly used and can often be replaced with regular functions.
    You should be aware of their existence, however, as they’re commonly mentioned
    in OOP tutorials and can be useful in some cases.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plotting with the Ship Dataclass**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To get a better feel for how you might use OOP, let’s take this project a step
    further and plot our ship objects on a grid. To plot the ships, we’ll use the
    Matplotlib plotting library. (We look at Matplotlib in more detail later in the
    book.) To install the library in your base environment, open Anaconda Prompt (in
    Windows) or a terminal (in macOS or Linux) and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Enter **y** if prompted, and don’t worry if you already have Matplotlib installed
    because Anaconda will just update the package, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re working in Spyder and aren’t sure which conda environment is currently
    active, enter conda info in the console. This will display the active environment
    and its path.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the text editor, save or copy your *ship_tracker_dc.py* file to a new file
    called *ship_display.py* and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Start by adding a line to import Matplotlib ➊. After instantiating the three
    ship objects, replace the remaining code starting at line ➋. This line assigns
    a list of the three ship objects to the variable `VISIBLE_SHIPS`, which represents
    the ships you can see on the simulation grid. We’ll treat this as a constant,
    hence the all-caps format.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a function for calculating the distance between two ships (`ship1`
    and `ship2`) and for plotting all the visible ships ➌. Call the `Ship` class’s
    `distance_to()` method on the two ships, assign the result to a variable named
    `sep` (for *separation*), and then loop through the `VISIBLE_LIST`, plotting each
    ship in a scatterplot ➍. For this, Matplotlib needs the ship’s x and y locations,
    a marker style (`'d'` represents a diamond shape), and a color (the `ship.obj_color`
    attribute). Note how you can enter a return after the comma associated with each
    argument, for more readable “stacked” input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, use Matplotlib’s `plt.plot()` method to draw a dashed line between the
    ships used for the distance measurement ➎. This method takes the x–y locations
    of each ship, a color, and a line style. Follow this with the `plt.text()` method,
    for adding text to the plot. Pass it a location, the `sep` variable, and a color
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Complete the function by setting x and y limits to the plot and then calling
    the `plt.show()` method to display the plot. Back in the global scope, call the
    function and pass it the `kobayashi` and `garcia` ship objects ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Save and run the file. You should see the plot shown in [Figure 13-5](ch13.xhtml#ch013fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-5: The output of the ship_display.py program*'
  prefs: []
  type: TYPE_NORMAL
- en: Bundling data and methods into classes produces compact, intuitive objects that
    you can manipulate en masse. Thanks to OOP, we could easily generate and track
    thousands of ship objects on our grid.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identifying Friend or Foe with Fields and Post-Init Processing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll want to initialize an attribute that depends on the value of
    another attribute. Because this other attribute must already exist, you’ll need
    to initialize the second attribute outside the `__init__` function. Fortunately,
    Python comes with the built-in `__post_init__` function that’s expressly designed
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example based on our war game simulation. Because alliances
    can change through time, a ship registered to a certain country might switch from
    ally to enemy. Although the `registry` attribute is fixed, its allegiance is uncertain,
    and you might want to evaluate its friend-or-foe status post-initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a version of the `Ship` dataclass that accommodates this need, in
    the text editor, enter the following and then save it as *ship_allegiance_post_init.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we start by importing both `dataclass` and `field` from the `dataclasses`
    module. The `field` function helps you change various properties of attributes
    in the dataclass, such as by providing them with default values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize the `Ship` class like we did in the *ship_tracker_dc.py*
    program, except that we add a new attribute, `friendly`, that’s set to a Boolean
    data type with a default value of `False` ➊. Note that we set this default value
    by calling the `field` function and using the keyword argument `init`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we define the `__post_init__()` method with `self` as a parameter ➋. We
    then assign a tuple of unfriendly registry designations to a variable named `unfriendlies`.
    Finally, we assign `True` or `False` to the `self.friendly` attribute by checking
    whether the current object’s `self.registry` attribute is present in the `unfriendlies`
    tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test it out by making two ships, one friendly and one unfriendly. Note
    that you don’t pass the `Ship` class an argument for the `friendly` attribute;
    this is because it uses a default value and is ultimately determined by the `__post_init__()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that you didn’t need to explicitly call the `__post_init__()`
    method. This is because the `dataclass`-generated `__init__()` code calls the
    method automatically if it’s defined in the class.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inheritance mostly works the same with dataclasses as with regular classes.
    One thing to be careful of is that dataclasses combine attributes in a way that
    prevents the use of attributes with defaults in a parent class when a child contains
    attributes without defaults. So, you’ll want to avoid setting field defaults on
    classes that are to be used as base classes.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Optimizing Dataclasses with __slots__***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re using a dataclass for storing lots of data, or if you expect to instantiate
    thousands to millions of objects from a single class, you should consider using
    the class variable `__slots__`. This special attribute optimizes the performance
    of a class by decreasing both memory consumption and the time it takes to access
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: A regular class stores instance attributes in an internally managed dictionary
    named `__dict__`. The `__slots__` variable stores them using highly efficient,
    array-related data structures implemented in the C programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example using a standard dataclass called `Ship`, followed by a `ShipSlots`
    dataclass that uses `__slots__`. Enter this code in the text editor and save it
    as *ship_slots.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the two class definitions is the assignment of a
    tuple of attribute names to the `__slots__` variable ➊. This variable lets you
    explicitly state which instance attributes you expect your objects to have. Now,
    instead of having a *dynamic* dictionary ( `__dict__`) that permits you to add
    attributes to objects after the creation of an object, you have a *static* structure
    that saves the overhead of one dictionary for every object that uses `__slots__`.
    Because it’s considered good practice to initialize all of an object’s attributes
    at once, the inability to dynamically add attributes with `__slots__` is not necessarily
    a bad thing.
  prefs: []
  type: TYPE_NORMAL
- en: Using `__slots__` with multiple inheritance can become problematic, however.
    Likewise, you’ll want to avoid using it when providing default values via class
    attributes for instance variables. You can find more caveats in the official docs
    at *[https://docs.python.org/3/reference/datamodel.html#slots/](https://docs.python.org/3/reference/datamodel.html#slots/)*
    and in this *Stack Overflow* answer at *[https://stackoverflow.com/questions/472000/usage-of-slots/](https://stackoverflow.com/questions/472000/usage-of-slots/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making a Class Module**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we used modules to abstract away code. A program with
    one or more class statements can serve as a module, too, letting you use the classes
    without having to define them in your current code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through an example using the *ship_slots.py* program you made in
    the previous section. In the console, begin by importing the *ship_slots.py* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use its classes as if you’d defined them in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Creating a class module would be useful if you were building a complete war
    games simulation. You could turn the various ship, fleet, and display classes
    into modular class libraries and then import these modules when building individual
    simulations. This would let you focus on the code for the current simulation without
    encountering the “clutter” of the class statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you forget class names or the arguments each class takes, just start instantiating
    a new object. Spyder will launch a pop-up window to prompt you on these values
    ([Figures 13-6](ch13.xhtml#ch013fig6) and [13-7](ch13.xhtml#ch013fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-6: The Spyder pop-up window listing the classes in the ship_slots
    module*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-7: The Spyder pop-up window listing parameters and data types used
    by the Ship class*'
  prefs: []
  type: TYPE_NORMAL
- en: These prompts will be less detailed if you’re using regular classes instead
    of dataclasses. In the next chapter, you’ll learn about documenting classes, and
    the documentation comment in [Figure 13-7](ch13.xhtml#ch013fig7) will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '6.  The `super()` built-in function removes the need for:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Specifying the appropriate data type for each instance attribute
  prefs: []
  type: TYPE_NORMAL
- en: b.  Class attributes common to every class instance
  prefs: []
  type: TYPE_NORMAL
- en: c.  An explicit call to a base class name when invoking methods
  prefs: []
  type: TYPE_NORMAL
- en: d.  An initialization (`__init__()`) method
  prefs: []
  type: TYPE_NORMAL
- en: '7.  The dataclass was designed for when you have:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Lots of methods that take lots of arguments
  prefs: []
  type: TYPE_NORMAL
- en: b.  A class with lots of attributes but few methods
  prefs: []
  type: TYPE_NORMAL
- en: c.  An initialization method that takes lots of arguments
  prefs: []
  type: TYPE_NORMAL
- en: d.  a. and b.
  prefs: []
  type: TYPE_NORMAL
- en: e.  b. and c.
  prefs: []
  type: TYPE_NORMAL
- en: '8.  The “syntactic sugar” symbol for a decorator is:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  `#`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `@`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `**`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `//`
  prefs: []
  type: TYPE_NORMAL
- en: '9.  True or False: A type hint specifies the type of data you should use with
    an attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: '10.  Post-initialization processing is used to:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Replace the `__init__()` method in a class definition
  prefs: []
  type: TYPE_NORMAL
- en: b.  Initialize attributes outside the `__init__()` method
  prefs: []
  type: TYPE_NORMAL
- en: c.  Optimize memory usage for large datasets
  prefs: []
  type: TYPE_NORMAL
- en: d.  Optimize processing speed when creating many objects
  prefs: []
  type: TYPE_NORMAL
- en: '11.  The class variable `__slots__` reduces memory footprint by:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Replacing the `__dict__` dictionary normally used to store instance attributes
  prefs: []
  type: TYPE_NORMAL
- en: b.  Implementing C behind the scenes
  prefs: []
  type: TYPE_NORMAL
- en: c.  Using a dynamic dictionary versus a static data structure
  prefs: []
  type: TYPE_NORMAL
- en: d.  a. & b.
  prefs: []
  type: TYPE_NORMAL
- en: e.  b. & c.
  prefs: []
  type: TYPE_NORMAL
- en: '12.  Edit the *ship_display.py* program so that it moves the Garcia across
    the grid while continuously updating the distance to the Kobayashi (hint: you’ll
    need a `for` loop).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Object-oriented programming* helps you to organize code while reducing its
    redundancy. *Classes* let you combine related data, and functions that act on
    that data, into new custom data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions in OOP are called *methods*. When you define a `class using a` `class
    statement`, you couple related elements together so that the relationship between
    the data and the methods is clear, and so the proper methods are used with the
    appropriate data. Consequently, you’ll want to consider using classes when you
    have multiple kinds of data, multiple functions that go with each kind of data,
    and a growing codebase that’s becoming increasingly complex.
  prefs: []
  type: TYPE_NORMAL
- en: A `class` serves as a template or factory for making *objects*, also called
    *instances* of a class. You create objects by calling the class’s name using function
    notation. As with regular functions, this practice introduces a new local name
    scope, and all names assigned in the `class` statement generate object *attributes*
    shared by all instances of the class. Attributes store data, and each object’s
    attributes might change over time to reflect changes in the object’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Classes can *inherit* attributes and methods from other classes, letting you
    reuse code. In this case, the new class is a child or *subclass*, and the preexisting
    class is the parent or *base* class. Inherited attributes and methods can be overwritten
    in the subclass to modify or enhance the inherited behaviors. With the `super()`
    function, you can call original methods from a base class in the event that they’ve
    been modified in the subclass. Because Python lets classes inherit from multiple
    parents, this can result in complex code that’s difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '*Decorators* are functions that modify the behavior of another function without
    permanently changing the modified function. They also help you to avoid duplicating
    code. The `@dataclass` decorator decorates `class` statements and makes them more
    concise. Although *dataclasses* were designed for classes that mainly store data,
    they can still be used as regular classes. A downside, however, is that the use
    of multiple inheritance can be more difficult with dataclasses than with regular
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The `__slots__` class variable optimizes both memory usage and attribute access
    speeds. It comes with some limitations, however, such as, but not limited to,
    the inability to dynamically create attributes after initialization and increased
    complexity when using multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: You can combine related `class` statements and save them as Python files. These
    *class libraries* then can be imported in other programs as modules. IDEs like
    Spyder will prompt users with the proper class names, arguments, methods, and
    documentation, removing the need to see all of the class definition code.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more to OOP than what we’ve covered here; it *is* the entire jungle,
    after all. If you think your projects would benefit from OOP and want to explore
    the topic further, you can find the official Python tutorial on classes at *[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)*,
    the official dataclass documentation at *[https://docs.python.org/3/library/dataclasses.html](https://docs.python.org/3/library/dataclasses.html)*,
    and the PEP 557 dataclass enhancement proposal at *[https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)*.
  prefs: []
  type: TYPE_NORMAL
