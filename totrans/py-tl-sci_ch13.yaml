- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13'
- en: OBJECT-ORIENTED PROGRAMMING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（**OOP**）
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: So far in this primer, you’ve been writing code using procedural programming
    techniques built around performing actions and evaluating logic. You’ve learned
    how to organize code using functions and modules, and you’ve used built-in data
    types to organize data. In this chapter, you’ll learn how to use object-oriented
    programming to define your own types to organize both code and data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，在本教程中，你一直在使用基于执行动作和评估逻辑的过程式编程技术编写代码。你已经学会了如何使用函数和模块组织代码，并使用内置数据类型来组织数据。在本章中，你将学习如何使用面向对象编程来定义你自己的类型，以组织代码和数据。
- en: '*Object-oriented programming (OOP)* is a language model that lets you bundle
    together related data with functionality that acts on that data. The data consists
    of *attributes* (akin to variables) that are manipulated by *methods* (akin to
    functions). These “bundles” form custom data types called *classes*. Classes help
    you split your program into different sections that deal with different pieces
    of information rather than letting it all blend into an unstructured mess.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程（OOP）*是一种语言模型，它允许你将相关数据与作用于这些数据的功能捆绑在一起。数据由*属性*（类似于变量）组成，通过*方法*（类似于函数）进行操作。这些“捆绑”形成了名为*类*的自定义数据类型。类帮助你将程序分成处理不同信息块的不同部分，而不是让所有信息混杂成一个无结构的混乱。'
- en: Classes let you create individual *objects* with specific properties and behaviors.
    Using a class template, you can efficiently “stamp out” multiple objects, just
    as a set of blueprints lets you build multiple versions of the same car. Each
    car will start off with the same attributes, such as color and mileage, and have
    the same methods, such as for accelerating and braking, but after they leave the
    factory, these can change. Some cars may be repainted, others can lose wheel alignment
    and pull to the left, their mileage will vary, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类允许你创建具有特定属性和行为的独立*对象*。通过使用类模板，你可以高效地“制作”多个对象，就像一套蓝图让你建造多个相同型号的汽车。每辆车一开始具有相同的属性，如颜色和里程，并且拥有相同的方法，如加速和刹车，但它们离开工厂后，情况可能会有所不同。一些汽车可能会重新喷漆，另一些可能会失去车轮对齐并向左偏移，它们的里程也会有所不同，等等。
- en: In this chapter, you’ll learn how to define classes that create objects, write
    attributes and methods for the objects, and then instantiate those objects. You’ll
    also write classes that inherit attributes and methods from other classes and
    use dataclasses to reduce code redundancy. This introduction to the topic should
    give you an understanding of the basics of OOP and an appreciation for how you
    can benefit from it as a programmer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何定义创建对象的类，编写对象的属性和方法，然后实例化这些对象。你还将编写继承其他类属性和方法的类，并使用数据类减少代码冗余。这个主题的介绍应当帮助你理解OOP的基本知识，并让你意识到作为程序员，你如何从中受益。
- en: '**When to Use OOP**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**何时使用OOP**'
- en: OOP is easier to appreciate when you’re writing large, complex programs because
    it helps you to structure your code into smaller parts that are easier to understand.
    It also reduces code duplication and makes code easier to maintain, update, and
    reuse. As a result, most commercial software is now built using OOP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程在编写大型复杂程序时更容易理解，因为它帮助你将代码结构化为更易于理解的小部分。它还减少了代码重复，使得代码更易于维护、更新和重用。因此，大多数商业软件现在都是采用面向对象编程构建的。
- en: Because Python is an object-oriented programming language, you’ve already been
    using objects and methods defined by other people. But unlike languages such as
    Java, Python doesn’t force you to use OOP for your own programs. It provides ways
    to encapsulate and separate abstraction layers using other approaches such as
    procedural or functional programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python是一种面向对象编程语言，你已经在使用其他人定义的对象和方法。但与Java等语言不同，Python并不强制你为自己的程序使用OOP。它提供了使用其他方法（如过程式编程或函数式编程）来封装和分离抽象层的方式。
- en: Having this choice is important. If you implement OOP in small programs, most
    of them will feel overengineered. To quote computer scientist Joe Armstrong, “The
    problem with object-oriented languages is they’ve got all this implicit environment
    that they carry around with them. You wanted a banana, but what you got was a
    gorilla holding the banana and the entire jungle!”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这种选择很重要。如果你在小型程序中实现OOP，大部分程序可能会显得过于复杂。引用计算机科学家Joe Armstrong的话来说，“面向对象语言的问题在于它们携带了所有这些隐式的环境。你想要的是一根香蕉，但你得到的是一只拿着香蕉和整个丛林的猩猩！”
- en: As a scientist or engineer, you can get a lot done without OOP, but that doesn’t
    mean you should ignore it. OOP makes it easy to simulate many objects at a time,
    such as a flock of birds or a cluster of galaxies. It’s also important when things
    that are manipulated, like a GUI button or window, must persist for a long time
    in the computer’s memory. And because most of the scientific packages you’ll encounter
    are built using OOP, you’ll want more than a passing familiarity with the paradigm.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为科学家或工程师，你可以在没有OOP的情况下完成很多工作，但这并不意味着你应该忽视它。OOP使得同时模拟许多对象变得简单，比如一群鸟或一簇星系。当需要在计算机内存中长时间保存和操作某些事物时，例如GUI按钮或窗口，它也变得非常重要。而且，由于你会遇到的大多数科学软件包都是基于OOP构建的，因此你需要对这一范式有一定的了解。
- en: '**Creating a New Spyder Project**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建一个新的Spyder项目**'
- en: Let’s make a new Spyder project to use in this chapter. If you need a refresher
    on Spyder projects, see “Using Project Files and Folders” on [page 68](ch04.xhtml#ch00lev1sec25).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Spyder项目，以便在本章中使用。如果你需要复习Spyder项目，请参见[第68页](ch04.xhtml#ch00lev1sec25)中的“使用项目文件和文件夹”。
- en: Start by launching Spyder from your *base* (root) environment (either from the
    Start menu or from Anaconda Navigator). In the Start window, this may show as
    Spyder (anaconda3). For a refresher on conda environments see [Chapter 2](ch02.xhtml).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的*base*（根）环境启动Spyder（无论是从开始菜单还是从Anaconda Navigator）。在开始窗口中，它可能显示为Spyder（anaconda3）。如果需要复习conda环境，请参见[第2章](ch02.xhtml)。
- en: Next, on the top toolbar, click **Projects** ▸ **New Project**. In the Create
    New Project dialog that opens ([Figure 13-1](ch13.xhtml#ch013fig1)), make sure
    the Location box includes your home directory, set the Project name to **oop**,
    and then click the **Create** button.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在顶部工具栏中，点击**Projects** ▸ **New Project**。在打开的创建新项目对话框中（见[图13-1](ch13.xhtml#ch013fig1)），确保位置框包含你的主目录，将项目名称设置为**oop**，然后点击**Create**按钮。
- en: '![Image](../images/13fig01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/13fig01.jpg)'
- en: '*Figure 13-1: The Spyder Create New Project dialog*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：Spyder 创建新项目对话框*'
- en: You should now see this new folder in Spyder’s File Explorer pane.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能在Spyder的文件资源管理器面板中看到这个新文件夹。
- en: For convenience, we’ll use the default conda environments folder that’s located
    within the *anaconda3* folder to hold third-party libraries. If you want to use
    an environments folder tied to this project, see the instructions in “Specifying
    an Environment’s Location” on [page 37](ch02.xhtml#ch00lev2sec20).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将使用位于*anaconda3*文件夹中的默认conda环境文件夹来存放第三方库。如果你希望使用与此项目绑定的环境文件夹，请参见[第37页](ch02.xhtml#ch00lev2sec20)中的“指定环境位置”的说明。
- en: '**Defining the Frigate Class**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义护卫舰类**'
- en: It’s a lot easier to demonstrate OOP than it is to talk about it, so let’s build
    some ship objects that might be used in a (very) simple war game simulator. Each
    unique type of ship will need its own class that can generate multiple versions
    of that ship type. We then can track and manipulate each of these objects independently.
    With OOP, the relationships among the ship class, the ship objects, and the methods
    that act on those objects will be clear, logical, and compact.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 演示面向对象编程（OOP）比单纯讨论它要容易得多，因此我们来构建一些可能在（非常）简单的战争游戏模拟器中使用的船只对象。每种独特类型的船只都需要自己的类来生成该船只类型的多个版本。我们可以独立追踪和操作这些对象。通过OOP，船只类、船只对象以及作用于这些对象的方法之间的关系将变得清晰、合逻辑且紧凑。
- en: Let’s begin by defining a class to build the most common type of warship, known
    as a “frigate” ([Figure 13-2](ch13.xhtml#ch013fig2)). Designed to be fast, maneuverable,
    and versatile, frigates escort and protect larger vessels from air, surface, and
    underwater threats.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个类开始，构建最常见类型的战舰，称为“护卫舰”（见[图13-2](ch13.xhtml#ch013fig2)）。护卫舰设计要快速、机动性强且多功能，用于护航和保护大型舰船免受空中、表面和水下的威胁。
- en: '![Image](../images/13fig02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/13fig02.jpg)'
- en: '*Figure 13-2: Brazilian Tamandaré-class frigate*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：巴西塔曼达雷级护卫舰*'
- en: To build the frigates, you’ll need a virtual shipyard, so, in your *oop* project,
    open up Spyder’s text editor and create a new file named *ships.py*. Save it wherever
    you’d like.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建护卫舰，你需要一个虚拟船坞，因此，在你的*oop*项目中，打开Spyder的文本编辑器并创建一个名为*ships.py*的新文件。将其保存在你喜欢的位置。
- en: 'To serve as a blueprint for the frigates, define a `Frigate` class using a
    `class` statement. After the `class` keyword, enter a name for the class followed
    by parentheses:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了作为护卫舰的蓝图，使用`class`语句定义一个`Frigate`类。在`class`关键字之后，输入类的名称并加上括号：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: According to the PEP 8 Style Guide, class names should be capitalized. If you
    need to use multiple words, use the *CapWords* convention, where each new word
    is capitalized without spaces between them (also called *CamelCase*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PEP 8风格指南，类名应该以大写字母开头。如果类名由多个单词组成，使用*CapWords*约定，即每个新单词首字母大写，且单词之间不加空格（也叫做*CamelCase*）。
- en: The `Frigate` class uses a single parameter, `object`. This `object` parameter
    represents the base class of all types in Python. Because `object` is the default
    parameter, you can omit stating it explicitly when defining a class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frigate`类使用一个参数，`object`。这个`object`参数表示Python中所有类型的基类。因为`object`是默认参数，所以在定义类时可以省略显式声明它。'
- en: Next, assign the string `USS`, for “United States Ship,” to an attribute named
    `designation` ➊. This is the ship’s name prefix. You can also use HMS (“Her Majesty’s
    Ship”), INS (“Indian Naval Ship”), or whatever you’d prefer. In Python, an attribute
    is any variable associated with an object. Like in a function, a class makes a
    fresh local namespace for the attributes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将字符串`USS`（代表“United States Ship”，即“美国战舰”）赋值给一个名为`designation` ➊的属性。这是船只的名称前缀。你也可以使用HMS（“Her
    Majesty’s Ship”，即“英皇舰”）、INS（“Indian Naval Ship”，即“印度海军舰”）或任何你喜欢的名称。在Python中，属性是与对象相关联的任何变量。就像在函数中一样，类为属性创建一个新的局部命名空间。
- en: Classes are objects, too, so they can have their own attributes. *Class attributes*
    are common to all objects made from the class and behave sort of like global variables.
    In this case, all the frigates you build will have the “USS” designation, such
    as the “USS Saratoga.” Class attributes are efficient, as they let you store a
    shared attribute in a single location.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类也是对象，因此它们也可以拥有自己的属性。*类属性*是所有从该类创建的对象共享的属性，表现得有点像全局变量。在这个例子中，你构建的所有护卫舰都会有“USS”前缀，例如“USS
    Saratoga”。类属性非常高效，因为它们允许你将共享属性存储在一个位置。
- en: Next, you define an *initialization* method ➋ that sets up the initial attribute
    values for an object. Methods are just functions that are defined within classes.
    The `__init__()` method is a special built-in method that Python automatically
    invokes as soon as a new object is created. In this case, it takes two parameters,
    `self` and the `name` of the object, which will be whatever you want to call the
    ship.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你定义一个*初始化*方法 ➋，用于设置对象的初始属性值。方法实际上是定义在类中的函数。`__init__()`方法是一个特殊的内置方法，Python在创建新对象时会自动调用它。在这个例子中，它接受两个参数，`self`和对象的`name`，`name`就是你为船只命名的名字。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The __init__() method is a dunder (double underscore) method, meaning its
    name is preceded and followed by double underscores. Also called magic or special
    methods, they let you create classes that behave like native Python data structures
    such as lists, tuples, and sets. They’re also the magic behind operator overloading
    and behavior customization of other functions. When you call the built-in len()
    function, for example, a __len__ method is called behind the scenes.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*`__init__()`方法是一个双下划线（dunder）方法，意味着它的名字前后都有双下划线。它也叫做魔法方法或特殊方法，允许你创建像Python原生数据结构（例如列表、元组和集合）一样行为的类。它们也是运算符重载和其他函数行为自定义的魔法。当你调用内置的len()函数时，例如，背后实际上是调用了一个`__len__`方法。*'
- en: The first argument of every class method, including `__init__()`, is always
    a reference to the current instance of the class, called `self` by convention.
    (A new object is known as an *instance* of a class, and the process of setting
    the initial values and behaviors of the instance is called *instantiation*.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类方法的第一个参数，包括`__init__()`，总是对当前实例的引用，按约定称为`self`。（一个新对象被称为类的*实例*，而设置实例的初始值和行为的过程叫做*实例化*。）
- en: You can think of `self` as a placeholder for the actual name you’ll give an
    object. If you create a ship object and name it “Intrepid,” `self` will become
    `Intrepid`. The `self.speed` attribute will become a reference to “Intrepid’s
    speed.” If you instantiate another ship object named “Indefatigable,” `self` for
    that object will become `Indefatigable`. This way, the scope of the `Intrepid`
    object’s `speed` attribute is kept separate from that of the `Indefatigable` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`self`看作是你给对象命名的占位符。如果你创建一个船只对象并命名为“Intrepid”，`self`就变成了`Intrepid`。`self.speed`属性将变成“Intrepid的速度”的引用。如果你实例化另一个船只对象并命名为“Indefatigable”，该对象的`self`就变成了`Indefatigable`。这样，`Intrepid`对象的`speed`属性的作用域就与`Indefatigable`对象的作用域相互独立。
- en: Now it’s time to list some attributes for a frigate. You’ll want to give each
    ship a name so that you can distinguish one ship from another. You’ll also want
    to specify the value of key operational and combat characteristics, like fuel,
    heading, and speed. Because these are associated with an instance of the class,
    they’re called *instance attributes*, and are assigned inside the `__init__()`
    method (with code such as `self.name = name`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候列出一些护卫舰的属性了。你需要为每艘船指定一个名称，以便区分不同的船只。你还需要指定一些关键的操作和战斗特性值，如燃料、航向和速度。由于这些属性与类的实例相关，因此被称为*实例属性*，并在`__init__()`方法内部分配（例如代码`self.name
    = name`）。
- en: Some of these attributes, like the number of guns and the length of the ship,
    represent values common to each ship that shouldn’t change over time. It’s best
    not to make these *class* attributes, however, because they *could* change. For
    example, an individual ship could be outfitted with an extra experimental gun,
    or its helicopter pad could be extended off the stern. Other attributes such as
    the heading and speed represent placeholders that are *expected* to change. In
    general, you should set attributes to good default values, such as filling the
    fuel tank to capacity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性中的一些，比如大炮的数量和船只的长度，代表了每艘船共有的、不会随时间变化的值。然而，最好不要将它们设置为*类*属性，因为它们*可能*会发生变化。例如，一艘特定的船只可能会装备额外的实验性炮台，或者它的直升机停机坪可能会延伸至船尾。其他属性，如航向和速度，代表了*预期*会变化的占位符。通常，你应该将属性设置为良好的默认值，比如将油箱加满。
- en: '**NOTE**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*While it’s possible to use methods to assign new attributes later, it’s best
    to initialize them all within the __init__ method. This way, all the available
    attributes are conveniently listed in an easy-to-find location.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然可以使用方法在之后分配新的属性，但最好在`__init__`方法中初始化所有属性。这样，所有可用的属性都会方便地列出，且易于查找。*'
- en: Take a moment to look through the list of attributes in the initialization method.
    For brevity, I’ve left off some that you might need in a true simulation, like
    the ship’s current location, it’s current “health,” and a maximum limit for reverse
    speed. You might even want “cost” attributes for building and operating ships,
    forcing you to stay in budget.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间查看初始化方法中的属性列表。为了简洁起见，我省略了一些在真实模拟中可能需要的属性，比如船只当前的位置、当前的“健康”状况，以及反向速度的最大限制。你可能还想要为建造和操作船只设置“成本”属性，这样可以帮助你保持预算。
- en: Note also that you can use expressions when assigning attributes, just as you
    can with variables. For example, we’ve assumed the ship carries 300 rounds of
    ammunition for each of its big guns ➌.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在分配属性时，你可以像使用变量一样使用表达式。例如，我们假设船只每门大炮携带300发弹药 ➌。
- en: Now let’s define some methods for piloting the ship and firing its guns.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一些方法来驾驶船只并开火。
- en: '***Defining Instance Methods***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义实例方法***'
- en: An *instance method* accesses or modifies the state of an object. They must
    have a `self` parameter to refer to the current object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例方法*用于访问或修改对象的状态。它们必须具有`self`参数，以引用当前对象。'
- en: 'Let’s define a `helm()` method to set the ship’s heading and speed, and clip
    the speed to a maximum value. In the text editor, enter the following (the `def`
    statements should be indented four spaces relative to the class definition):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`helm()`方法，用于设置船只的航向和速度，并将速度限制在最大值。请在文本编辑器中输入以下内容（`def`语句应相对于类定义缩进四个空格）：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to the `self` parameter, you’ll also pass the method a heading (between
    0 and 359 degrees) and a speed (in knots).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`self`参数外，你还需要传递一个航向（介于0到359度之间）和一个速度（单位为节）。
- en: The code within the method definition updates the object’s existing attributes
    using the values passed to it as arguments. To access and change an attribute,
    use dot notation. You’ve used this syntax before to call methods in modules such
    as `os` and `random`. To override the heading and speed attributes initially assigned
    in the `__init__()` method, simply set them as equal to the values passed to the
    method ➊.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义中的代码使用传递给它的参数更新对象的现有属性。要访问和更改属性，可以使用点符号。你之前已经使用过这种语法来调用像`os`和`random`模块中的方法。要覆盖在`__init__()`方法中最初分配的航向和速度属性，只需将它们设置为传递给方法的值
    ➊。
- en: At this point, you’ll want to validate the user inputs. To make sure the speed
    value doesn’t exceed the ship’s maximum speed. Compare the `self.speed` attribute
    to the `self.max_speed` attribute. If it’s greater, set it equal to `self.max_speed`
    ➋. Complete the method by printing the heading and speed to the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你需要验证用户输入。确保速度值不超过船只的最大速度。将`self.speed`属性与`self.max_speed`属性进行比较。如果大于最大速度，将其设置为`self.max_speed`
    ➋。通过打印船的航向和速度来完成方法。
- en: 'Now, let’s define a method called `fire_guns()` that fires all the big guns
    at once. You won’t need to pass this method any arguments other than `self`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个名为`fire_guns()`的方法，用于一次性发射所有大炮。除了`self`之外，你不需要传递任何参数给此方法：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, check that you’re not out of ammunition ➌. If you’re not, print “BOOM!”
    Then, decrement the `self.ammo` attribute by the number of guns (`self.guns`)
    ➍ and display the number of rounds left. Otherwise, print a message that you’re
    out of ammunition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查是否还有弹药 ➌。如果有，打印“BOOM！”然后，将`self.ammo`属性减去枪支数量（`self.guns`） ➍，并显示剩余的子弹数。否则，打印出弹药耗尽的消息。
- en: One thing to note here is that the methods we’ve defined are not returning anything.
    Instead, they’re changing attribute values in place. This behavior is very similar
    to the ill-advised technique of altering global variables within functions (see
    [Chapter 12](ch12.xhtml)). What makes these methods acceptable, however, is that
    the attributes exist under the class umbrella rather than in the global namespace.
    Because changes are confined to the local namespace of the class, it’s easier
    to track and debug issues than if you used global variables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们定义的方法没有返回任何内容。相反，它们直接在原地更改属性值。这种行为非常类似于在函数内更改全局变量（参见[第12章](ch12.xhtml)）。然而，这些方法之所以可以接受，是因为这些属性存在于类的范围内，而不是全局命名空间中。由于这些变化仅限于类的局部命名空间，所以跟踪和调试问题比使用全局变量要容易得多。
- en: '***Instantiating Objects and Calling Instance Methods***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实例化对象并调用实例方法***'
- en: 'We’ve defined a `Frigate` class and some methods for working with a `Frigate`
    object. Now, let’s instantiate a ship and start using it. Add the following code,
    unindented, to *ships.py* and save the file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个`Frigate`类以及一些用于操作`Frigate`对象的方法。现在，让我们实例化一艘船并开始使用它。将以下代码添加到*ships.py*文件中，并保存：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code first instantiates a new `Frigate` object named “Garcia” and assigns
    it to the `garcia` variable. It then prints the name of the ship, calling the
    built-in `upper()` method to print in uppercase characters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先实例化了一个名为“Garcia”的新`Frigate`对象，并将其赋值给`garcia`变量。然后，它打印出船的名称，并调用内置的`upper()`方法以大写字母显示。
- en: 'Note that this code prints the “USS” designation by accessing the designation
    class attribute using the class name (`Frigate.designation`). You might have noticed
    that it would be easier to type “USS” here rather than access the `designation`
    attribute. We’re using this attribute to demonstrate how class attributes work,
    but also to highlight a common problem with class attributes: in many cases, you
    can find an equally good alternative to avoid using them.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码通过使用类名访问`Frigate.designation`类属性来打印“USS”标识。你可能注意到，在这里直接输入“USS”会更容易，而不是访问`designation`属性。我们使用这个属性是为了演示类属性的工作方式，同时也想强调类属性的一个常见问题：在许多情况下，你可以找到一个同样好的替代方案来避免使用它们。
- en: Next, the code prints the crew complement, using dot notation to access the
    `crew` attribute. Finally, it fires the guns twice and then changes the ship’s
    direction and speed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码打印船员配备情况，使用点符号表示法访问`crew`属性。最后，它发射大炮两次，然后改变船只的方向和速度。
- en: 'If you run the file, you should get this output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行文件，你应该会看到以下输出：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using our `Frigate` class template, we can create as many ships as we want.
    Let’s make another one named “Boone.” In the text editor, enter the following
    and save it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`Frigate`类模板，我们可以创建任意数量的船只。让我们再创建一艘名为“Boone”的船。在文本编辑器中输入以下内容并保存：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, run it to see this output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行它以查看此输出：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You now have two ships that use similar code but have different speeds and headings.
    With the `Frigate` class and OOP, you can easily create and track hundreds of
    ships with dozens of attributes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有两艘船，它们使用相似的代码，但速度和航向不同。使用`Frigate`类和面向对象编程，你可以轻松创建和跟踪数百艘具有不同属性的船只。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '1.  OOP makes code easier to read, maintain, and update by:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  面向对象编程（OOP）通过以下方式使代码更易于阅读、维护和更新：
- en: a.  Removing the need for functions
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: a.  消除对函数的需求
- en: b.  Reducing code duplication
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: b.  减少代码重复
- en: c.  Using methods instead of functions
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: c.  使用方法而非函数
- en: d.  Providing bananas to gorillas
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: d.  给猩猩提供香蕉
- en: '2.  What is the name of an object created from a class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  由类创建的对象的名称是什么：
- en: a.  Child
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: a.  子类
- en: b.  Attribute
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: b.  属性
- en: c.  Instance
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: c.  实例
- en: d.  Method
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: d.  方法
- en: '3.  True or False: A method is a function defined in a class and called with
    dot notation.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  判断题：方法是定义在类中的函数，并通过点符号调用。
- en: '4.  In OOP, you can think of the `self` parameter as:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  在OOP中，你可以将`self`参数理解为：
- en: a.  a placeholder for the name of the class being invoked
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: a.  调用的类名的占位符
- en: b.  a placeholder for the name of the method being called
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: b.  调用方法时的占位符
- en: c.  a placeholder for the name of the object being created
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: c.  创建对象时的占位符
- en: d.  All of the above
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: d.  以上所有
- en: 5.  Write a `Parrot` class with name, color, and age attributes and methods
    for squawking and “parroting” (repeating) input.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  编写一个`Parrot`类，包含名称、颜色和年龄属性，并具有尖叫和“模仿”（重复）输入的方法。
- en: '**Defining a Guided-Missile Frigate Class Using Inheritance**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用继承定义导弹护卫舰类**'
- en: Today, guns on warships have largely been replaced by missile systems ([Figure
    13-3](ch13.xhtml#ch013fig3)). We can easily build new guided-missile frigates
    by simply refitting the existing `Frigate` class using the technique of inheritance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，战舰上的炮已经大多被导弹系统取代（[图13-3](ch13.xhtml#ch013fig3)）。我们可以通过简单地使用继承技术重新改造现有的`Frigate`类，轻松构建新的导弹护卫舰。
- en: '![Image](../images/13fig03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/13fig03.jpg)'
- en: '*Figure 13-3: The frigate HMS Iron Duke, firing her Harpoon anti-ship missile
    system*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：护卫舰HMS Iron Duke，发射她的Harpoon反舰导弹系统*'
- en: A key concept in OOP, *inheritance* lets you define a new child class based
    on an existing parent or ancestor class. (Technically, the original class is called
    a *base class* or *superclass*. The new class is called a *derived class* or *subclass*.)
    The new subclass inherits all of the attributes and methods of the existing superclass.
    This makes it easy to copy and extend an existing base class by adding new attributes
    and methods specific to the subclass.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）中的一个关键概念是*继承*，它允许你基于现有的父类或祖先类定义一个新的子类。（从技术上讲，原始类称为*基类*或*超类*，新类称为*派生类*或*子类*。）新子类继承了现有超类的所有属性和方法。这使得通过添加特定于子类的新属性和方法，复制和扩展现有的基类变得容易。
- en: 'Let’s make a new guided-missile class called `GMFrigate` that inherits from
    and modifies our current `Frigate` class. Enter the following at the bottom of
    your *ships.py* program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的导弹护卫舰类，名为`GMFrigate`，它继承并修改我们当前的`Frigate`类。在你的*ships.py*程序的底部输入以下内容：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To create a child class, pass the `class` statement the name of the parent,
    or superclass, which in this case is `Frigate`. Remember that, when you first
    defined `Frigate`, you passed it `object`. This means `Frigate` inherited from
    the `object` class, which is the root of all Python objects. The `object` class
    provides the default implementation of common methods that all derived classes
    might need. By now passing `Frigate` instead of `object`, you get the attributes
    and methods under `object` as well as the new ones you added to the `Frigate`
    class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个子类，传递`class`语句父类或超类的名称，在本例中是`Frigate`。记住，当你第一次定义`Frigate`时，你传递了`object`。这意味着`Frigate`从`object`类继承，`object`类是所有Python对象的根类。`object`类提供了所有派生类可能需要的常见方法的默认实现。现在通过传递`Frigate`而不是`object`，你将获得`object`下的属性和方法以及你添加到`Frigate`类中的新属性和方法。
- en: Guided-missile frigates will have the same “USS” designation as frigates, so
    assign a `designation` class attribute to the same `Frigate` class attribute,
    referenced using dot notation ➊. You could skip doing this and just use the `Frigate.designation`
    attribute when you need it, but by explicitly reassigning the class attribute,
    you add clarity to the code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 导弹护卫舰将与护卫舰使用相同的“USS”命名方式，因此将一个`designation`类属性分配给相同的`Frigate`类属性，并使用点符号进行引用
    ➊。你可以跳过这一步，只在需要时使用`Frigate.designation`属性，但通过显式重新分配类属性，你可以增加代码的清晰度。
- en: Next, we define the `__init__()` initialization method for the `GMFrigate` class,
    which, like the `Frigate` class, has a `self` and `name` parameter. Immediately
    beneath it, we call the initialization method from the `Frigate` class ➋ and pass
    it `Frigate` instead of `self`, along with a `name` parameter. Passing in the
    `Frigate` class gives you access to all the attributes in the `Frigate.__init__()`method,
    so you don’t need to duplicate any code, such as for crew, tonnage, guns, and
    so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为 `GMFrigate` 类定义 `__init__()` 初始化方法，该方法与 `Frigate` 类一样，包含 `self` 和 `name`
    参数。在其下方，我们调用 `Frigate` 类的初始化方法 ➋，并传入 `Frigate` 而不是 `self`，以及一个 `name` 参数。传入 `Frigate`
    类可以访问 `Frigate.__init__()` 方法中的所有属性，因此你无需重复编写代码，例如关于船员、吨位、火炮等内容。
- en: If you don’t define an `__init__()` method for a child class, it will use the
    `__init__()` method from the parent class. If you want to override some of the
    attribute values in the parent class, or add new attributes, you’ll need to include
    an `__init__()` method for the child class, as we did in this example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为子类定义 `__init__()` 方法，它将使用父类的 `__init__()` 方法。如果你想重写父类中的某些属性值，或添加新的属性，你需要为子类包含一个
    `__init__()` 方法，正如我们在这个示例中所做的那样。
- en: Our original frigate class did not allow for missiles, so add a new `self.missile`
    attribute ➌. Set the complement of missiles to `100`. Because these missiles take
    up space, you have less room for other ammunition, so *override* the `self.ammo`
    attribute by setting it to 100x the number of guns rather than 300x, as we used
    before. Note that this won’t affect the ammunition count for ships instantiated
    directly from the original `Frigate` class; they will use the superclass’s ammunition
    setting.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原始驱逐舰类不支持导弹，因此添加一个新的 `self.missile` 属性 ➌。将导弹数量设为 `100`。由于这些导弹占用空间，你就没有足够的空间来存放其他弹药，因此通过将
    `self.ammo` 属性设为火炮数量的 100 倍，而不是我们之前使用的 300 倍，来 *覆盖* 该属性。注意，这不会影响直接从原始 `Frigate`
    类实例化的舰船的弹药数量；它们将使用父类的弹药设置。
- en: Your ship will need a way to fire the missiles, so define a new method called
    `fire_missile()`, which will behave much like the `fire_guns()` that you defined
    earlier, but fires only one missile at a time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的舰船需要一种发射导弹的方式，因此定义一个新的方法 `fire_missile()`，其行为与之前定义的 `fire_guns()` 类似，但一次只发射一枚导弹。
- en: '***Instantiating a New Guided-Missile Frigate Object***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实例化一个新的导弹驱逐舰对象***'
- en: 'You can now instantiate a new guided-missile frigate. Let’s name it “Ticonderoga”:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以实例化一个新的导弹驱逐舰。我们将它命名为 “Ticonderoga”：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code generates the following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会生成以下输出：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By having your new class inherit attributes and methods from the `Frigate` class,
    you were able to follow the *DRY* (“don’t repeat yourself”) principle of software
    development, aimed at reducing the repetition of software patterns. You’ll need
    to be careful not to make any changes to the `Frigate` class, however, unless
    you want those changes to be reflected in the `GMFrigate` class, as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让你的新类继承 `Frigate` 类的属性和方法，你能够遵循软件开发中的 *DRY*（“不要重复自己”）原则，旨在减少软件模式的重复。不过，你需要小心不要对
    `Frigate` 类做出任何更改，除非你希望这些更改也体现在 `GMFrigate` 类中。
- en: '**NOTE**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Python permits the use of multiple inheritance, by which a child class inherits
    from more than one parent class. This is accomplished by passing the names of
    the parent classes, separated by commas, to the class definition. Using multiple
    parents is straightforward if none of the method names in the parent classes overlap.
    When they do, Python uses a process called Method Resolution Order (MRO) to sort
    them out. This can be tricky, so in most cases, you’ll want to stick to single
    inheritance, no inheritance, or cases where all parent classes contain distinct
    attribute and method names.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 允许使用多重继承，即子类可以从多个父类继承。这是通过在类定义中传递以逗号分隔的父类名称来实现的。如果父类中的方法名称没有重叠，使用多重继承是直接的。当方法名称重叠时，Python
    会使用一种叫做方法解析顺序（MRO）的过程来解决问题。这可能会比较棘手，因此在大多数情况下，建议使用单一继承、不继承，或者确保所有父类的属性和方法名称不同的情况。*'
- en: '***Using the super() Function for Inheritance***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 super() 函数进行继承***'
- en: 'The `super()` built-in function removes the need for an explicit call to a
    base class name when invoking base class methods. It works with both single and
    multiple inheritance. For example, in the `GMFrigate` class definition, you called
    the `Frigate` class’s `__init__()` method within the `GMFrigate` class’s `__init__()`
    method, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()` 内置函数消除了在调用基类方法时显式调用基类名称的需要。它适用于单继承和多继承。例如，在 `GMFrigate` 类定义中，你在 `GMFrigate`
    类的 `__init__()` 方法中调用了 `Frigate` 类的 `__init__()` 方法，如下所示：'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This lets the `GMFrigate` class inherit from `Frigate`. Alternatively, you
    could have used the `super()` function, which returns a proxy object that allows
    access to methods of the base class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这让 `GMFrigate` 类从 `Frigate` 类继承。或者，你可以使用 `super()` 函数，它返回一个代理对象，允许访问基类的方法：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, `super()` removes the need for an explicit call to the `Frigate`
    class. When using single inheritance, `super()` is just a fancier way to refer
    to the base type. It makes the code a bit more maintainable. For example, if you
    are using `super()` everywhere and want to change the name of the base class (such
    as from `Frigate` to `Type26Frigate`) you need to change the name only once, when
    defining the base class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`super()` 消除了显式调用 `Frigate` 类的需要。在使用单一继承时，`super()` 只是一个更高级的方式来引用基类类型。它使代码更易于维护。例如，如果你在代码中到处使用
    `super()` 并且想更改基类的名称（比如从 `Frigate` 改为 `Type26Frigate`），你只需要在定义基类时更改一次名称。
- en: 'Another use for `super()` is for accessing inherited methods that have been
    overridden in a new class. Let’s look at an example in which we define a `Destroyer`
    class that includes the guns found on a smaller corvette (another class of warship),
    plus some larger guns. Start a new *super_destroyer.py* file in the text editor
    and then enter the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()` 的另一个用途是访问在新类中被重写的继承方法。让我们看一个例子，我们定义一个 `Destroyer` 类，该类包括了较小型的护卫舰（另一种类型的军舰）上的炮火，外加一些更大的炮火。在文本编辑器中启动一个新的
    *super_destroyer.py* 文件，然后输入以下内容：'
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we define a `Corvette` class with a method for firing its guns. Because
    these guns are relatively small, they make a lowercase “boom.” Next, we define
    a `Destroyer` class that inherits from `Corvette` class ➊. It has its own `fire_guns()`
    method that prints “BOOM!” for its large guns.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个 `Corvette` 类，并为其添加一个触发炮火的方法。因为这些炮火相对较小，所以它们发出的声音是小写的“boom”。接下来，我们定义一个从
    `Corvette` 类继承的 `Destroyer` 类 ➊。它有自己的 `fire_guns()` 方法，会为其大炮打印“BOOM!”。
- en: To fire the small guns available on the destroyer, use the `super()` function
    ➋. Because “super” refers to the *base* class, it calls the `Corvette` class’s
    `fire_guns()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发驱逐舰上的小型炮火，请使用 `super()` 函数 ➋。因为“super”指的是*基类*，它调用了 `Corvette` 类的 `fire_guns()`
    方法。
- en: 'Now, let’s instantiate a corvette and destroyer object and fire their guns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实例化一个护卫舰和驱逐舰对象，并触发它们的炮火：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s the output. Notice that both versions of “boom” are printed by the destroyer
    object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果。注意到“boom”的两种版本都被驱逐舰对象打印出来：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**NOTE**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The use of super() is somewhat controversial. On one hand, it makes code more
    maintainable. On the other, it makes it less explicit, which violates the Zen
    of Python edict “Explicit is better than implicit.”*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用 super() 是有些争议的。一方面，它使代码更易于维护；另一方面，它使代码变得不够显式，这违反了 Python 的禅宗格言“显式优于隐式。”*'
- en: '**Objects Within Objects: Defining the Fleet Class**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**对象中的对象：定义舰队类**'
- en: 'Returning to our wargame simulation, let’s create a `Fleet` class for manipulating
    all the ship objects we’ve been instantiating. That’s right: using OOP, objects
    can control other objects.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的战争模拟，让我们创建一个 `Fleet` 类来操作我们已经实例化的所有舰船对象。没错：使用面向对象编程（OOP），对象可以控制其他对象。
- en: 'In the editor, add the following code to the bottom of your *ships.py* file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中，将以下代码添加到 *ships.py* 文件的底部：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initialization method for this class looks a lot like the one for the `Frigate`
    class, except now it has a parameter for a list of ships. This will be a list
    data type whose items are previously instantiated ship objects, like `garcia`
    and `boone`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的初始化方法看起来和 `Frigate` 类的初始化方法很像，只不过现在它有一个参数用于传递舰船列表。这个列表数据类型的项是之前实例化的舰船对象，比如
    `garcia` 和 `boone`。
- en: 'Now define some methods for the class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为这个类定义一些方法：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A fleet can travel no faster than its slowest ship, so define a method for setting
    the fleet’s maximum speed, just as we did earlier for individual ships. The first
    step is to use list comprehension to loop through the ships in the `self.ships`
    list and append their maximum speeds, as found in the `ship.max_speed` attribute,
    to a new list named `max_speeds` ➊.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个舰队的速度不能超过最慢的船，因此需要定义一个方法来设置舰队的最大速度，就像我们之前为单个舰船所做的那样。第一步是使用列表推导，遍历`self.ships`列表中的船只，并将它们的最大速度（在`ship.max_speed`属性中找到）追加到一个名为`max_speeds`的新列表中
    ➊。
- en: When the list is complete, you print it and then set the `self.fleet_max_speed`
    attribute to the maximum speed of the slowest ship, found by calling the built-in
    `min()` function on the list ➋. End the method by printing the fleet’s maximum
    speed attribute.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表完成后，打印它，并通过调用内置的`min()`函数找到最慢舰船的最大速度 ➋，并将`self.fleet_max_speed`属性设置为该最大速度。最后，打印舰队的最大速度属性。
- en: Next, define a method for setting the heading and speed of the fleet. Again,
    this is similar to the technique we used for setting these values on an individual
    ship. As before, we clip the speed to the maximum speed limit, in the event that
    the user inputs an invalid speed ➌. We then print the information and loop through
    each ship in the `self.ships` list, setting its heading and speed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个方法来设置舰队的航向和速度。这个方法与我们为单个舰船设置这些值时使用的技术类似。和之前一样，我们会将速度限制在最大速度范围内，以防用户输入无效的速度
    ➌。然后，我们打印信息，并遍历`self.ships`列表中的每艘船，设置它们的航向和速度。
- en: 'Let’s test the `Fleet` class by instantiating a “Seventh” fleet comprising
    the Garcia, Boone, and Ticonderoga ship objects created earlier. Enter the following
    and then save and run the program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实例化一个包含之前创建的Garcia、Boone和Ticonderoga舰船对象的“第七舰队”来测试`Fleet`类。输入以下内容，然后保存并运行程序：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This produces the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As all the ships are frigates, there’s no difference in their maximum speeds,
    but if you had destroyers, aircraft carriers, and so on, you would see a mix of
    values in the `max_speeds` list.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有的船都是护卫舰，它们的最大速度没有区别。但如果你有驱逐舰、航母等，你会在`max_speeds`列表中看到不同的值。
- en: 'With the `Fleet` class and its `fleet_helm()` method, you can simultaneously
    assign your ships the same heading and speed. You can also override these settings
    if you want by calling the `self.helm()` method of individual ships, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Fleet`类及其`fleet_helm()`方法，你可以同时为舰船分配相同的航向和速度。如果你想要覆盖这些设置，也可以通过调用单个船只的`self.helm()`方法来实现，例如：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the Garcia’s heading is different than those of the rest of the fleet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Garcia的航向与舰队中其他船只的航向不同：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Reducing Code Redundancy with Dataclasses**'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过数据类减少代码冗余**'
- en: The built-in `dataclass` module introduced in Python 3.7 provides a convenient
    way to make classes less verbose. Although primarily designed for classes that
    store data, data classes work just like regular classes and can include methods
    that interact with the data. Some use cases include classes for bank accounts,
    the content of scientific articles, and employee information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.7中引入的内置`dataclass`模块提供了一种方便的方式来使类变得更简洁。虽然数据类主要设计用于存储数据的类，但它们像普通类一样工作，并可以包括与数据交互的方法。一些使用场景包括银行账户类、科学文章内容类和员工信息类。
- en: A dataclass comes with basic “boilerplate” functionality already implemented.
    You can instantiate, print, and compare dataclass instances straight out of the
    box, and many of the common things you do in a class, like instantiating properties
    based on the arguments passed to the class, can be reduced to a few basic instructions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类已经实现了基本的“模板”功能。你可以直接实例化、打印和比较数据类实例，许多在类中常做的事情，比如根据传入的参数实例化属性，都可以简化为几条基本指令。
- en: '**NOTE**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Code linters will typically complain if you use more than seven or so instance
    attributes in a class. This seems to contradict the purpose of a dataclass, which
    is to store data. In addition, this limit can be difficult to honor in the scientific
    domain, where many attributes are often needed. Although the linter recommendations
    can be ignored, you should still strive to limit the number of instance attributes
    per class to reduce complexity. You might be able to treat some as class attributes,
    move others into parent classes, merge some into a single attribute, and so on.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码检查器通常会抱怨如果在类中使用超过七个实例属性。这似乎与数据类的目的相矛盾，因为数据类的目的是存储数据。此外，在科学领域，这一限制可能很难遵守，因为通常需要许多属性。尽管可以忽略代码检查器的建议，但你仍然应该尽量限制每个类的实例属性数量，以减少复杂性。你可以尝试将一些作为类属性处理，其他的移动到父类中，合并一些为一个单独的属性，等等。*'
- en: '***Using Decorators***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用装饰器***'
- en: Dataclasses are implemented using a helpful and powerful Python tool called
    a *decorator*. A decorator is a function designed to wrap around (encapsulate)
    another function or class to alter or enhance the wrapped object’s behavior. It
    lets you modify the behavior without permanently changing the object. Decorators
    also let you avoid duplicating code when you’re running the same process on multiple
    functions, such as checking memory use, adding logging, or testing performance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类是使用一种有用且强大的 Python 工具——*装饰器*来实现的。装饰器是一个设计用来包裹（封装）另一个函数或类的函数，以改变或增强被包裹对象的行为。它使你能够修改行为，而无需永久改变对象。装饰器还可以让你在多个函数上运行相同的过程时避免代码重复，例如检查内存使用情况、添加日志记录或测试性能。
- en: '**Decorator Basics**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**装饰器基础**'
- en: 'To see how decorators work, let’s define a function that squares a number.
    Then, we’ll define a decorator function that squares that result. Enter the following
    in the console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解装饰器是如何工作的，让我们定义一个函数来计算一个数字的平方。然后，我们将定义一个装饰器函数来对该结果进行平方。请在控制台输入以下内容：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first function, `square_it()`, takes a number, represented by `x`, and returns
    its square. The second function, `square_it_again()`, will serve as a decorator
    to the first function and is a little more complicated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数` square_it()`接受一个数字，由`x`表示，并返回它的平方。第二个函数` square_it_again()`将作为第一个函数的装饰器，稍微复杂一些。
- en: The decorator function has a `func` parameter, representing a function. Because
    functions are objects, you can pass a function to another function as an argument
    and even define a function within a function. When we call this decorator function,
    we’ll pass it the `square_it()` function as an argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器函数有一个`func`参数，表示一个函数。因为函数是对象，你可以将一个函数作为参数传递给另一个函数，甚至在一个函数内定义一个函数。当我们调用这个装饰器函数时，我们会将`
    square_it()`函数作为参数传递给它。
- en: Next, we define an inner function, which we’ll call `wrapper()`. Because `square_it()`
    takes an argument, we need to set up the inner function to handle arguments by
    using the special positional and keyword arguments `*args` and `**kwargs`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个内部函数，叫做`wrapper()`。因为` square_it()`需要一个参数，所以我们需要设置内部函数来处理参数，使用特殊的位置参数和关键字参数`*args`和`**kwargs`。
- en: Within the `wrapper()` function, we call the function we passed to the decorator
    (`func`), square its output, assign the resulting number to the `result` variable,
    and return `result`. Finally, we return the `wrapper()` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wrapper()`函数内，我们调用传递给装饰器的函数（`func`），对其输出进行平方，将结果赋值给`result`变量，并返回`result`。最后，我们返回`wrapper()`函数。
- en: 'To use the `square_it_again()` decorator, call it, pass it the function that
    you want to decorate (`square_it()`), and assign the result to a variable (`square`),
    which also represents a function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`square_it_again()`装饰器，调用它，将你想要装饰的函数（`square_it()`）传递给它，并将结果赋值给一个变量（`square`），该变量同样代表一个函数：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can now call the new function and pass it an appropriate argument:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以调用这个新函数，并传入一个合适的参数：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we manually called the decorator function. This demonstrated
    how decorators work, but it’s a bit verbose and contorted. In the next section,
    we’ll look at a more convenient method for using a decorator.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们手动调用了装饰器函数。这展示了装饰器是如何工作的，但它有点冗长和复杂。在下一节中，我们将查看一种更方便的使用装饰器的方法。
- en: '**Decorator Syntactic Sugar**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**装饰器语法糖**'
- en: 'In computer science, *syntactic sugar* is clear, concise syntax that simplifies
    the language and makes it “sweeter” for human use. The syntactic sugar for a decorator
    is the `@` symbol, which must be immediately followed by the name of the decorator
    function. The next line must be the definition statement for the function or class
    being wrapped, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*语法糖*是简洁明了的语法，简化了语言，使其对人类使用更加“甜美”。装饰器的语法糖是`@`符号，它必须紧跟装饰器函数的名称。接下来的行必须是被包装函数或类的定义语句，如下所示：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, `decorator_func_name` represents the decorator function, and `new_func()`
    is the function being wrapped. A class definition can be substituted for the `def`
    statement.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`decorator_func_name`表示装饰器函数，`new_func()`是被包装的函数。类定义可以替代`def`语句。
- en: To see how it works, let’s re-create our number-squaring example. Use the arrow
    key to bring up the previously defined `square_it_again()` function in the console.
    Because we must invoke the decorator *before* defining the function to be wrapped,
    we must rewrite the code in the reverse order compared to the previous example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看其工作原理，让我们重新创建一个数字平方的示例。使用箭头键调出控制台中之前定义的`square_it_again()`函数。因为我们必须在定义要包装的函数之前调用装饰器，所以我们必须将代码顺序与之前的示例相反地编写。
- en: 'Now, add the decorator and define the `square_it()` function in the next line.
    Note that, when using the `@` symbol, you use the decorator function name with
    no parentheses:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加装饰器并在下一行定义`.square_it()`函数。请注意，在使用`@`符号时，装饰器函数的名称后不带括号：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To use the decorated function, simply call it and pass it a number:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用装饰后的函数，只需调用它并传入一个数字：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that with the `@` decorator we didn’t need to use the `square` function,
    as in line `In [3]`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`@`装饰器时，我们不需要像在`In [3]`行中那样使用`square`函数。
- en: If decorators make your head spin a little, don’t worry. If you can type `@dataclass`,
    you can use dataclasses. This decorator modifies regular Python classes so that
    you can define them using shorter and sweeter syntax.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰器让你感到有点头晕，不用担心。如果你能输入`@dataclass`，那么你就可以使用数据类了。这个装饰器修改了常规的Python类，使得你可以使用更简洁的语法来定义它们。
- en: '***Defining the Ship Class***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义船只类***'
- en: To see the benefits of dataclasses, let’s define a regular class and then repeat
    the exercise using a dataclass. Our goal will be to make generic ship objects
    that we can track on a simulation grid. For each ship, we’ll need to supply a
    name, a classification (like “frigate”), a country of registry, and a location.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到数据类的优势，让我们定义一个常规类，然后使用数据类重复这个练习。我们的目标是创建通用的船只对象，供我们在模拟网格上进行跟踪。对于每个船只，我们需要提供一个名称、一个分类（如“护卫舰”）、一个注册国家和一个位置。
- en: '**Defining Ship as a Regular Class**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将船只定义为常规类**'
- en: 'To define a regular class called `Ship`, in the text editor, enter the following
    and then save it as *ship_tracker.py*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个名为`Ship`的常规类，在文本编辑器中输入以下内容，然后将其保存为*ship_tracker.py*：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code looks a lot like the `Frigate` class we defined earlier. This time,
    however, the `__init__()` method includes more parameters ➊. All this data will
    need to be passed as arguments when instantiating an object based on this class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与我们之前定义的`Frigate`类非常相似。不过，这次`__init__()`方法包括更多的参数➊。所有这些数据在实例化基于此类的对象时都需要作为参数传递。
- en: 'Note how we’re forced to duplicate code by repeating each parameter name, like
    `classification`, three times: once as a parameter and twice when assigning the
    instance attribute. The more data you need to pass to the method, the greater
    this redundancy.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们被迫通过重复每个参数名称（如`classification`）来复制代码：一次作为参数，另两次用于分配实例属性。你需要传递给方法的数据越多，这种冗余就越大。
- en: In addition to the parameters passed to the initialization method, the `Ship`
    class includes two “fixed” attributes representing the object type ➋ and color.
    These are assigned using an equal sign, as with a regular class. Because these
    attributes are always the same for a given object, there’s no need to pass them
    as arguments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递给初始化方法的参数外，`Ship`类还包括两个“固定”属性，分别表示对象类型➋和颜色。这些属性使用等号赋值，就像常规类一样。因为这些属性对于给定的对象始终相同，所以无需将其作为参数传递。
- en: 'Now, let’s instantiate a new ship object. Enter the following, save the file,
    and run it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实例化一个新的船只对象。输入以下内容，保存文件并运行：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This created a US frigate named `garcia` at grid location (20, 15). But when
    you print the object, the output isn’t very helpful:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为`garcia`的美国护卫舰，位于网格位置(20, 15)。但是，当你打印对象时，输出并不太有帮助：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The issue here is that printing information on an object requires you to define
    additional dunder methods, like `__str__` and `__repr__`, that return string representations
    of objects for informational and debugging purposes. Another useful method is
    `__eq__`, which lets you compare instances of a class. The list of special methods
    in Python is long, but a few basic examples are listed in [Table 13-1](ch13.xhtml#ch013tab1).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，打印对象信息需要你定义额外的双下划线方法，如`__str__`和`__repr__`，它们返回对象的字符串表示，供信息性和调试使用。另一个有用的方法是`__eq__`，它允许你比较类的实例。Python中有很多特殊方法，这里列出了一些基本的例子，详见[表13-1](ch13.xhtml#ch013tab1)。
- en: '**Table 13-1:** Basic Special Methods'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-1：** 基本特殊方法'
- en: '| **Special Method** | **Description** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **特殊方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__init__(self)` | Called when initializing an object from a class. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `__init__(self)` | 在从类初始化一个对象时被调用。 |'
- en: '| `__del__(self)` | Called to destroy an object. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `__del__(self)` | 被调用以销毁一个对象。 |'
- en: '| `__repr__(self)` | Returns a printable string for the object to use in debugging.
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `__repr__(self)` | 返回一个可打印的字符串，用于调试时显示对象信息。 |'
- en: '| `__str__(self)` | Returns a string for pretty-printing useful information
    about an object. If not implemented, `__repr__` is used instead. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `__str__(self)` | 返回一个字符串，用于漂亮地打印有关对象的有用信息。如果未实现，则使用`__repr__`。 |'
- en: '| `__eq__(self, other)` | Performs an equal to (`==`) comparison of two objects.
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `__eq__(self, other)` | 执行两个对象的相等比较（`==`）。 |'
- en: Defining these methods for each class you write can become a burden, which is
    where dataclasses come in. Dataclasses automatically handle the redundancy issues
    around attributes and dunder methods.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个你编写的类定义这些方法可能会变得繁琐，这就是数据类派上用场的地方。数据类自动处理有关属性和双下划线方法的冗余问题。
- en: '**Defining Ship as a Dataclass**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将Ship定义为数据类**'
- en: 'Now, let’s define the `Ship` class again as a dataclass. Do this in a new file
    named *ship_tracker_dc.py* (for “ship tracker dataclass”):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次将`Ship`类定义为数据类。将此操作放在名为*ship_tracker_dc.py*（即“船只跟踪数据类”）的新文件中：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Start by importing the `math` and `dataclass` modules. We’ll use the `dist`
    method from `math` to calculate the distance between ships, and `dataclass` to
    decorate our `Ship` class. To use `dist`, you’ll need Python 3.8 or higher.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`math`和`dataclass`模块。我们将使用`math`中的`dist`方法来计算船只之间的距离，并使用`dataclass`来装饰我们的`Ship`类。要使用`dist`，你需要Python
    3.8或更高版本。
- en: Next, prefix `dataclass` with the `@` symbol to make it a decorator. Define
    the `Ship` class on the following line to let the decorator know it’s wrapping
    this class ➊.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`@`符号将`dataclass`前缀化，使其成为装饰器。在下一行定义`Ship`类，以便让装饰器知道它正在包装这个类➊。
- en: Normally, the next step would be to define the `__init__()` method with `self`
    and other parameters, but dataclasses don’t need this. The initialization is handled
    behind the scenes, removing the need for this code. You’ll still need to list
    the attributes, however, but with a lot less redundancy than before.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，下一步是定义带有`self`和其他参数的`__init__()`方法，但数据类不需要这个。初始化是在幕后处理的，这样就不需要这段代码了。不过，你仍然需要列出属性，但与之前相比冗余大大减少。
- en: For each attribute that must be passed as an argument, enter the attribute name,
    followed by a colon, followed by a *type hint* ➋. A type hint, or type *annotation*,
    tells people reading your code what types of data to expect. Static analysis tools
    can use type hints to check your code for errors. Type hints were introduced in
    PEP 484 (*[https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)*).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个必须作为参数传递的属性，输入属性名称，后跟冒号，再跟一个*类型提示* ➋。类型提示或类型*注解*告诉阅读代码的人预期的数据类型。静态分析工具可以使用类型提示检查代码中的错误。类型提示在PEP
    484中引入（*[https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)*）。
- en: A class variable with a type hint is called a *field*. The `@dataclass` decorator
    examines classes to find fields. Without a type hint, the attribute won’t become
    a field in the dataclass. In this example, all the fields in the `Ship` class
    use the string data type (`str`), except for `location`, which uses a `tuple`
    (for a pair of x, y coordinates). For a reminder of some common data types see
    [Table 7-5](ch07.xhtml#ch07tab5) on [page 184](ch07.xhtml#ch07tab5).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 带有类型提示的类变量称为*字段*。`@dataclass`装饰器检查类以查找字段。如果没有类型提示，该属性将不会成为数据类中的字段。在这个例子中，`Ship`类中的所有字段都使用字符串数据类型（`str`），除了`location`，它使用`tuple`（表示一对x、y坐标）。有关常见数据类型的提醒，请参见[表7-5](ch07.xhtml#ch07tab5)在[第184页](ch07.xhtml#ch07tab5)。
- en: '**NOTE**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can use default values with the type annotations. For example, location:
    tuple = (0, 0) will place new Ship objects at coordinates x = 0, y = 0 if none
    are specified when the object is created. When you use a default parameter, however,
    all subsequent parameters must have default values.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以使用类型注解的默认值。例如，location: tuple = (0, 0) 将把新创建的Ship对象放置在坐标x = 0, y = 0的位置，如果在创建对象时未指定位置。然而，当你使用默认参数时，所有后续的参数必须也有默认值。*'
- en: Because we don’t need to pass the `obj_type` and `obj_color` attributes as arguments
    when creating a new object, we define them using an equal sign rather than a colon,
    and with no type hints ➌. By assigning them as we would in a regular class, every
    `Ship` object will, by default, be designated a “ship” and have a consistent color
    attribute for plotting.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在创建新对象时不需要传递`obj_type`和`obj_color`属性作为参数，所以我们用等号定义它们而不是冒号，并且不使用类型提示➌。通过像普通类一样赋值，每个`Ship`对象默认会被指定为“船只”，并具有一致的颜色属性用于绘图。
- en: 'Dataclasses can have methods, just like regular classes. Let’s define a method
    that calculates the Euclidian distance between two ships. The `def` statement
    should be indented four spaces relative to the class definition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类（Dataclasses）可以像常规类一样具有方法。让我们定义一个方法来计算两艘船之间的欧几里得距离。`def`语句应该相对于类定义缩进四个空格：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `distance_to()` method takes the current ship object and another ship object
    as arguments. It then uses the built-in `dist` method to get the distance between
    them. This method returns the Euclidean distance between two points (x and y),
    where x and y are the coordinates of that point. The distance is returned as a
    string, so we can include a reference to kilometers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance_to()`方法接受当前船只对象和另一个船只对象作为参数。然后，它使用内置的`dist`方法来计算它们之间的距离。该方法返回两点（x和y）之间的欧几里得距离，其中x和y是该点的坐标。距离以字符串形式返回，因此我们可以包含公里数的引用。'
- en: 'Now, in the global scope with no indentation, create three ship objects, passing
    them the following information:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在全局作用域中，不进行缩进，创建三个船只对象，并传递以下信息：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As soon as you began entering the `Ship()` class arguments, a window should
    have appeared in the Spyder text editor, prompting you on the proper inputs ([Figure
    13-4](ch13.xhtml#ch013fig4)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始输入`Ship()`类的参数，Spyder文本编辑器中应该会弹出一个窗口，提示你输入正确的内容（[图13-4](ch13.xhtml#ch013fig4)）。
- en: '![Image](../images/13fig04.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/13fig04.jpg)'
- en: '*Figure 13-4: The Spyder text editor pop-up, showing the names and data types
    for the parameters in the Ship class.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：Spyder文本编辑器弹出窗口，显示Ship类中参数的名称和数据类型。*'
- en: Because classes you create are legitimate datatypes in Python, they behave like
    built-in datatypes. As a result, the Spyder editor will use the type hints to
    guide you when creating the ship objects. In the next chapter, we’ll look at how
    to properly document classes so that the “No documentation available” message
    in [Figure 13-4](ch13.xhtml#ch013fig4) is replaced with a one-line summary of
    the class, such as “Object for tracking a ship on a grid.”
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你创建的类是Python中的合法数据类型，它们的行为与内置数据类型类似。因此，Spyder编辑器会使用类型提示来指导你创建船只对象。在下一章中，我们将讨论如何正确地记录类，以便在[图13-4](ch13.xhtml#ch013fig4)中替换掉“No
    documentation available”消息，变成类似“用于在网格上跟踪船只的对象”这样的一行类描述。
- en: 'It’s also worth noting that you don’t need to use the correct data type for
    a parameter. Because Python is a *dynamically* typed language (see [page 184](ch07.xhtml#ch00lev1sec52)
    in [Chapter 7](ch07.xhtml)), you can assign an integer as the `classification`
    argument, and the program will still run. Here’s an example with the incorrect
    parameter highlighted in gray (don’t add this to your code):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，你不需要为参数使用正确的数据类型。因为Python是一个*动态*类型语言（见[第7章](ch07.xhtml#ch00lev1sec52)的[第184页](ch07.xhtml)），你可以将整数作为`classification`参数传递，程序仍然会运行。下面是一个包含错误参数的示例，错误部分以灰色突出显示（请不要将其添加到代码中）：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**NOTE**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even though the Python interpreter ignores type hints, you can use third-party
    static type-checking tools, like Mypy ([https://mypy.readthedocs.io/](https://mypy.readthedocs.io/)),
    to analyze your code and check for errors before the program runs.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管Python解释器会忽略类型提示，你可以使用第三方静态类型检查工具，如Mypy（[https://mypy.readthedocs.io/](https://mypy.readthedocs.io/)），在程序运行之前分析代码并检查错误。*'
- en: 'The `@dataclass` decorator is a code generator that automatically adds methods
    under the hood. This includes the `__repr__` method. This means that you now get
    useful information when you call `print(garcia)`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`@dataclass` 装饰器是一个代码生成器，它会自动添加方法。这包括 `__repr__` 方法。这意味着，当你调用 `print(garcia)`
    时，你现在会看到有用的信息：'
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s check that our data is there and the method works. Add the following
    lines and rerun the script:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查数据是否存在，并且方法是否正常工作。添加以下代码行并重新运行脚本：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By putting the ship objects in a list, we can loop through the list, access
    attributes using dot notation, and print the results:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将船只对象放入一个列表中，我们可以遍历该列表，使用点符号访问属性，并打印结果：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Ship` dataclass lets you instantiate a ship object and store data such
    as the ship’s name and location in type-annotated fields. By reducing redundancy
    and automatically generating required class methods such as `__init__()` and `__repr__()`,
    the `@dataclass` decorator lets you produce code that’s easier to read and write.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ship` 数据类让你实例化一个船只对象，并在类型注解的字段中存储诸如船只名称和位置等数据。通过减少冗余并自动生成所需的类方法，例如 `__init__()`
    和 `__repr__()`，`@dataclass` 装饰器使得你可以编写更易于阅读和编写的代码。'
- en: '**NOTE**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The @classmethod and @staticmethod decorators let you define methods inside
    a class namespace that are not connected to a particular instance of that class.
    Neither of these are commonly used and can often be replaced with regular functions.
    You should be aware of their existence, however, as they’re commonly mentioned
    in OOP tutorials and can be useful in some cases.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*@classmethod 和 @staticmethod 装饰器让你可以在类的命名空间内定义与类的特定实例无关的方法。它们不常用，通常可以用普通函数替代。然而，你应该知道它们的存在，因为它们在
    OOP 教程中经常提到，在某些情况下也很有用。*'
- en: '**Plotting with the Ship Dataclass**'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Ship 数据类绘图**'
- en: 'To get a better feel for how you might use OOP, let’s take this project a step
    further and plot our ship objects on a grid. To plot the ships, we’ll use the
    Matplotlib plotting library. (We look at Matplotlib in more detail later in the
    book.) To install the library in your base environment, open Anaconda Prompt (in
    Windows) or a terminal (in macOS or Linux) and enter the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何使用面向对象编程（OOP），让我们进一步推进这个项目，并在网格上绘制我们的船只对象。绘制船只时，我们将使用 Matplotlib 绘图库。（我们将在本书后面更详细地讨论
    Matplotlib。）要在你的基础环境中安装该库，打开 Anaconda Prompt（在 Windows 中）或终端（在 macOS 或 Linux 中），并输入以下内容：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Enter **y** if prompted, and don’t worry if you already have Matplotlib installed
    because Anaconda will just update the package, if needed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示输入**y**，请按提示操作，如果你已经安装了 Matplotlib，不用担心，因为 Anaconda 会根据需要更新该软件包。
- en: '**NOTE**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re working in Spyder and aren’t sure which conda environment is currently
    active, enter conda info in the console. This will display the active environment
    and its path.*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在使用 Spyder，并且不确定当前激活的是哪个 conda 环境，可以在控制台输入 conda info。这样会显示当前环境及其路径。*'
- en: 'In the text editor, save or copy your *ship_tracker_dc.py* file to a new file
    called *ship_display.py* and edit it as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中，将你的 *ship_tracker_dc.py* 文件保存或复制到一个新文件 *ship_display.py*，并按如下方式编辑：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Start by adding a line to import Matplotlib ➊. After instantiating the three
    ship objects, replace the remaining code starting at line ➋. This line assigns
    a list of the three ship objects to the variable `VISIBLE_SHIPS`, which represents
    the ships you can see on the simulation grid. We’ll treat this as a constant,
    hence the all-caps format.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加一行代码以导入 Matplotlib ➊。在实例化三个船只对象后，替换从 ➋ 开始的其余代码。这行代码将三个船只对象的列表赋值给变量 `VISIBLE_SHIPS`，它表示你在仿真网格上可以看到的船只。我们将其视为常量，因此使用大写格式。
- en: Next, define a function for calculating the distance between two ships (`ship1`
    and `ship2`) and for plotting all the visible ships ➌. Call the `Ship` class’s
    `distance_to()` method on the two ships, assign the result to a variable named
    `sep` (for *separation*), and then loop through the `VISIBLE_LIST`, plotting each
    ship in a scatterplot ➍. For this, Matplotlib needs the ship’s x and y locations,
    a marker style (`'d'` represents a diamond shape), and a color (the `ship.obj_color`
    attribute). Note how you can enter a return after the comma associated with each
    argument, for more readable “stacked” input.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数来计算两个船只（`ship1` 和 `ship2`）之间的距离，并绘制所有可见的船只 ➌。对两个船只调用 `Ship` 类的 `distance_to()`
    方法，将结果赋值给名为 `sep`（表示*分离*）的变量，然后遍历 `VISIBLE_LIST`，在散点图中绘制每个船只 ➍。为此，Matplotlib 需要船只的
    x 和 y 位置、标记样式（`'d'` 表示菱形形状）以及颜色（`ship.obj_color` 属性）。注意你可以在每个参数后面的逗号处输入换行，以便使输入更加易读“堆叠”。
- en: Now, use Matplotlib’s `plt.plot()` method to draw a dashed line between the
    ships used for the distance measurement ➎. This method takes the x–y locations
    of each ship, a color, and a line style. Follow this with the `plt.text()` method,
    for adding text to the plot. Pass it a location, the `sep` variable, and a color
    as arguments.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Matplotlib的`plt.plot()`方法在用于距离测量的船只之间绘制虚线 ➎。该方法接受每艘船的x–y坐标、颜色和线条样式。接着，使用`plt.text()`方法向图表中添加文本，传入一个位置、`sep`变量和颜色作为参数。
- en: Complete the function by setting x and y limits to the plot and then calling
    the `plt.show()` method to display the plot. Back in the global scope, call the
    function and pass it the `kobayashi` and `garcia` ship objects ➏.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 完成函数后，设置图表的x和y坐标限制，然后调用`plt.show()`方法来显示图表。在全局作用域中，调用该函数并传入`kobayashi`和`garcia`船只对象
    ➏。
- en: Save and run the file. You should see the plot shown in [Figure 13-5](ch13.xhtml#ch013fig5).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行文件。你应该能看到[图 13-5](ch13.xhtml#ch013fig5)中显示的图表。
- en: '![Image](../images/13fig05.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/13fig05.jpg)'
- en: '*Figure 13-5: The output of the ship_display.py program*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-5：ship_display.py程序的输出*'
- en: Bundling data and methods into classes produces compact, intuitive objects that
    you can manipulate en masse. Thanks to OOP, we could easily generate and track
    thousands of ship objects on our grid.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据和方法封装到类中可以生成紧凑、直观的对象，方便你批量操作。得益于面向对象编程（OOP），我们可以轻松地在网格上生成和追踪成千上万的船只对象。
- en: '***Identifying Friend or Foe with Fields and Post-Init Processing***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过字段和后初始化处理来识别敌友***'
- en: Sometimes you’ll want to initialize an attribute that depends on the value of
    another attribute. Because this other attribute must already exist, you’ll need
    to initialize the second attribute outside the `__init__` function. Fortunately,
    Python comes with the built-in `__post_init__` function that’s expressly designed
    for this purpose.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要初始化一个依赖于另一个属性值的属性。由于另一个属性必须已经存在，因此你需要在`__init__`函数外初始化第二个属性。幸运的是，Python提供了内置的`__post_init__`函数，专门用于此目的。
- en: Let’s look at an example based on our war game simulation. Because alliances
    can change through time, a ship registered to a certain country might switch from
    ally to enemy. Although the `registry` attribute is fixed, its allegiance is uncertain,
    and you might want to evaluate its friend-or-foe status post-initialization.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个基于战争游戏模拟的例子来看看。由于联盟关系可能随时间变化，某一国家注册的船只可能从盟友转变为敌人。尽管`registry`属性是固定的，但它的归属关系是不确定的，你可能想在初始化后评估它的敌友状态。
- en: 'To create a version of the `Ship` dataclass that accommodates this need, in
    the text editor, enter the following and then save it as *ship_allegiance_post_init.py*:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个能够满足这个需求的`Ship`数据类版本，请在文本编辑器中输入以下内容，并将其保存为*ship_allegiance_post_init.py*：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, we start by importing both `dataclass` and `field` from the `dataclasses`
    module. The `field` function helps you change various properties of attributes
    in the dataclass, such as by providing them with default values.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先从`dataclasses`模块导入`dataclass`和`field`。`field`函数帮助你更改数据类属性的各种属性，例如为它们提供默认值。
- en: Next, we initialize the `Ship` class like we did in the *ship_tracker_dc.py*
    program, except that we add a new attribute, `friendly`, that’s set to a Boolean
    data type with a default value of `False` ➊. Note that we set this default value
    by calling the `field` function and using the keyword argument `init`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化`Ship`类，就像在*ship_tracker_dc.py*程序中那样，不同的是我们添加了一个新的属性`friendly`，其数据类型为布尔类型，默认值为`False`
    ➊。请注意，我们通过调用`field`函数并使用关键字参数`init`来设置这个默认值。
- en: Now we define the `__post_init__()` method with `self` as a parameter ➋. We
    then assign a tuple of unfriendly registry designations to a variable named `unfriendlies`.
    Finally, we assign `True` or `False` to the `self.friendly` attribute by checking
    whether the current object’s `self.registry` attribute is present in the `unfriendlies`
    tuple.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义`__post_init__()`方法，并以`self`作为参数 ➋。接着，我们将一组敌对的注册名称赋给一个名为`unfriendlies`的变量。最后，通过检查当前对象的`self.registry`属性是否出现在`unfriendlies`元组中，我们为`self.friendly`属性赋值为`True`或`False`。
- en: 'Let’s test it out by making two ships, one friendly and one unfriendly. Note
    that you don’t pass the `Ship` class an argument for the `friendly` attribute;
    this is because it uses a default value and is ultimately determined by the `__post_init__()`
    method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建两艘船来测试它，一艘是友好的，另一艘是敌对的。请注意，你并没有为`Ship`类传递`friendly`属性的参数；这是因为它使用默认值，最终由`__post_init__()`方法决定：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This produces the following result:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You may have noticed that you didn’t need to explicitly call the `__post_init__()`
    method. This is because the `dataclass`-generated `__init__()` code calls the
    method automatically if it’s defined in the class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，不需要显式调用`__post_init__()`方法。这是因为`dataclass`生成的`__init__()`代码会在类中定义该方法时自动调用它。
- en: '**NOTE**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Inheritance mostly works the same with dataclasses as with regular classes.
    One thing to be careful of is that dataclasses combine attributes in a way that
    prevents the use of attributes with defaults in a parent class when a child contains
    attributes without defaults. So, you’ll want to avoid setting field defaults on
    classes that are to be used as base classes.*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承在数据类中与常规类中的工作方式大体相同。需要注意的一点是，数据类通过一种方式组合属性，这种方式会阻止在子类中使用具有默认值的父类属性，尤其是当子类中包含没有默认值的属性时。因此，你应该避免在作为基类使用的类上设置字段默认值。*'
- en: '***Optimizing Dataclasses with __slots__***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用__slots__优化数据类***'
- en: If you’re using a dataclass for storing lots of data, or if you expect to instantiate
    thousands to millions of objects from a single class, you should consider using
    the class variable `__slots__`. This special attribute optimizes the performance
    of a class by decreasing both memory consumption and the time it takes to access
    attributes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用数据类存储大量数据，或者预计从一个类实例化成千上万个对象，你应该考虑使用类变量`__slots__`。这个特殊属性通过减少内存消耗和访问属性的时间来优化类的性能。
- en: A regular class stores instance attributes in an internally managed dictionary
    named `__dict__`. The `__slots__` variable stores them using highly efficient,
    array-related data structures implemented in the C programming language.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常规类将实例属性存储在一个名为`__dict__`的内部管理字典中。`__slots__`变量通过使用在C编程语言中实现的高效数组相关数据结构来存储它们。
- en: 'Here’s an example using a standard dataclass called `Ship`, followed by a `ShipSlots`
    dataclass that uses `__slots__`. Enter this code in the text editor and save it
    as *ship_slots.py*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，使用了一个名为`Ship`的标准数据类，接着是一个使用`__slots__`的`ShipSlots`数据类。将此代码输入文本编辑器，并将其保存为*ship_slots.py*：
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The only difference between the two class definitions is the assignment of a
    tuple of attribute names to the `__slots__` variable ➊. This variable lets you
    explicitly state which instance attributes you expect your objects to have. Now,
    instead of having a *dynamic* dictionary ( `__dict__`) that permits you to add
    attributes to objects after the creation of an object, you have a *static* structure
    that saves the overhead of one dictionary for every object that uses `__slots__`.
    Because it’s considered good practice to initialize all of an object’s attributes
    at once, the inability to dynamically add attributes with `__slots__` is not necessarily
    a bad thing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类定义之间的唯一区别是将一个属性名元组分配给`__slots__`变量 ➊。这个变量允许你明确声明期望对象具有哪些实例属性。现在，代替拥有一个允许在对象创建后添加属性的*动态*字典(`__dict__`)，你有了一个*静态*结构，它为使用`__slots__`的每个对象节省了一个字典的开销。由于通常建议一次性初始化对象的所有属性，因此无法使用`__slots__`动态添加属性并不一定是坏事。
- en: Using `__slots__` with multiple inheritance can become problematic, however.
    Likewise, you’ll want to avoid using it when providing default values via class
    attributes for instance variables. You can find more caveats in the official docs
    at *[https://docs.python.org/3/reference/datamodel.html#slots/](https://docs.python.org/3/reference/datamodel.html#slots/)*
    and in this *Stack Overflow* answer at *[https://stackoverflow.com/questions/472000/usage-of-slots/](https://stackoverflow.com/questions/472000/usage-of-slots/)*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`__slots__`与多重继承结合时可能会出现问题。同样，当通过类属性为实例变量提供默认值时，你也应该避免使用它。你可以在官方文档中的* [https://docs.python.org/3/reference/datamodel.html#slots/](https://docs.python.org/3/reference/datamodel.html#slots/)*
    和这个*Stack Overflow*回答中找到更多注意事项，链接为* [https://stackoverflow.com/questions/472000/usage-of-slots/](https://stackoverflow.com/questions/472000/usage-of-slots/)*。
- en: '**Making a Class Module**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建类模块**'
- en: In the previous chapter, we used modules to abstract away code. A program with
    one or more class statements can serve as a module, too, letting you use the classes
    without having to define them in your current code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们使用模块来抽象代码。一个包含一个或多个类声明的程序也可以作为模块使用，让你在当前代码中使用这些类，而无需重新定义它们。
- en: 'Let’s walk through an example using the *ship_slots.py* program you made in
    the previous section. In the console, begin by importing the *ship_slots.py* program:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来逐步讲解，使用你在上一节中制作的 *ship_slots.py* 程序。在控制台中，首先导入 *ship_slots.py* 程序：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now you can use its classes as if you’d defined them in the console:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以像在控制台中定义它们一样使用它的类：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Creating a class module would be useful if you were building a complete war
    games simulation. You could turn the various ship, fleet, and display classes
    into modular class libraries and then import these modules when building individual
    simulations. This would let you focus on the code for the current simulation without
    encountering the “clutter” of the class statements.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类模块对于构建完整的战争游戏模拟将非常有用。你可以将各种船只、舰队和显示类转化为模块化的类库，然后在构建个别模拟时导入这些模块。这将使你专注于当前模拟的代码，而不会遇到类声明的“杂乱”。
- en: If you forget class names or the arguments each class takes, just start instantiating
    a new object. Spyder will launch a pop-up window to prompt you on these values
    ([Figures 13-6](ch13.xhtml#ch013fig6) and [13-7](ch13.xhtml#ch013fig7)).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了类名或每个类所需的参数，只需开始实例化一个新对象。Spyder 将弹出一个窗口提示你这些值（见 [图 13-6](ch13.xhtml#ch013fig6)
    和 [13-7](ch13.xhtml#ch013fig7)）。
- en: '![Image](../images/13fig06.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/13fig06.jpg)'
- en: '*Figure 13-6: The Spyder pop-up window listing the classes in the ship_slots
    module*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-6：Spyder 弹出窗口列出 ship_slots 模块中的类*'
- en: '![Image](../images/13fig07.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/13fig07.jpg)'
- en: '*Figure 13-7: The Spyder pop-up window listing parameters and data types used
    by the Ship class*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-7：Spyder 弹出窗口列出 Ship 类使用的参数和数据类型*'
- en: These prompts will be less detailed if you’re using regular classes instead
    of dataclasses. In the next chapter, you’ll learn about documenting classes, and
    the documentation comment in [Figure 13-7](ch13.xhtml#ch013fig7) will be useful.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用常规类而非 dataclass，这些提示会少一些详细信息。在下一章中，你将学习如何文档化类，并且 [图 13-7](ch13.xhtml#ch013fig7)
    中的文档注释将非常有用。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '6.  The `super()` built-in function removes the need for:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  `super()` 内置函数消除了以下需求：
- en: a.  Specifying the appropriate data type for each instance attribute
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: a.  为每个实例属性指定适当的数据类型
- en: b.  Class attributes common to every class instance
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: b.  每个类实例共有的类属性
- en: c.  An explicit call to a base class name when invoking methods
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: c.  显式调用基类名称来调用方法
- en: d.  An initialization (`__init__()`) method
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: d.  一个初始化（`__init__()`）方法
- en: '7.  The dataclass was designed for when you have:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  dataclass 设计用于当你有：
- en: a.  Lots of methods that take lots of arguments
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: a.  许多需要大量参数的方法
- en: b.  A class with lots of attributes but few methods
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: b.  拥有大量属性但方法较少的类
- en: c.  An initialization method that takes lots of arguments
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: c.  一个需要大量参数的初始化方法
- en: d.  a. and b.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: d.  a. 和 b.
- en: e.  b. and c.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: e.  b. 和 c.
- en: '8.  The “syntactic sugar” symbol for a decorator is:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  装饰器的“语法糖”符号是：
- en: a.  `#`
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `#`
- en: b.  `@`
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `@`
- en: c.  `**`
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `**`
- en: d.  `//`
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `//`
- en: '9.  True or False: A type hint specifies the type of data you should use with
    an attribute.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  对错：类型提示指定了你应该使用的属性数据类型。
- en: '10.  Post-initialization processing is used to:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  后初始化处理用于：
- en: a.  Replace the `__init__()` method in a class definition
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: a.  替换类定义中的 `__init__()` 方法
- en: b.  Initialize attributes outside the `__init__()` method
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: b.  在 `__init__()` 方法外初始化属性
- en: c.  Optimize memory usage for large datasets
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: c.  为大数据集优化内存使用
- en: d.  Optimize processing speed when creating many objects
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: d.  在创建大量对象时优化处理速度
- en: '11.  The class variable `__slots__` reduces memory footprint by:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  类变量 `__slots__` 通过以下方式减少内存占用：
- en: a.  Replacing the `__dict__` dictionary normally used to store instance attributes
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: a.  替换通常用于存储实例属性的 `__dict__` 字典
- en: b.  Implementing C behind the scenes
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: b.  在幕后实现 C
- en: c.  Using a dynamic dictionary versus a static data structure
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: c.  使用动态字典与静态数据结构
- en: d.  a. & b.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: d.  a. 和 b.
- en: e.  b. & c.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: e.  b. 和 c.
- en: '12.  Edit the *ship_display.py* program so that it moves the Garcia across
    the grid while continuously updating the distance to the Kobayashi (hint: you’ll
    need a `for` loop).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  编辑 *ship_display.py* 程序，使其在网格中移动 Garcia，同时持续更新到 Kobayashi 的距离（提示：你需要一个
    `for` 循环）。
- en: '**Summary**'
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: '*Object-oriented programming* helps you to organize code while reducing its
    redundancy. *Classes* let you combine related data, and functions that act on
    that data, into new custom data types.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程* 帮助你组织代码，同时减少冗余。*类* 让你将相关的数据和操作这些数据的函数结合成新的自定义数据类型。'
- en: Functions in OOP are called *methods*. When you define a `class using a` `class
    statement`, you couple related elements together so that the relationship between
    the data and the methods is clear, and so the proper methods are used with the
    appropriate data. Consequently, you’ll want to consider using classes when you
    have multiple kinds of data, multiple functions that go with each kind of data,
    and a growing codebase that’s becoming increasingly complex.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的函数称为*方法*。当你使用`class`语句定义一个`类`时，你将相关的元素组合在一起，使数据与方法之间的关系变得清晰，并确保合适的方法与适当的数据一起使用。因此，当你有多种类型的数据、与每种数据相关的多个函数，以及一个日益复杂的代码库时，你会想考虑使用类。
- en: A `class` serves as a template or factory for making *objects*, also called
    *instances* of a class. You create objects by calling the class’s name using function
    notation. As with regular functions, this practice introduces a new local name
    scope, and all names assigned in the `class` statement generate object *attributes*
    shared by all instances of the class. Attributes store data, and each object’s
    attributes might change over time to reflect changes in the object’s state.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`是创建*对象*（也称为*实例*）的模板或工厂。你通过使用函数符号调用类的名称来创建对象。与常规函数一样，这种做法引入了一个新的局部名称空间，所有在`class`语句中分配的名称都会生成类的对象*属性*，这些属性是所有类实例共享的。属性用于存储数据，每个对象的属性可能随着时间的推移而改变，以反映对象状态的变化。'
- en: Classes can *inherit* attributes and methods from other classes, letting you
    reuse code. In this case, the new class is a child or *subclass*, and the preexisting
    class is the parent or *base* class. Inherited attributes and methods can be overwritten
    in the subclass to modify or enhance the inherited behaviors. With the `super()`
    function, you can call original methods from a base class in the event that they’ve
    been modified in the subclass. Because Python lets classes inherit from multiple
    parents, this can result in complex code that’s difficult to understand.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以*继承*其他类的属性和方法，从而实现代码重用。在这种情况下，新的类是子类或*子类*，而已有的类是父类或*基类*。继承的属性和方法可以在子类中被重写，以修改或增强继承的行为。通过`super()`函数，你可以调用基类中的原始方法，即使这些方法在子类中已经被修改。由于
    Python 允许类从多个父类继承，这可能导致复杂的代码，难以理解。
- en: '*Decorators* are functions that modify the behavior of another function without
    permanently changing the modified function. They also help you to avoid duplicating
    code. The `@dataclass` decorator decorates `class` statements and makes them more
    concise. Although *dataclasses* were designed for classes that mainly store data,
    they can still be used as regular classes. A downside, however, is that the use
    of multiple inheritance can be more difficult with dataclasses than with regular
    classes.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*是修改另一个函数行为的函数，但不会永久改变被修改的函数。它们还帮助你避免重复代码。`@dataclass`装饰器装饰`class`语句，使其更加简洁。尽管*数据类*是为主要存储数据的类设计的，它们仍然可以作为常规类使用。然而，缺点是，与常规类相比，使用数据类时多重继承可能会变得更加困难。'
- en: The `__slots__` class variable optimizes both memory usage and attribute access
    speeds. It comes with some limitations, however, such as, but not limited to,
    the inability to dynamically create attributes after initialization and increased
    complexity when using multiple inheritance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`__slots__`类变量优化了内存使用和属性访问速度。然而，它也有一些限制，例如，初始化后无法动态创建属性，并且在使用多重继承时，复杂度会增加。'
- en: You can combine related `class` statements and save them as Python files. These
    *class libraries* then can be imported in other programs as modules. IDEs like
    Spyder will prompt users with the proper class names, arguments, methods, and
    documentation, removing the need to see all of the class definition code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将相关的`class`语句组合在一起并保存为 Python 文件。这些*类库*随后可以作为模块导入到其他程序中。像 Spyder 这样的集成开发环境（IDE）将提示用户正确的类名、参数、方法和文档，从而无需查看所有的类定义代码。
- en: There’s a lot more to OOP than what we’ve covered here; it *is* the entire jungle,
    after all. If you think your projects would benefit from OOP and want to explore
    the topic further, you can find the official Python tutorial on classes at *[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)*,
    the official dataclass documentation at *[https://docs.python.org/3/library/dataclasses.html](https://docs.python.org/3/library/dataclasses.html)*,
    and the PEP 557 dataclass enhancement proposal at *[https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）远比我们在这里讨论的内容要广泛；毕竟它*就是*整个丛林。如果你认为你的项目可以从OOP中受益，并且希望进一步探索这个主题，你可以查看官方的Python类教程，地址为
    *[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)*，官方的数据类文档，地址为
    *[https://docs.python.org/3/library/dataclasses.html](https://docs.python.org/3/library/dataclasses.html)*，以及PEP
    557数据类增强提案，地址为 *[https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)*。
