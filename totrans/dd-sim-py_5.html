<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="part">
<span class="PartNumber"><span epub:type="pagebreak" title="511" id="Page_511"/>Part V</span><br/>
<span class="PartTitle">BEYOND THE CODE</span></h1>
</header>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="513" id="Page_513"/>18</span><br/>
<span class="ChapterTitle">Packaging and Distribution</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">The best code in the world amounts to little if you never ship it. Once your project is functional, you should work out how you’ll package and distribute it, before continuing development. The trouble is, packaging in Python sometimes feels like beating yourself with a wet trout.</p>
<p>Often, the difficulty doesn’t come from packaging your own code—that’s usually easy enough—but rather from handling your code’s dependencies, especially its non-Python dependencies. Distribution can be a snarly issue for even experienced programmers, due in part to the diverse scenarios in which Python is used. Still, if you understand how things are supposed to work, you’ll have a good foundation for pushing past the frustration and shipping working code.</p>
<p>In this chapter, I’ll break down the essentials of packaging and distributing a Python project, first via the Python Package Index, and then as an installable binary. To do this, I’ll walk you through packaging an actual application I wrote: Timecard. This project is well-suited as an example, because it has both Python and system dependencies, plus a few non-code <span epub:type="pagebreak" title="514" id="Page_514"/>resources, all of which need to be accounted for, somehow. The repository for this project is available on GitHub: <a href="https://github.com/codemouse92/timecard/" class="LinkURL">https://github.com/codemouse92/timecard/</a>. I’ve set up the <code>packaging_example</code> branch to contain only the project itself and none of the packaging files, so you can practice.</p>
<p>This chapter functions as an introduction to the packaging process in general, regardless of the tool you plan to use. However, to avoid getting lost in the weeds explaining the myriad packaging tools out there, I’ll package Timecard using the popular setuptools package, from which we get the majority of modern packaging patterns.</p>
<p>Along the way, I’ll touch on many other common tools, including a few popular third-party alternatives, but I won’t go into detail on most of them. In case you want to learn more about these tools, I will link to their official documentation  for your reference. Also, if you want to go deeper into packaging in general, one of the best resources is the community-maintained <em>Python Packaging User Guide</em> at <a href="https://packaging.python.org/" class="LinkURL">https://packaging.python.org/</a>, which covers a number of more advanced topics, such as packaging a CPython binary extension.</p>
<p>To make this whole idea of packaging feel less threatening to you, I’d also like to mention that the mascot of Python packaging is a happy, purple platypus: an odd little creature that seems to be made up of many disparate parts, is cute and generally friendly, and can lay eggs. (That last part is a pun you’ll likely understand by the time this chapter is over.) If you’re feeling intimidated by packaging right now, go to <a href="https://monotreme.club/" class="LinkURL">https://monotreme.club/</a> and revel in the cuteness that is the Python Packaging mascot. They have stickers.</p>
<h2 id="h1-500920c09-0001">Planning Your Packaging</h2>
<p class="BodyFirst">Before you begin packaging, you need a solid idea of what you’re trying to accomplish, why, and how. Unfortunately, very few developers recognize this necessity and instead plunge headlong into writing their packaging scripts, with no real direction. These ad hoc packaging schemes can suffer from brittleness, unnecessary complexity, a lack of portability between systems, and poor or missing dependency installation.</p>
<h3 id="h2-500920c09-0001">The Dangers of Cargo Cult Programming</h3>
<p class="BodyFirst">In an attempt to encourage the use of good packaging tools and practices, many well-meaning people will provide templates for the files <em>setup.py</em>, <em>setup.cfg</em>, or others used in packaging, with advice to copy and modify the templates. This practice, known as <em>cargo cult programming</em>, is widely employed in Python packaging, to the detriment of both project and ecosystem. Because configuration files are copied blind, errors, hacks, and anti-patterns propagate like plague-carrying rabbits.</p>
<p>A bug in packaging won’t always manifest with a failed installation or a helpful error message. For example, a mistake in packaging a library may <span epub:type="pagebreak" title="515" id="Page_515"/>instead manifest when that library is used as a dependency. Distribution is especially pesky in this regard, as many related bugs are platform specific. Sometimes, you’ll be able to install the package, but the program will fail in surprising ways! Issue trackers are rife with these sorts of tickets, many of which are unhelpfully closed with “Cannot reproduce,” perhaps because the bug only occurs on that one version of Linux with a particular version of that one system library.</p>
<p>All that is to say, do not give in to the temptation of cargo cult programming! While it is reasonable to start from a proven template, aim to understand every single line of code therein. Read through the documentation. Be certain you haven’t omitted a needed parameter the template may have overlooked, used some deprecated option, or even swapped the proper sequence of lines. (Yes, that last one is a thing.)</p>
<p>Thankfully, the <em>Python Packaging Authority</em> (<em>PyPA</em>) working group has done a lot to move the community away from this. The PyPA is a quasi-official group made up of Python community members who want to make Python packaging a better experience, and membership is open to anyone who maintains a project. They have extensively explained the whys and wherefores of each piece of their packaging templates and the Python Packaging User Guide they maintain.</p>
<h3 id="h2-500920c09-0002">A Note on Packaging Opinions</h3>
<p class="BodyFirst">As you’re about to discover, there are a plethora of ways to package and distribute Python projects. I’ll focus primarily on the techniques advised by the PyPA, but there are plenty of alternatives.</p>
<p>Whatever packaging techniques you ultimately use, they must produce a reasonably portable, stable, “just works” package. Your end user should be able to run a predictable set of steps on any supported system and succeed at running your code. While it isn’t uncommon for there to be variations in installation instructions from one platform to the next, you want to minimize the number of steps that your end user needs to follow. The more steps, the more chances for errors! Keep things simple and try to respect the recommended packaging and distribution practices for each platform. If your end users consistently report problems or confusion when installing your project, <em>fix the packaging</em>.</p>
<h3 id="h2-500920c09-0003">Determining Your Packaging Goals</h3>
<p class="BodyFirst">Ultimately, the goal of any packaging tool is to create a single <em>artifact</em>, usually a file, that can be installed on an end user’s environment, be it a personal computer, a server, a virtual machine, or another piece of hardware. There are a number of ways to package a project in Python for distribution. Selecting the right way all comes down to what your project is and who is going to be using it.</p>
<p>At the PyBay2017 conference, Mahmoud Hashemi presented a talk entitled “The Packaging Gradient” (<a href="https://youtu.be/iLVNWfPWAC8" class="LinkURL">https://youtu.be/iLVNWfPWAC8</a>), in which he brought a lot of clarity to the Python packaging ecosystem. (I definitely <span epub:type="pagebreak" title="516" id="Page_516"/>recommend watching it.) In that talk, he introduced the concept of the <em>packaging gradient</em>, which visualizes the options for Python packaging and distribution like the layers of an onion.</p>
<h4 id="h3-500920c09-0001">Option 1: Python Modules</h4>
<p class="BodyFirst">On the innermost layer of the packaging gradient is the <em>Python module</em>, which can be distributed by itself. If your entire project consists of a single Python module, such as some utility script, you may be able to simply distribute that. However, as you’ve probably noticed by now, this isn’t practical whenever there is more than one module involved in the project.</p>
<p>Unfortunately, many Python developers chicken out at this point, zip up their whole project in a compressed file (perhaps with a README file), and leave the hapless end user to figure out how to run the package on their particular system. Don’t do this to your users. It’s not a great experience.</p>
<h4 id="h3-500920c09-0002">Option 2: Python Distribution Packages</h4>
<p class="BodyFirst">So far in your Python journey, you’ve installed plenty of packages with pip. These are all provided by the <em>Python Package Index (PyPI)</em>, an online repository of Python packages. Each package in PyPI is in one or both of two formats: source distribution and built distribution.</p>
<p>The <em>source distribution</em>, or <em>sdist</em>, contains one or more Python packages bundled into a compressed archive, such as a <em>.tar.gz</em> file. This is fine as long as your project’s code is solely in Python and only depends on Python packages. This is the second layer in the packaging gradient.</p>
<p>The third layer in the packaging gradient is the <em>built distribution</em>, or <em>bdist</em>, which contains precompiled Python bytecode, as well as binary files needed for the package to run. A built distribution is faster to install than a source distribution, and it can contain non-Python components.</p>
<p>A built distribution is packaged as a <em>wheel</em>, a standardized format defined in PEP 427. The name <em>wheel</em> refers to a wheel of cheese, which is a reference to the “cheese shop,” the original code name for what is now PyPI. Prior to the 2012 adoption of the wheel standard, Python unofficially used another format called <em>eggs</em>, which had a number of technical limitations that wheel overcame.</p>
<p>The source distribution, and by extension, the associated built distribution, is known as a <em>distribution package</em> once it has been bundled together and versioned. </p>
<p>PyPI can distribute both wheels and sdists, so it’s trivial (and thus recommended) to upload both. If you have to choose, favor sdists. If you were to upload only a <em>platform wheel</em>—a wheel built for a specific system—and omitted the sdist, users on other systems would not be able to install your package. Only publishing wheels also leaves out users in situations where auditing the source code is mandatory, such as in some corporations. Still, wheels are faster to install than sdists. Whenever you can, upload both.</p>
<h4 id="h3-500920c09-0003"><span epub:type="pagebreak" title="517" id="Page_517"/>Option 3: Application Distribution</h4>
<p class="BodyFirst">There’s just one problem so far: PyPI is intended for distributing to developers, not to end users. While it is possible to distribute an application on PyPI, it’s not well-suited for deploying to end users or production environments; pip is too brittle to be that reliable!</p>
<p>This chapter’s example project, Timecard, is certainly a good example of this. While providing a Python distribution package for my application doesn’t hurt, many end users will be at a loss if I just tell them to install from pip. I will need an additional layer in my packaging later.</p>
<p>Determining the right distribution method for your application depends largely on your project dependencies, your target environments, and the needs of your end users. Later in this chapter, I’ll cover several good options for distributing an application.</p>
<h2 id="h1-500920c09-0002">Project Structure: src or src-less</h2>
<p class="BodyFirst">Before you start the process of packaging, you must decide whether to use a <em>src/</em> directory. Up to this point, all my examples in this book have used so-called <em>src-less</em> (“source-less”) project structures, where the main project package sits directly in the repository. I chose this technique in prior chapters because of the ease of running the package via <code>python3 -m </code><var>packagenamehere</var>, without the need for installation.</p>
<p class="BodyFirst">An alternative project structure involves placing all your project modules and scripts in a dedicated <em>src/</em> directory. Python developer Ionel Cristian Mărieș, one of the leading advocates of this approach, details several advantages of using a <em>src/</em> directory, which I can summarize:</p>
<ul>
<li>It simplifies maintenance of your packaging scripts.</li>
<li>It keeps your packaging scripts and your project source code clearly separated.</li>
<li>It prevents several common packaging mistakes.</li>
<li>It prevents you from making assumptions about the current working directory.</li>
<li>To test or run your package, you are forced to install your package, usually in a virtual environment.</li>
</ul>
<p>That last item may seem like a peculiar benefit. Avoiding that situation is exactly why I didn’t introduce this technique back in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, since it would have been impossible to properly introduce <em>setup.cfg</em> and <em>setup.py</em> then.</p>
<p>In production-grade development, however, forcing yourself to install the package is highly beneficial. It immediately exposes flaws in packaging, assumptions about current working directories, and a number of related problems and anti-patterns. I didn’t actually learn about this until researching this book, and I deeply wish I’d discovered it sooner, as it would have saved me many woes.</p>
<p>Another benefit of that approach is that it keeps you from putting off questions of packaging until the last step in a project. I can say from personal <span epub:type="pagebreak" title="518" id="Page_518"/>experience that there is little more frustrating than building an entire project, only to discover you cannot package anywhere but on your own machine! Figure out packaging as early in the development process as you can.</p>
<p>For the rest of this book, and in the Timecard project in particular, I’ll use the <em>src/</em> directory approach. Even if you don’t use a dedicated <em>src/</em> directory, you should install your package in a virtual environment when you want to test it. By the end of the next section, you’ll have done exactly that.</p>
<h2 id="h1-500920c09-0003">Packaging a Distribution Package with setuptools</h2>
<p class="BodyFirst">There are a lot of interesting packaging tools out there for Python, each with its own vocal proponents, so it can be easy to get overwhelmed. When in doubt, I recommend starting with <em>setuptools</em>, the de facto standard tool for Python packaging. Even if you decide to use another packaging tool later, many concepts from setuptools are borrowed by most of the other packaging tools.</p>
<p>The setuptools library is a fork of a Python standard library package called <em>distutils</em>. In its heyday, distutils was the official standard packaging tool (ergo, its inclusion), but as of Python 3.10, it is now deprecated in favor of setuptools.</p>
<p>To package Timecard as a distribution package, I will use the <code>setuptools</code> and <code>wheel</code> modules, the latter of which is not installed by default. It’s good to ensure both are up-to-date in your environment, along with pip. You can do this with the following terminal command, <em>inside</em> your virtual environment:</p>
<pre><code>pip install --upgrade pip setuptools wheel</code></pre>
<p>Remember to run that inside of the virtual environment you’re using, either by activating the virtual environment first or by directly invoking its captive pip binary (such as <code>venv/bin/pip</code>).</p>
<h3 id="h2-500920c09-0004">Project Files and Structure</h3>
<p class="BodyFirst">Here’s a quick overview of the files I’ll create for this project:</p>
<ul>
<li><em>README.md</em> is a Markdown file with project information.</li>
<li><em>LICENSE</em> contains the project license.</li>
<li><em>pyproject.toml</em> specifies the build backend and lists build requirements for the package.</li>
<li><em>setup.cfg</em> contains distribution package metadata, options, and dependencies.</li>
<li><em>setup.py</em> used to contain packaging instructions and dependencies; now it just ties things together in the source distribution package.</li>
<li><em>MANIFEST.in</em> lists all the non-code files that should be included in the distribution package.</li>
<li><em>requirements.txt</em> lists dependencies (which are used differently from <em>setup.cfg</em>; it’s often useful to have both).</li>
</ul>
<p><span epub:type="pagebreak" title="519" id="Page_519"/>I’ll cover each of these files in the sections to come.</p>
<p>The recommendations contained herein are based partly on the latest version of PyPA’s sample project, which you can see at <a href="https://github.com/pypa/sampleproject/" class="LinkURL">https://github.com/pypa/sampleproject/</a>. The rest of the information comes from the PyCon 2021 talk “Packaging Python in 2021” by Jeremiah Paige. Bernát Gábor, a member of PyPA, generously reviewed this chapter to make sure it was up-to-date.</p>
<h3 id="h2-500920c09-0005">Where Metadata Belongs</h3>
<p class="BodyFirst">These days, the Python packaging ecosystem is evolving quickly, and standards are stuck in an odd limbo between yesterday, today, and tomorrow.</p>
<p>Historically, all the metadata for your project—its title, description, and so forth—belonged in a file called <em>setup.py</em>. This file also contained other build instructions, such as dependencies to install. Even today, most Python projects still use this convention.</p>
<p>The current convention is to move all of this data into a file called <em>setup.cfg</em>, which is easier to maintain by merit of being <em>declarative</em>, meaning it focuses on data rather than implementation. This technique is the one I’m using herein. The <em>setup.py</em> file still has an occasional role to play, but it’s mostly relegated to legacy builds.</p>
<p>In the near future, some packaging data, especially the metadata, will be moved to a third file: <em>pyproject.toml</em>. This will allow for a clear separation between the project metadata and options used by all packaging tools on the one hand, and the setuptools-specific configuration in <em>setup.cfg</em> on the other hand. As of the date of this writing, this new convention isn’t yet implemented by some Python packaging tools, but it is expected to be very soon. In the meantime, <em>pyproject.toml</em> still plays the invaluable role of specifying what packaging tools are used.</p>
<h3 id="h2-500920c09-0006">The README.md and LICENSE Files</h3>
<p class="BodyFirst">Every good project should have a <em>README</em> file, which describes the project, its authors, and its basic usage. Nowadays, these are typically written as Markdown files (<em>.md</em>), which are rendered with nice formatting by most version control platforms, such as GitHub, GitLab, Bitbucket, and Phorge.</p>
<p>It is a significant packaging mistake to skimp on your README! I like to put a bit of thought and time into mine, and I include (at minimum) the following:</p>
<ul>
<li>A project description, written to “sell” users on the project</li>
<li>A list of authors and contributors</li>
<li>Basic installation instructions</li>
<li>Basic usage instructions, such as how to start the program</li>
<li>The technology stack I used</li>
<li>How to contribute code or report an issue</li>
</ul>
<p>In addition, whether your code is open source or not, you should include a <em>LICENSE</em> file. In the case of free and open source software, this file should contain the complete text of the license. If you need help <span epub:type="pagebreak" title="520" id="Page_520"/>selecting an open source license for your project, check out <a href="https://choosealicense.com/" class="LinkURL">https://choosealicense.com/</a> and <a href="https://tldrlegal.com/" class="LinkURL">https://tldrlegal.com/</a>. Otherwise, include the copyright information.</p>
<p>If you prefer, you can also include the <em>.txt</em> file extension (<em>LICENSE.txt</em>) or use Markdown (<em>LICENSE.md</em>). </p>
<p>On occasion, I may also include such files as <em>BUILDING.md</em> or <em>INSTALL.md</em>, to describe building (for development) or installing the project. Whether you use these is up to you.</p>
<h3 id="h2-500920c09-0007">The setup.cfg File</h3>
<p class="BodyFirst">When creating a distribution package ultimately intended for production, one of the first files to create is <em>setup.cfg</em>, which is placed in the root of the repository. The <em>setup.cfg</em> file contains all the project metadata, dependencies, and options for setuptools, and it may be used by other packaging tools as well.</p>
<p>It may be tempting to grab a minimalist <em>setup.cfg</em> template, but I, like Mahmoud Hashemi, recommend you do not wait until the last phase of your project to start on packaging. Using a <em>src/</em> directory forces you to think about packaging early. This is one of those lessons I wish I’d learned years ago.</p>
<p>As soon as you start work on a project, create your <em>setup.cfg</em> file. I’ll break down the one for Timecard in this section. This is the most important file in your packaging scripts, so I’ll be spending a lot of time on this one file.</p>
<p>If you want to know about this file format, see the official documentation here: <a href="https://setuptools.readthedocs.io/en/latest/userguide/declarative_config.html" class="LinkURL">https://setuptools.readthedocs.io/en/latest/userguide/declarative_config.html</a>.</p>
<h4 id="h3-500920c09-0004">Project Metadata</h4>
<p class="BodyFirst">In writing the <em>setup.cfg</em> file for Timecard, I’ll start with the basic metadata. The <em>setup.cfg</em> file is divided into <em>sections</em>, indicating the tool or set of options the parameters to follow belong to. Each section is marked out with the section name in square brackets. For example, all the metadata belongs under the <code>[metadata]</code> section:</p>
<pre><code>[metadata]
name = timecard-app</code></pre>
<p class="CodeListingCaption"><a id="listing18-1">Listing 18-1</a>: <em>setup.cfg:1</em></p>
<p>All the data in a <em>setup.cfg</em> file is in key-value pairs. The first key here is called <code>name</code>, and I pass the string value <code>timecard-app</code>. Notice that I didn’t need to use quotes around the string value. (The documentation outlines the different types <em>setup.cfg</em> understands and what types it expects for each key.)</p>
<p>Although my program is called Timecard, I gave the distribution package the name “Timecard-App,” to avoid confusion with the unrelated “Timecard” library published on PyPI. This is the name that will be used in the <code>pip install</code> command. PyPI further restricts this name: it must contain only ASCII letters and numbers, although you may include periods, <span epub:type="pagebreak" title="521" id="Page_521"/>underscores, and hyphens in the name, as long as they’re not at the start or end.</p>
<p>The version must be a string following the format outlined in PEP 440, as demonstrated here:</p>
<pre><code>version = 2.1.0</code></pre>
<p class="CodeListingCaption"><a id="listing18-2">Listing 18-2</a>: <em>setup.cfg:2</em></p>
<p>In short, it must be made up of two or three integers, separated by dots: either in the format <var>major</var>.<var>minor</var> (<code>'3.0'</code>) or <var>major</var>.<var>minor</var>.<var>micro</var> (<code>'3.2.4'</code>). I strongly recommend employing semantic versioning. In this case, the version of Timecard is major version <code>2</code>, minor version <code>0</code>, and micro (or “patch”) version <code>5</code>.</p>
<p>If you need to indicate something more in the version, such as a release candidate, beta version, postrelease, or development version, this is permitted using a suffix. For example, <code>'3.1rc2'</code> would mean “3.1, release candidate 2.” See PEP 440 for more details on this convention.</p>
<p>Tools like <em>setuptools-scm</em> can handle version numbers for you, which can be helpful if you need to update them often: <a href="https://pypi.org/project/setuptools-scm/" class="LinkURL">https://pypi.org/project/setuptools-scm/</a>. I’ll stick to the manual method for this book, however.</p>
<p>The <code>description</code> is a one-line description of the package, which I enter here explicitly:</p>
<pre><code>description = Track time beautifully.
long_description = file: <em>README.md</em>
long_description_content_type = text/markdown; charset=UTF-8</code></pre>
<p class="CodeListingCaption"><a id="listing18-3">Listing 18-3</a>: <em>setup.cfg:3</em></p>
<p>The <code>long_description</code> is a large multiline description, which I am deriving directly from the contents of the <em>README.md</em> file. The <code>file:</code> prefix indicates I’m reading from the file that follows. That file <em>must</em> exist in the same directory as <em>setup.cfg</em>, as paths are not supported here.</p>
<p>Since my README is a Markdown file, I also need to indicate that it needs to be processed as Markdown text with UTF-8 encoding, via the <code>long_description_content_type</code> keyword argument. If the README were instead written in reStructuredText (another markup language), I’d indicate that with the argument <code>'text/x-rst'</code>. Otherwise, if this keyword argument is omitted, it defaults to <code>'text/plain'</code>. If you view my project on PyPI (<a href="https://pypi.org/project/Timecard-App/" class="LinkURL">https://pypi.org/project/Timecard-App/</a>), you’ll see that the <em>README.md</em> is used as the body of the page.</p>
<p>I also include the license information. There are three ways to do that: explicitly via a string value on the <code>license</code> key, via a single file with <code>license_file</code>, or via multiple files with <code>license_files</code>. Since I only have one license for the whole project, and that is in a <em>LICENSE</em> file, I’ll use the second option:</p>
<pre><code>license_file = LICENSE</code></pre>
<p class="CodeListingCaption"><a id="listing18-4">Listing 18-4</a>: <em>setup.cfg:4</em></p>
<p><span epub:type="pagebreak" title="522" id="Page_522"/>Next, I’ll include more information about the project authorship:</p>
<pre><code>author = Jason C. McDonald
author_email = codemouse92@outlook.com
url = https://github.com/codemouse92/timecard
project_urls =
    Bug Reports = https://github.com/codemouse92/timecard/issues
    Funding = https://github.com/sponsors/CodeMouse92
    Source = https://github.com/codemouse92/timecard</code></pre>
<p class="CodeListingCaption"><a id="listing18-5">Listing 18-5</a>: <em>setup.cfg:5</em></p>
<p>I indicate the <code>author</code> (myself) and the contact email for the author, <code>author_email</code>. In the case of this project, I’m also the project maintainer. If someone else were responsible for the packaging, their information would be included with the <code>maintainer</code> and <code>maintainer_email</code> keyword arguments.</p>
<p>I also include the <code>url</code> for more information about the project. Optionally, you can include any other links by passing a dictionary to the <code>project_urls</code> argument. The keys are all strings with the link names, as they will be displayed on the PyPI project page. The values are the actual URLs as strings.</p>
<p>To make finding my distribution package in PyPI easier, I include a space-delimited list of keywords:</p>
<pre><code>keywords = time tracking office clock tool utility</code></pre>
<p class="CodeListingCaption"><a id="listing18-6">Listing 18-6</a>: <em>setup.cfg:6</em></p>
<p>If you find yourself translating a <em>setup.py</em> file to a <em>setup.cfg</em>, be aware that <em>setup.py</em> uses a comma-separated list instead. Be sure to revise it when moving it to <em>setup.cfg</em>.</p>
<h4 id="h3-500920c09-0005">Classifiers</h4>
<p class="BodyFirst">PyPI makes use of <em>classifiers</em>, standardized strings that facilitate organizing and searching for packages on the index. The complete list of classifiers can be found at <a href="https://pypi.org/classifiers/" class="LinkURL">https://pypi.org/classifiers/</a>.</p>
<p>I include the relevant classifiers for Timecard in my <em>setup.cfg</em>, like this:</p>
<pre><code>classifiers =
    Development Status :: 5 - Production/Stable
    Environment :: X11 Applications :: Qt
    Natural Language :: English
    Operating System :: OS Independent
    Intended Audience :: End Users/Desktop
    Topic :: Office/Business
    License :: OSI Approved :: BSD License
    Programming Language :: Python
    Programming Language :: Python :: 3
    Programming Language :: Python :: 3.6
    Programming Language :: Python :: 3.7
<span epub:type="pagebreak" title="523" id="Page_523"/>    Programming Language :: Python :: 3.8
    Programming Language :: Python :: 3 :: Only
    Programming Language :: Python :: Implementation :: CPython</code></pre>
<p class="CodeListingCaption"><a id="listing18-7">Listing 18-7</a>: <em>setup.cfg:7</em></p>
<p>I’ve included all of the relevant classifiers for my project above as a list of strings. Your project’s classifier list will likely be different. Browse the complete classifier list from PyPI and find the ones relevant to your project. A good rule of thumb is to pick at least one for each of the categories—the part of each classifier before the first double colon—in the list above. (If this task feels overwhelming, you can skip this part until you’re ready to distribute.)</p>
<h4 id="h3-500920c09-0006">Including Packages</h4>
<p class="BodyFirst">Now I need to specify what files belong in my package. This is where the <em>src/</em> directory approach I used in structuring my repository really comes in handy. In a new section marked as <code>[options]</code>, I include the following keys and values:</p>
<pre><code>[options]<br/>
package_dir =
    = src
packages = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> find:</code></pre>
<p class="CodeListingCaption"><a id="listing18-8">Listing 18-8</a>: <em>setup.cfg:8a</em></p>
<p>The <code>package_dir</code> key informs setuptools where to find all my packages. It accepts a <em>dict</em>, which in <em>setup.cfg</em> is denoted as an indented, comma-separated list of key-value pairs.</p>
<p>Because I’m using the <em>src/</em> directory approach, I only need to tell setuptools that all packages, denoted by the empty string as the key, are in the directory <code>src</code>. This is recursive, so any nested packages will also be found.</p>
<p>This key does not actually tell setuptools <em>what</em> packages it will find. For that part, I need the <code>packages</code> key. Instead of manually listing all my packages, I can tell setuptools to use its special<code> find_packages()</code> function by passing the value <code>find:</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> (note the trailing colon!). This technique is especially helpful when your project consists of multiple top-level packages.</p>
<p>The <code>find:</code> function can find all the packages in a given directory, but it has to know where to look first. I provide that information in a separate section:</p>
<pre><code>[options.packages.find]
where = src</code></pre>
<p class="CodeListingCaption"><a id="listing18-9">Listing 18-9</a>: <em>setup.cfg:9</em></p>
<p>On the key <code>where</code>, I provide the name of the directory to search for packages on, namely <code>src</code>.</p>
<h4 id="h3-500920c09-0007"><span epub:type="pagebreak" title="524" id="Page_524"/>Including Data</h4>
<p class="BodyFirst">Not everything that ships in a package is code. I need to include some non-code files as well. Returning to my <code>[options]</code> section, I indicate that setuptools will be including some non-code files like this:</p>
<pre><code>[options]
package_dir =
    = src
packages = find:
<b>include_package_data = True</b></code></pre>
<p class="CodeListingCaption"><a id="listing18-10">Listing 18-10</a>: <em>setup.cfg:8b</em></p>
<p>In <em>setup.cfg</em>, the values <code>True</code> and <code>False</code> are interpreted as boolean values, not as strings.</p>
<p>There are two ways to specify what non-code files to include. The approach I’m taking in this project is to use the <em>MANIFEST.in</em> file to list all non-code files I want included in the project. (I’ll cover this file shortly.)</p>
<p>The second approach for including non-code files, which I’m not showing here, is to use the <code>[options.package_data]</code> section. This gives you finer-grained control over what is and isn’t included, but it is likely overkill for your average project. The setuptools documentation has a good example with this approach: <a href="https://setuptools.readthedocs.io/en/latest/userguide/declarative_config.html" class="LinkURL">https://setuptools.readthedocs.io/en/latest/userguide/declarative_config.html</a>.</p>
<h4 id="h3-500920c09-0008">Dependencies</h4>
<p class="BodyFirst">Next, I’ll define my project’s dependencies in the <code>[options]</code> section:</p>
<pre><code>[options]
package_dir =
    = src
packages = find:
include_package_data = True
<b>python_requires = &gt;=3.6, &lt;4</b></code></pre>
<p class="CodeListingCaption"><a id="listing18-11">Listing 18-11</a>: <em>setup.cfg:8c</em></p>
<p>I can specify the version of Python that the project requires, using <code>python_requires</code> in place of a package name. Notice the key and value are still separated by an equal sign, even though the value may also start with an equal, greater-than, or less-than sign. Something like <code>python_requires = ==3.8</code> is completely valid, as the <code>==3.8</code> is a string.</p>
<p>I denote that Timecard requires Python 3.6 or later. I also assume it won’t work with the theoretical Python 4, since major releases of Python aren’t guaranteed to be backward compatible.</p>
<p>Next, I’ll list the packages that my project depends on:</p>
<pre><code>[options]
package_dir =
    = src
packages = find:
<span epub:type="pagebreak" title="525" id="Page_525"/>include_package_data = True
python_requires = &gt;=3.6, &lt;4
<b>install_requires =</b>
<b>    PySide2&gt;=5.15.0</b>
<b>    appdirs&gt;=1.4.4</b></code></pre>
<p class="CodeListingCaption"><a id="listing18-12">Listing 18-12</a>: <em>setup.cfg:8d</em></p>
<p>The <code>install_requires</code> key expects an indented list of values. Each value in the list specifies a Python package dependency. Timecard relies on the <code>PySide2</code> library and uses features introduced in version 5.15.0 of that library. Technically, I could have omitted the version and merely listed <code>PySide2</code>, but that is often a bad idea. It’s better to test the different versions and determine the oldest one your code will work with. You can always set this to the version you are currently using and change it later.</p>
<p>I could also require certain packages only for particular versions of Python. I don’t need this behavior in this example, but here’s what it might look like if I wanted to install PySide2 only for Python 3.7 and earlier:</p>
<pre><code>install_requires =
    PySide2&gt;=5.15.0<b>; python_requires &lt;= "3.7"</b>
    appdirs&gt;=1.4.4</code></pre>
<p>After a semicolon at the end of the dependency I want to limit, I include <code>python_requires</code>, a comparison operator, and the version <em>in quotes</em>. The quotes are necessary, or you’ll get a cryptic <code>Expected stringEnd</code> error.</p>
<p>In practice, it is seldom necessary to only install packages for certain versions of Python.</p>
<p>Optionally, I can use the <code>[options.extras_require]</code> section to specify additional packages used for certain optional features. For example, if I wanted to allow installing this distribution package with tests, I’d need the following:</p>
<pre><code>[options.extras_require]
test =
    pytest</code></pre>
<p class="CodeListingCaption"><a id="listing18-13">Listing 18-13</a>: <em>setup.cfg:10</em></p>
<p>When I install Timecard via <code>pip install Timecard-App[test]</code>, it will install both the Timecard distribution package and everything I listed under <code>test</code> here. You can name the keys whatever you like, as long as you use alphanumeric characters and underscores. You can also include as many keys as you like.</p>
<h4 id="h3-500920c09-0009">Adding Entry Points</h4>
<p class="BodyFirst">Lastly, I need to specify the <em>entry points</em>, the means by which a user starts the program. Instead of having to write custom executable Python scripts to serve as entry points, I can let setuptools do this for me. It will even create these scripts as <em>.exe</em> files on Windows.</p>
<p><span epub:type="pagebreak" title="526" id="Page_526"/>Entry points are specified in the section <code>[options.entry_points]</code>, like this:</p>
<pre><code>[options.entry_points]
gui_scripts =
    Timecard-App = timecard.__main__:main</code></pre>
<p class="CodeListingCaption"><a id="listing18-14">Listing 18-14</a>: <em>setup.cfg:11</em></p>
<p>There are two possible keys here: <code>'gui_scripts'</code>, for starting the program’s GUI, and <code>'console_scripts'</code>, for starting the command-line version of the program. The value of each is a list of strings containing assignment statements, which assign a particular function to a name that will be the name of the executable file or script. In this case, Timecard needs a single GUI script named <em>Timecard-App</em>, which calls the <code>main()</code> function in the module <em>timecard/__main__.py</em>.</p>
<h3 id="h2-500920c09-0008">The setup.py File</h3>
<p class="BodyFirst">Before <em>setup.cfg</em> became the convention, most projects used <em>setup.py</em> to store their project’s metadata and build instructions. All the information now provided to <em>setup.cfg</em> was instead passed directly to the <code>setuptools.setup()</code> function as keyword arguments.</p>
<p>The <em>setup.py</em> file is a Python module like any other, so using it for packaging configuration is considered <em>imperative</em>—it focuses on how packaging takes place. This stands in contrast to the data-centric (and more error-proof) <em>declarative</em> approach with <em>setup.cfg</em>.</p>
<p>One difficulty with this approach was that folks tended to get clever about their setup configurations. All manner of unrelated functionality crept in: scraping versions from files, creating git tags, publishing to PyPI, and so on. This ran the risk of introducing confusing bugs into the packaging process, which is already particularly hard to debug and could utterly block someone else’s packaging efforts. This has happened to me before!</p>
<p>Thankfully, in many modern projects, <em>setup.py</em> is no longer needed at all; <em>setup.cfg</em> can be used for all setuptools configurations instead.</p>
<p>However, if your project needs good backward compatibility, uses C-extensions, or requires tools that depend on <em>setup.py</em>, you will want to include the following minimal <em>setup.py</em> file:</p>
<pre><code>from setuptools import setup
setup()</code></pre>
<p class="CodeListingCaption"><a id="listing18-15">Listing 18-15</a>: <em>setup.py</em></p>
<p>That file merely imports the <code>setup()</code> function from the <code>setuptools</code> module and calls it. In the past, all the packaging data would have been passed to <code>setup()</code> as keyword arguments, but now, that all lives in <em>setup.cfg</em>.</p>
<p>No shebang line is necessary in this file; let the build tools find the interpreter they want to use.</p>
<h3 id="h2-500920c09-0009"><span epub:type="pagebreak" title="527" id="Page_527"/>The MANIFEST.in File</h3>
<p class="BodyFirst">The <em>manifest template</em>, <em>MANIFEST.in</em>, provides a list of all the non-code files that should be included in the distribution package. These files can come from anywhere in your repository.</p>
<pre><code>include LICENSE *.md</code></pre>
<p class="CodeListingCaption"><a id="listing18-16">Listing 18-16</a>: <em>MANIFEST.in:1</em></p>
<p>Since my setup files are using the <em>README.md</em> and <em>LICENSE</em> files, I must include them here. I can list any number of files after an <code>include</code> directive, separating each with spaces. Manifest templates also support <em>glob patterns</em>, wherein I can use an asterisk (<code>*</code>) as a wildcard. For example, <code>*.md</code> matches all Markdown files, so any markdown files in the root of my repository, including <em>README.md</em>, are automatically included.</p>
<p>I also want to include all the files in the directories <em>src/timecard/resources/</em> and <em>distribution_resources/</em>:</p>
<pre><code>graft src/timecard/resources
graft distribution_resources</code></pre>
<p class="CodeListingCaption"><a id="listing18-17">Listing 18-17</a>: <em>MANIFEST.in:2</em></p>
<p>The <code>graft</code> keyword includes all files that are in the specified directories and below. The <em>distribution_resources/</em> directory is where I keep OS-specific installation files for this particular project.</p>
<p>There are a few more important directives, which I’m not using for Timecard. Here’s a more complex example with a different <em>MANIFEST.in</em> file (not belonging to my Timecard project):</p>
<pre><code>recursive-include stuff *.ini
graft data
prune data/temp
recursive-exclude data/important *.scary</code></pre>
<p>In this example, I add all files under the <em>stuff/</em> directory that have the <em>.ini</em> file extension. Next, I include the entire <em>data/</em> directory with the <code>graft</code> directive. The <code>prune</code> directive then goes back and excludes all files in the <em>data/temp/</em> subdirectory. I also exclude all files in <em>data/important/</em> that have the <em>.scary</em> file extension. None of the excluded files are deleted, but they are left out of the package.</p>
<p>The order of lines in the manifest template matters. Each subsequent directive adds to or removes from the list of files compiled by the prior lines. If you were to move the <code>prune</code> directive above the <code>graft</code> directive, the files in <em>data/temp/</em> would <em>not</em> be excluded!</p>
<p>Your manifest template will be used by setuptools to compile a <em>MANIFEST</em> file, which contains a complete list of all the non-code files <span epub:type="pagebreak" title="528" id="Page_528"/>being included in your distribution package. While you could theoretically write this <em>MANIFEST</em> file yourself, listing one file per line, this is strongly discouraged, as it’s easier to mess up the <em>MANIFEST</em> file than the <em>MANIFEST.in</em> file. Trust setuptools to follow the directives you give it in the manifest template.</p>
<p>There are a few more directives and patterns that you can use in <em>MANIFEST.in</em>. Check out <a href="https://packaging.python.org/guides/using-manifest-in/" class="LinkURL">https://packaging.python.org/guides/using-manifest-in/</a> for more information.</p>
<h3 id="h2-500920c09-0010">The requirements.txt File</h3>
<p class="BodyFirst">You may remember this file from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. The <em>requirements.txt</em> file contains a list of Python packages that your project depends on. This probably sounds like its duplicating <code>install_requires</code> from <em>setup.cfg</em>, but I usually recommend that you use both, for reasons I’ll describe shortly.</p>
<p>Here’s the <em>requirements.txt</em> for Timecard:</p>
<pre><code>PySide2 &gt;= 5.11.0
pytest</code></pre>
<p class="CodeListingCaption"><a id="listing18-18">Listing 18-18</a>: <em>requirements.txt</em></p>
<p>You may wonder if there is a way to use the contents of <em>requirements.txt</em> in <em>setup.cfg</em>, but in fact, it’s best if you keep the two separate. In practice, they serve slightly different purposes.</p>
<p>While the requirements listed in <em>setup.cfg</em> include everything you need to install your distribution package, the <em>requirements.txt</em> file is best thought of as a list of everything you need to re-create the complete development environment—all the optional packages and development tools needed to participate in developing your project, as opposed to merely using it.</p>
<p>Under some circumstances, you may omit <em>requirements.txt</em> if you list all your development dependencies as optional dependencies. The other benefit of using <em>requirements.txt</em>, however, is the ability to use a specific version of a library or tool—called <em>pinning</em>—for development, while enforcing looser version requirements for your users via <em>setup.cfg</em>. For example, your application might require <code>click &gt;= 7.0</code>, but you’re developing the new version to use <code>click == 8.0.1</code> in particular. Pinning is mainly useful for application development. If you’re developing a library, it’s best to avoid pinning, since you can’t really make good assumptions about the package versions that a user of your library will need.</p>
<p>Another major benefit of having a <em>requirements.txt</em> file is that, as mentioned in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, you can quickly install everything needed for development in one step:</p>
<pre><code>pip install -r requirements.txt</code></pre>
<p>I still recommend you keep <em>requirements.txt</em> to the things that your project truly needs, especially when versions matter. You generally wouldn’t include <span epub:type="pagebreak" title="529" id="Page_529"/>tools like <code>black</code> or <code>flake8</code>, which can be swapped out for other tools without breaking anything. Sometimes, I’ll create a separate <em>dev-requirements.txt</em> file (or <em>requirements.dev.txt</em>, if you prefer) with all of my optional development tools. Then, to set up my complete environment in a virtual environment, I’ll only need to run the following:</p>
<pre><code>pip install -r requirements.txt -r dev-requirements.txt</code></pre>
<p>If you have quite a number of packages installed in your working virtual environment, it can be a pain to try to turn this into a <em>requirements.txt</em> file. To aid you in this, you can use the command <code>pip freeze</code> to generate a complete list, with versions, of all packages installed in the environment. Then, you can redirect the contents into a file:</p>
<pre><code>venv/bin/pip freeze &gt; requirements.txt</code></pre>
<p>That command works the same on Windows, macOS, and Linux, exporting the complete list of packages installed within <em>venv/</em>, dependencies and all, to the file <em>requirements.txt</em>. Be sure to inspect that file for errors and <em>remove your own package from it</em>—it wouldn’t make sense for your package to rely on itself.</p>
<p>If you want both <em>requirements.txt</em> and <em>dev-requirements.txt</em>, you’ll want to <code>pip freeze</code> on two separate virtual environments: one that runs your package, and the other that contains your complete development environment. In both cases, inspect the output file and remove your own package from it!</p>
<h3 id="h2-500920c09-0011">The pyproject.toml File</h3>
<p class="BodyFirst">The <em>pyproject.toml</em> file serves a few purposes, but the most important is to specify the <em>build system</em> used to package your project, a standard introduced in PEP 517 and PEP 518.</p>
<pre><code>[build-system]
requires = ["setuptools&gt;=40.8.0", "wheel"]
build-backend = "setuptools.build_meta"</code></pre>
<p class="CodeListingCaption"><a id="listing18-19">Listing 18-19</a>: <em>pyproject.toml</em></p>
<p>The <code>[build-system]</code> section contains information about what packages are needed for building the distribution package: in this case, <code>setuptools</code> and <code>wheel</code>. These requirements are specified by assigning a list of strings to <code>requires</code>, with each string following the same convention as <code>install_requires</code> in <em>setup.py</em>. You’ll notice here that I can use any version of <code>wheel</code>, but I must use version 40.8.0 or later of <code>setuptools</code>. The latter is necessary since it is the first version of <code>setuptools</code> that supports PEP 517 and PEP 518.</p>
<p>The <code>build-backend</code> property specifies the scheme used for building the project, in this case, <code>setuptools.build_meta</code>. If you were using a different build tool, such as Poetry or Flit, you’d specify that here, according to the tool’s documentation.</p>
<p><span epub:type="pagebreak" title="530" id="Page_530"/>The <em>pyproject.toml</em> file is also one of the common files for storing Python tool configurations. Many of the major linters, autoformatters, and testing tools (albeit not all of them) support their configurations being stored in this file.</p>
<p>PEP 518 introduced the <em>pyproject.toml</em> file for project configuration, but it can increasingly be used to store tool configuration as well, thereby cutting down on the number of files in a project. There is heated debate about adding support for <em>pyproject.toml</em> to some prominent tools like Flake8. It’s not as straightforward as it looks. If you really want Flake8 and <em>pyproject.toml</em> to play well together, check out <em>Flake9</em>, a fork of Flake8 that accomplishes just that.</p>
<h3 id="h2-500920c09-0012">Testing the Setup Configuration</h3>
<p class="BodyFirst">If everything has been configured correctly, you’ll be able to install your project in a virtual environment. I’ll do that now, using the following command (assuming I have a fresh virtual environment called <code>venv</code>):</p>
<pre><code>venv/bin/pip install .</code></pre>
<p>I particularly recommend testing this out in a fresh virtual environment the first time. The trailing dot installs whatever package is detailed by the <em>setup.cfg</em> file in the current directory.</p>
<p>Watch the output when you install and correct any warnings or errors. Once your package is installed successfully, try to run your project using the entry point(s) you specified in the <em>setup.cfg</em>, which should be installed as executables in the <em>bin/</em> directory of the virtual environment. I’d run the following:</p>
<pre><code>venv/bin/Timecard-App</code></pre>
<p>If your project is a library, rather than an application, open the Python shell within the virtual environment (<code>venv/bin/python</code>) and import the library.</p>
<h4 id="h3-500920c09-0010">Troubleshooting</h4>
<p class="BodyFirst">Take the time to test out your project now. Does everything work as expected? Most packaging and distribution tools depend on this instance working correctly! If you encounter any new bugs or errors, go back and fix them. A few common causes of problems appearing only in a virtual-environment installation of your project include the following:</p>
<ul>
<li>Missing dependencies that need to be added to <em>setup.cfg</em></li>
<li>Data files not being included correctly via the <em>MANIFEST.in</em> or <em>setup.cfg</em> files</li>
<li>False assumptions in your code about the current working directory</li>
</ul>
<p><span epub:type="pagebreak" title="531" id="Page_531"/>Once you have your distribution package installed and working in a virtual environment, you’re ready to move on to the next step!</p>
<h4 id="h3-500920c09-0011">Installing as Editable</h4>
<p class="BodyFirst">In some circumstances, it can be useful to install your project in editable mode, so the virtual environment will directly use the source code files in <em>src/</em>. Any changes made to the code will immediately be reflected in the test installation.</p>
<p>To install in editable mode, supply the <code>-e</code> flag to <code>pip</code>, like this:</p>
<pre><code>venv/bin/pip install -e .</code></pre>
<p>Installing your package in editable mode makes testing and development a lot easier, as you don’t have to reinstall the package each time. However, it’s not without its drawbacks. Installing in editable mode can make it possible for the virtual environment to find external packages and modules that were not explicitly required in <em>setup.cfg</em>, thereby covering up packaging problems. Only use <code>-e</code> for testing your code, not your packaging.</p>
<h2 id="h1-500920c09-0004">Building Your Package</h2>
<p class="BodyFirst">Once you’ve ensured that your <em>setup.cfg</em> and related files are configured correctly, it’s time to build your source distribution and wheel artifacts. Run the following commands in your terminal, from the root of your project’s repository.</p>
<pre><code>python3 -m pip install --upgrade setuptools wheel build
python3 -m build</code></pre>
<p>The installation command ensures that <code>setuptools</code>, <code>wheel</code>, and <code>build</code> are installed and up-to-date in the current environment.</p>
<p>The next command builds according to whatever <code>build-backend</code> is specified in <em>pyproject.toml</em>. In this case, the project will be built with setuptools, applying the configuration in the <em>setup.cfg</em> file in the current directory. This command builds a source distribution, or sdist, and a built distribution or wheel.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">	If you need to build your project for Python 2 or a very old Python 3—such that you’re using either an old version of setuptools that doesn’t support PEP 517 and PEP 518 or the deprecated <code>distutils</code>—you’ll need to use the old-style <em>setup.py</em> and invoke that directly with <code>python -m </code><em>setup.py</em><code> sdist bdist_wheel</code>.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>The two artifacts are saved in the newly created <em>dist/</em> directory: the <em>.tar.gz</em> is your source distribution, and the <em>.whl</em> is the <code>build</code> distribution wheel.</p>
<p>There are a few other commands available for <code>build</code>, which you will find in the documentation: <a href="https://pypa-build.readthedocs.io/en/latest/" class="LinkURL">https://pypa-build.readthedocs.io/en/latest/</a>.</p>
<p>Alternatively, if you’re only using the default invocation of <code>build</code>, you can just run <code>pyproject-build</code>.</p>
<h2 id="h1-500920c09-0005"><span epub:type="pagebreak" title="532" id="Page_532"/>Publishing on pip (Twine)</h2>
<p class="BodyFirst">From here, you’re ready to publish your distribution package! In this section, I’ll do exactly that with Timecard.</p>
<h3 id="h2-500920c09-0013">Uploading to Test PyPI</h3>
<p class="BodyFirst">Before you upload your project to the official PyPI index, test everything out one more time via Test PyPI, which is an altogether separate index specifically for testing out the tools. If you’re experimenting, you’re welcome to use Test PyPI. Packages and user accounts are periodically pruned, so don’t worry if you leave a bit of a mess.</p>
<p>To upload to the index, you must first create an account at <a href="https://test.pypi.org/account/register/" class="LinkURL">https://test.pypi.org/account/register/</a>. If you had one a while back but it’s not working now, don’t worry; as part of the regular pruning, old accounts are deleted. You can safely make a new one.</p>
<p>Once you’re logged in, go to <b>Account settings</b> and scroll down to <b>API tokens</b>. Select <b>Add API Token</b>. You can name this token whatever you like, but be certain you set Scope to <b>Entire account</b> if you’re uploading a new project.</p>
<p>After creating the API token, you must save the entire token (including the leading <code>pypi-</code>) before leaving the page, as it will never be shown again. You’ll need this token in the next step.</p>
<p>By the way, you can always delete tokens from the Account settings page. Do this any time you no longer remember the token or have no need of it anymore.</p>
<p>I’ll upload my Timecard-App distribution package to Test PyPI. (You’ll need to try uploading a package with a different name; Timecard-App will be taken by the time you read this.) For this step, I use a package called <em>twine</em>, which I install to my user environment:</p>
<pre><code>python3 -m pip install --upgrade twine</code></pre>
<p>I use twine to upload the artifacts from my project’s <em>dist/</em> directory:</p>
<pre><code>twine upload --repository testpypi dist/*</code></pre>
<p>Notice I’ve explicitly specified that I’m uploading to the <em>testpypi</em> repository, which twine knows about by default.</p>
<p>When prompted, enter the username <em>__token__</em> and use your API key from earlier as the password:</p>
<pre><code>Enter your username: <var class="bold">__token__</var>
Enter your password: <var>(your API token here)</var></code></pre>
<p>Watch the terminal output carefully for any errors or warnings. If you need to make any corrections to your project or its packaging files, be certain to delete the <em>dist/</em> directory and cleanly rebuild the <em>sdist</em> and <em>bdist_wheel</em> artifacts before trying to upload again.</p>
<p><span epub:type="pagebreak" title="533" id="Page_533"/>If all goes well, you will be given a URL where you can see your distribution package on Test PyPI. Make sure everything on that page looks correct.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">	As you may have noticed, pip works with more than just the default PyPI. If you need to, you can run your <em>own</em> Python package repository using devpi (<a href="https://devpi.net/" class="LinkURL">https://devpi.net/</a>) or your own PyPI mirror with Bandersnatch (<a href="https://bandersnatch.readthedocs.io/" class="LinkURL">https://bandersnatch.readthedocs.io/</a>).</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c09-0014">Installing Your Uploaded Package</h3>
<p class="BodyFirst">Next, make sure you can install your distribution package from Test PyPI in a <em>fresh</em> virtual environment. I’ll do that now with my Timecard-App distribution package.</p>
<p>For the next step to work, I’ll need to manually install the dependencies for my package. This is one of the reasons I have a separate <em>requirements.txt</em> file:</p>
<pre><code>venv/bin/pip install -r requirements.txt</code></pre>
<p>Now, I can install the package itself. Because this is a particularly long command, I’m splitting it up UNIX-style, with the backslash character (<code>\</code>):</p>
<pre><code>venv/bin/pip install \
    --index-url https://test.pypi.org/simple/ \
    --no-deps/ \
    Timecard-App</code></pre>
<p>Because I’m testing the distribution package I uploaded to Test PyPI, rather than the regular PyPI, I have to explicitly tell pip to use that as the source repository, which I do with the <code>--index-url</code> argument. However, I don’t want to install any of the package dependencies from <a href="http://test.pypi.org" class="LinkURL">test.pypi.org</a>—they might be missing, broken, malicious copycats, or otherwise wrong—so I pass the <code>--no-deps</code> flag. Finally, I specify that I’m installing the distribution package <code>Timecard-App</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">	Don’t get the idea that you can somehow get the dependency packages from the normal PyPI using the <code>--extra-index-url</code> argument you may have read about somewhere. If a package appears in both the main index and the extra index or indices you specify, Python isn’t always predictable about which one it picks.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If all went well, I should be able to invoke Timecard-App within that virtual environment:</p>
<pre><code>venv/bin/Timecard-App</code></pre>
<p>I try it out as before, to make sure everything works as expected, and it does! At this point, I’d want to try it out on other machines to ensure it functions as expected. I can use the <code>pip install</code> command from a moment ago to install this distribution package on any machine that’s connected to the internet.</p>
<h3 id="h2-500920c09-0015"><span epub:type="pagebreak" title="534" id="Page_534"/>Uploading to PyPI</h3>
<p class="BodyFirst">Once I’m certain that Timecard-App is ready for prime time, I can repeat the entire upload process with PyPI at <a href="https://pypi.org/" class="LinkURL">https://pypi.org/</a>: create a user account (if necessary), log in, create an API key, and finally upload with this:</p>
<pre><code>twine upload dist/*</code></pre>
<p>The official PyPI is the default target, so once that upload completes, you’ll be given a new URL: the one for your project on the PyPI. Congratulations! You can now share this link exuberantly. You’ve shipped software!</p>
<h2 id="h1-500920c09-0006">Alternative Packaging Tools</h2>
<p class="BodyFirst">As you can see, pip, setuptools, wheel, and twine do a pretty good job these days, but there are a lot of steps and details to using them. There are a couple of alternative tools you may benefit from learning on your own.</p>
<h3 id="h2-500920c09-0016">Poetry</h3>
<p class="BodyFirst">If you only learn one of these alternative tools, make it this one!</p>
<p>Instead of using four different tools, some Python developers prefer <em>Poetry</em>, which handles everything from dependency management to building and publishing your distribution package. Absolutely all of the packaging configuration, from dependencies to metadata, goes into <em>pyproject.toml</em>.</p>
<p>Learning how to use Poetry is easy because it has excellent, succinct documentation, which is especially clear if you’re already somewhat familiar with setuptools. Information, installation instructions, and documentation can all be found at <a href="https://python-poetry.org/" class="LinkURL">https://python-poetry.org/</a>.</p>
<h3 id="h2-500920c09-0017">Flit</h3>
<p class="BodyFirst"><em>Flit</em> is a tool that focuses on making the easy packaging scenarios easier—namely, by building and publishing pure Python distribution packages—and leaving the hard stuff for other, more complex tools to handle. It uses a few simple commands to handle building and publishing your distribution package. Many of the ideas from Flit have trickled into other tools and workflows.</p>
<p>The official documentation is the best place to find more information about Flit: <a href="https://flit.readthedocs.io/en/latest/index.html" class="LinkURL">https://flit.readthedocs.io/en/latest/index.html</a>.</p>
<h2 id="h1-500920c09-0007">Distributing to End Users</h2>
<p class="BodyFirst">There is still one leg of the journey to go before you reach your goal of being able to distribute software to end users. Installing via pip is not a good means of distributing your software to end users, for two reasons. First, most users don’t know anything about pip. Second, pip was never intended to deploy software in that manner. There are too many things that <span epub:type="pagebreak" title="535" id="Page_535"/>could go wrong when installing from PyPI, all of which would require the intervention of a Python developer well-versed in the ways of pip. To ship software to non-developers, you need a more robust, user-oriented solution.</p>
<p>Mahmoud Hashemi describes layers of the packaging gradient for shipping to an end user. I’ve adapted them here:</p>
<ol class="decimal">
<li value="1"><b>PEX:</b> Uses system-wide Python.</li>
<li value="2"><b>Freezers:</b> Includes Python.</li>
<li value="3"><b>Images and containers:</b> Includes most or all system dependencies.</li>
<li value="4"><b>Virtual machines:</b> Includes <em>kernel</em>, the “heart” of the operating system.</li>
<li value="5"><b>Hardware:</b> Includes . . . well, everything!</li>
</ol>
<p>Let’s look at each of these options in a little more depth and consider which would be appropriate for Timecard.</p>
<h3 id="h2-500920c09-0018">PEX</h3>
<p class="BodyFirst">The lowest-level option for distributing a stand-alone artifact—one that doesn’t need to be installed from pip—is a format called PEX (short for Python Executable). It allows you to package an entire virtual environment as a stand-alone file, which is essentially a neatly structured <em>.zip</em> file. This PEX file then relies on the Python interpreter provided by whatever system it’s being run on. Once you have a PEX, you can distribute it to anyone on Mac or Linux who has Python installed.</p>
<p>PEX is far from intuitive, in terms of usage. It’s easy enough to turn a virtual environment into a PEX, but actually specifying a script to run on execution takes a bit more work. What’s more, PEX only works on Mac or Linux, so it’s not a viable option if you need to distribute on Windows.</p>
<p>Since PEX is oriented toward developers, it’s definitely not a good fit for distributing Timecard. If you want to learn more about PEX, read their documentation at <a href="https://pex.readthedocs.io/" class="LinkURL">https://pex.readthedocs.io/</a>. Alex Leonhardt also has an excellent article about PEX (<a href="https://medium.com/ovni/pex-python-executables-c0ea39cee7f1" class="LinkURL">https://medium.com/ovni/pex-python-executables-c0ea39cee7f1</a>) that is considerably easier to digest than the documentation.</p>
<h3 id="h2-500920c09-0019">Freezers</h3>
<p class="BodyFirst">The most portable means by far of packaging and distributing a Python application is with a <em>freezer</em>, which bundles the compiled Python code, the Python interpreter, and all the package dependencies into a single artifact. With some freezers, system dependencies are included as well. The benefit of all this is that you wind up with a single executable file in the target system’s preferred format, at the cost of an increased artifact size (usually by about 2–12 MB).</p>
<p>Far and away, this is one of the most common ways of distributing Python applications. It’s used by such programs as Dropbox and Eve Online.</p>
<p>There are a number of freezers in existence, but the three most common at present are <em>PyInstaller</em>, <em>cx_Freeze</em>, and <em>py2app</em>. If you’re building <span epub:type="pagebreak" title="536" id="Page_536"/>GUI-based applications with the Qt 5 toolkit, <em>fman Build System</em> is another great option. Yet another option is <em>py2exe</em>, although it is presently unmaintained.</p>
<h4 id="h3-500920c09-0012">PyInstaller</h4>
<p class="BodyFirst">My personal favorite freezer is PyInstaller. It has the particular advantage of working on all major operating systems. Although you will need to run PyInstaller separately on each of the targeted environments, you will seldom need to configure it more than once.</p>
<p>There is quite a bit to learn about PyInstaller. You’ll find extensive guidance for its use, as well as how to handle various errors and tricky situations, in the official documentation: <a href="https://pyinstaller.readthedocs.io/" class="LinkURL">https://pyinstaller.readthedocs.io/</a>.</p>
<h4 id="h3-500920c09-0013">PyOxidizer</h4>
<p class="BodyFirst">One of the newer kids on the block is PyOxidizer. It’s a promising-looking cross-platform tool for converting your project into a single executable file, bundled with the Python interpreter. The focus is on ensuring it remains easy to package, distribute, and install the end product.</p>
<p>Complete documentation, as well as a breakdown of what gives PyOxidizer an advantage over other tools, can be found at <a href="https://pyoxidizer.readthedocs.io/en/stable/index.html" class="LinkURL">https://pyoxidizer.readthedocs.io/en/stable/index.html</a>.</p>
<h4 id="h3-500920c09-0014">py2app</h4>
<p class="BodyFirst">If you only want to package your project for macOS, <em>py2app</em> is a great option. It works off your project’s <em>setup.py</em> file and freezes down into a single <em>.app</em> file.</p>
<p>To learn more about py2app, see the official documentation at <a href="https://py2app.readthedocs.io/en/latest/tutorial.html" class="LinkURL">https://py2app.readthedocs.io/en/latest/tutorial.html</a>.</p>
<h4 id="h3-500920c09-0015">cx_Freeze</h4>
<p class="BodyFirst">Another option for freezing your project is <em>cx_Freeze</em>, a cross-platform tool for building on Windows, Mac, and Linux. It’s quite a bit older than PyInstaller, but it still works well. If you’re having trouble with PyInstaller or py2app, try this one.</p>
<p>Information and documentation can be found at <a href="https://cx_freeze.readthedocs.org/" class="LinkURL">https://cx_freeze.readthedocs.org/</a>.</p>
<h4 id="h3-500920c09-0016">fman Build System</h4>
<p class="BodyFirst">If you’re building a GUI-based application using the Qt 5 library—Timecard is one such application—you can build and package your project once for all operating systems with <em>fman Build System</em>. Unlike other tools, it even creates an executable installer on Windows, a <em>.dmg</em> on macOS, a <em>.deb</em> package on Debian-based Linux, an <em>.rpm</em> on Fedora-based Linux, and a <em>.tar.xz</em> for everyone else.</p>
<p><span epub:type="pagebreak" title="537" id="Page_537"/>The fman freezer requires you to set up your project in a particular manner, so if you want to use it, you’ll have the best results if you use it from the start of your project. Otherwise, you’ll need to restructure it according to what fman Build System needs (which is why Timecard doesn’t use it).</p>
<p>You can find more information, a great tutorial, and the complete documentation at <a href="https://build-system.fman.io/" class="LinkURL">https://build-system.fman.io/</a>.</p>
<h4 id="h3-500920c09-0017">Nuitka</h4>
<p class="BodyFirst">I mentioned back in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> that the <em>Nuitka</em> compiler allows you to transpile Python code to C and C++ and then assemble that down to machine code. Nuitka is practically a separate implementation, and the end-result executable is about two times faster than CPython.</p>
<p>As of the date of this writing, Nuitka has reached feature parity with Python 3.8. They’re working on adding 3.9+ features and further optimization. In any case, this is an exciting project to watch.</p>
<p>If you want truly “compiled” Python code, this is the tool you’re looking for. More information and documentation are available at <a href="https://nuitka.net/pages/overview.html" class="LinkURL">https://nuitka.net/pages/overview.html</a>.</p>
<h3 id="h2-500920c09-0020">Images and Containers</h3>
<p class="BodyFirst">All the packaging options I’ve covered up to this point are limited by a common factor: what system libraries are installed on the user’s machine. It’s possible to bundle some of these libraries, such as is seen with PyInstaller, but those are still subject to their <em>own</em> dependencies, some of which cannot be bundled. When you start getting into more complex applications, this can become a tricky problem to solve.</p>
<p>This becomes particularly difficult when distributing on Linux. With so many Linux-based operating systems (each with multiple versions) and countless combinations of packages, building once for all can be a royal pain. The solution is found in <em>containers</em>, which are self-contained environments that bring all their own dependencies. Multiple applications can be installed on the system, each in its own container, and it won’t matter if they have different or even conflicting dependencies.</p>
<p>Another advantage of using containers is <em>sandboxing</em>, which limits the containerized application’s access to the system. This provides transparency and control to users: they know what privileges any given container has, and in many cases, they can control those privileges.</p>
<p>At present, there are four major containers: <em>Flatpak</em>, <em>Snapcraft</em>, <em>Appimage</em>, and <em>Docker</em>. Each one has unique advantages.</p>
<h4 id="h3-500920c09-0018">Flatpak</h4>
<p class="BodyFirst"><em>Flatpak</em> allows you to package an application as a standalone unit that can be installed on virtually any Linux environment, as well as Chrome OS. It is highly forward compatible, meaning your package will continue to work even on as-yet unreleased versions of operating systems that support <span epub:type="pagebreak" title="538" id="Page_538"/>Flatpak. It is not a container in the strictest sense, but it functions similarly. Even so, installed Flatpaks can share some dependencies they might have in common.</p>
<p>One of the reasons I particularly like Flatpak is that you can select or build each of the dependencies or components you need. I can know that if my Flatpak works on my machine, it will work on others. The extra degree of control and predictability it provides makes it easier to work with snarly packaging scenarios in Python.</p>
<p>Flatpak also has its own app store, <em>Flathub</em>, which makes it easy for end users to browse and install applications on their Linux machines. For more information about and complete documentation on Flatpak, see their official website: <a href="https://flatpak.org/" class="LinkURL">https://flatpak.org/</a>.</p>
<p>You can see how I packaged Timecard with Flatpak here: <a href="https://github.com/flathub/com.codemouse92.timecard" class="LinkURL">https://github.com/flathub/com.codemouse92.timecard</a>.</p>
<h4 id="h3-500920c09-0019">Snapcraft</h4>
<p class="BodyFirst">The <em>Snapcraft</em> format, maintained by Canonical (the company behind the Ubuntu operating system), packages your application into a dedicated container with its own filesystem. It is sandboxed from the rest of the system, accessing and sharing as little as possible. Because of its structure, you can build snaps from any development environment, including Windows and macOS, although you cannot install snaps in those environments. Snapcraft also has its own associated app store, the <em>Snap Store</em>.</p>
<p>Unfortunately, the footprint of an installed snap can be quite large, as it brings everything <em>for each container</em>, excepting the kernel and a handful of core dependencies; it does not share dependencies between snaps. It also can be difficult to give a snap the correct permissions for many user applications to function. Due to these and other criticisms, some Linux environments have dropped their official support for Snapcraft.</p>
<p>Despite all this, Snapcraft is still a viable container format with a fairly loyal following. You can learn more about the format and find complete documentation at <a href="https://snapcraft.io/" class="LinkURL">https://snapcraft.io/</a>.</p>
<h4 id="h3-500920c09-0020">AppImage</h4>
<p class="BodyFirst">The <em>AppImage</em> format provides self-contained executables that don’t require anything, including themselves, to be installed. In many ways, an AppImage behaves like a macOS application. Unlike Flatpak and Snapcraft, AppImage requires no infrastructure on the target system, although the user may choose to use <em>appimaged</em> to automate registering AppImages with the system.</p>
<p>AppImage is intended to be decentralized, allowing you to provide your own download to the end user. You can even issue updates to your package by integrating <em>AppImageUpdate</em>. Technically, AppImage does have an app store of sorts, <em>AppImageHub</em>, where you can browse through many of the apps that are packaged in the format. New apps are added via a pull request against the store on GitHub.</p>
<p><span epub:type="pagebreak" title="539" id="Page_539"/>The sole disadvantage of AppImage is that you need to test your package against every Linux distribution you plan to support. Your package <em>can</em> rely on existing system libraries, and in fact, it must do so for a few essentials like <em>libc</em> (the C language standard library, which is used by nearly everything). As a result, this can create a “works on my machine” scenario, where the AppImage may be implicitly relying on a system library and then may fail when run on another Linux system that lacks that library.</p>
<p>To achieve that same aim, it is recommended you build your AppImage on the oldest environment you want to support, as it collects and bundles libraries from the current environment itself. AppImages are pretty decently forward compatible, but they’re not intended to be backward compatible.</p>
<p>Still, if you don’t mind working with some extra environments, AppImage can be a fantastic way to distribute your software to any Linux machine, without any other infrastructure being required. More information about the format and complete documentation can be found at <a href="https://appimage.org/" class="LinkURL">https://appimage.org/</a>.</p>
<h4 id="h3-500920c09-0021">Docker</h4>
<p class="BodyFirst">In modern software development parlance, <em>Docker</em> is usually the first thing that people think of when they hear “container.” It allows you to define a custom environment, bringing everything except the kernel. This is the one format out of the four I’m covering that will work on Windows and macOS, in addition to Linux.</p>
<p>Docker is primarily geared toward deploying on servers, rather than for user applications, as it requires quite a bit of setup on the target machine. Once Docker is configured, it’s relatively trivial to launch an image. This makes it ideal for distributing server applications.</p>
<p>Because a Docker image is a fully self-contained environment, it’s easy to create one for your project. You start by defining a <em>Dockerfile</em>, which outlines the steps for building the image. You start with a base image, such as one for a particular operating system, and you install all the packages and dependencies you need. You can even install via pip in the context of the Dockerfile. Docker converts the Dockerfile into an image, which can be uploaded to a registry like <em>Docker Hub</em> and then downloaded onto the client machine.</p>
<p>Complete information and exhaustive documentation can be found at <a href="https://www.docker.com/" class="LinkURL">https://www.docker.com/</a>.</p>
<h3 id="h2-500920c09-0021">A Note on Native Linux Packaging</h3>
<p class="BodyFirst">Linux users will notice that I haven’t touched native Debian or Fedora packaging at all. These packaging formats are still relevant, but decreasingly so as more portable formats like the preceding gain in adoption. Both Debian and Fedora packaging can be particularly difficult, while offering few, if any, advantages over portable formats.</p>
<p>In case this sounds faddish, I assure you that I have been among the slowest to consider Flatpak, Snapcraft, and Appimage as viable alternatives to my beloved Debian packages. The difference in end user experience is slightly improved in these newer portable formats, but more importantly, <span epub:type="pagebreak" title="540" id="Page_540"/>the <em>developer</em> experience is significantly better. All three leverage varying degrees of sandboxing, in a manner similar to virtual environments and in stark contrast to native packaging formats, where one must be concerned with the exact versions of dependencies on each end user machine. What’s more, while portable packaging formats generally play well with virtual environments and PyPI, native packaging formats seldom do, especially when used in full compliance with the standards and policies of the distribution’s package repositories.</p>
<p>If you want to package your Python project using Debian or Fedora packaging, you can certainly do so. Tools like <em>dh-virtualenv</em> can help! Still, be prepared for a battle if your project has any significant dependencies. Before you try to distribute your project in any native packaging format, be absolutely certain that portable packaging formats will not suffice. This is a decision only you can make.</p>
<h2 id="h1-500920c09-0008"/><h2 id="h1-500920c09-0009">Documentation</h2>
<p class="BodyFirst">Every project needs documentation, and yes, that includes yours. The best code in the world means nothing if the end user doesn’t know how to install and use it!</p>
<p>In the case of particularly small projects, a single <em>README.md</em> may be sufficient, so long as it is easily discoverable by users. For anything more robust, you need a better solution.</p>
<p>The historic answer to documentation in Python was the built-in module <em>pydoc</em>, but over the past several years, this has been utterly eclipsed by <em>Sphinx</em>. Nearly all documentation in the Python world, including the official documentation for Python itself, is built with Sphinx. In fact, while Sphinx was originally built for Python projects, its robust feature set and ease of use has led to its wide adoption across the entire programming industry.</p>
<p>Sphinx builds the documentation using a markup language called <em>reStructuredText</em>, abbreviated as <em>reST</em>. While a bit more complex and exacting than Markdown, reST is packed full of powerful features for even the most complicated technical writing. The end result can be exported to HTML, PDF, ePUB, Linux man pages, and many other formats.</p>
<p>Your project’s documentation belongs in a separate directory, conventionally named <em>docs/</em>, in the project repository. If you have the <code>sphinx</code> package installed in your environment—usually, your development virtual environment—you can build the basic file structure and configuration by running the following command:</p>
<pre><code>venv/bin/sphinx-quickstart</code></pre>
<p>You will be guided through several questions. For most things, I recommend using the defaults, displayed in square brackets (<code>[ ]</code>) at each prompt, until you know better.</p>
<p>For most of your documentation, you will write your own reStructuredText (<em>.rst</em>) files by hand, saving them in this <em>docs/</em> directory. There is no replacement for handwritten documentation! Expecting a user to learn your <span epub:type="pagebreak" title="541" id="Page_541"/>software purely from API documentation is like teaching someone to use a toaster by explaining the electrical specifications of the heating element.</p>
<p>At the same time, in some projects, especially libraries, it is useful to pull in the docstrings from your code. This is possible with Sphinx as well, using its <em>autodoc</em> feature.</p>
<p>The best way to get started with Sphinx and reStructuredText, including the autodoc feature, is to read the official Quick Start Guide at <a href="https://www.sphinx-doc.org/en/master/usage/quickstart.html" class="LinkURL">https://www.sphinx-doc.org/en/master/usage/quickstart.html</a>. That website also provides the rest of the Sphinx documentation.</p>
<p>When you’re getting ready to release your project, you will almost certainly want to publish your documentation online. For open source projects, one of the easiest ways to do this is to sign up for a free account on Read the Docs. That service specifically works with Sphinx and reStructuredText, and it can automatically update your documentation from your repository. For more information and to sign up, visit <a href="https://readthedocs.org/" class="LinkURL">https://readthedocs.org/</a>.</p>
<h2 id="h1-500920c09-0010">Wrapping Up</h2>
<p class="BodyFirst">When you’re getting ready to start a project, consider how you want to handle packaging. There are a lot of options for packaging and distributing Python applications, so that leaves the question of which tools to use. As the developer of your own project, you’re the only person who can ultimately determine the best packaging scheme for your situation. If you’re completely lost, here’s my own opinion.</p>
<p>First, I strongly recommend using a <em>src/</em> directory for your code. It makes everything else easier. Then, get your project set up so you can install it in a virtual environment with pip. Personally, I use setuptools, although both Poetry and Flit are excellent options; use whichever you like more.</p>
<p>If you’re developing a library or command-line tool for other Python developers to use, plan to publish it to the PyPI. If your project is an end user application or command-line program, I recommend packaging it into a stand-alone artifact using a tool like PyInstaller. For Linux distribution, I also strongly recommend creating a Flatpak. If you’re building a server application, on the other hand, I recommend packaging it into a Docker image.</p>
<p>The last level of the packaging gradient is to deploy your project embedded on hardware. There are countless ways to do this, but some of the more popular options include single-board computers like <em>Arduino</em> and <em>Raspberry Pi</em>. This is a deep enough topic that entire books are dedicated to it. In <span class="xref" itemid="xref_target_Chapter 21">Chapter 21</span>, I’ll refer you to some resources for further study in this arena.</p>
<p>Once again, these are my opinions, based on my own adventures in Python packaging. Regardless, remember that all these tools exist for a reason, and something that works well for my projects may not be suitable for yours. As I said at the start of this chapter, whatever packaging techniques you ultimately use, they should produce a reasonably portable, stable, “just works” package.</p>
</section>
</div>
<div id="sbo-rt-content"><section>

<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="543" id="Page_543"/>19</span><br/>
<span class="ChapterTitle">Debugging and Logging</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Mistakes in code are inevitable. The bugs you’ll encounter can range from simple typos to malformed logic, from misunderstood usage to those strange errors that originate from deeper in the tech stack. As Lubarsky’s Law of Cybernetic Entomology observes, “There is always one more bug.” When things go horribly wrong in your code, you’re going to need the tools to find and fix the problem. In this chapter, you’ll learn all about those tools.</p>
<p>I’ll begin by covering three features of the Python language that you can add to your code to help you debug it later: warnings, logging, and assertions. These are improvements over using print statements for debugging purposes, as you are likely to forget where your “debugging” print statements are or may be tempted to leave them in place in production.</p>
<p>Then, I’ll guide you through the use of the Python debugger (<code>pdb</code>), which helps you step through the logic in your Python program, and <code>faulthandler</code>, <span epub:type="pagebreak" title="544" id="Page_544"/>which enables you to investigate undefined behavior in the C code behind Python. Finally, I’ll discuss using Bandit to check for security problems in your code.</p>
<h2 id="h1-500920c19-0001">Warnings</h2>
<p class="BodyFirst">You can use a <em>warning</em> to notify the user of a problem that the program worked around or alert a developer to an upcoming breaking change in a later version of your library. Unlike an exception, which we discussed in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, a warning won’t crash the program. This is preferable for problems that don’t interfere with the program’s normal function.</p>
<p>In addition, warnings are more convenient than print statements because they’re output to the standard error stream by default. In a print statement like <code>print("My warning message", file=sys.stderr)</code>, I must explicitly output to the standard error stream.</p>
<p>Python offers a warning module with a bevy of additional features and behaviors. To issue warnings, use the <code>warnings.warn()</code> function. For example, this rather theatrical (if silly) program aims to write some text to a file. If the value of <code>thumbs</code> is <code>"pricking"</code>, I issue a warning that something evil is coming. After the warning, I open a file, <em>locks.txt</em>, and write some text to it:</p>
<pre><code>import warnings

thumbs = "pricking"

if thumbs == "pricking":
    warnings.warn("Something wicked this way comes.")

with open('locks.txt', 'w') as file:
    file.write("Whoever knocks")</code></pre>
<p class="CodeListingCaption"><a id="listing19-1">Listing 19-1</a>: <em>basic_warning.py:1a</em></p>
<p>Running that module outputs the following:</p>
<pre><code>basic_warning.py:6: UserWarning: Something wicked this way comes.
  warnings.warn("Something wicked this way comes.")</code></pre>
<p>The warning appears on the terminal via the standard error stream, but importantly, it does not crash the program. The file <em>locks.txt</em> is still created with the desired text:</p>
<pre><code>Whoever knocks</code></pre>
<p class="CodeListingCaption"><a id="listing19-2">Listing 19-2</a>: <em>locks.txt</em></p>
<h3 id="h2-500920c19-0001"><span epub:type="pagebreak" title="545" id="Page_545"/>Types of Warnings</h3>
<p class="BodyFirst">Warnings come in different types, each of which can be treated differently, as you see fit. For example, you should probably let your user know if the program had to work around a missing file on their system, but you may not want to bother them with warnings about weird syntax in the code; such warnings are things only a developer would need to know. Warning categories allow you to handle these different situations in a manner appropriate to your project.</p>
<p><a href="#table19-1" id="tableanchor19-1">Table 19-1</a> lists the various types of warnings, all of which inherit from the <code>Warning</code> base class. Just as you can create a custom <code>Exception</code>, you can create your own types of warnings by inheriting from the <code>Warning</code> class of any of its subclasses in <a href="#table19-1">Table 19-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table19-1">Table 19-1</a>: Warning Categories</p></figcaption>
<table id="table-500920c19-0001" border="1">
<thead>
<tr>
<td><b>Class</b></td>
<td><b>Usage</b></td>
<td><b>Ignored by default</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>UserWarning</code></td>
<td>The default if no category is specified in <code>warn()</code></td>
<td/>
</tr>
<tr>
<td><code>DeprecationWarning</code></td>
<td>Warnings about deprecated features, intended for developers</td>
<td>✓</td>
</tr>
<tr>
<td><code>PendingDeprecationWarning</code></td>
<td>Warnings about features that will be deprecated in the future</td>
<td>✓</td>
</tr>
<tr>
<td><code>FutureWarning</code></td>
<td>Warnings about deprecated features, intended for users (Prior to 3.7, this instead referred to a feature’s behavior being changed.)</td>
<td/>
</tr>
<tr>
<td><code>SyntaxWarning</code></td>
<td>Warnings about potentially problematic syntax</td>
<td/>
</tr>
<tr>
<td><code>RuntimeWarning</code></td>
<td>Warnings about questionable runtime behavior</td>
<td/>
</tr>
<tr>
<td><code>ImportWarning</code></td>
<td>Warnings related to importing modules</td>
<td>✓</td>
</tr>
<tr>
<td><code>UnicodeWarning</code></td>
<td>Warnings related to Unicode</td>
<td/>
</tr>
<tr>
<td><code>BytesWarning</code></td>
<td>Warnings related to bytes-like objects</td>
<td/>
</tr>
<tr>
<td><code>ResourceWarning</code></td>
<td>Warnings related to hardware resource usage</td>
<td>✓</td>
</tr>
</tbody>
</table>
</figure>
<p>This table is up-to-date for Python 3.7 through at least Python 3.10. Earlier versions of Python ignore different warnings by default, meaning you’ll have to explicitly enable those warnings to see them while running the program.</p>
<p><span epub:type="pagebreak" title="546" id="Page_546"/>To issue a particular type of warning, pass the desired <code>Warning</code> class as the second argument of <code>warn()</code>. For irony’s sake, I’ll revise my earlier example to issue a <code>FutureWarning</code>:</p>
<pre><code>import warnings

thumbs = "pricking"

if thumbs == "pricking":
    warnings.warn("Something wicked this way comes.", <b>FutureWarning</b>)

with open('locks.txt', 'w') as file:
    file.write("Whoever knocks")</code></pre>
<p class="CodeListingCaption"><a id="listing19-3">Listing 19-3</a>: <em>basic_warning.py:1b</em></p>
<p>Running that code produces the following output on the terminal, in addition to creating the same <em>locks.txt</em> file as before:</p>
<pre><code>basic_warning.py:6: <b>FutureWarning</b>: Something wicked this way comes.
  warnings.warn("Something wicked this way comes.", <b>FutureWarning</b>)</code></pre>
<h3 id="h2-500920c19-0002">Filtering Warnings</h3>
<p class="BodyFirst">The <em>warnings filter</em> controls how warnings are displayed, and it can be passed as an argument to the Python interpreter when you run a module or package. For example, you can display a warning once or multiple times, hide it altogether, or even cause it to crash a program. (I’ll explain why you’d want to in the Converting Warnings to Exceptions section below.)</p>
<p>Warning filters are composed of five optional fields, separated by colons:</p>
<pre><code><var>action</var>:<var>message</var>:<var>category</var>:<var>module</var>:<var>lineno</var></code></pre>
<p><a href="#table19-2" id="tableanchor19-2">Table 19-2</a> explains what each of those fields does.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table19-2">Table 19-2</a>: Warning Filter Field</p></figcaption>
<table id="table-500920c19-0002" border="1"><tbody>
<tr>
<td><var>action</var></td>
<td>How the warning should be displayed. There are six options for this field: <code>default</code>, <code>error</code>, <code>always</code>, <code>module</code>, <code>once</code>, and <code>ignore</code>. (See <a href="#table19-3" id="tableanchor19-3">Table 19-3</a>.)</td>
</tr>
<tr>
<td><var>message</var></td>
<td>A regular expression that the warning message must match to be filtered.</td>
</tr>
<tr>
<td><var>category</var></td>
<td>The warning category to be filtered.</td>
</tr>
<tr>
<td><var>module</var></td>
<td>The module the warning must occur in to be filtered. (Not to be confused with the <code>module</code> option for the <var>action</var> field.)</td>
</tr>
<tr>
<td><var>lineno</var></td>
<td>The line number where the warning must occur to be filtered.</td>
</tr>
</tbody>
</table>
</figure>
<p>You can omit any field, but you’d still need to include the appropriate number of delimiting colons between fields. If you were to specify <var/><span epub:type="pagebreak" title="547" id="Page_547"/>action and <var>category</var> but omit <var>message</var>, you’d still need the separating colons between them:</p>
<pre><code><var>action</var>::<var>category</var></code></pre>
<p>Notice, however, that I did not need any trailing colons for the omitted <var>module</var> and <var>lineno</var> fields, as those came after the last field I specified: <var>category</var>.</p>
<p>Using the <var>message</var> field, you can filter warnings that have a particular message. The <var>module </var>field can be used to filter warnings only in a particular module.</p>
<h4 id="h3-500920c19-0001">Hiding Duplicate Warnings</h4>
<p class="BodyFirst">It isn’t uncommon for a warning to be raised multiple times, such as if it appears in a function that is called more than once. The <var>action</var> field controls this. <a href="#table19-3">Table 19-3</a> shows the possible options you could pass to <var>action</var>
<var>.</var></p>
<figure>
<figcaption class="TableTitle"><p><a id="table19-3">Table 19-3</a>: Warning Filter Action Options</p></figcaption>
<table id="table-500920c19-0003" border="1"><tbody>
<tr>
<td><code>ignore</code></td>
<td>Never show the warning.</td>
</tr>
<tr>
<td><code>once</code></td>
<td>Only show the warning once, for the whole program.</td>
</tr>
<tr>
<td><code>module</code></td>
<td>Only show the warning once per module.</td>
</tr>
<tr>
<td><code>default</code></td>
<td>Show the warning once per module and line number.</td>
</tr>
<tr>
<td><code>always</code></td>
<td>Always show the warning, no matter how often it occurs.</td>
</tr>
<tr>
<td><code>error</code></td>
<td>Convert the warning to an exception.</td>
</tr>
</tbody>
</table>
</figure>
<p>For example, if I only wanted to see the first instance of any particular warning in a module, I’d pass the string <code>module</code> to the <var>action</var> field, like this:</p>
<pre><code>python3 -Wmodule basic_warning.py</code></pre>
<p>I pass the warnings filter to the warning filter flag, <code>-W</code>, followed by the warning filter itself (with no space in between the flag and the filter.) This flag must come <em>before</em> the module to run, as it’s an argument for Python itself. If it came at the end, it would be erroneously passed as an argument to the <em>basic_warning.py</em> module itself.</p>
<p>Likewise, you can alternatively print only the first occurrence of each warning in the entire program’s run with <code>-Wonce</code>.</p>
<h4 id="h3-500920c19-0002">Ignoring Warnings</h4>
<p class="BodyFirst">You can also use warning filters to hide an entire category of warnings from an end user by using the <var>ignore</var> action. Let’s say you don’t want the user to see all the deprecation warnings you plan to address in the next version of your program:</p>
<pre><code>python3 -Wignore::DeprecationWarning basic_warning.py</code></pre>
<p><span epub:type="pagebreak" title="548" id="Page_548"/>The <code>ignore</code> action hides warnings, and <code>DeprecationWarning</code> in the <var>category</var> field causes only deprecation warnings to be hidden while the Python module is running.</p>
<h3 id="h2-500920c19-0003">Converting Warnings into Exceptions</h3>
<p class="BodyFirst">Using the <code>error</code> action, you can convert warnings into fatal exceptions to crash the program. This is possible because the base class <code>Warning</code> inherits from the <code>Exception</code> class. The following example turns all warnings into errors when running a particular module:</p>
<pre><code>python3 -Werror basic_warning.py</code></pre>
<p>Since no other fields are provided in the filter, this <code>error</code> action will affect all warnings. This might be helpful in continuous integration systems where a pull request should automatically be rejected if there are warnings.</p>
<p>Another reason why you might raise warnings as exceptions is to ensure your program isn’t using any deprecated code. You can turn all <code>DeprecationWarning</code> warnings into errors with <code>-Werror::DeprecationWarning</code> and then resolve them one by one, until your program runs.</p>
<p>However, turning errors into exceptions can have negative consequences because it also turns any warnings from within dependencies or the standard library into errors. To get around this, I need to limit the warning filter, like this:</p>
<pre><code>python3 -Werror<b>:::__main__</b> basic_warning.py</code></pre>
<p>This warning filter will only convert warnings to errors in the module I’m directly executing, and it will handle any warnings from elsewhere according to the default rules.</p>
<p>To convert warnings to errors across an entire package, such as my <code>timecard</code> package, without getting warnings from dependencies and the standard library, I’d use the following filter:</p>
<pre><code>python3 -Werror:::timecard[.*] basic_warning.py</code></pre>
<p>The regular expression <code>timecard[.*]</code> matches any module contained in the <code>timecard</code> package or any <code>subpackage</code> thereof.</p>
<p>There is quite a bit more to warning filters that’s outside the scope of this chapter. I recommend reading further at <a href="https://docs.python.org/3/library/warnings.html" class="LinkURL">https://docs.python.org/3/library/warnings.html</a>.</p>
<h2 id="h1-500920c19-0002">Logging</h2>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you learned how to log exceptions, rather than merely passing them to <code>print()</code>. This technique has a few advantages. It grants you control over whether messages are sent to the standard output or to a file, and it <span epub:type="pagebreak" title="549" id="Page_549"/>gives you the ability to filter messages based on their severity. The severity levels, in increasing order of severity, are as follows: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>.</p>
<p>The patterns I used in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> were sufficient to get you this far, but logging in a production-grade project requires a bit more thought. You must consider which messages should be visible under which circumstances and how different types of messages should be logged. A critical warning might need to be displayed on the terminal and stored in a file, while an informative message about a normal operation may be hidden, except when the user runs the program in a provided “verbose” mode.</p>
<p>To handle all things logging, Python provides the <code>logging</code> module, which defines four components: <code>Logger</code>, <code>Handler</code>, <code>Filter</code>, and <code>Formatter</code>. I’ll break down each of these in turn.</p>
<h3 id="h2-500920c19-0004">Logger Objects</h3>
<p class="BodyFirst">A <code>Logger</code> object handles your logging messages. It accepts messages to be logged as <code>LogRecord</code> objects and passes them on to one or more <code>Handler</code> objects, based on the reported severity. I’ll come back to severity and <code>Handler</code> shortly.</p>
<p>A typical project has one <code>Logger</code> per module. Never instantiate these <code>Logger</code> objects yourself. Instead, you must acquire <code>Logger</code> objects with <code>logger.getLogger()</code>, instead of instantiating them. This ensures that more than one logger with the same name is never created:</p>
<pre><code>import logging
logger = logging.getLogger(__name__)</code></pre>
<p>The <code>__name__</code> attribute is the name of the current module, as well as its parent packages (if any). If no <code>Logger</code> object yet exists by that name, it is created behind the scenes. In either case, the <code>Logger</code> object is bound to <code>logger</code> and becomes ready for use.</p>
<p>This pattern works in most situations. In the entry module for a package, however, you must explicitly declare the name of the logger, using the name of the package. Using the <code>__name__</code> attribute here would be impractical, since it will always report the name of the entry module as <code>__main__</code>. This logger should have the package name, so it can serve as the primary logger for all the modules belonging to the package. All the other loggers will pass their messages up to this one.</p>
<p>To illustrate the use of <code>Logger</code>, I’ll create a <code>letter_counter</code> package for determining the most commonly occurring letters in a given passage of text. The package will use logging to handle warnings and informative messages. Here is the beginning of my <code>__main__.py</code> module:</p>
<pre><code>import pathlib
import argparse
import logging

<span epub:type="pagebreak" title="550" id="Page_550"/>from letter_counter.common import scrub_string
from letter_counter.letters import most_common_consonant, most_common_vowel

logger = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> logging.getLogger('letter_counter')</code></pre>
<p class="CodeListingCaption"><a id="listing19-4">Listing 19-4</a>: <em>letter_counter/__main__.py:1</em></p>
<p>I acquire the <code>Logger</code> object by passing the name of the package explicitly to the <code>logging.getLogger()</code> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then binding that object to <code>logger</code>.</p>
<p>It’s important that the name of this logger should match the package name, so it can serve as the primary logger for the <code>letter_counter</code> package.</p>
<p>I must also acquire a <code>Logger</code> object for each module and subpackage in this package that needs to perform logging. Here, the <em>letter.py</em> module acquires a logger:</p>
<pre><code>import logging
from collections import defaultdict

logger = logging.getLogger(__name__)</code></pre>
<p class="CodeListingCaption"><a id="listing19-5">Listing 19-5</a>: <em>letter_counter/</em><em>letters</em><em>.py:1</em></p>
<p>Because this <code>__name__</code> expression resolves to <code>letter_counter.letters</code>, the <code>letter_counter</code> logger created in <a href="#listing19-4" id="listinganchor19-4">Listing 19-4</a> automatically becomes the parent of this logger. As a result, all messages passed to the logger in <em>letters.py</em> will be passed in turn to the <code>letter_counter</code> logger.</p>
<p>In the same way, I can add a logger to the other file in my package, <em>common.py</em>:</p>
<pre><code>import logging

logger = logging.getLogger(__name__)</code></pre>
<p class="CodeListingCaption"><a id="listing19-6">Listing 19-6</a>: <em>letter_counter/</em><em>common</em><em>.py:1</em></p>
<h3 id="h2-500920c19-0005">Handler Objects</h3>
<p class="BodyFirst">The <code>Handler</code> is responsible for sending the <code>LogRecord</code> objects to the right place, whether that be the standard output, the standard error, a file, over a network, or some other location. The logging module contains a number of built-in <code>Handler</code> objects, all of which are thoroughly documented at <a href="https://docs.python.org/3/library/logging.handlers.html" class="LinkURL">https://docs.python.org/3/library/logging.handlers.html</a>. This chapter won’t cover many of these useful handlers, so the documentation is well worth a quick read. In most situations, however, you’ll wind up using one of the following:</p>
<ul>
<li><code>StreamHandler</code> sends logging output to streams, especially the standard output and standard error streams. You may pass the desired output stream to the <code>logging.StreamHandler</code> class initializer; otherwise, <code>sys.stderr</code> is used by default. Although you can use this handler for logging to a file, <code>FileHandler</code> will give you better results for that use case.</li>
<li><span epub:type="pagebreak" title="551" id="Page_551"/><code>FileHandler</code> sends logging output to files. You must pass the filename or <code>Path</code> to the target output file to the <code>logging.FileHandler</code> class initializer. (There are a number of further specialized <code>Handler</code> classes for dealing with rotating and system log files.)</li>
<li><code>SocketHandler</code> sends logging output to a network socket over TCP. You would pass the host and port as arguments to the <code>logging.handlers.SocketHandler</code> class initializer.</li>
<li><code>SMTPHandler</code> sends logging output to an email address via SMTP. The mail host, sender email address, recipient email address, subject, and login credentials all have to be passed to the <code>logging.handlers.SMTPHandler</code> class initializer.</li>
<li><code>NullHandler</code> sends logging output into the black hole at the heart of a captive dark star, never to be seen or heard from again. Nothing has to be passed to the <code>logging.NullHandler</code> class initializer.</li>
</ul>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">	If your project is a library, use <code>NullHandler</code> as its only logging handler, so as to not clutter or confuse any logging systems employed by end developers. This will explicitly suppress all logging from the library. An end developer can attach a different handler to the library’s logger, if desired.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>I’ll continue my <code>letter_counter</code> package example by printing all the <code>LogRecord</code> objects in the <code>letter_counter</code> package to the terminal with <code>logging.StreamHandler()</code>, which sends logs to the standard-output or standard-error streams. I add this handler to my top-level <code>Logger</code> object like this:</p>
<pre><code>stream_handler = logging.StreamHandler()
logger.addHandler(stream_handler)</code></pre>
<p class="CodeListingCaption"><a id="listing19-7">Listing 19-7</a>: <em>letter_counter/__main__.py:2</em></p>
<p>Because I did not specify a stream with the <code>StreamHandler()</code> constructor, <code>stream_handler</code> will pass messages to the <code>sys.stderr</code> stream.</p>
<p>Notice that I only need to add the <code>Handler</code> to the <code>letter_counter</code> logger. Since the loggers for <code>letter_counter.letters</code> and <code>letter_counter.common</code> are children, they will pass all their <code>LogRecord</code> objects up to their parent.</p>
<p>You may attach as many handlers as you like, to any of the loggers. Child loggers will still relay their <code>LogRecord</code> objects to their parents in addition to employing their own handlers, unless you set the <code>propagate</code> attribute of a child logger to <code>False</code>:</p>
<pre><code>logger.propagate = False</code></pre>
<p>In my example, I don’t need to add any handlers to the child loggers. I can let the loggers pass their <code>LogRecord</code> objects back up to the parent logger, which has the one <code>StreamHandler</code> attached.</p>
<h3 id="h2-500920c19-0006"><span epub:type="pagebreak" title="552" id="Page_552"/>Logging with Levels</h3>
<p class="BodyFirst">My logging example is still incomplete because it doesn’t include the <em>severity</em> <em>level</em> of each message, which indicates the message’s relative importance.</p>
<p>Logging with levels allows you to configure a logging system to display only messages that are at or above a given severity level. For example, you may want to see all <code>DEBUG</code> messages while developing, but end users should only see <code>WARNING</code> messages and above.</p>
<p>There are six built-in severity levels, as outlined in <a href="#table19-4" id="tableanchor19-4">Table 19-4</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table19-4">Table 19-4</a>: Logging Severity Levels</p></figcaption>
<table id="table-500920c19-0004" border="1">
<thead>
<tr>
<td><b>Level</b></td>
<td><b>Numeric value</b></td>
<td><b>Use</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>CRITICAL</code></td>
<td>50</td>
<td>Messages related to horrible, terrible, no good, very bad, everything-is-broken situations</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>40</td>
<td>Messages related to an error that can probably be recovered from (meaning at least all is not lost)</td>
</tr>
<tr>
<td><code>WARNING</code></td>
<td>30</td>
<td>Messages related to problems that are not (yet) errors but may require attention</td>
</tr>
<tr>
<td><code>INFO</code></td>
<td>20</td>
<td>Informative and useful messages that are not related to actual problems</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>10</td>
<td>Messages that are only of interest to developers, particularly when hunting for bugs</td>
</tr>
<tr>
<td><code>NOTSET</code></td>
<td>0</td>
<td>Only used to specify that all messages should be displayed (never used as a message severity level)</td>
</tr>
</tbody>
</table>
</figure>
<p>To assign a level to a message when logging it, use the <code>Logger</code> instance method corresponding to the level for the message, as I do in this function from <em>letter_counter/common.py</em>:</p>
<pre><code>def scrub_string(string):
    string = string.lower()
    string = ''.join(filter(str.isalpha, string))
    logger.debug(f"{len(string)} letters detected.")
    return string</code></pre>
<p class="CodeListingCaption"><a id="listing19-8">Listing 19-8</a>: <em>letter_counter/</em><em>common</em><em>.py:2</em></p>
<p>This function converts a string to all lowercase and filters it down to contain only letters. The important part of this example is the <code>logger.debug()</code> method call, which passes a <code>LogRecord</code> to this module’s <code>logger</code> object (<a href="#listing19-6" id="listinganchor19-6">Listing 19-6</a>) with level <code>DEBUG</code>.</p>
<p>Meanwhile, over in <em>letter_counter/letters.py</em>, I have some <code>INFO </code>level messages I need to output under certain circumstances:</p>
<pre><code>consonants = 'bcdfghjklmnpqrstvwxyz'
vowels = 'aeiou'


def count_letters(string, letter_set):
<span epub:type="pagebreak" title="553" id="Page_553"/>    counts = defaultdict(lambda: 0)
    for ch in string:
        if ch in letter_set:
            counts[ch] += 1
    return counts


def most_common_consonant(string):
    if not len(string):
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> logger.info("No consonants in empty string.")
        return ""
    counts = count_letters(string, consonants)
    return max(counts, key=counts.get).upper()


def most_common_vowel(string):
    if not len(string):
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> logger.info("No vowels in empty string.")
        return ""
    counts = count_letters(string, vowels)
    return max(counts, key=counts.get).upper()</code></pre>
<p class="CodeListingCaption"><a id="listing19-9">Listing 19-9</a>: <em>letter_counter/</em><em>letters</em><em>.py:1</em></p>
<p>These functions count up the number of vowels and consonants in a given string, and they return the vowel or consonant that appears most frequently. The important parts here are the two calls to <code>logger.info()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Notice that these messages are logged only if an empty string is passed to <code>most_common_consonant()</code> or <code>most_common_vowel()</code>.</p>
<h3 id="h2-500920c19-0007">Controlling the Log Level</h3>
<p class="BodyFirst">Any given <code>Logger</code> object can be set to pick up <code>LogRecord</code> objects with a particular level or higher, using the <code>setLevel()</code> method. As with adding <code>Handler</code> objects, you only need to set the level on the top-level logger. While you <em>can</em> set it on child loggers if you see fit to do so, they will no longer delegate their <code>LogRecord</code> objects to their parents. By default, a <code>Logger</code> has a level of <code>NOTSET</code>, causing it to delegate its <code>LogRecord</code> objects up the hierarchy. As soon as a <code>Logger</code> with a level other than <code>NOTSET</code> is encountered in that hierarchy, the chain of delegation stops.</p>
<p>In my example, I set the logging level on the top-level logger to <code>WARNING</code> by default, but I allow users to pass a <code>-v</code> argument on the invocation of my package to instead set the level to <code>INFO</code>. I’m using the built-in <code>argparse</code> module to handle command-line arguments:</p>
<pre><code>parser = argparse.ArgumentParser(description="Find which letters appear most.")
parser.add_argument("-v", help="Show all messages.", action="store_true") <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>
parser.add_argument("raw_path", metavar="P", type=str, help="The file to read.") <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>

def main():
    args = parser.parse_args()

    <span epub:type="pagebreak" title="554" id="Page_554"/>if args.v:
      <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> logger.setLevel(logging.INFO)
    else:
        logger.setLevel(logging.WARNING)</code></pre>
<p class="CodeListingCaption"><a id="listing19-10">Listing 19-10</a>: <em>letter_counter/__main__.py:3</em></p>
<p>I won’t go into the usage of <code>argparse</code> in much detail here, as it’s largely off-topic and the official <code>argparse</code> tutorial does a decent job of introducing it: <a href="https://docs.python.org/3/howto/argparse.html" class="LinkURL">https://docs.python.org/3/howto/argparse.html</a>. Suffice to say that I define two arguments: a <code>-v</code> flag for toggling verbose mode <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the path to the file the program should read from <span class="CodeAnnotation" aria-label="annotation2">❷</span>. That flag is the important part in this situation. If it was passed in the package invocation, I set the level of <code>logger</code> to <code>logging.INFO</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Otherwise, I use <code>logging.WARNING</code>, thereby ignoring all messages logged with <code>logger.info()</code>.</p>
<p>Here’s the rest of my <code>__main__.py</code> module, which reads the file, calls the functions to count letters, and displays the output:</p>
<pre><code>    path = pathlib.Path(args.raw_path).resolve()
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> logger.info(f"Opening {path}")

    if not path.exists():
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> logger.warning("File does not exist.")
        return

    with path.open('r') as file:
        string = scrub_string(file.read())
        print(f"Most common vowel: {most_common_vowel(string)}")
        print(f"Most common consonant: {most_common_consonant(string)}")


if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing19-11">Listing 19-11</a>: <em>letter_counter/__main__.py:4</em></p>
<p>Nothing much to see here in relation to logging, except for a couple more logged messages: one at <code>INFO</code> level <span class="CodeAnnotation" aria-label="annotation1">❶</span> and one at <code>WARNING</code> level <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<h3 id="h2-500920c19-0008">Running the Example</h3>
<p class="BodyFirst">To demonstrate the logging system at work, I’ll invoke my package from the command line, passing it a path to a text file containing The Zen of Python:</p>
<pre><code>python3 -m letter_counter zen.txt</code></pre>
<p>Because I omitted the <code>-v</code> flag, the logging level is <code>WARNING</code>, meaning only messages at level <code>WARNING</code>, <code>ERROR</code>, or <code>CRITICAL</code> will be logged. Since <em>zen.txt</em> is a valid path, I see the following output:</p>
<pre><code>Most common vowel: E
Most common consonant: T</code></pre>
<p><span epub:type="pagebreak" title="555" id="Page_555"/>Now, I’ll add that <code>-v</code> flag to my invocation, which should change the logger level according to the logic in <a href="#listing19-10" id="listinganchor19-10">Listing 19-10</a>:</p>
<pre><code>python3 -m letter_counter <b>-v</b> zen.txt</code></pre>
<p>This causes the output to change a bit:</p>
<pre><code>Opening /home/jason/Documents/DeadSimplePython/Code/ch19/zen.txt
Most common vowel: E
Most common consonant: T</code></pre>
<p>I now see the <code>INFO</code> level message from <em>letter_counter/__main__.py</em>. However, since the file exists and isn’t empty, I don’t see any of the <code>INFO</code> messages from the other modules. To see those, I’ll pass a path to an empty file instead:</p>
<pre><code>python3 -m letter_counter -v <b>empty.txt</b></code></pre>
<p>The output now contains additional messages:</p>
<pre><code>Opening /home/jason/Documents/DeadSimplePython/Code/ch19/empty.txt
No vowels in empty string.
Most common vowel: 
No consonants in empty string.
Most common consonant: </code></pre>
<p>You’ll notice one other message that is absent: the letter count message from <em>letter_counter/common.py</em> (<a href="#listing19-8" id="listinganchor19-8">Listing 19-8</a>). As it was logged at level <code>DEBUG</code>, it is still being ignored with the logger set to level <code>INFO</code>. I would have to modify my code to see it.</p>
<p>For one last test, I’ll drop the <code>-v</code> flag, thereby using the <code>WARNING</code> level on the logger, and I will pass an invalid file name in the invocation:</p>
<pre><code>python3 -m letter_counter <b>invalid.txt</b></code></pre>
<p>This time, I see the following output:</p>
<pre><code>File does not exist.</code></pre>
<p>That output would be the same in this scenario whether I passed the <code>-v</code> flag to my program or not, as <code>WARNING</code> is higher priority than <code>INFO</code>.</p>
<h3 id="h2-500920c19-0009">Filter, Formatter, and Configuration</h3>
<p class="BodyFirst">There are two more components you can add to a logging system: a <em>Filter</em> and a <em>Formatter</em>.</p>
<p>A <code>Filter</code> object further defines where to pick up <code>LogRecord</code> objects, and it can be applied to a <code>Logger</code> or <code>Handler</code> using the <code>addFilter()</code> method. You can also use any callable object as a filter.</p>
<p>A <code>Formatter</code> object is responsible for converting a <code>LogRecord</code> object to a string. These are usually defined by passing a special format string to the <code/><span epub:type="pagebreak" title="556" id="Page_556"/>logging.Formatter() function. You can also add a single <code>Formatter</code> to a <code>Handler</code> object with the <code>setFormatter()</code> method.</p>
<p>It is also possible to configure a logger using a specialized configuration file.</p>
<p>For additional information on logging, I recommend reading the official <em>Logging HOWTO</em> tutorial by Vinay Sajip at <a href="https://docs.python.org/3/howto/logging.html" class="LinkURL">https://docs.python.org/3/howto/logging.html</a>, followed by the official documentation at <a href="https://docs.python.org/3/library/logging.html" class="LinkURL">https://docs.python.org/3/library/logging.html</a>.</p>
<p>Alternatively, you could use a third-party logging library like <em>eliot</em> (<a href="https://eliot.readthedocs.io/" class="LinkURL">https://eliot.readthedocs.io/</a>) or <em>loguru</em> (<a href="https://github.com/Delgan/loguru" class="LinkURL">https://github.com/Delgan/loguru</a>). These libraries have their own patterns and techniques, so you’ll want to see their documentation to learn more.</p>
<h2 id="h1-500920c19-0003">Assert Statements</h2>
<p class="BodyFirst">While coding, you may sometimes become aware of conditions that would render your logic nonsensical. You can check for these conditions using an <code>assert</code> statement, which will raise an <code>AssertionError</code> exception if an expression fails.</p>
<p>However, while these checks are useful during development or debugging, they’re often extraneous during normal operation by the end user. If you pass the <code>-O</code> flag (for <em>optimize</em>) to the Python interpreter when invoking your package or module, all <code>assert</code> statements are removed from the code by the Python interpreter.</p>
<p>For this reason, only use <code>assert</code> statements to check for mistakes <em>you</em> made! Never use them for data validation, nor in response to user mistakes, as users should never be able to disable data and input validation. Use exceptions and warnings for those scenarios.</p>
<p>Instead, use assertions to aid you in debugging particularly <em>brittle</em> areas of your code: places where a minor or seemingly unrelated change to the code could have unintended side effects. The following simple example will demonstrate where <code>assert</code> is and is not useful.</p>
<h3 id="h2-500920c19-0010">Proper Use of assert</h3>
<p class="BodyFirst">In this example program, I want to calculate how many vinyl records I can store on any given bookshelf. There’s one key constant in the program: the thickness of a single vinyl record in its jacket:</p>
<pre><code>THICKNESS = 0.125  # must be a positive number</code></pre>
<p class="CodeListingCaption"><a id="listing19-12">Listing 19-12</a>: <em>vinyl_collector.py:1a</em></p>
<p>Using a constant for this value is helpful for making the code maintainable. If I need to update this thickness later—perhaps because I do some complicated statistics to find a more precise average—I need to make sure the value I’m using is still valid. I know in advance that I’ll need to use this constant as the divisor in some later math, which means the constant absolutely cannot be zero. It should also be a positive number, as vinyl records <span epub:type="pagebreak" title="557" id="Page_557"/>can’t have a negative thickness. Thus, the comment is somewhat helpful here . . . but then again, it won’t do anything to stop me from assigning a nonsense value to the constant!</p>
<p>Since a wrong value will cause major problems in the code itself, and since the value is not externally sourced data or user input, I can make an assertion. Under the hood, an <code>assert</code> statement looks like this:</p>
<pre><code>THICKNESS = 0.125
<b>if __debug__:</b>
<b>    if not THICKNESS &gt; 0:</b>
<b>        raise AssertionError("Vinyl must have a positive thickness!")</b></code></pre>
<p class="CodeListingCaption"><a id="listing19-13">Listing 19-13</a>: <em>vinyl_collector.py:1b</em></p>
<p>The <code>__debug__</code> constant is defined by the interpreter and set to <code>True</code> by default. If the <code>-O</code> flag is passed to the interpreter, it is set to <code>False</code>. It is not possible to assign a value to <code>__debug__</code> directly, so as long as <code>-O</code> was not passed to the interpreter, the assertion condition is evaluated. In this case, if <code>THICKNESS</code> is not greater than <code>0</code>, I raise an <code>AssertionError</code>.</p>
<p>The <code>assert</code> statement wraps all this logic into one line:</p>
<pre><code>THICKNESS = 0.125
<b>assert THICKNESS &gt; 0, "Vinyl must have a positive thickness!"</b></code></pre>
<p class="CodeListingCaption"><a id="listing19-14">Listing 19-14</a>: <em>vinyl_collector.py:1c</em></p>
<p>Note the lack of parentheses involved here, as <code>assert</code> is a keyword, not a function. The condition <code>THICKNESS &gt; 0</code> is checked, and if it fails, an <code>AssertionError</code> is raised, with the string after the comma used as the error’s message.</p>
<p>The reason for placing the <code>assert</code> here becomes clearer given the next part of the code, which performs some operations using <code>THICKNESS</code>:</p>
<pre><code>def fit_records(width, shelves):
    records_per_shelf = width / THICKNESS
    records = records_per_shelf * shelves
    return int(records)</code></pre>
<p class="CodeListingCaption"><a id="listing19-15">Listing 19-15</a>: <em>vinyl_collector.py:2</em></p>
<p>If <code>THICKNESS</code> were ever <code>0</code>, the division in this function would raise a <code>ZeroDivisionError</code>. That error could point me in the right direction while debugging, but there are three issues. First, the actual problem is where I define <code>THICKNESS</code>, which could (theoretically) be some distance away from this function. Second, the error would only surface once this function is called, meaning that if I don’t happen to invoke this function during my testing, I could miss the bug entirely. Third, a negative value in <code>THICKNESS</code> would produce nonsense output, but the math would still be valid, so the bug might slip past.</p>
<p>The purpose of placing the assertion right next to the definition of the constant is to alert me to a bug at its source, as early in the execution flow as possible.</p>
<h3 id="h2-500920c19-0011"><span epub:type="pagebreak" title="558" id="Page_558"/>Wrong Use of assert</h3>
<p class="BodyFirst">As I mentioned earlier, <code>assert</code> should not be used for data or input validation. Regular exceptions and conditions should be used for those instead.</p>
<p>For example, this function prompts the user to input a value and then attempts to convert it to an integer. This first version improperly uses <code>assert</code> to ensure that the number is positive:</p>
<pre><code>def get_number(prompt):
    while True:
        value = input(prompt)
        try:
            assert value.isnumeric(), "You must enter a whole number"
            value = int(value)
            assert value &gt; 0, "You must enter a positive number."
        except AssertionError as e:
            print(e)
            continue
        value = int(value)
        return value</code></pre>
<p class="CodeListingCaption"><a id="listing19-16">Listing 19-16</a>: <em>vinyl_collector.py:3</em><em>a</em></p>
<p>You may be able to see where this is going, but I’ll finish up with the rest of the program so we can see the problem in action:</p>
<pre><code>def main():
    width = get_number("What is the bookcase shelf width (in inches)? ")
    print("How many shelves are...")
    shelves_lp = get_number("    12+ inches high? ")
    shelves_78 = get_number("    10-11.5 inches high? ")
    shelves_single = get_number("    7-9.5 inches high? ")

    records_lp = fit_records(width, shelves_lp)
    records_single = fit_records(width, shelves_single)
    records_78 = fit_records(width, shelves_78)

    print(f"You can fit {records_lp} LPs, "
          f"{records_single} singles, and "
          f"{records_78} 78s.")


if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing19-17">Listing 19-17</a>: <em>vinyl_collector.py:4</em></p>
<p>If I run the program normally, this seems to work pretty well. However, if I pass the <code>-O</code> flag to the interpreter, I find that my input validation has vanished:</p>
<pre><code>$ <b>python3 -O vinyl_collector.py </b>
What is the bookcase shelf width (in inches)? -4
How many shelves are...
<span epub:type="pagebreak" title="559" id="Page_559"/>    12+ inches high? 0
    10-11.5 inches high? 4
    7-9.5 inches high? -4
You can fit 0 LPs, 128 singles, and -128 78s.</code></pre>
<p>Input validation isn’t very useful if it can be turned off. This is why <code>assert</code> should never be used for validating external data or user input. Instead, I use other techniques and leave <code>assert</code> out of it:</p>
<pre><code>def get_number(prompt):
    while True:
        value = input(prompt)
        try:
            value = int(value)
        <b>except ValueError:</b>
            <b>print(</b>"You must enter a whole number."<b>)</b>
            continue

        <b>if value &lt;= 0:</b>
            <b>print(</b>"You must enter a positive number."<b>)</b>
            <b>continue</b>

        return value</code></pre>
<p class="CodeListingCaption"><a id="listing19-18">Listing 19-18</a>: <em>vinyl_collector.py:3</em><em>b</em></p>
<p>Now, even if I run the program with the <code>-O</code> flag, data validation will work as expected.</p>
<h3 id="h2-500920c19-0012">Seeing assert in Action</h3>
<p class="BodyFirst">The final program only uses <code>assert</code> to catch a nonsense value being assigned to the <code>THICKNESS</code> constant in code, and nothing else. For the sake of example, I’ll change <code>THICKNESS</code> to a negative value, to get on the bad side of the assert statement:</p>
<pre><code>THICKNESS = -0.125  <b># HACK: this value is now wrong, for test purposes</b>
assert THICKNESS &gt; 0, "Vinyl must have a positive thickness!"</code></pre>
<p class="CodeListingCaption"><a id="listing19-19">Listing 19-19</a>: <em>vinyl_collector.py:1d</em></p>
<p>I invoke the program in the ordinary way:</p>
<pre><code>python3 vinyl_collector.py</code></pre>
<p>That outputs the expected <code>AssertionError</code>, since the value of <code>THICKNESS</code> is negative:</p>
<pre><code>Traceback (most recent call last):
  File "./vinyl_collector.py", line 2, in &lt;module&gt;
    assert THICKNESS &gt; 0, "Vinyl must have a positive thickness!"
AssertionError: Vinyl must have a positive thickness!</code></pre>
<p><span epub:type="pagebreak" title="560" id="Page_560"/>I can jump right to line 2, which is immediately next to the source of the problem. I can fix the problem, although I won’t do that yet, for the sake of example.</p>
<p>If I instead pass <code>-O</code> to the interpreter, that will turn on optimizations and thereby suppress the assertion:</p>
<pre><code>python3 -O vinyl_collector.py</code></pre>
<p>Even though the value of <code>THICKNESS</code> is wrong, the program will try to work with it anyway, as if the <code>assert</code> statement weren’t even there:</p>
<pre><code>What is the bookcase shelf width (in inches)? 1
How many shelves are at least...
    12 inches high? 1
    10 inches high? 2
    7 inches high? 3
You can fit -8 LPs, -24 singles, or -16 78s.</code></pre>
<p>Nonsense output, sure, but I was expecting problems since I ran the program with <code>-O</code>, without fixing the assertion errors. In reality, you’ll only want to invoke with <code>-O</code> once you’re reasonably certain there are no assertion errors in your program; it’s a flag you’ll only ever use in <em>production</em>, not in development.</p>
<h2 id="h1-500920c19-0004">The inspect Module</h2>
<p class="BodyFirst">One more useful tool in your debugging toolbox is the <code>inspect</code> module, which provides a number of functions to return data about objects and modules in Python, as well as code and traceback information. This data can be used to log more insightful debug messages.</p>
<p>As a fun little aside, outside of debugging, one of my favorite tricks I’ve ever done with <code>inspect</code> is to send the source of a Python function over a network to a remote machine. This allowed me to perform automated testing on those machines, without first having to install anything special.</p>
<p>The documentation is sufficient to introduce the functionality of this module: <a href="https://docs.python.org/3/library/inspect.html" class="LinkURL">https://docs.python.org/3/library/inspect.html</a>.</p>
<h2 id="h1-500920c19-0005">Using pdb</h2>
<p class="BodyFirst">Warnings, logging, and <code>assert</code> statements make it possible to perform quite a bit of manual debugging, without the use of external tools. While this is useful for many scenarios, there are a number of other tools that can help you quickly home in on a problem in your code. These are primarily helpful when there’s a possibility that the source of the error is some distance from its manifestation or when there are multiple components involved in the problem.</p>
<p>The <em>Python Debugger </em>(<code>pdb</code>) is a full-featured debugger for Python. Its workflow is similar to other command-line debuggers like <code>gdb</code> (for C++) and <code/><span epub:type="pagebreak" title="561" id="Page_561"/>jdb (for Java). You use it by setting <em>breakpoints</em>, places in the program where control is turned over to the debugger, allowing you to step through the code line by line to observe what’s going on.</p>
<p>If you’re using an IDE, it may include features that integrate with <code>pdb</code> or else offer its own alternative debugger. While you should familiarize yourself with your IDE’s debugging tools, it is also helpful to know how to use <code>pdb</code> on the command line, especially for those cases where you don’t have access to your development environment of choice.</p>
<h3 id="h2-500920c19-0013">A Debugging Example</h3>
<p class="BodyFirst">The best way to learn how to use the debugger is to try it out. <a href="#listing19-20" id="listinganchor19-20">Listing 19-20</a> is a complete module with a fairly pesky bug. If you take the time to read it, you’ll probably figure out the problem yourself, but production code is rarely this linear. So, even if you think you’ve identified the problem, enter this code into a file as is. I’ll work with this code quite a lot through the rest of the chapter.</p>
<pre><code>from datetime import time


def get_timetable(train):
    # Pretend this gets data from a server.
    return [
        {"station": "target_field", "arrives": time(hour=16, minute=27)},
        {"station": "fridley", "arrives": time(hour=16, minute=41)},
        {"station": "coon_rapids_fridley", "arrives": time(hour=16, minute=50)},
        {"station": "anoka", "arrives": time(hour=16, minute=54)},
        {"station": "ramsey", "arrives": time(hour=16, minute=59)},
        {"station": "elk_river", "arrives": time(hour=17, minute=4)},
        {"station": "big_lake", "arrives": time(hour=17, minute=17)},
    ]


def next_station(now, timetable):
    """Return the name of the next station."""
    station = None
    for stop in timetable:
        if stop['arrives'] &gt; now:
            station = stop
            break
    station['station'] = station['station'].replace('_', ' ').title()
    return station


def arrives_at(station, timetable):
    for stop in timetable:
        if station == stop['station']:
            return stop


timetable = get_timetable('nstar_northbound')

<span epub:type="pagebreak" title="562" id="Page_562"/>station = next_station(time(hour=16, minute=43), timetable)
print(f"Next station is {station['station']}.")

stop = arrives_at('coon_rapids_fridley', timetable)
print(f"Arrives at {stop['arrives']}.")</code></pre>
<p class="CodeListingCaption"><a id="listing19-20">Listing 19-20</a>: <em>train_timetable.py</em></p>
<p>This module simulates grabbing live data about a particular train, perhaps from API transit data. It then processes that data to find particular information. (A more realistic example might work with data in the widely used <em>General Transit Feed Specification (GTFS)</em> format; this imaginary API merely serves up a list of dictionaries.)</p>
<p>If you run this code, it crashes with an exception that may seem indicative of a simple mistake in my code:</p>
<pre><code>Traceback (most recent call last):
  File "./train_timetable.py", line 40, in &lt;module&gt;
    stop = arrives_at('coon_rapids_fridley', timetable)
TypeError: 'NoneType' object is not subscriptable</code></pre>
<p> “Oh, sure,” I might say to myself. “I must have forgotten my return statement.” But when I check the <code>arrives_at()</code> function, the logic makes sense. Besides, the station ID  <code>'coon_rapids_fridley'</code> is <em>right there</em> in the test data! Something spooky is going on here.</p>
<p>Enter debugger, stage left.</p>
<h3 id="h2-500920c19-0014">Starting the Debugger</h3>
<p class="BodyFirst">You’ll usually want to run the debugger directly on your code. One way is to invoke <code>pdb</code> from the command line when you run your program. For example, if I wanted to invoke the debugger on my <em>train_timetable.py</em> module, I could do this:</p>
<pre><code>python3 -m pdb train_timetable.py</code></pre>
<p>Since Python 3.7, the <code>pdb</code> module can also run a package with <code>-m</code> in the same manner as the interpreter. If I wanted to run my <code>timecard</code> package within the debugger, I’d do this:</p>
<pre><code>python3 -m pdb -m timecard</code></pre>
<p>Either way, the module or package is started in the <code>pdb</code> shell. The debugger immediately stops the program, awaiting a command. </p>
<pre><code>&gt; ./train_timetable.py(1)&lt;module&gt;()
-&gt; from datetime import time
(Pdb) </code></pre>
<p>At the <code>(Pdb)</code> prompt, I can enter debugger shell commands. I’ll come back to the usage of this debugger shell in a moment.</p>
<p><span epub:type="pagebreak" title="563" id="Page_563"/>Another way of starting the debugger is by setting a breakpoint directly in your code. When you run the code normally, it will hit this breakpoint and hand off control to <code>pdb</code>.</p>
<p>From Python 3.7 onward, you can set a breakpoint anywhere in your code with the following built-in function:</p>
<pre><code>breakpoint()</code></pre>
<p>Prior to 3.7, you could do the same with the following:</p>
<pre><code>import pdb; pdb.set_trace()</code></pre>
<p>Breakpoints will save you considerable time if you have an idea where the bug might originate from, or at least where the problematic execution stack begins. If you have a breakpoint set in your code, you only need to execute the program normally:</p>
<pre><code>python3 the_module_being_debugged.py</code></pre>
<p>This command starts the program normally, but as soon as it hits the breakpoint, the Python interpreter hands off execution control to <code>pdb</code>.</p>
<h3 id="h2-500920c19-0015">Debugger Shell Commands</h3>
<p class="BodyFirst">The <code>pdb</code> tool has quite a few commands you can enter at the <code>(Pdb)</code> prompt to control and monitor the execution of the code.</p>
<p>In <span class="xref" itemid="xref_target_Appendix B">Appendix B</span>, I document the most important <code>pdb</code> commands. These commands are also exhaustively documented at <a href="https://docs.python.org/3/library/pdb.html" class="LinkURL">https://docs.python.org/3/library/pdb.html</a>, although that page can be a bit hard to navigate when you’re looking for something in particular.</p>
<p>While I won’t be able to demonstrate many of the <code>pdb</code> commands, I’ll walk you through debugging this particular example from <a href="#listing19-20">Listing 19-20</a>.</p>
<h3 id="h2-500920c19-0016">Stepping Through the Code</h3>
<p class="BodyFirst">For this example, I’ll start debugging at the top of my code by invoking <code>pdb</code> directly, like this:</p>
<pre><code>python3 -m pdb train_timetable.py</code></pre>
<p>I’ll use the debugger as shown below. I strongly encourage you to follow along.</p>
<p>The <code>pdb</code> session starts at the top of the module, but the problem is farther down. I use the <code class="bold">next</code> (or <code class="bold">n</code>) command to move down to the beginning of the usage section of my module.</p>
<pre><code>&gt; ./train_timetable.py(1)&lt;module&gt;()
-&gt; from datetime import time
(Pdb) <b>next</b>
&gt; ./train_timetable.py(4)&lt;module&gt;()
-&gt; def get_timetable(train):
<span epub:type="pagebreak" title="564" id="Page_564"/>(Pdb) <b>n</b>
&gt; ./train_timetable.py(17)&lt;module&gt;()
-&gt; def next_station(now, timetable):
(Pdb) <b>n</b>
&gt; ./train_timetable.py(28)&lt;module&gt;()
-&gt; def arrives_at(station, timetable):
(Pdb) <b>n</b>
&gt; ./train_timetable.py(34)&lt;module&gt;()
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> -&gt; timetable = get_timetable('nstar_northbound')
(Pdb) <b>list</b>
 29      for stop in timetable:
 30          if station == stop['station']:
 31              return stop
 32
 33
 34  -&gt;timetable = get_timetable('nstar_northbound')
 35
 36  station = next_station(time(hour=16, minute=43), timetable)
 37  print(f"Next station is {station['station']}.")
 38
 39  stop = arrives_at('coon_rapids_fridley', timetable)</code></pre>
<p>When I reach the first function call <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I use the <code class="bold">list</code> (or <code class="bold">l</code>) command to see the nearby code. I’m currently stopped on line 34, as indicated by the <code>-&gt;</code> in the code.</p>
<h3 id="h2-500920c19-0017">Setting a Breakpoint and Stepping into a Function</h3>
<p class="BodyFirst">I know I’m having a problem around line 39, so I’ll set a breakpoint there:</p>
<pre><code>(Pdb) <b>break 39</b>
Breakpoint 1 at ./train_timetable.py:39
(Pdb) <b>continue</b>
Next station is Coon Rapids Fridley.
&gt; ./train_timetable.py(39)&lt;module&gt;()
-&gt; stop = arrives_at('coon_rapids_fridley', timetable)</code></pre>
<p>The command <code class="bold">break 39</code> sets a breakpoint on line 39. I then use the <code class="bold">continue</code> command to proceed to that breakpoint, since it is later in the execution flow than the present position.</p>
<p>Next, I use the <code class="bold">step</code> (or <code class="bold">s</code>) command to step into the <code>arrives_at()</code> function. Then, before checking that code, I use the <code class="bold">args</code> command to see what values were passed to the function:</p>
<pre><code>(Pdb) <b>step</b>
--Call--
&gt; ./train_timetable.py(28)arrives_at()
-&gt; def arrives_at(station, timetable):
(Pdb) <b>s</b>
&gt; ./train_timetable.py(29)arrives_at()
-&gt; for stop in timetable:
(Pdb) <b>args</b>
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> station = 'coon_rapids_fridley'
<span epub:type="pagebreak" title="565" id="Page_565"/>timetable = (
    {'station': 'target_field', 'arrives': datetime.time(16, 27)},
    {'station': 'fridley', 'arrives': datetime.time(16, 41)},
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span>     {'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)},
    {'station': 'anoka', 'arrives': datetime.time(16, 54)},
    {'station': 'ramsey', 'arrives': datetime.time(16, 59)},
    {'station': 'elk_river', 'arrives': datetime.time(17, 4)},
    {'station': 'big_lake', 'arrives': datetime.time(17, 17)}
)</code></pre>
<p>The station ID for Coon Rapids Fridley looks odd <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and it certainly doesn’t match the station ID I’m looking for <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The data in <code>timetable</code> is getting mutated somewhere, and this is probably part of the reason why my code is returning <code>None</code>. Still, I need to confirm my theory.</p>
<h3 id="h2-500920c19-0018">Moving Through the Execution Stack</h3>
<p class="BodyFirst">Since I didn’t change the station ID in this part of the code, the problem must exist in an earlier part of the code. I <em>could</em> start over with a fresh debugging session, so I could stop earlier in the execution stack, but when debugging in a large, real-world program, that could be a royal pain. Thankfully, <code>pdb</code> provides an alternative.</p>
<p>First, I need to know where I am in the execution stack. The <code class="bold">where</code> command shows me the current stack trace, which is composed of four frames:</p>
<pre><code>(Pdb) <b>where</b>
  /usr/local/lib/python3.9/bdb.py(580)run()
-&gt; exec(cmd, globals, locals)
  &lt;string&gt;(1)&lt;module&gt;()
  ./train_timetable.py(39)&lt;module&gt;()
-&gt; stop = arrives_at('coon_rapids_fridley', timetable)
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> &gt; ./train_timetable.py(29)arrives_at()
-&gt; for stop in timetable:
(Pdb) <b>up</b>
&gt; ./train_timetable.py(39)&lt;module&gt;()
-&gt; stop = arrives_at('coon_rapids_fridley', timetable)</code></pre>
<p>I’m currently at the bottommost frame, as indicated by the <code>&gt;</code> character <span class="CodeAnnotation" aria-label="annotation1">❶</span>. I can move up one frame with the <code>up</code> command, which changes my focus to this line:</p>
<pre><code>stop = arrives_at('coon_rapids_fridley', timetable)</code></pre>
<p>Next, I’ll inspect the nearby code:</p>
<pre><code>(Pdb) <b>l</b>
 34  timetable = get_timetable('nstar_northbound')
 35
 36  station = next_station(time(hour=16, minute=43), timetable)
 37  print(f"Next station is {station['station']}.")
 38
 39 B-&gt;stop = arrives_at('coon_rapids_fridley', timetable)
 40  print(f"Arrives at {stop['arrives']}.")
<span epub:type="pagebreak" title="566" id="Page_566"/>[EOF]
(Pdb) <b>b 36</b>
Breakpoint 2 at ./train_timetable.py:36</code></pre>
<p>I use the <code class="bold">l</code> command (an alias for <code>list</code>) to see the surrounding code. You can see that line 39 has a breakpoint, indicated by the <code>B</code>. The <code>-&gt;</code> also indicates that this is my current position.</p>
<p>I know from earlier that <code>timetable</code> is getting mutated somewhere unexpected. The first suspect is that <code>next_station()</code> function call on line 36, so I set a breakpoint there with <code class="bold">b 36</code> (the same as <code>break 36</code>).</p>
<p>I must move backward in the execution stack, which is one of the cool features of <code>pdb</code>. There are two ways to do this: either I could use the <code>restart</code> command from this point and then continue to the new breakpoint, or I could use <code>jump</code>. Because the latter is a bit trickier, I’ll show how to accomplish it here.</p>
<p>The difficulty with using <code>jump</code> comes from the fact that I cannot jump from any position other than the newest frame, and I’m one level removed from that. There are a few ways around this. I could set a breakpoint at a later line on the outer scope and then continue to it. My present situation is simple enough, so I can use the <code>next</code> command from this point to step out of the current function call:</p>
<pre><code>(Pdb) <b>next</b>
&gt; ./train_timetable.py(40)&lt;module&gt;()
-&gt; print(f"Arrives at {stop['arrives']}.")</code></pre>
<p>I’m now in a position to jump. However, an important distinction between <code>restart</code> and <code>jump</code> is that while the former starts afresh, the latter executes with the current state staying as it is. This means that if I want to get an accurate picture of what’s happening, I need to get a fresh value for <code>timetable</code> without changing anything else. The easiest way to do that in this code is to jump to line 34:</p>
<pre><code>(Pdb) <b>jump 34</b>
&gt; ./train_timetable.py(36)&lt;module&gt;()
-&gt; timetable = get_timetable('nstar_northbound')
(Pdb) <b>n</b>
&gt; ./train_timetable.py(36)&lt;module&gt;()
-&gt; station = next_station(time(hour=16, minute=43), timetable)
(Pdb) <b>pp timetable</b>
({'arrives': datetime.time(16, 27), 'station': 'target_field'},
 {'arrives': datetime.time(16, 41), 'station': 'fridley'},
 {'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'},
 {'arrives': datetime.time(16, 54), 'station': 'anoka'},
 {'arrives': datetime.time(16, 59), 'station': 'ramsey'},
 {'arrives': datetime.time(17, 4), 'station': 'elk_river'},
 {'arrives': datetime.time(17, 17), 'station': 'big_lake'})</code></pre>
<p>Immediately after making the jump, <code>pdb</code> stays paused, awaiting further instructions. I run this line with <code>n</code> and then confirm that <code>timetable</code> is back to what it should be by pretty-printing it with <code>pp timetable</code>.</p>
<h3 id="h2-500920c19-0019"><span epub:type="pagebreak" title="567" id="Page_567"/>Inspecting the Source</h3>
<p class="BodyFirst">Now, I’ll see how <code>timetable</code> is getting messed up. I don’t need to <code>continue</code> at this point, as I’m already sitting on line 36, where I’d wanted to check next. I know that the data in <code>timetable</code> is being mutated, so I inspect the code of <code>next_station()</code> with the <code class="bold">source next_station</code> command:</p>
<pre><code>(Pdb) <b>source next_station</b>
 17  def next_station(now, timetable):
 18      """Return the name of the next station."""
 19      station = None
 20      for stop in timetable:
 21          if stop['arrives'] &gt; now:
 22              station = stop
 23              break
 24      station['station'] = station['station'].replace('_', ' ').title()
 25      return station
(Pdb) <b>b 24</b>
Breakpoint 2 at ./train_timetable.py:24
(Pdb) <b>c</b>
&gt; ./train_timetable.py(22)next_station()
-&gt; station = stop</code></pre>
<p>Hmm . . . line 24 is intriguing, isn’t it? That’s the logic for changing from so-called <em>lower_snake_case</em> to <em>Title Case</em>. I don’t want to waste time stepping through that <code>for</code> loop, so I set a breakpoint on the suspect line with <code class="bold">b 24</code> and then continue execution with <code class="bold">c</code>.</p>
<p>Now I can check the before-and-after state of <code>station</code>:</p>
<pre><code>(Pdb) <b>p station</b>
{'station': 'coon_rapids_fridley', 'arrives': datetime.time(16, 50)}
(Pdb) <b>n</b>
&gt; ./ch19/train_timetable.py(25)next_station()
-&gt; return station
(Pdb) <b>p station</b>
{'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)}
(Pdb) <b>pp timetable</b>
({'arrives': datetime.time(16, 27), 'station': 'target_field'},
 {'arrives': datetime.time(16, 41), 'station': 'fridley'},
 {'arrives': datetime.time(16, 50), 'station': 'Coon Rapids Fridley'},
 {'arrives': datetime.time(16, 54), 'station': 'anoka'},
 {'arrives': datetime.time(16, 59), 'station': 'ramsey'},
 {'arrives': datetime.time(17, 4), 'station': 'elk_river'},
 {'arrives': datetime.time(17, 17), 'station': 'big_lake'})</code></pre>
<p>Aha! The first time I check station with <code class="bold">p station</code>, it has the correct station ID. After running that suspect line with <code class="bold">n</code>, I check the value again and find it has changed. That’s not so bad in itself, but if I look at the value <code>timetable</code> with <code class="bold">pp timetable</code>, I find the change was made there.</p>
<p>Although a tuple itself is immutable, this isn’t necessary true of its items, and a dictionary is most certainly mutable. By binding an item from the tuple to <code>station</code> and then mutating it, that change is visible in the tuple. <span epub:type="pagebreak" title="568" id="Page_568"/>The <code>next_station()</code> function has side effects. The <code>arrives_at()</code> function couldn’t find the station with the expected ID because the ID had been changed.</p>
<h3 id="h2-500920c19-0020">Checking a Solution</h3>
<p class="BodyFirst">Once I have found the problem, I can quit the debugger and fix it. However, if I’m wrong, I have to start all over, and that could be a pain! Since I’m already located at the point of error, I’ll try changing the dictionary back to what it should be.</p>
<p>I can execute a Python statement at the current position, effectively before the line I’m stopped on, using the <code>!</code> command:</p>
<pre><code>(Pdb) <b>!station['station'] = 'coon_rapids_fridley'</b>
(Pdb) <b>pp timetable</b>
({'arrives': datetime.time(16, 27), 'station': 'target_field'},
 {'arrives': datetime.time(16, 41), 'station': 'fridley'},
 {'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'},
 {'arrives': datetime.time(16, 54), 'station': 'anoka'},
 {'arrives': datetime.time(16, 59), 'station': 'ramsey'},
 {'arrives': datetime.time(17, 4), 'station': 'elk_river'},
 {'arrives': datetime.time(17, 17), 'station': 'big_lake'})
(Pdb) <b>n</b>
--Return--
&gt; ./train_timetable.py(25)next_station()-&gt;{'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'}
-&gt; return station</code></pre>
<p>After running the statement that fixes the value of <code>station</code>, I confirm that the fix worked with <code>pp timetable</code>. Sure enough, the <code>'coon_rapids_fridley'</code> entry changed to what it should be. Then, I move forward to the next line of code with the <code>n</code> command.</p>
<p>Just because I fixed a problem in the code doesn’t mean I fixed the only problem. I need to let the program finish running to be absolutely certain the problem is resolved. I list all the breakpoints with <code>b</code> (or <code>break</code>) without arguments. For this example, I’ll clear breakpoints 1 and 2, as those are the ones that will get in the way when I continue:</p>
<pre><code>(Pdb) <b>b</b>
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at ./train_timetable.py:39
        breakpoint already hit 1 time
2   breakpoint   keep yes   at ./train_timetable.py:36
        breakpoint already hit 1 time
3   breakpoint   keep yes   at ./train_timetable.py:24
        breakpoint already hit 1 time
(Pdb) <b>clear 1 2</b>
Deleted breakpoint 1 at ./train_timetable.py:39
Deleted breakpoint 2 at ./train_timetable.py:36</code></pre>
<p>Now, I have removed the breakpoints I don’t need anymore. (I could also have cleared all breakpoints using <code>clear</code>.)</p>
<p><span epub:type="pagebreak" title="569" id="Page_569"/>I continue from here using the <code>continue</code> command:</p>
<pre><code>(Pdb) <b>continue</b>
Next station is coon_rapids_fridley.
Arrives at 16:50:00.
The program finished and will be restarted
&gt; ./train_timetable.py(1)&lt;module&gt;()
-&gt; from datetime import time
(Pdb) <b>q</b></code></pre>
<p>While the output for “Next station is . . . ” isn’t what I want—I’ll have to work out a solution for that—the rest of the code functions without crashing. I’ve solved it! Finally, I can exit the <code>pdb</code> shell with <code>q</code> and then change my code based on what I discovered.</p>
<h3 id="h2-500920c19-0021">Postmortem Debugging</h3>
<p class="BodyFirst">So far, you’ve seen that you can run a debugger from the top of a program or from a preset breakpoint. A third way to run a debugger is <em>postmortem</em>, meaning after a fatal crash has taken place. This is best thought of as a snapshot of the moment of the crash. You cannot move about in the code, set breakpoints, step into function calls, or jump around. However, you <em>can</em> inspect anything you want from the point of the crash.</p>
<p>There are a couple of ways to start postmortem debugging. The easiest way is to start the module in the interactive Python shell and allow it to crash, then invoke the postmortem debugger with <code>import pdb; pdb.pm()</code>:</p>
<pre><code>$ <b>python3 -i train_timetable.py</b>
Next station is Coon Rapids Fridley.
Traceback (most recent call last):
  File "/home/jason/IBP Nextcloud/Documents/NoStarchPress/DeadSimplePython/Code/ch19/train_timetable.py", line 40, in &lt;module&gt;
    print(f"Arrives at {stop['arrives']}.")
TypeError: 'NoneType' object is not subscriptable
&gt; <b>import pdb; pdb.pm()</b>
&gt; /home/jason/IBP Nextcloud/Documents/NoStarchPress/DeadSimplePython/Code/ch19/train_timetable.py(40)&lt;module&gt;()
-&gt; print(f"Arrives at {stop['arrives']}.")
(Pdb) </code></pre>
<p>There’s not much I can do here apart from inspection, which means this technique isn’t terribly helpful in this particular scenario. That said, I could still check the value bound to the names <code>timetable</code> and <code>station</code>, which might grant me some initial insight:</p>
<pre><code>(Pdb) <b>pp timetable</b>
({'arrives': datetime.time(16, 27), 'station': 'target_field'},
 {'arrives': datetime.time(16, 41), 'station': 'fridley'},
 {'arrives': datetime.time(16, 50), 'station': 'Coon Rapids Fridley'},
 {'arrives': datetime.time(16, 54), 'station': 'anoka'},
 {'arrives': datetime.time(16, 59), 'station': 'ramsey'},
 {'arrives': datetime.time(17, 4), 'station': 'elk_river'},
<span epub:type="pagebreak" title="570" id="Page_570"/> {'arrives': datetime.time(17, 17), 'station': 'big_lake'})
(Pdb) <b>p station</b>
{'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)}</code></pre>
<p>This is quite similar to print statement debugging, at least from the point of failure. From this, I could ascertain that the <code>timetable</code> itself might have been mutated unexpectedly, which is a useful insight. From here, I could start the module over in regular debugging mode and follow up that idea, as you saw me do earlier.</p>
<h2 id="h1-500920c19-0006">Using faulthandler</h2>
<p class="BodyFirst">If you’ve ever worked with C or C++, you may be familiar with the concept of <em>undefined behavior</em>, or a situation in code with no formal definition for how it should be handled. Code with undefined behavior may do anything: it might appear to work, fail with an error, or even do something weird.</p>
<p>You may hear many Python developers say, “Python doesn’t have undefined behavior!” This is only partly true. Nothing in Python’s own language specification is marked as “undefined behavior.” Everything should either work in a defined fashion or fail with a specific error.</p>
<p>True as that may be, CPython (the default interpreter) and many common Python extensions and libraries are still built with C, and undefined behavior is a possibility in C. If you search for the term <em>undefined</em> in the Python documentation, you’ll find a few advanced situations where undefined behavior is possible.</p>
<p>When you believe you’re up against undefined behavior, particularly <em>segmentation faults</em>—fatal system errors resulting from a program trying to access computer memory it doesn’t have permission to access—the <code>faulthandler</code> module is one of the most helpful tools in your toolbox.</p>
<p>To demonstrate this tool’s use, consider the following brief segment of Python code with undefined behavior:</p>
<pre><code>import ctypes

ctypes.memset(0, 254, 1)</code></pre>
<p class="CodeListingCaption"><a id="listing19-21">Listing 19-21</a>: <em>segfault.py:1a</em></p>
<p>The undefined behavior here comes from the underlying C code: I attempt to set the memory at address <code>0</code>, the <em>null pointer</em>, to the value <code>254</code>. The behavior of accessing or modifying memory at the null pointer is undefined. While anything could happen, this particular action almost always results in a segmentation fault:</p>
<pre><code>Segmentation fault (core dumped)</code></pre>
<p>It’s easy to spot this problem in a simple, two-line program, but imagine if this error occurred in a vast project with hundreds of lines.</p>
<p><span epub:type="pagebreak" title="571" id="Page_571"/>This is where <code>faulthandler</code> comes in handy. It allows you to quickly locate the line in your code that contains the undefined behavior. There are two ways to run this tool for a project. The first way is to invoke it with <code>-X faulthandler</code> when you run the interpreter:</p>
<pre><code>python3 -X faulthandler segfault.py</code></pre>
<p>Alternatively, you can enable <code>faulthandler</code> directly in your code:</p>
<pre><code>import ctypes

<b>import faulthandler; faulthandler.enable()</b>

ctypes.memset(0, 254, 1)</code></pre>
<p class="CodeListingCaption"><a id="listing19-22">Listing 19-22</a>: <em>segfault.py:1b</em></p>
<p>Because the line enabling <code>faulthandler</code> is intended to be removed once the problem has been found, it’s acceptable to cram the import statement onto the same line as the call to <code>enable()</code>.</p>
<p>Regardless of how you enable <code>faulthandler</code>, the output is essentially the same. As soon as a segmentation fault or similar fatal error is encountered, you’ll see a complete stack trace:</p>
<pre><code>Fatal Python error: Segmentation fault

Current thread 0x00007f7af346a280 (most recent call first):
  File "/home/jason/DeadSimplePython/segfault.py", line 5 in &lt;module&gt;
Segmentation fault (core dumped)</code></pre>
<p>Based on this traceback, you can see that the problem is on line 5 of <em>segfault.py</em> (from <a href="#listing19-22" id="listinganchor19-22">Listing 19-22</a>), which contains the invalid call to <code>ctypes.memset</code>.</p>
<h2 id="h1-500920c19-0007">Evaluating Your Program’s Security with Bandit</h2>
<p class="BodyFirst">As I’ve alluded to throughout this book, your choices about what modules and libraries you use and how you use them may introduce risks of a number of security concerns into your code. While you should try to stay informed about vulnerabilities, it’s not practical to memorize every single possible issue. Thankfully, you can employ a tool to help monitor your code’s security.</p>
<p><em>Bandit</em> is a security-focused static analyzer. It checks your code for security issues by building and testing it as an <em>abstract syntax tree (AST)</em>, which is a tree data structure that represents the overall structure of the code. You can install the <code>bandit</code> package from pip and use it in the manner of most other static analyzers.</p>
<p><span epub:type="pagebreak" title="572" id="Page_572"/>Consider the following very small program, which contains a significant security issue:</p>
<pre><code>equation = input("Enter an equation: ")
result = eval(equation)
print(f"{equation} = {result}")</code></pre>
<p class="CodeListingCaption"><a id="listing19-23">Listing 19-23</a>: <em>magic_calculator.py:1a</em></p>
<p>Rather than point out the security problem here myself, I’ll run this program through Bandit to see what issues it finds:</p>
<pre><code>python3 -m bandit magic_calculator.py</code></pre>
<p>Here’s the output:</p>
<pre><code>[main]  INFO    profile include tests: None
[main]  INFO    profile exclude tests: None
[main]  INFO    cli include tests: None
[main]  INFO    cli exclude tests: None
[main]  INFO    running on Python 3.9.0
[node_visitor]  INFO    Unable to find qualified name for module: super_calculator.py
Run started:2022-05-29 22:25:37.497963
Test results:
Issue: [B322:blacklist] The input method in Python 2 will read from standard input, evaluate, and run the resulting string as python source code. This is similar to, though in many ways worse than, using eval. On Python 2, use raw_input instead. Input is safe in Python 3. 1
   Severity: High   Confidence: High
   Location: super_calculator.py:1
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b322-input
1       equation = input("Enter an equation: ")
2       result = eval(equation)
3       print(f"{equation} = {result}")

--------------------------------------------------
Issue: [B307:blacklist] Use of possibly insecure function - consider using safer ast.literal_eval. 2
   Severity: Medium   Confidence: High
   Location: super_calculator.py:2
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b307-eval
1       equation = input("Enter an equation: ")
2       result = eval(equation)
3       print(f"{equation} = {result}")

--------------------------------------------------

Code scanned:
        Total lines of code: 3
        Total lines skipped (#nosec): 0

Run metrics:
        <span epub:type="pagebreak" title="573" id="Page_573"/>Total issues (by severity):
                Undefined: 0.0
                Low: 0.0
                Medium: 1.0
                High: 1.0
        Total issues (by confidence):
                Undefined: 0.0
                Low: 0.0
                Medium: 0.0
                High: 2.0
Files skipped (0):
</code></pre><p>The first warning <span class="CodeAnnotation" aria-label="annotation1">❶</span> complains about the <code>input()</code> built-in function being insecure in Python 2. In looking at that warning, a developer might be tempted to say, “Oh, Bandit must be wrong. It’s complaining about Python 2, and I’m using Python 3!” In fact, it’s not wrong here. I am assuming that the code will be run in Python 3, but it might accidentally get executed by Python 2, where <code>input()</code> actually <em>is</em> insecure.</p>
<p>To fix this, I need to add a shebang to the top of my module, to ensure that the code will be executed by Python 3:</p>
<pre><code>#!/usr/bin/env python3

equation = input("Enter an equation: ")
result = eval(equation)
print(f"{equation} = {result}")</code></pre>
<p class="CodeListingCaption"><a id="listing19-24">Listing 19-24</a>: <em>magic_calculator.py:1b</em></p>
<p>Bandit’s second issue <span class="CodeAnnotation" aria-label="annotation2">❷</span> comes with a suggestion: switch to <code>ast.literal_eval()</code> instead of <code>eval()</code>, as the latter is vulnerable to code injection attacks. I’ll revise accordingly:</p>
<pre><code>#!/bin/env/python3
<b>import ast</b>

equation = input("Enter an equation: ")
result = <b>ast.literal_eval(</b>equation<b>)</b>
print(f"{equation} = {result}")</code></pre>
<p class="CodeListingCaption"><a id="listing19-25">Listing 19-25</a>: <em>magic_calculator.py:1c</em></p>
<p>Rerunning Bandit on this revised code shows no more issues. You can find the tool’s full documentation at <a href="https://bandit.readthedocs.io/en/latest/" class="LinkURL">https://bandit.readthedocs.io/en/latest/</a>.</p>
<p>The topic of security may feel irrelevant to your project, but you must remember that it doesn’t necessarily have anything to do with the data your program works with! Many security issues are related to an attacker using your code as a vector or tool in an oft-unrelated attack. Security flaws are like a screen door on a bank vault. It doesn’t matter how it got there, who is meant to use it, or how helpful it is to the authorized users. Sooner or later, someone is going to abuse it for illicit or unauthorized purposes.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2><span epub:type="pagebreak" title="574" id="Page_574"/>GOTCHA ALERT</h2><p class="BoxBodyFirst">	All claims about your program’s security are myths until they’re tested. A clean analysis report from Bandit is not a guarantee your code is secure. Stay up-to-date on the latest security vulnerabilities, including those of any third-party dependencies or their dependencies. When your code even remotely involves system or data security, be prepared to do some fairly rigorous testing.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c19-0008">Reporting Bugs to Python</h2>
<p class="BodyFirst">Sometimes, the problem in your code isn’t your fault! Python, like all code, has bugs that crop up now and then. Once you’re quite certain the bug isn’t coming from your own code or a third-party module or package, you are strongly encouraged to report the bug to the Python developers.</p>
<p>Your first step should be to check whether the bug has already been reported. In any issue tracker, this can be tricky, so be patient with this step. All issues for Python are tracked at <a href="https://bugs.python.org/" class="LinkURL">https://bugs.python.org/</a>, so it’s worthwhile to have an account there. Try searching the site for different words, focusing on the parts of the language you’re using and any keywords in error messages you’ve received. Make sure to omit any words that are unique to your code, as they probably won’t appear in other bug reports. Also, don’t count out previously closed bugs as candidates. Regressions happen. If you find an existing bug that matches your situation, leave a comment with the information you have.</p>
<p>If you can’t find a matching issue, open a new bug report. Be prepared to put some time and effort into it. Since you’re the one facing the bug, you’re in a better position than anyone to pin it down. Provide as much information as possible to help the Python developers reproduce it. Be prepared to respond to further questions, as you’ll likely need to try some things out to prove your code isn’t the real issue.</p>
<p>The Python documentation has a helpful guide explaining how to report bugs effectively. Before reporting an issue, please read that guide at <a href="https://docs.python.org/3/bugs.html" class="LinkURL">https://docs.python.org/3/bugs.html</a>.</p>
<p>Security issues should be handled separately from normal bugs, as they need to be treated with confidentiality to minimize the risks to existing code. If you come across a security flaw in Python, please report it via email to <a href="http://mailto:security@python.org">security@python.org</a>, following the instructions at <a href="https://www.python.org/dev/security/" class="LinkURL">https://www.python.org/dev/security/</a>.</p>
<h2 id="h1-500920c19-0009">Wrapping Up</h2>
<p class="BodyFirst">When it comes to combating bugs, the best defense is a good offense. Writing your code to make good use of exceptions, warnings, assertions, and logging will save you debugging work later.</p>
<p>When bugs do happen, don’t limit yourself to cramming <code>print()</code> statements into every part of your code. Logging and <code>assert</code> statements are helpful for manual debugging and catching problems while developing. <span epub:type="pagebreak" title="575" id="Page_575"/>Meanwhile, the Python debugger (<code>pdb</code>) is one of the most useful tools in your toolbox, and it is well worth learning to use, no matter how fancy the debugger in your IDE is.</p>
<p>Python’s default implementation, CPython, and many extensions besides, are built in C. This means that undefined behavior and other C-related bugs can creep into your Python code. When this happens, <code>faulthandler</code> is your best friend.</p>
<p>Finally, be prepared to check for and address security flaws in your code before anyone can take advantage of them. Bandit helps you get started with this, though true security testing will go beyond the scope of that tool.</p>
<p>Bugs may be inevitable, but the Python ecosystem provides excellent tools for catching, examining, and fixing them!</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="577" id="Page_577"/>20</span><br/>
<span class="ChapterTitle">Testing and Profiling</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">There are two important rules about code: untested code is broken code, and all claims of performance are mythical until proven otherwise. Thankfully, the Python ecosystem offers a wide variety of tools to test and profile your code.</p>
<p><em>Testing</em> is one component of <em>quality assurance (QA)</em>, which in software development aims to improve the overall stability and maintainability of code. While many companies have dedicated QA teams, testing should be the shared responsibility of <em>every single developer</em> on a project. Similarly, <em>profiling</em> is a critical part of confirming that a project meets its performance goals. Even if some design pattern or algorithm looks faster on paper, profiling ensures that your implementation is meaningfully better performing than some alternative. In this chapter, I’ll cover the essentials of testing and profiling in Python, primarily with the pytest testing framework and with an eye toward production code.</p>
<p>Most experienced developers find it most effective to test their programs as part of the coding process, rather than testing the entire finished program <span epub:type="pagebreak" title="578" id="Page_578"/>after the fact. This approach allows developers the flexibility of catching and correcting issues early, when identifying and performing fixes is easier. I follow this process in this chapter. I’ll walk through the development of a complete (if small) multifile project, writing and expanding tests for each section before continuing with development. You’ll learn how to run basic unit tests, conditionally run tests, and correct flaky tests. You’ll additionally learn how to use fixtures, mocks, and parametrization. I’ll also touch on measuring test coverage, automating testing, benchmarking code, and profiling.</p>
<h2 id="h1-500920c20-0001">What About TDD?</h2>
<p class="BodyFirst">The practice of testing should not be confused with the specific methodology of <em>test-driven development (TDD)</em>, wherein you write tests before writing the code and then write the code to make the tests pass. TDD is not mandatory, as you can just as effectively write the tests just after writing your code.</p>
<p>If you’re already a practitioner of TDD, I encourage you to continue applying it throughout this chapter, by writing your tests first. If you’re like me and prefer writing the code before the tests, you can stick with that. The important thing is to write tests, and the sooner, the better.</p>
<h2 id="h1-500920c20-0002">Test Frameworks</h2>
<p class="BodyFirst">There are several frameworks for running tests in Python, many with unique features and use cases. The most popular testing framework for Python is <em>pytest</em>, a streamlined alternative to <code>unittest</code>-based frameworks with minimal boilerplate code. If you don’t know which framework to use, this is the one to pick up. You can find out more from the official documentation at <a href="https://docs.pytest.org/" class="LinkURL">https://docs.pytest.org/</a>, and you can install the <code>pytest</code> package from PyPI via pip.</p>
<p>This chapter also uses <em>tox</em>, which ensures that your packaging works across different Python environments and automatically runs your test suites in each of those environments. You can find the official tox documentation at <a href="https://tox.readthedocs.io/" class="LinkURL">https://tox.readthedocs.io/</a>, and you can install the <code>tox</code> package from PyPI via pip.</p>
<p>Before I dive into testing, I want to touch on a few of the other testing frameworks in regular use in Python projects.</p>
<p>Python’s standard library includes <code>unittest</code>, which has a long history of use. Python 2 had both <code>unittest</code> and <code>unittest2</code>, and the latter became just <code>unittest</code> in Python 3 (<a href="https://docs.python.org/3/library/unittest.html" class="LinkURL">https://docs.python.org/3/library/unittest.html</a>). The standard library also includes <code>doctest</code>, which allows you to write simple tests in docstrings (<a href="https://docs.python.org/3/library/doctest.html" class="LinkURL">https://docs.python.org/3/library/doctest.html</a>). Both of these can be useful when you need to write tests without installing any packages.</p>
<p>The <code>unittest</code> module was further extended and improved by the now discontinued <code>nose</code> framework, which added support for plug-ins. This was in turn replaced by <code>nose2</code>. However, <code>nose2</code> is largely considered outdated, so it’s usually best to rewrite <code>nose2</code> tests to pytest or another modern framework when possible. The pytest documentation has a guide to this at <a href="https://docs.pytest.org/en/stable/nose.html" class="LinkURL">https://docs.pytest.org/en/stable/nose.html</a>.</p>
<p><span epub:type="pagebreak" title="579" id="Page_579"/>There are newer testing libraries, many of which apply innovative ideas and offer simpler interfaces. One such example is <em>Hypothesis</em>, which automatically finds edge cases you may have overlooked simply by writing assertions describing what the code <em>should</em> do. More information is available in the documentation at <a href="https://hypothesis.readthedocs.io/" class="LinkURL">https://hypothesis.readthedocs.io/</a>.</p>
<p>My personal favorite testing library is <em>Ward</em>, which features improved test organization and clearer output. It also works with Hypothesis, and it is fully compatible with asynchrony. You can learn more at <a href="https://wardpy.com/" class="LinkURL">https://wardpy.com/</a>.</p>
<p>Finally, <em>RobotFramework</em> is a test automation framework that integrates with many other tools. It is better suited to large and complex systems that are harder to test, rather than small and compact stand-alone projects. You can learn more about RobotFramework at <a href="https://robotframework.org/" class="LinkURL">https://robotframework.org/</a>.</p>
<h2 id="h1-500920c20-0003">The Example Project</h2>
<p class="BodyFirst">To demonstrate real-world Python testing, I’ll build a complete (but small) command-line program that performs a proofread check on a plaintext file. The program will accept a file path as input, and then it will check the contents of that file for spelling and grammar errors, using a free API. It will then prompt the user to correct the errors by allowing them to choose between suggested revisions. The corrected text will then be written out to another file.</p>
<p>The complete source code for this project can be found on my GitHub, at <a href="https://github.com/codemouse92/textproof" class="LinkURL">https://github.com/codemouse92/textproof</a>. However, I’ll be demonstrating good testing habits in this chapter by testing the program as I write it. I encourage you to follow along. The <code>example_starter</code> branch on that repository contains the initial folder structure and packaging scripts for this example.</p>
<p>To implement the actual spelling and grammar checking, I’ll use the free web API for <em>LanguageTool</em>, an open-source proofreading tool and service (<a href="https://languagetool.org/" class="LinkURL">https://languagetool.org/</a>).</p>
<p>With the exception of the third-party modules <code>requests</code> and <code>click</code> and the LanguageTool API, this example only uses features and techniques you’ve already learned elsewhere in this book.</p>
<p>To use the LanguageTool API, you make a POST request with <code>requests</code>, to which you pass a plaintext string and some other necessary information packed in dictionaries that will be converted behind the scenes to JSON. The LanguageTool service will reply with a very large JSON object containing, among other things, all detected grammar and spelling errors and their suggested corrections. The <code>requests</code> module will return this as a Python dictionary. From there, my code will need to pick out whatever information it needs.</p>
<p>You can find more information about the API, as well as a web interface for trying it out, at <a href="https://languagetool.org/http-api/swagger-ui/#!/default/post_check" class="LinkURL">https://languagetool.org/http-api/swagger-ui/#!/default/post_check</a>.</p>
<p>The <code>click</code> module provides a more intuitive way to design a command-line interface than <code>argparse</code>, which I used in <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>. I’ll use only the decorators <code>@click.command()</code>, <code>@click.argument()</code>, and <code>@click.option()</code>.</p>
<p><span epub:type="pagebreak" title="580" id="Page_580"/>You can install the <code>requests</code> and <code>click</code> modules in your virtual environment via pip. The official documentation for <code>requests</code> can be found at <a href="https://requests.readthedocs.io/" class="LinkURL">https://requests.readthedocs.io/</a>, although I’ll only use the <code>requests.post()</code> method and the <code>requests.Response</code> object it returns. The <code>click</code> module is documented at <a href="https://click.palletsprojects.com/" class="LinkURL">https://click.palletsprojects.com/</a>.</p>
<p>If the LanguageTool API is offline, or if you’re otherwise unable to access it, rest assured that nearly all my tests run <em>without</em> access to the API. Thus, even without an internet connection, you should be able to work through most of the examples and ultimately prove that the code works correctly. This is the beauty of testing.</p>
<h2 id="h1-500920c20-0004">Testing and Project Structure</h2>
<p class="BodyFirst">Before you start testing, it’s critical to get the project structure right. Back in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, I introduced the recommended layout for a Python project, including the all-important <em>setup.cfg</em> file. I’ll expand on a similar structure for this example:</p>
<pre><code>textproof/
├── LICENSE
├── MANIFEST.in
├── pyproject.toml
├── README.md
├── requirements.txt
├── setup.cfg
├── setup.py
├── src/
│   └── textproof/
│   │   ├── __init__.py
│   │   └── __main__.py
├── tests/
│   ├── conftest.py
│   └── __init__.py
└── venv/</code></pre>
<p class="CodeListingCaption"><a id="listing20-1">Listing 20-1</a>: Project directory tree for <em>textproof/</em></p>
<p>The source code for the <code>textproof</code> package belongs in <em>src/textproof/</em>. As I mentioned back in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, use of a <em>src/</em> directory is optional but strongly recommended. Not only does it make packaging easier, but it also simplifies configuration of testing tools. What’s more, it forces you to install your package directly before testing, exposing packaging flaws and any wrong assumptions about the current working directory in your code.</p>
<p>In this structure, the tests themselves will go in the <em>tests/</em> directory. This is known as <em>out-of-place testing</em>.</p>
<p>I’ll briefly review the setup-related files here, focusing primarily on their effect on the testing configuration. See <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span> for a full explanation of each.</p>
<p><span epub:type="pagebreak" title="581" id="Page_581"/><em>LICENSE</em> and <em>README.md</em> are fairly self-explanatory, so I won’t reproduce those here. Similarly, <em>setup.py</em> is the same as in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, so it’s omitted here.</p>
<p>The <em>setup.cfg</em> file is largely the same as the one for the Timecard project in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, except for the metadata and the dependencies. I’ve omitted the metadata to save space:</p>
<pre><code>[options]
package_dir =
    = src
packages = find:
include_package_data = True
install_requires =
    requests
    click
python_version = &gt;=3.6, &lt;4

[options.packages.find]
where = src
exclude = tests

[options.extras_require]
test =
    pytest

[options.entry_points]
console_scripts =
    textproof = textproof.__main__:main

[flake8]
max-line-length = 120</code></pre>
<p class="CodeListingCaption"><a id="listing20-2">Listing 20-2</a>: <em>setup.</em><em>cfg</em><em>:1a</em></p>
<p>I’m using two libraries in this project: <em>requests</em>, for working with the API, and <em>click</em>, for creating the command-line interface. I’m also using pytest for testing; I’ll add some tools here later.</p>
<p>I don’t have any non-code data to include in the package this time, so my <em>MANIFEST.in</em> is pretty sparse:</p>
<pre><code>include LICENSE *.md</code></pre>
<p class="CodeListingCaption"><a id="listing20-3">Listing 20-3</a>: <em>MANIFEST.in</em></p>
<p>The most interesting setup-related file for this example is going to be <em>pyproject.toml</em>, which will ultimately store settings for some testing tools I’m using. For the moment, it looks like the one in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>:</p>
<pre><code>[build-system]
requires = ["setuptools&gt;40.8.0", "wheel"]
build-backend = "setuptools.build_meta"</code></pre>
<p class="CodeListingCaption"><a id="listing20-4">Listing 20-4</a>: <em>pyproject.toml:1a</em></p>
<p><span epub:type="pagebreak" title="582" id="Page_582"/>Under the project structure in <a href="#listing20-1" id="listinganchor20-1">Listing 20-1</a>, my source code belongs in <em>src/textproof/</em>, and my tests belong in <em>tests/</em>.</p>
<h2 id="h1-500920c20-0005">Testing Basics</h2>
<p class="BodyFirst">In this first part, I’ll write some initial code and a few basic tests, which I’ll be able to run even before the full program can be executed.</p>
<h3 id="h2-500920c20-0001">Starting the Example</h3>
<p class="BodyFirst">The first thing my code needs to do is become able to load a text file and save it back out again. I’ll make that happen in my project with a <code>FileIO</code> class, which I’ll use for storing the file contents while I’m working with them:</p>
<pre><code>import pathlib


class FileIO:

    def __init__(self, in_file, out_file=None):
        self.in_file = pathlib.Path(in_file)

        if out_file is None:
            out_file = in_file
        self.out_file = pathlib.Path(out_file)
        self.out_file_tmp = pathlib.Path(out_file + '.tmp')

        self.data = None

    def load(self):
        if not self.data:
            with self.in_file.open('r') as file:
                self.data = file.read()

        return self.data

    def save(self):
        if not self.data:
            raise RuntimeError("Nothing to save.")

        with self.out_file_tmp.open('w') as file:
            file.write(self.data)
        self.out_file_tmp.rename(self.out_file)</code></pre>
<p class="CodeListingCaption"><a id="listing20-5">Listing 20-5</a>: <em>src/textproof/</em><em>fileio.py:1a</em></p>
<p>The <code>FileIO</code> class’s initializer accepts a path to a file to read and optionally a path for writing back out; if no <code>out_file</code> path is specified, it will write to the same file it reads. The <code>load()</code> instance method reads the specified file into a <code>data</code> instance attribute, and the <code>save()</code> instance method writes data out to a file.</p>
<h3 id="h2-500920c20-0002"><span epub:type="pagebreak" title="583" id="Page_583"/>Unit Testing</h3>
<p class="BodyFirst">I test individual behaviors of my code so far with <em>unit tests</em>, so named because each one tests a single <em>unit</em>, such as a function, or in this case, a particular conditional path through a function.</p>
<p>Before I write any more code, I want to test the behaviors of this class so far. In my <em>tests/</em> directory, I create <em>test_fileio.py</em>. By default in pytest, all test modules must start with <code>test_</code> to be detected by the framework. If I named the file <em>tests/fileio.py</em>, none of these tests would run.</p>
<p>Each test is written as a function containing one or more <code>assert</code> statements:</p>
<pre><code>import pathlib
import pytest
from textproof.fileio import FileIO

class TestFileIO:

    def test_in_path(self):
        file = FileIO('tests/to_be.txt')
        assert file.in_file == pathlib.Path('tests/to_be.txt')

    def test_out_path(self):
        file = FileIO('tests/to_be.txt', 'tests/out.txt')
        assert file.out_file == pathlib.Path('tests/out.txt')

    def test_no_out_path(self):
        file = FileIO('tests/to_be.txt')
        assert file.in_file == file.out_file</code></pre>
<p class="CodeListingCaption"><a id="listing20-6">Listing 20-6</a>: <em>tests/test_fileio.py:1a</em></p>
<p>Because all these tests relate to the same part of the code base, it is useful for organizational purposes to group them together in a class.</p>
<p>The first two tests check that the path string passed to the <code>FileIO</code> initializer is turned into a <code>pathlib.Path</code> object bound to the <code>in_file</code> and <code>out_file</code> attributes, respectively. The third test checks that, if only one path string is provided, that path will be used for both <code>in_file</code> and <code>out_file</code>.</p>
<p>Although these may seem like needlessly obvious things to check, these unit tests become invaluable as the code becomes more complex. If any change to the code causes the code to no longer behave in the manner these tests expect, I will be alerted by the failing tests, rather than by some sort of unexpected behavior that must be debugged.</p>
<p>Good testing practice demands that each unit test check only one behavior, which is why I wrote three individual tests, instead of one that checks all three things. This helps me zero in on a particular behavior that isn’t working, instead of having to pick through multiple assertions to find what’s broken.</p>
<p>I also didn’t create constants to hold the string literals I keep repeating. While this is contrary to the coding practice of DRY, it is often considered good practice in Python testing, so your tests never run the risk of false <span epub:type="pagebreak" title="584" id="Page_584"/>positives if a function under testing rebinds, mutates, or otherwise interacts with a variable in an odd way. Avoid using the same variable for both the input and the output.</p>
<p>Lastly, notice that pytest requires test functions to start with <code>test_</code>, and requires test classes to start with <code>Test</code>, in the same way the module must start with <code>test_</code>. If I named that first test only <em>in_path()</em>, it would not be run as a test. You can change this behavior in the settings for pytest: <a href="https://docs.pytest.org/en/latest/example/pythoncollection.html" class="LinkURL">https://docs.pytest.org/en/latest/example/pythoncollection.html</a>. Some other testing frameworks, like Ward, do not have this default convention.</p>
<h3 id="h2-500920c20-0003">Executing the Tests with pytest</h3>
<p class="BodyFirst">To run these tests, I must first install my package in a virtual environment. In the example below, I already created a virtual environment, <em>venv/</em>. I will now install the package, along with its optional testing dependencies, by running the following in the command line from the root of the project:</p>
<pre><code>venv/bin/pip install -e '.[test]'</code></pre>
<p>This installs the local package according to <em>setup.cfg</em>, including any packages needed for testing—namely <code>pytest</code>—which were specified in the <code>[options.extras_require]</code> section (see <a href="#listing20-2" id="listinganchor20-2">Listing 20-2</a>). You’ll notice that I wrap the <code>.[test]</code> in single quotes, to keep the command line from misinterpreting those square brackets as a glob pattern.</p>
<p>I’m also installing my package in <em>editable</em> mode via the <code>-e</code> argument, meaning the installation is directly using the files in <em>src/textproof/</em>, rather than copying them into the virtual environment. This is extremely useful if I need to run the code through a debugger!</p>
<p>To run my project’s tests with pytest, I issue the following command:</p>
<pre><code>venv/bin/pytest</code></pre>
<p>This automatically scans the entire current directory for any modules starting with <em>test_</em>, any classes starting with <em>Test</em>, and any functions starting with <em>test_</em>. When pytest finds these test functions, it runs them, outputting the results onto the terminal in colorful, insightful detail, like this (sans color here in the book, unfortunately):</p>
<pre><code>====================== test session starts =======================
platform linux -- 
rootdir: /home/jason/Code/Repositories/textproof
collected 3 items

tests/test_fileio.py ...                                   [100%]

======================= 3 passed in 0.02s ========================</code></pre>
<p>All’s green and passing! The pytest tool found three tests in the module <em>tests/test_fileio.py</em>, and all three passed, as represented by the three dots after the module name.</p>
<h3 id="h2-500920c20-0004"><span epub:type="pagebreak" title="585" id="Page_585"/>Testing for Exceptions</h3>
<p class="BodyFirst">One significant danger when testing is receiving false positives, wherein a test passes only due to a bug or logic error in the code. For example, have you noticed something odd about those passing tests? They all refer to a file called <em>tests/to_be.txt</em>, but that file does not exist in the project. If <code>FileIO</code> is passed a path to a file that doesn’t exist, it should raise a <code>FileNotFoundError</code> instead of proceeding quietly.</p>
<p>I’ll put that expectation into the form of a test:</p>
<pre><code>    def test_invalid_in_path(self):
        with pytest.raises(FileNotFoundError):
            FileIO('tests/idonotexist.txt')</code></pre>
<p class="CodeListingCaption"><a id="listing20-7">Listing 20-7</a>: <em>tests/test_fileio.py:2a</em></p>
<p>To test that an exception is raised, I use the context manager <code>pytest.raises()</code> instead of an ordinary <code>assert</code> statement. In the suite of the <code>with</code> statement, I run the code that should raise the expected exception.</p>
<p>Re-running pytest shows the test is failing:</p>
<pre><code>====================== test session starts =======================
platform linux -- 
rootdir: /home/jason/Code/Repositories/textproof
collected 4 items

tests/test_fileio.py ...<span class="CodeAnnotation" aria-label="annotation1">❶</span>  F                                  [100%]

============================ FAILURES ============================
________________ TestFileIO.test_invalid_in_path _________________

self = &lt;tests.test_fileio.TestFileIO object at 0x7f9945d29580&gt;

    def test_invalid_in_path(self):
        with pytest.raises(FileNotFoundError):
&gt;           FileIO('tests/idonotexist.txt')
E       <span class="CodeAnnotation" aria-label="annotation2">❷</span>  Failed: DID NOT RAISE &lt;class 'FileNotFoundError'&gt;

tests/test_fileio.py:21: Failed
==================== short test summary info =====================
FAILED tests/test_fileio.py::TestFileIO::test_invalid_in_path
================== 1 failed, 3 passed in 0.03s ===================</code></pre>
<p>The <code>F</code> after the module name indicates a failed test <span class="CodeAnnotation" aria-label="annotation1">❶</span>. More details follow the <code>FAILURES</code> header, indicating that the expected exception was not raised <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Remember that, in this case, failure is a good thing! It means the test has detected a mismatch between the expectations of the test and the behavior of the code.</p>
<p><span epub:type="pagebreak" title="586" id="Page_586"/>Now I set about making the test pass, which, in this case, is as simple as adding some logic to the initializer of the <code>FileIO</code> object:</p>
<pre><code>import pathlib


class FileIO:

    def __init__(self, in_file, out_file=None):
        self.in_file = pathlib.Path(in_file)
        <b>if not self.in_file.exists():</b>
<b>            raise FileNotFoundError(f"Invalid input file: {self.in_file}")</b>

        if out_file is None:
            out_file = in_file
        <var># --snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing20-8">Listing 20-8</a>: <em>src/textproof/</em><em>fileio.py:1b</em></p>
<p>Because I installed my local package as editable, I do not have to reinstall before running pytest again—the virtual environment directly uses the source code, so my changes are visible in that context immediately.</p>
<p>Running the tests now shows the first three tests failing and the fourth passing. Readers familiar with the practice of testing will recognize that this is a step forward, not backward: it reveals that the first three tests were originally passing erroneously!</p>
<h2 id="h1-500920c20-0006">Test Fixtures</h2>
<p class="BodyFirst">Those tests failed not because of a flaw in the code, but due to their own logic. All three wrongly assumed the presence of a particular file, <em>tests/to_be.txt</em>. I could create that file myself, but it would be better to use the test framework to ensure that file is always there in advance. I can do so by creating a <em>software test fixture</em>, usually known as a <em>test fixture</em> or a <em>fixture</em>, which is a function or method that sets up anything a test might need, especially things that are shared by multiple tests. Fixtures can also perform <em>teardown</em>—tasks like closing a stream or database connection or deleting temporary files. By using a fixture, you cut down on errors in writing your tests and save time besides.</p>
<p>I’ll add a fixture to my <code>TestFileIO</code> test class, to create that demo file my tests are expecting.</p>
<pre><code>import pytest
import pathlib
from textproof.fileio import FileIO


class TestFileIO:

    <b>demo_data = "To be, or not to be, that is the question!"</b>

<b>    @pytest.fixture</b>
<span epub:type="pagebreak" title="587" id="Page_587"/><b>    def demo_in_file(self, tmp_path):</b>
<b>        test_in_file = pathlib.Path(tmp_path) / 'to_be.txt'</b>
<b>        with test_in_file.open('w') as file:</b>
<b>            file.write(self.demo_data)</b>
<b>        return str(test_in_file)</b>

<b>    @pytest.fixture</b>
<b>    def demo_out_file(self, tmp_path):</b>
<b>        test_out_file = pathlib.Path(tmp_path) / 'out.txt'</b>
<b>        return str(test_out_file)</b>

    <var>#</var> <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing20-9">Listing 20-9</a>: <em>tests</em><em>/test_</em><em>fileio.py:1c</em></p>
<p>I define the contents of the demo file in the class attribute <code>demo_data</code>. This is acceptable for populating a fixture with example data, so long as I don’t also use the attribute in the test itself as part of an assertion.</p>
<p>The <code>demo_in_file()</code> and <code>demo_out_file()</code> functions are turned into fixtures via the <code>@pytest.fixture</code> decorator. Both fixtures have two important parameters. The <code>tmp_path</code> parameter is actually a fixture that is automatically provided by pytest via <em>dependency injection</em>, wherein an object receives the other objects it needs when it is created or called. In this case, merely <em>naming</em> the parameter <code>tmp_path</code> “magically” causes pytest to provide the <code>tmp_path</code> fixture object to this fixture. The <code>tmp_path</code> fixture will create a temporary directory on the filesystem, and it will automatically delete that directory and its contents when the fixture is torn down.</p>
<p>The <code>demo_in_file()</code> fixture itself writes <code>demo_data</code> to the file, and then it returns the path to that file. Whatever is returned by the fixture is provided directly to any test using said fixture. You can use <code>yield</code> in place of <code>return</code> in a fixture if you need to add teardown logic after that statement, such as closing a database connection.</p>
<p>The <code>demo_out_file()</code> fixture returns a path to an <em>out.txt</em> file (which doesn’t yet exist) in the temporary directory provided by <code>tmp_path</code>.</p>
<p>I use the fixtures in my tests like this:</p>
<pre><code>    # <var>--snip--</var>
    def test_in_path(self, <b>demo_in_file</b>):
        file = FileIO(<b>demo_in_file</b>)
        assert file.in_file == pathlib.Path(<b>demo_in_file</b>)

    def test_out_path(self, <b>demo_in_file, demo_out_file</b>):
        file = FileIO(<b>demo_in_file, demo_out_file</b>)
        assert file.out_file == pathlib.Path(<b>demo_out_file</b>)

    def test_no_out_path(self, <b>demo_in_file</b>):
        file = FileIO(<b>demo_in_file</b>)
        assert file.in_file == file.out_file</code></pre>
<p class="CodeListingCaption"><a id="listing20-10">Listing 20-10</a>: <em>tests</em><em>/test_</em><em>fileio.py:1c</em> (continued)</p>
<p><span epub:type="pagebreak" title="588" id="Page_588"/>Like before, fixtures are added to tests via dependency injection. I need only add a parameter with the fixture’s name (<code>demo_in_file</code>), and pytest will inject the fixture. In the context of the test, <code>demo_in_file</code> will then refer to whatever value was returned or yielded by the fixture; in this case, that’s a string representation of the path to the demo file the fixture created.</p>
<p>I run pytest again and find that all four tests are passing.</p>
<p>Here are a few more unit tests, checking the read-write logic of my <code>FileIO</code> class:</p>
<pre><code>    def test_load(self, demo_in_file):
        file = FileIO(demo_in_file)
        file.load()
        assert file.data == self.demo_data

    def test_save(self, demo_in_file, demo_out_file):
        file = FileIO(demo_in_file, demo_out_file)
        file.data = self.demo_data
        file.save()
        with pathlib.Path(demo_out_file).open('r') as check_file:
            assert check_file.read() == self.demo_data

    def test_save__no_load(self, demo_in_file, demo_out_file):
        file = FileIO(demo_in_file, demo_out_file)
        with pytest.raises(RuntimeError):
            file.save()</code></pre>
<p class="CodeListingCaption"><a id="listing20-11">Listing 20-11</a>: <em>tests</em><em>/test_</em><em>fileio.py:3</em></p>
<p>There’s not much to explain here. I test loading a file, saving a file, and ensuring that saving before loading raises a <code>RuntimeError</code>. These also pass on the first try.</p>
<p>The one thing worth noting is the name <code>test_save__no_load</code>. Some developers like using the naming convention <code>test_</code><var>subject__scenario</var>, using the double-underscore to separate the subject of the test from the description of the scenario under which the subject is being tested.</p>
<h3 id="h2-500920c20-0005">Continuing the Example: Using the API</h3>
<p class="BodyFirst">Now that I have the basic file-reading and file-writing functionality built, I can add the next piece: communicating with the LanguageTool API. Here’s how I do that in my program:</p>
<pre><code>import requests


def api_query(text):
    lang = "en-US"
    response = requests.post(
        "https://languagetool.org/api/v2/check",
        headers={"Content-Type": "application/json"},
        data={"text": text, "language": lang},
    )
<span epub:type="pagebreak" title="589" id="Page_589"/>    if response.status_code != 200:
        raise RuntimeError(f"API error: [{response}] {response.text}")

    software = response.json()["software"]
    print(f"{software['name']} v{software['version']}")
    print(response.json()['language']['name'])
    return response.json()["matches"]</code></pre>
<p class="CodeListingCaption"><a id="listing20-12">Listing 20-12</a>: <em>src/textproof/api.py</em></p>
<p>I use the <code>requests</code> module to send a POST request to the public API endpoint at <a href="https://languagetool.org/api/v2/check" class="LinkURL">https://languagetool.org/api/v2/check</a>. The API will respond with JSON data, which <code>requests</code> will automatically convert to a Python dictionary and return from <code>requests.post()</code>; I bind this dictionary to <code>response</code>.</p>
<p>I check the status code of the POST request; if it’s not <code>200</code>, that indicates a problem communicating with or using the API, and I’d want to raise a <code>RuntimeError</code> with the details.</p>
<p>Otherwise, for a successful response, I print out the name and version of the API on the console for reference, as well as the language I’m checking against. Finally, I return the list of errors detected by LanguageTool. (I know about the keys and structure of the dictionary from trying it out at <a href="https://languagetool.org/http-api/swagger-ui/#!/default/post_check" class="LinkURL">https://languagetool.org/http-api/swagger-ui/#!/default/post_check</a>.)</p>
<p>This either works or doesn’t work, so I won’t test this function directly—although some may see testing it as justifiable. I <em>will</em> test the assumptions it makes about the API response later.</p>
<h3 id="h2-500920c20-0006">Sharing Data Between Test Modules</h3>
<p class="BodyFirst">I need most of my tests to work without internet, for two reasons. First, I want them to work even if I’m disconnected or the API I’m using is temporarily unavailable. Second, I don’t want to send unnecessary API requests just to test my code. Instead, I want to use predetermined local data for most of my tests. This means I’ll need all my tests to have access to this data.</p>
<p>I also need to ensure my assumptions about the API, which are what my code and tests are based on, are correct. This looks like a job for testing!</p>
<p>In my <em>tests/</em> directory, I create a special <em>conftest.py</em> module. This module, <em>with this exact name</em>, is used by pytest to perform initial setup and share fixtures and the like between test modules. Here, I define the data I want my tests to use:</p>
<pre><code>import pytest

example_text = "He and me went too the stor."

example_output = "He and I went to the store."

example_api_response = [
    {
        'context': {
            'length': 2,
            'offset': 7,
<span epub:type="pagebreak" title="590" id="Page_590"/>            'text': 'He and me went too the stor.'
        },
        'length': 2,
        'message': 'Did you mean "I"?',
        'offset': 7,
        'replacements': [{'value': 'I'}],
    },
    {
        'context': {
                'length': 7,
                'offset': 15,
                'text': 'He and me went too the stor.'
        },
        'length': 7,
        'message': 'Did you mean "to the"?',
        'offset': 15,
        'replacements': [{'value': 'to the'}],
    },
    {
        'context': {
            'length': 4,
            'offset': 23,
            'text': 'He and me went too the stor.'
        },
        'length': 4,
        'message': 'Possible spelling mistake found.',
        'offset': 23,
        'replacements': [{'value': 'story'},
                        {'value': 'stop'},
                        {'value': 'store'},
                        {'value': 'storm'}]
    }
]


def pytest_configure(config):
    pytest.example_text = example_text
    pytest.example_output = example_output
    pytest.example_api_response = example_api_response</code></pre>
<p class="CodeListingCaption"><a id="listing20-13">Listing 20-13</a>: <em>t</em><em>ests/conftest.py:1a</em></p>
<p>The value bound to <code>example_api_response</code> is adapted directly from the <code>['matches']</code> value of the LanguageTool API server response for <code>example_text</code>, but I’ve removed all the fields I don’t use in my code. I’ll use this data for many other tests later. The string literal bound to <code>example_output</code> is the grammatically correct form of <code>example_text</code>, after applying the corrections suggested by LanguageTool.</p>
<p>To make these names available to all test modules in the <em>tests/</em> directory, I override the <code>pytest_configure()</code> function and add them as attributes of the <code>pytest</code> namespace. I can access them in any test module in the <em>tests/</em> directory as attributes on <code>pytest</code>.</p>
<h2 id="h1-500920c20-0007"><span epub:type="pagebreak" title="591" id="Page_591"/>Flaky Tests and Conditionally Skipping Tests</h2>
<p class="BodyFirst">Sometimes, there are conditions under which you might want to skip a test, rather than have it fail. The pytest framework offers a function for doing exactly that.</p>
<p>For example, my API test is the only test dependent on having a working internet connection and the LanguageTool API’s availability. If I’m not careful how I write it, it could easily become a <em>flaky test</em>, which is a test that may fail unexpectedly or periodically for reasons other than a flaw in the code it’s testing. Deal with flaky tests as soon as you find them, lest you condition yourself to ignore false negatives. The pytest documentation has an entire section on flaky tests and how to mitigate them at <a href="https://docs.pytest.org/en/stable/flaky.html" class="LinkURL">https://docs.pytest.org/en/stable/flaky.html</a>.</p>
<p>In this case, I need to skip my API layout test when the public API server is unavailable or having other problems. In the following code, I do this with the <code>pytest.skip()</code> function:</p>
<pre><code>import pytest
import requests


def test_api_layout():
    response = requests.post(
        "https://languagetool.org/api/v2/check",
        headers={"Content-Type": "application/json"},
        data={"text": pytest.example_text, "language": "en-US"},
    )
    if response.status_code != 200:
        pytest.skip("Server unavailable")

    matches = response.json()["matches"]
    for from_api, expected in zip(matches, pytest.example_api_response):
        from_api = set(from_api.keys())
        expected = set(expected.keys())
        assert expected.issubset(from_api)</code></pre>
<p class="CodeListingCaption"><a id="listing20-14">Listing 20-14</a>: <em>t</em><em>ests/test_api.py</em></p>
<p>The first part of the test is almost identical to my <code>textproof.api.api_query()</code> function, as I’m sending a POST request with the <code>example_text</code> and storing the response.</p>
<p>Next, I want to skip the test if <code>response.status_code</code> is any value other than <code>200</code>, thereby indicating some sort of problem with the API itself.</p>
<p>I skip a test with <code>pytest.skip()</code>. The pytest results will show that this test was skipped, rather than indicate a failure.</p>
<p>If the API request was successful, then I iterate over the values in the list bound to the <code>["matches"]</code> key in the dictionary representing the API response, and I iterate over the same in <code>pytest.example_api_response</code> as defined in <em>tests/conftest.py</em>. I create a set from each of those lists, and then I ensure that all the expected keys, as outlined in <code>pytest.example_api_response</code>, are also found in the API response.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="592" id="Page_592"/>Pedantic Note</h2><p class="BoxBodyFirst">It is okay to write tests that call an API or access another external resource your program depends on, but you should do this in as few tests as possible. The point is to avoid accidentally hammering the API or resource with too many requests. Making one or two requests in the whole suite of tests is reasonable.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c20-0008">Advanced Fixtures: Mocking and Parametrizing</h2>
<p class="BodyFirst">One of the more challenging components of testing is replicating external inputs, such as user inputs or network responses. <em>Mocking</em> enables you to temporarily replace parts of the code with versions that will simulate inputs or other scenarios during testing.</p>
<p><em>Parametrizing</em> expands a single test out into multiple tests, each one with the same logic but different data. This is especially helpful for testing how your code handles different input data.</p>
<h3 id="h2-500920c20-0007">Continuing the Example: Representing a Typo</h3>
<p class="BodyFirst">Mocking and parametrizing are particularly useful for testing how code handles different user input. In the case of <code>textproof</code>, I’ll be using these concepts to test the command-line user interface, but I have to build that interface first.</p>
<p>In my <code>textproof</code> program, I want to represent a single error found by LanguageTool as an object:</p>
<pre><code>class Typo:
    def __init__(self, typo):
        context = typo["context"]
        self.text = context["text"]
        self.hint_offset = int(context["offset"])
        self.offset = int(typo["offset"])
        self.length = int(typo["length"])
        self.message = typo["message"]
        self.suggestions = typo["replacements"]

    def __str__(self):
        underline = "".join((" " * self.hint_offset, "^" * self.length))
        return "\n".join((self.text, underline, self.message))</code></pre>
<p class="CodeListingCaption"><a id="listing20-15">Listing 20-15</a>: <em>src/textproof/typo.py:1</em></p>
<p>In the initializer, I populate the instance attributes with data from the API response. In the <code>__str__()</code> special instance method, I convert the typo to a string representation by showing the original sentence, underlining the typo with caret symbols (<code>^</code>), and then describing the typo on the next line. The result would look something like this:</p>
<pre><code>He and me went too the stor.
       ^^
Did you mean "I"?</code></pre>
<p><span epub:type="pagebreak" title="593" id="Page_593"/>Displaying a typo is one thing, but it won’t do much good unless the user can change it somehow. LanguageTool provides some suggestions, and I want to allow a user to choose between them.</p>
<p>Here’s the instance method for getting the user’s choice, where each suggested correction from LanguageTool is numbered from one onward, and where <code>0</code> is “skip”:</p>
<pre><code>    def get_choice(self):
        while True:
            raw = input("Select an option: ")
            try:
                choice = int(raw)
            except ValueError:
                print("Please enter a valid integer.")
                continue

            if choice &lt; 0 or choice &gt; len(self.suggestions):
                print("Invalid choice.")
                continue

            return choice</code></pre>
<p class="CodeListingCaption"><a id="listing20-16">Listing 20-16</a>: <em>src/textproof/typo.py:2</em></p>
<p>Finally, here’s the instance method for displaying all the suggestions, which will also call <code>get_choice()</code> and act on the user’s choice:</p>
<pre><code>    def select_fix(self):
        print('')
        print(self)

        for num, suggestion in enumerate(self.suggestions, 1):
            if "shortDescription" in suggestion:
                print(
                    f"{num}: {suggestion['value']} "
                    f"({suggestion['shortDescription']})"
                )
            else:
                print(f"{num}: {suggestion['value']}")
        print("0: (Skip)")

        choice = self.get_choice()
        if choice &gt; 0:
            suggestion = self.suggestions[choice - 1]["value"]
            length_change = len(suggestion) - self.length
            return (suggestion, self.offset, self.length, length_change)
        else:
            return (None, 0, 0, 0)</code></pre>
<p class="CodeListingCaption"><a id="listing20-17">Listing 20-17</a>: <em>src/textproof/typo.py:3</em></p>
<p>With that code in place, I move onward to tests!</p>
<h3 id="h2-500920c20-0008"><span epub:type="pagebreak" title="594" id="Page_594"/>Parametrizing</h3>
<p class="BodyFirst">The first thing I want to test is that the <code>Typo</code> initializer is storing values where and how I expect them. It’s all too easy to mess up dictionary access, after all! I want to test on multiple scenarios, namely the three typos I have the example data for in my <em>conftest.py</em> module.</p>
<p><em>Parametrization</em> allows you to generate multiple scenarios from the same test function. This is preferred over hardcoding all the scenarios in one test, so you can isolate which specific scenarios are failing. In pytest, this is accomplished with the <code>@pytest.mark.parametrize()</code> decorator:</p>
<pre><code>import pytest
from textproof.typo import Typo


class TestTypo:

    @pytest.mark.parametrize("index", range(3))
    def test_create_typo(self, index):
        example_response = pytest.example_api_response[index]
        example_typo = Typo(example_response)
        assert example_typo.offset == example_response['offset']
        assert example_typo.length == example_response['length']
        assert example_typo.message == example_response['message']
        assert example_typo.suggestions == example_response['replacements']</code></pre>
<p class="CodeListingCaption"><a id="listing20-18">Listing 20-18</a>: <em>tests/test_typo.py:1a</em></p>
<p>In this case, I want to run <code>test_create_typo()</code> three times: once for each of the three valid indices on <code>pytest.example_api_response</code> (defined in <a href="#listing20-14" id="listinganchor20-14">Listing 20-14</a>).</p>
<p>The <code>@pytest.mark.parametrize</code> decorator accepts two arguments. The first is the string representation of the name of the parameter to pass values to, which is <code>"index"</code> in this case. The second decorator argument is an iterable of values to pass to the named parameter.</p>
<p>The test itself must have a parameter of the same name, <code>index</code> here, which will receive the values from parametrization. I use that herein to access a particular item in the list <code>pytest.example_api_response</code>.</p>
<p>If I run this with pytest, I see the following:</p>
<pre><code>====================== test session starts =======================
platform linux -- Python 3.8.10, pytest-7.1.2, pluggy-1.0.0
rootdir: /home/jason/Code/Repositories/textproof
collected 11 items

tests/test_api.py .                                        [  9%]
tests/test_fileio.py .......                               [ 72%]
tests/test_typo.py ...                                     [100%]

======================= 11 passed in 0.58s =======================</code></pre>
<p><span epub:type="pagebreak" title="595" id="Page_595"/>You’ll notice three dots next to <em>tests/test_typo.py</em>, indicating three tests were run. These were the three scenarios for <code>test_create_typo()</code>, as generated by parametrization.</p>
<p>If one were to fail, you’d see the value passed to the parameter, like this:</p>
<pre><code>FAILED tests/test_typo.py::TestTypo::test_create_typo[1] - ...</code></pre>
<p>The <code>[1]</code> after the test name indicates the parametrized value, from which you’d know that the problem occurred with the scenario where <code>index</code> was <code>1</code>.</p>
<h3 id="h2-500920c20-0009">Indirect Parametrization of Fixtures</h3>
<p class="BodyFirst">Thinking forward to some other tests I’ll write later, I don’t want to have to directly access items in the <code>pytest.example_api_response</code> list every time, as this is going to be repetitive. Instead, I want to provide a fixture that returns part of the example API response. I want this fixture to be available to all tests, not just those defined in the <em>tests/test_typo.py</em> module, so it belongs in <em>conftest.py</em>.</p>
<p>For this new fixture to work, I will need it to work with parametrization of tests. This is possible via <em>indirect parametrization</em>, where parametrized values are relayed to the fixture.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2>	<p class="BoxBodyFirst">My editors astutely point out that there are less-brittle ways to write many of the following tests. That said, I chose these techniques so I could demonstrate some of the more difficult corners of pytest. These are finely tuned examples, not bastions of best practice. It will be up to you to decide how to best structure your tests and fixtures, based on your situation.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Here’s my new fixture:</p>
<pre><code>@pytest.fixture
def example_response(request):
    return example_api_response[request.param]</code></pre>
<p class="CodeListingCaption"><a id="listing20-19">Listing 20-19</a>: <em>tests/conftest.py:2a</em></p>
<p>To work with parametrization, this fixture <em>must</em> have a parameter named <code>request</code>, which correlates with pytest’s <code>request</code> fixture. Don’t confuse this with the <code>requests</code> module I’ve been using to work with the API. (Can you tell yet that pytest is extraordinarily picky about names?) This will be used to receive the indirect parametrization value; I access that value via <code>request.param</code>.</p>
<p>I’ll also add a similar fixture for generating a <code>Typo</code> object:</p>
<pre><code>@pytest.fixture
def example_typo(request):
    from textproof.typo import Typo
    return Typo(example_api_response[request.param])</code></pre>
<p class="CodeListingCaption"><a id="listing20-20">Listing 20-20</a>: <em>tests/conftest.py:3a</em></p>
<p><span epub:type="pagebreak" title="596" id="Page_596"/>Tests and fixtures are among the rare exceptions to the rule of placing <code>import</code> statements at the top of the module. I want to perform the import when the fixture is used and only make the imported names available in the context of the fixture. That way, these imports won’t leak into other fixtures, which is especially helpful if I need to import conflicting names from elsewhere in a different fixture.</p>
<p>Now I rewrite my test to use these fixtures:</p>
<pre><code>import pytest
from textproof.typo import Typo


class TestTypo:

    @pytest.mark.parametrize(
        <b>("example_typo", "example_response"),</b>
<b>        [(0, 0), (1, 1), (2, 2)],</b>
<b>        indirect=("example_typo", "example_response")</b>
    )
    def test_create_typo(self, <b>example_typo, example_response</b>):
        assert example_typo.offset == example_response['offset']
        assert example_typo.length == example_response['length']
        assert example_typo.message == example_response['message']
        assert example_typo.suggestions == example_response['replacements']</code></pre>
<p class="CodeListingCaption"><a id="listing20-21">Listing 20-21</a>: <em>tests/</em><em>test_typo</em><em>.py:1b</em></p>
<p>The test itself doesn’t need to change much, since I was already using the names <code>example_typo</code> and <code>example_response</code> in the suite of the test function. (It’s almost like I planned this!) I add the new fixtures <code>example_typo</code> and <code>example_response</code> to the parameter list of the test function—these are provided by the special <em>conftest.py</em> module—and those names are locally bound to the values returned by those fixtures.</p>
<p>I need to parametrize on the fixtures, so I once again use the <code>@pytest.mark.parametrize</code> decorator. The first argument is a tuple of names (as strings) I’m parametrizing on. The second is an iterable of tuples, with each tuple representing the values passed to each name. The third argument, the <code>indirect=</code> keyword argument, is a tuple (or other iterable) of names that actually refer to fixtures that will receive the values. In this case, both names are fixtures, although that does not necessarily have to be the case.</p>
<p>Running pytest again shows three tests in <em>test_typo.py</em> as passing, indicating that the parametrization is working!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">I should say, the parametrization <em>appears</em> to work! Once you get the test passing, it’s good to be in the habit of veryfing your assumptions by temporarily printing some of your values and running pytest with the <code>-s</code> flag, to allow print statements through to the standard output. (More on that in a later section.) In an early attempt to write this test, I was inadvertently running the same scenario three times and skipping the other two scenarios completely.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c20-0010"><span epub:type="pagebreak" title="597" id="Page_597"/>Mocking Inputs with Monkeypatch</h3>
<p class="BodyFirst">The way to know that the <code>Typo.get_choice()</code> method is working is to give it some user input. Instead of bribing my four-year-old niece to hammer in some input on the keyboard every time I need to run the test—even though she would work for snacks—I’ll create a <em>mock</em> to temporarily replace Python’s built-in <code>input()</code> method and provide some inputs for the test. In pytest, mocking is performed by a tool called <code>monkeypatch</code>.</p>
<p>I’ll add a fixture to <em>conftest.py</em> for monkeypatching <code>input()</code>:</p>
<pre><code>@pytest.fixture
def fake_inputs(request, monkeypatch):
    def fake():
        value = iter(request.param)

        def input(_):
            return next(value)

        return input

    monkeypatch.setattr('builtins.input', fake())</code></pre>
<p class="CodeListingCaption"><a id="listing20-22">Listing 20-22</a>: <em>tests/conftest.py:4</em></p>
<p>This fixture uses two other fixtures: <code>request</code> and <code>monkeypatch</code>. I intend to have this fixture receive an iterable via parametrization. I’ll use a closure, provided by <code>fake()</code>, to return each value in that iterable with each subsequent call to the closure.</p>
<p>I then temporarily replace the built-in <code>input()</code> method with this closure via <code>monkeypatch.setattr()</code>. Note that I am actually calling <code>fake()</code> here, as I want to monkeypatch the closure itself in place of <code>input()</code>.</p>
<p>Note that I return nothing from this fixture! Its sole purpose is to mock <code>input()</code> for the lifespan of the test using the fixture. The <code>monkeypatch</code> fixture will automatically undo itself during teardown.</p>
<p>Here’s the first version of my test for the <code>Typo.get_choice()</code> unit:</p>
<pre><code>    @pytest.mark.parametrize(
        "fake_inputs",
        [('-1', '20', '3'), ('3',), ('fish', '1.1', '3')],
        indirect=True
    )
    def test_choice(self, fake_inputs):
        example_response = pytest.example_api_response[2]
        example_typo = Typo(example_response)
        assert example_typo.get_choice() == 3</code></pre>
<p class="CodeListingCaption"><a id="listing20-23">Listing 20-23</a>: <em>tests/</em><em>test_typo</em><em>.py:2a</em></p>
<p>I parametrize on <code>fake_inputs</code>, creating three separate scenarios. The first scenario should act as the user inputting <code>-1</code>, <code>20</code>, and <code>3</code>; the first two inputs would prompt the user to try again. The second scenario would act as if the user had input <code>3</code> on the first try. Finally, the third scenario, my favorite, would involve two nonsense inputs: <code>fish</code> and <code>1.1</code>, followed by the <span epub:type="pagebreak" title="598" id="Page_598"/>valid input <code>3</code>. The <code>indirect=True</code> parameter indicates that the other parameters should be passed on to the <code>fake_inputs</code> fixture.</p>
<p>I’ve designed these inputs to be used only with the scenario presented in the third typo scenario; ergo, my explicitly fetching <code>pytest.example_api_response[2]</code>.</p>
<h3 id="h2-500920c20-0011">Marking</h3>
<p class="BodyFirst">I want to be able to use my <code>example_typo</code> fixture, instead of manually accessing the <code>pytest.example_api_response</code> list in this test, but it’s rather overkill to parametrize the same value each time to the <code>example_response</code> fixture. Instead, I can pass a single parameter with <em>marking</em>, which is the application of metadata to tests and fixtures. (Parametrization is a type of marking.)</p>
<p>I’ll use my own custom mark called <code>typo_id</code> to specify a scenario number. I want this same mark to work on <code>example_response</code> and <code>example_typo</code>. Here’s the adjusted <code>example_response</code> fixture:</p>
<pre><code>@pytest.fixture
def example_response(request):
    <b>marker = request.node.get_closest_marker("typo_id")</b>
    <b>if marker:</b>
<b>        index = marker.args[0]</b>
<b>    else:</b>
        <b>index = request.param</b>
    return example_api_response[<b>index</b>]</code></pre>
<p class="CodeListingCaption"><a id="listing20-24">Listing 20-24</a>: <em>tests/conftest:2b</em></p>
<p>In short, I try to get the value passed to the <code>typo_id</code> mark, but if it’s not provided, I default to using the value provided by parametrization. If a value is not provided to the fixture by either means, an <code>AttributeError</code> will be raised from trying to access the then-undefined <code>request.param</code>.</p>
<p>While I’m here, I’ll modify the <code>example_typo</code> fixture in the same way:</p>
<pre><code>@pytest.fixture
def example_typo(request):
    <b>marker = request.node.get_closest_marker("typo_id")</b>
<b>    if marker:</b>
<b>        index = marker.args[0]</b>
<b>    else:</b>
<b>        index = request.param</b>

    from textproof.typo import Typo
    return Typo(example_api_response[<b>index</b>])</code></pre>
<p class="CodeListingCaption"><a id="listing20-25">Listing 20-25</a>: <em>tests/conftest:3b</em></p>
<p>I can now rewrite my <code>test_choice</code> test to use the <code>example_typo</code> fixture with marking:</p>
<pre><code>    <b>@pytest.mark.typo_id(2)</b>
    @pytest.mark.parametrize(
        "fake_inputs",
<span epub:type="pagebreak" title="599" id="Page_599"/>        [('-1', '20', '3'), '3', ('fish', '1.1', '3')],
        indirect=True
    )
    def test_choice(self, <b>example_typo, </b>fake_inputs):
        assert example_typo.get_choice() == 3</code></pre>
<p class="CodeListingCaption"><a id="listing20-26">Listing 20-26</a>: <em>tests/</em><em>test_typo</em><em>.py:2b</em></p>
<p>I use the <code>@pytest.mark.typo_id</code> decorator to pass a value to the <code>typo_id</code> mark, and that is used by the <code>example_typo</code> fixture.</p>
<p>Running pytest again shows this is successful, with one small hiccup:</p>
<pre><code>===================== test session starts ======================
platform linux -- 
rootdir: /home/jason/Code/Repositories/textproof
collected 14 items                                             

tests/test_api.py .                                      [  7%]
tests/test_fileio.py .......                             [ 57%]
tests/test_typo.py ......                                [100%]

======================= warnings summary =======================
tests/test_typo.py:38
  /home/jason/Code/Repositories/textproof/tests/test_typo.py:38: PytestUnknownMarkWarning: Unknown pytest.mark.typo_id - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/mark.html
    @pytest.mark.typo_id(2)

-- Docs: https://docs.pytest.org/en/stable/warnings.html
================ 14 passed, 1 warning in 0.89s =================</code></pre>
<p>There is now a warning about using an unknown mark. To fix this, I need to register the mark with pytest. There are two primary ways I can do this. The first way is to use a configuration file named <em>pytest.ini</em>; the second is to add the setting (using slightly different syntax) to <em>pyproject.toml</em>. Of the two, the latter is preferred, as it allows you to collect nearly all the configuration settings for various Python tools into one <em>pyproject.toml</em> file. I’ll use that approach in this example:</p>
<pre><code>[build-system]
requires = ["setuptools&gt;40.8.0", "wheel"]
build-backend = "setuptools.build_meta"

<b>[tool.pytest.ini_options]</b>
<b>markers = [</b>
<b>    "typo_id: the example scenario number"</b>
<b>]</b></code></pre>
<p class="CodeListingCaption"><a id="listing20-27">Listing 20-27</a>: <em>pyproject.toml:1b</em></p>
<p>Below the section <code>[tool.pytest.ini_options]</code>, I assign to <code>markers</code> a list of all custom mark names as strings. The part of the string after the colon is the mark’s optional description, not part of the mark name.</p>
<p><span epub:type="pagebreak" title="600" id="Page_600"/>Alternatively, I could register the mark from the <code>pytest_configure()</code> function in <em>conftest.py</em>, like this:</p>
<pre><code>def pytest_configure(config):
    pytest.example_text = example_text
    pytest.example_output = example_output
    pytest.example_api_response = example_api_response

    <b>config.addinivalue_line(</b>
<b>        "markers", "typo_id: the example scenario number"</b>
<b>    )</b></code></pre>
<p>However, I’ll stick with the <em>pyproject.toml</em> approach in <a href="#listing20-27" id="listinganchor20-27">Listing 20-27</a> instead.</p>
<p>Whichever way you register the mark, running pytest again shows that the warning is resolved.</p>
<h3 id="h2-500920c20-0012">Capturing from Standard Streams</h3>
<p class="BodyFirst">If I want to test <code>Typo.select_fix()</code>, I need to not only be able to provide input, but also verify the output. By default, pytest captures everything sent to the standard output and standard error streams, including everything sent from print statements. This is why you cannot use <code>print()</code> directly in a test and see the output during the run, unless you invoke pytest with the <code>-s</code> argument to shut off standard output and standard error capture. Because pytest captures output, that output can be accessed directly using the <code>capsys</code> fixture.</p>
<p>Before continuing, I must add the expected outputs to <em>conftest.py</em>:</p>
<pre><code># <var>--snip--</var>

<b>example_prompts = [</b>
<b>"""</b>
<b>He and me went too the stor.</b>
<b>       ^^</b>
<b>Did you mean "I"?</b>
<b>1: I</b>
<b>0: (Skip)</b>
<b>""",</b>
<b>"""</b>
<b>He and me went too the stor.</b>
<b>               ^^^^^^^</b>
<b>Did you mean "to the"?</b>
<b>1: to the</b>
<b>0: (Skip)</b>
<b>""",</b>
<b>"""</b>
<b>He and me went too the stor.</b>
<b>                       ^^^^</b>
<b>Possible spelling mistake found.</b>
<b>1: story</b>
<b>2: stop</b>
<b>3: store</b>
<b>4: storm</b>
<b>0: (Skip)</b>
<span epub:type="pagebreak" title="601" id="Page_601"/><b>"""</b>
<b>]</b>


def pytest_configure(config):
    pytest.example_text = example_text
    pytest.example_output = example_output
    pytest.example_api_response = example_api_response
    <b>pytest.example_prompts = example_prompts</b></code></pre>
<p class="CodeListingCaption"><a id="listing20-28">Listing 20-28</a>: <em>tests/conftest.py:1b</em></p>
<p>I’ll also add a fixture for accessing these prompts using parametrization or the <code>typo_id</code> mark:</p>
<pre><code>@pytest.fixture
def example_prompt(request):
    marker = request.node.get_closest_marker("typo_id")
    if marker:
        index = marker.args[0]
    else:
        index = request.param

    return example_prompts[index]</code></pre>
<p class="CodeListingCaption"><a id="listing20-29">Listing 20-29</a>: <em>tests/conftest.py:5</em></p>
<p>Here’s the test for <code>Typo.select_fix()</code>:</p>
<pre><code>    @pytest.mark.parametrize(
        ("example_typo, example_prompt"),
        [(n, n) for n in range(3)],
        indirect=["example_typo", "example_prompt"]
    )
    def test_prompt(self, example_typo, example_prompt, capsys, monkeypatch):
        monkeypatch.setattr('builtins.input', lambda _: '0')
        example_typo.select_fix()
        captured = capsys.readouterr()
        assert captured.out == example_prompt</code></pre>
<p class="CodeListingCaption"><a id="listing20-30">Listing 20-30</a>: <em>tests/</em><em>test_typo</em><em>.py:3</em></p>
<p>I indirectly parametrize on the fixtures <code>example_typo</code> and <code>example_prompt</code>. I monkeypatch <code>input()</code> to always simulate the user entering <code>0</code> at choice prompts. <em>After</em> running the <code>example_typo.select_fix()</code> method, I retrieve the captured output and ensure it matches the expected output as defined in <code>example_prompts</code> from <em>conftest.py</em>.</p>
<h3 id="h2-500920c20-0013">GUI Testing</h3>
<p class="BodyFirst">Mocking <code>input()</code> and capturing from the standard output stream is all well and good for command-line applications, but what about GUI-based and web-based applications? Although testing a user interface is considerably more complicated, there are a number of libraries that make this easier.</p>
<p><span epub:type="pagebreak" title="602" id="Page_602"/><em>PyAutoGUI</em> is one such tool, allowing you to control the mouse and keyboard from Python. It’s compatible with any Python test framework, and it works on Windows, macOS, and Linux (but not on mobile). More information is available in the official documentation: <a href="https://pyautogui.readthedocs.io/" class="LinkURL">https://pyautogui.readthedocs.io/</a>.</p>
<p>If you’re using the Qt GUI framework (PyQt5, PyQt6, PySide2, or PySide6), consider <em>pytest-qt</em>, which is designed specifically for testing Qt 5 applications. As the name suggests, this is a plug-in for the pytest framework. Check out their official documentation at <a href="https://pytest-qt.readthedocs.io/" class="LinkURL">https://pytest-qt.readthedocs.io/</a>. </p>
<p>If you work with web development, you may already be familiar with <em>Selenium</em>, a browser automation tool for testing web applications. Selenium has official Python bindings, which are available on pip simply as <code>selenium</code>. You can learn more about Selenium at <a href="https://www.selenium.dev/" class="LinkURL">https://www.selenium.dev/</a> or by reading the unofficial documentation, <em>Selenium with Python</em> by Baiju Muthukadan, at <a href="https://selenium-python.readthedocs.io/" class="LinkURL">https://selenium-python.readthedocs.io/</a>.</p>
<p>For mobile development, <em>Appium</em> is one of the leading test automation frameworks. It borrows some concepts and specifications from Selenium, as the name implies. <em>Appium-Python-Client</em> is the official Appium client for Python, and it is available through pip. For more information about Appium, see <a href="https://appium.io/" class="LinkURL">https://appium.io/</a> and <a href="https://github.com/appium/python-client" class="LinkURL">https://github.com/appium/python-client</a>.</p>
<h3 id="h2-500920c20-0014">Continuing the Example: Connecting the API to Typo</h3>
<p class="BodyFirst">In my program, I now need to connect the API request logic and the <code>Typo</code> class. I’ll create a <code>CheckedText</code> class to store the text being edited, alongside the typos detected in it.</p>
<pre><code>from textproof.typo import Typo
from textproof.api import api_query


class CheckedText:
    def __init__(self, text):
        self.text = text
        self.revised = text
        self.length_change = 0
        self.typos = [Typo(typo) for typo in api_query(text)]

    def __str__(self):
        return self.revised

    def fix_typos(self):
        for typo in self.typos:
            suggestion, offset, length, change = typo.select_fix()
            if not suggestion:
                continue
            offset += self.length_change
            self.revised = "".join(
                (
                    self.revised[:offset],
                    suggestion,
<span epub:type="pagebreak" title="603" id="Page_603"/>                    self.revised[offset + length:]
                )
            )
            self.length_change += change</code></pre>
<p class="CodeListingCaption"><a id="listing20-31">Listing 20-31</a>: <em>src/textproof/checked_text.py</em></p>
<p>I’ll let you read through the logic yourself, using what you know. In short, the initializer creates a <code>CheckedText</code> object by running a provided string of plaintext through the API and then initializing <code>Typo</code> objects for each typo reported by the API.</p>
<p>The <code>fix_typos()</code> instance method will iterate over each <code>Typo</code>, prompting the user to select what to do about each via the <code>Typo.select_fix()</code> instance method. Then, the method will make the selected correction directly in a copy of the text, bound to <code>self.revised</code>. In this logic, I had to work out how to deal with a correction having a different length from the original text being replaced, then factor that into future edits. One of the upcoming tests will confirm this logic worked.</p>
<h3 id="h2-500920c20-0015">Autouse Fixtures</h3>
<p class="BodyFirst">All my tests up to this point, except one, have been able to sidestep use of the API. I need to start tying together all the logic in my <code>textproof</code> program, so my upcoming tests will need to monkeypatch the API call. In tests, I <em>always</em> want a call to <code>textproof.api.api_query()</code> to return <code>example_api_response</code>, rather than send a request to the public API. I don’t want to leave it to my (infamously bad) memory to include the fixture on each test that might have such a call. To get around this, I’ll make an <em>autouse fixture</em>, which is automatically applied to all tests.</p>
<p>I add the following fixture to <em>conftest.py</em>:</p>
<pre><code>@pytest.fixture(autouse=True)
def fake_api_query(monkeypatch):
    def mock_api_query(_):
        print("FAKING IT")
        return example_api_response

    monkeypatch.setattr('textproof.api.api_query', mock_api_query)</code></pre>
<p class="CodeListingCaption"><a id="listing20-32">Listing 20-32</a>: <em>tests/conftest.py:6a</em></p>
<p>The <code>autouse=True</code> argument passed to the <code>@pytest.fixture</code> decorator causes this fixture to be used by <em>all</em> tests.</p>
<p>In this fixture, I have a callable that can be called in the same way as <code>textproof.api.api_query</code>, accepting one argument, which I ignore. The callable returns <code>example_api_response</code>. I also print “FAKING IT” to the screen, instead of the public API information that <code>textproof.api.api_query()</code> prints. This is ordinarily invisible, since pytest captures all output, but if I invoke the test with <code>pytest -s</code>, I can confirm that the monkeypatched function is being used instead of the real thing.</p>
<p><span epub:type="pagebreak" title="604" id="Page_604"/>There’s one surprising problem with this fixture: it won’t actually monkeypatch the <code>api_query()</code> function in the context of the <em>src/textproof/checked_text.py</em> module. This is because of this import line:</p>
<pre><code>from textproof.api import api_query</code></pre>
<p>Monkeypatching occurs <em>after</em> the modules have performed all their imports, so replacing <code>textproof.api.api_query</code> doesn’t shadow the function that was already imported into this module as <code>api_query</code>. In other words, the <code>import</code> statement bound the function in question to a second fully qualified name: <code>textproof.checked_text.api_query</code>.</p>
<p>Instead, I need to monkeypatch each fully qualified name that the function may be bound to:</p>
<pre><code>@pytest.fixture(autouse=True)
def fake_api_query(monkeypatch):
    def mock_api_query(_):
        print("FAKING IT")
        return example_api_response

    monkeypatch.setattr('textproof.api.api_query', mock_api_query)
    <b>monkeypatch.setattr('textproof.checked_text.api_query', mock_api_query)</b></code></pre>
<p class="CodeListingCaption"><a id="listing20-33">Listing 20-33</a>: <em>tests/conftest.py:6b</em></p>
<p>If I import <code>api_query</code> elsewhere in my program, I’ll need to add any other fully qualified names to this fixture.</p>
<p>Once this fixture is in place, there’s nothing else I need to do to use it. Because it’s an autouse fixture, all the tests in this project will automatically use it. I can now safely proceed with testing <em>src/textproof/checked_text.py</em>, knowing that no actual API requests will take place in the process:</p>
<pre><code>import pytest
from textproof.checked_text import CheckedText


class TestCheckedText:

    @pytest.fixture
    def example_checked(self, monkeypatch):
        return CheckedText(pytest.example_text)

    def test_checked_text__init(self, example_checked):
        assert example_checked.text == pytest.example_text
        assert len(example_checked.typos) == 3</code></pre>
<p class="CodeListingCaption"><a id="listing20-34">Listing 20-34</a>: <em>tests/test_checked_text.py:1</em></p>
<p>That new fixture and test employ the concepts I’ve already introduced, so I won’t rehash them.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2><span epub:type="pagebreak" title="605" id="Page_605"/>GOTCHA Alert</h2>	<p class="BoxBodyFirst">Monkeypatch cannot be used to provide a function, class, or module that just doesn’t exist. If you need pytest to work despite a missing module, you can write your own module with the same interface as the one that’s missing. Then, in <em>conftest.py</em>, you can add that module to the environment with the dictionary <code>sys.modules</code>, with the key being the name of the module you’re missing.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c20-0016">Mixed Parametrization</h3>
<p class="BodyFirst">It is possible to mix direct and indirect parametrization in the same test. For example, to test different outcomes with the <code>CheckedText</code> object, I will need to use the <code>fake_inputs</code> fixture while directly providing the expected outcome. I can do that like so:</p>
<pre><code>    @pytest.mark.parametrize(
        ("fake_inputs", "expected"),
        [
            ((0, 0, 0), pytest.example_text),
            ((1, 1, 3), pytest.example_output)
        ],
        indirect=["fake_inputs"]
    )
    def test_fix_typo(self, example_checked, fake_inputs, expected):
        example_checked.fix_typos()
        assert example_checked.revised == expected</code></pre>
<p class="CodeListingCaption"><a id="listing20-35">Listing 20-35</a>: <em>tests/test_checked_text.py:2</em></p>
<p>The trick here is that, although I’ve specified two arguments to parametrize, I’ve only made one of them—<code>fake_inputs</code>—indirect. I can then run the <code>example_checked.fix_typos()</code> method, which will use the monkeypatched <code>input()</code> function provided by the <code>fake_inputs</code> fixture, and then compare <code>example_checked.revised</code> to the expected result parametrized on <code>expected</code>.</p>
<p>I should point out that although this test corresponds to a unit, <code>CheckedText.fix_typos()</code>, it is also an <em>integration test</em>, because it demonstrates several other units working together correctly. Integration tests are just as important as unit tests, as it’s perfectly possible to have multiple working units that simply don’t interact correctly.</p>
<h3 id="h2-500920c20-0017">Fuzzing</h3>
<p class="BodyFirst">In the program I built in this chapter, I provided explicit input values for all my tests. However, passing tests may conceal many bugs, because it’s all too easy to overlook edge cases. <em>Fuzzing</em> is a technique that can help catch these edge cases, generating random inputs in tests to find ones that fail in unexpected ways.</p>
<p>The <em>pythonfuzz</em> tool, currently maintained by GitLab, is designed to conduct fuzz testing on Python. It works independently of any other testing framework. To learn more about pythonfuzz, check out the README and examples in the official repository: <a href="https://gitlab.com/gitlab-org/security-products/analyzers/fuzzers/pythonfuzz" class="LinkURL">https://gitlab.com/gitlab-org/security-products/analyzers/fuzzers/pythonfuzz</a>.</p>
<h3 id="h2-500920c20-0018"><span epub:type="pagebreak" title="606" id="Page_606"/>Wrapping Up the Example</h3>
<p class="BodyFirst">Have you noticed that I haven’t even run the <code>textproof</code> package directly yet? It isn’t a complete or valid program, but even now, I know that all the pieces will work as expected. This is the beauty of testing while coding. I can confirm my work on each part as I go, even if the whole is not complete.</p>
<p>Still, this example would feel wrong if it didn’t result in a complete program, so here’s the last needed module: <em>src/textproof/__main__.py</em>:</p>
<pre><code>#!/usr/bin/env python3

import click
from textproof.fileio import FileIO
from textproof.checked_text import CheckedText

@click.command()
@click.argument('path')
@click.option('--output', default=None, help="the path to write to")
def main(path, output):
    file = FileIO(path, output)
    try:
        file.load()
    except FileNotFoundError:
        print(f"Could not open file {path}")
        return

    check = CheckedText(file.data)
    check.fix_typos()
    file.data = str(check)

    file.save()


if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing20-36">Listing 20-36</a>: <em>src/textproof/__main__.py:1a</em></p>
<p>This module defines my program’s command-line interface, using the popular <code>click</code> package, which is easier to use than the similar built-in <code>argparse</code> module. On the command line, I accept one required parameter, <em>path</em>, where I want to read the text from. The optional <code>--output</code> flag accepts a path depicting where I want to write the revised text to.</p>
<p>I define the <code>FileIO</code> object with these paths, read in the text, and instantiate a <code>CheckedText</code> object from that text. As you will remember, in the process of instantiating the <code>CheckedText</code> object, a request is sent to the LanguageTool public API, and the suggested revisions are sent back.</p>
<p>The call to <code>check.fix_typos()</code> will walk the user through each suggestion, prompting them to select a fix, which will be immediately applied. The revised text is given back to the <code>FileIO</code> object file and saved to the file.</p>
<p><span epub:type="pagebreak" title="607" id="Page_607"/>That’s it! Now I can try this out. First, I’ll create a file containing text to revise, which for this example, I’ll just save in the root of the <em>textproof/</em> project directory, next to <em>setup.cfg</em>:</p>
<pre><code>He and me went too the stor.
We gott three bags of chips for the prty.
the cola was too much so we gott lemon lime insted.</code></pre>
<p class="CodeListingCaption"><a id="listing20-37">Listing 20-37</a>: <em>fixme.txt</em></p>
<p>Finally, I’ll invoke my <code>textproof</code> program in the virtual environment, like this:</p>
<pre><code>venv/bin/textproof fixme.txt --output fixmeout.txt</code></pre>
<p>Assuming I have an internet connection with access to the LanguageTool public API, the program will display the first error and prompt me to select a fix. I’ll omit the full output here, since it’s quite long, but I encourage you to try out the program yourself if you’ve been building along with me.</p>
<h2 id="h1-500920c20-0009">Code Coverage</h2>
<p class="BodyFirst">When you start talking to developers about testing, you’ll likely hear the term <em>code coverage</em> a lot. Code coverage refers to the percentage of lines of code in your project that your tests execute, or <em>cover</em>. Good code coverage is important because any uncovered code is likewise not tested and could be harboring bugs or other undesirable behavior.</p>
<p>Python offers two built-in modules that track which statements are executed: <code>trace</code> and <code>ctrace</code>. Instead of using these directly, most Python developers use the third-party tool <em>coverage.py</em> (<code>coverage</code> in pip), which employs <code>trace</code> and <code>ctrace</code> behind the scenes to generate code coverage reports.</p>
<p>I’ll test my code coverage now. If you’re using pytest specifically, you can use <em>pytest-cov</em>, a plug-in that allows you to invoke coverage.py from pytest. I won’t use that plug-in here, to keep this example as framework agnostic as possible. Instead, I’ve adapted and expanded a technique from developer Will Price (<a href="https://www.willprice.dev/2019/01/03/python-code-coverage.html" class="LinkURL">https://www.willprice.dev/2019/01/03/python-code-coverage.html</a>).</p>
<p>First, I want to add the <code>coverage</code> package to my testing dependencies in <em>setup.cfg</em>, like this:</p>
<pre><code><var># --snip--</var>
[options.extras_require]
test =
    pytest
    <b>coverage</b>
<var># --snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing20-38">Listing 20-38</a>: <em>setup.cfg:1b</em></p>
<p><span epub:type="pagebreak" title="608" id="Page_608"/>Next, I’ll ensure that the package is installed in the virtual environment by issuing the following in the command line:</p>
<pre><code>venv/bin/pip install -e '.[test]'</code></pre>
<p>Code coverage will be assessed the same, whether you install your package as editable (with <code>-e</code>) or not. </p>
<p>I also need to tell coverage.py what files to scan and tell it about any replication of those files. This is especially important with an <code>src</code>-based project configuration, where tests may be running code installed in a virtual environment. To inform coverage.py what to scan, I add two new sections to the <em>pyproject.toml</em> file:</p>
<pre><code>[tool.coverage.run]
source = [
    "textproof",
]

[tool.coverage.paths]
source = [
    "src/textproof",
    "**/site-packages/textproof"
]</code></pre>
<p class="CodeListingCaption"><a id="listing20-39">Listing 20-39</a>: <em>pyproject.toml:2</em></p>
<p>In the first section, <code>[tool.coverage.run]</code>, I specify a list of packages I am testing. In the second section, <code>[tool.coverage.paths]</code>, I indicate the path to the original source code and where the source code can be found inside a virtual environment. These paths will be considered equivalent, as far as coverage.py is concerned; the tool will recognize <em>src/textproof/api.py</em> and <em>venv/lib64/python3.9/site-packages/textproof/api.py</em> as the same module, in terms of results.</p>
<p>Finally, I can invoke coverage.py from the command line, like this:</p>
<pre><code>venv/bin/coverage run -m pytest
venv/bin/coverage combine
venv/bin/coverage report</code></pre>
<p>The first command invokes pytest in the context of coverage.py. Although I don’t pass any arguments to pytest here, you can. If you’re using a different test suite, you can invoke that instead of pytest here.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2>	<p class="BoxBodyFirst">You can also invoke coverage.py on your program itself to help find potentially “dead” code—code that is never used by the program—during manual testing. Be careful about the conclusions you draw, however, as a lot of code exists to handle edge and corner cases that might not normally come up.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="609" id="Page_609"/>Next, I combine reports for the same files in different locations, following the guidance I provided in the <code>[tool.coverage.paths]</code> section of <em>pyproject.toml</em>. Depending on your circumstances, this command may not have anything to combine, but it never hurts to check.</p>
<p>Finally, I display the coverage report:</p>
<pre><code>Name                                                     Stmts   Miss  Cover
----------------------------------------------------------------------------
venv/lib/python3.10/site-packages/textproof/__init__.py       0      0   100%
venv/lib/python3.10/site-packages/textproof/__main__.py      19     19     0%
venv/lib/python3.10/site-packages/textproof/api.py           10      8    20%
venv/lib/python3.10/site-packages/textproof/checked_text.py  17      1    94%
venv/lib/python3.10/site-packages/textproof/fileio.py        22      0   100%
venv/lib/python3.10/site-packages/textproof/typo.py          37      1    97%
----------------------------------------------------------------------------
TOTAL                                                      105     29    72%</code></pre>
<p>Seventy-two percent isn’t too bad for a first attempt! I could go back and add more tests if I wished, pushing this number ever closer to 100 percent.</p>
<p>Code coverage is a useful metric to have, so long as you remember that it is part of a larger picture. In his article, “Flaws in coverage measurement” (<a href="https://nedbatchelder.com/blog/200710/flaws_in_coverage_measurement.html" class="LinkURL">https://nedbatchelder.com/blog/200710/flaws_in_coverage_measurement.html</a>), coverage.py developer Ned Batchelder points out that 100 percent coverage can create a false sense of security:</p>
<blockquote class="blockquote">
<p class="Blockquote">There are dozens of ways your code or your tests could still [be] broken, but now you aren’t getting any directions. The measurement coverage.py provides is more accurately called statement coverage, because it tells you which statements were executed. Statement coverage testing has taken you to the end of its road, and the bad news is, you aren’t at your destination, but you’ve run out of road.</p>
</blockquote>
<p>Similarly, in a 2000 paper entitled “How to Misuse Code Coverage,” Brian Marick makes this observation:</p>
<blockquote class="blockquote">
<p class="Blockquote">If a part of your test suite is weak in a way that coverage can detect, it’s likely also weak in a way coverage can’t detect.</p>
</blockquote>
<p>That 72-percent code coverage I achieved tells me that <em>at least</em> 28 percent of the code is not being tested, but the true percentage of untested code is almost certainly more. Code coverage can point out areas where additional testing will be helpful, but it cannot issue any guarantees that additional testing isn’t needed elsewhere.</p>
<p>You can learn more about coverage.py from the official documentation: <a href="https://coverage.readthedocs.io/" class="LinkURL">https://coverage.readthedocs.io/</a>.</p>
<h2 id="h1-500920c20-0010"><span epub:type="pagebreak" title="610" id="Page_610"/>Automating Testing with tox</h2>
<p class="BodyFirst">Up to this point, I’ve been testing on one virtual environment, which in my case is running Python 3.9. I also like to believe that said virtual environment only contains the packages demanded explicitly by <em>setup.cfg</em>, but I may have forgotten about something I manually installed or something I’d previously specified as a requirement that I’ve since dropped but forgotten to uninstall.</p>
<p>The <em>tox</em> tool is a fairly essential part of a testing system, because it automates installing and testing your package in fresh virtual environments for multiple versions of Python. In this section, I’ll demonstrate this tool’s use within my Timecard project.</p>
<p>I should first add <code>tox</code> to my <em>setup.cfg</em>:</p>
<pre><code><var># --snip--</var>
[options.extras_require]
test =
    pytest
    coverage
    <b>tox</b>
<var># --snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing20-40">Listing 20-40</a>: <em>setup.cfg:1c</em></p>
<p>Traditionally, all of the configuration for tox belongs in a <em>tox.ini</em> file. More recently, the trend is shifting toward use of <em>pyproject.toml</em> instead, for as much as possible. As I write, however, native support for <em>pyproject.toml</em> syntax is still forthcoming. You’ll need to embed the <em>tox.ini</em> file contents directly in <em>pyproject.toml</em>, like this:</p>
<pre><code>[tool.tox]
legacy_tox_ini = """
[tox]
isolated_build = True
envlist = py38, py39, py310

[testenv]
deps = pytest
commands = pytest
"""</code></pre>
<p class="CodeListingCaption"><a id="listing20-41">Listing 20-41</a>: <em>pyproject.toml:3</em></p>
<p>Whatever I would have saved in <em>tox.ini</em> now belongs in the multiline string assigned to <code>legacy_tox_ini</code>, under the <code>[tool.tox]</code> section.</p>
<p>Within the <em>tox.ini</em>-style data itself, I have two sections. Under <code>[tox]</code>, I use <code>isolated_build</code> to specify that tox should create fresh, isolated virtual environments for its tests. The field <code>envlist</code> is a comma-separated list of Python environments I want to test against. The tox tool supports Python 2.7 (<code>py27</code>), Python 3.4 (<code>py34</code>) through the latest release (<code>py310</code>, at the moment), Pypy’s latest releases (<code>pypy27</code> and  <code>pypy35</code>), and Jython (<code>jython</code>). (See <span class="xref" itemid="xref_target_Chapter 21">Chapter 21</span> to learn more about Pypy and Jython.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2><span epub:type="pagebreak" title="611" id="Page_611"/>GOTCHA Alert</h2>	<p class="BoxBodyFirst">The tox tool is not magic. You will need to have each Python interpreter you want to test with installed on your base system.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Under the <code>[testenv]</code> section, I list the testing dependencies with <code>deps</code>. You’ll notice I omitted <code>coverage</code> here, since there’s no need to run coverage in all these different environments. I set <code>commands</code> to the command I use to invoke tests: in this case, that’s just <code>pytest</code>. This command will be run directly in each virtual environment, so I don’t need to worry about the <code>venv/bin/</code> prefix, which would be wrong anyway.</p>
<p>I ensure tox is installed in my primary virtual environment via the following, as usual:</p>
<pre><code>venv/bin/pip install '.[test]'</code></pre>
<p>Finally, I can invoke tox:</p>
<pre><code>venv/bin/tox</code></pre>
<p>It may take several minutes to run. As it does, you’ll notice the <code>textproof</code> package and its dependencies (but not the optional <code>[test]</code> dependencies) being installed in each virtual environment and the tests being run.</p>
<p>After everything has run, you’ll see a summary report:</p>
<pre><code>__________________________ summary ___________________________
  py38: commands succeeded
  py39: commands succeeded
  py310: commands succeeded
  congratulations :)</code></pre>
<p>I know that my package installs and my tests work on Python 3.8, Python 3.9, and Python 3.10, so I’m also reasonably confident <code>textproof</code> could run in any of those environments on other machines.</p>
<p>You can learn more about tox from the official documentation: <a href="https://tox.readthedocs.io/" class="LinkURL">https://tox.readthedocs.io/</a>.</p>
<h2 id="h1-500920c20-0011">Benchmarking and Profiling</h2>
<p class="BodyFirst">As programmers, we’re often very interested in making our code run faster. You will likely make many decisions about your code, based primarily on the notion that one technique will run faster than another. As I mentioned at the top of the chapter, all claims of performance are mythical until proven otherwise.</p>
<p><em>Benchmarking</em> is how you establish that one piece of code is faster than another. The closely related technique of <em>profiling</em> is how you find areas where existing code can be optimized, by locating performance bottlenecks and common inefficiencies.</p>
<p>Python offers four built-in tools that are useful for these tasks: <code>timeit</code>, <code>cProfile</code>, <code>profile</code>, and <code>tracemalloc</code>. I’ll cover each briefly.</p>
<h3 id="h2-500920c20-0019"><span epub:type="pagebreak" title="612" id="Page_612"/>Benchmarking with timeit</h3>
<p class="BodyFirst">When you need to quickly verify that one chunk of code is faster than another, <code>timeit</code> is an excellent tool. For example, you may encounter a claim online that multiple assignment in Python is faster than the ordinary single assignment I’ve used throughout the book. You can verify that claim using <code>timeit</code>, like this:</p>
<pre><code>from timeit import timeit

count = 10_000_000

def multiple_assign():
    x, y, z = 'foo', 'bar', 'baz'

time_multiple_assign = timeit(multiple_assign)

def single_assign():
    x = 'foo'
    y = 'bar'
    z = 'baz'

time_single_assign = timeit(single_assign)

print("Multiple assignment:", time_multiple_assign, sep='\t')
print("Individual assignment:", time_single_assign, sep='\t')</code></pre>
<p class="CodeListingCaption"><a id="listing20-42">Listing 20-42</a>: <em>profiling_with_timeit.py</em></p>
<p>Each statement I’m measuring should be in a function or other callable object. I also must determine how many times to evaluate and run each statement. This needs to be a large number of times for the results to be meaningful, and the larger the number is, the more accurate the results will be. I bound this value, <code>10_000_000</code> (10 million), to <code>count</code> and passed it to the optional <code>number=</code> keyword argument of <code>timeit</code>, rather than risk entering different numbers on the two function calls, which would skew the results.</p>
<p>The number of seconds that elapsed while running the statement repeatedly is returned by <code>timeit</code>. I bind the results to <code>time_multiple_assign</code> and <code>time_single_assign</code>. Finally, I print out the results. I use a tab separator in the print statement to line up the two numbers.</p>
<p>Running the code, here are the results:</p>
<pre><code>Multiple assignment:    0.21586943799957226
Individual assignment:  0.18725779700071143</code></pre>
<p>You’ll get different results each time because your computer manages processes via pre-emptive multitasking (recall <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>), meaning the Python process may get suspended at any time to allow another process to work for a few milliseconds. One profiling result is not conclusive; instead, look for trends among a large sample of results.</p>
<p>There’s not a profound difference between the two, but it’s fairly clear that multiple assignment is <em>not</em> faster; it is rather slightly slower, at least on Python 3.10 on my environment.</p>
<p><span epub:type="pagebreak" title="613" id="Page_613"/>Alternatively, I could pass a string literal containing the code to be timed. In this case, that code must be able to run by itself and not depend on anything else in the module. If I needed to perform some setup, I could pass any amount of code as a string to the <code>setup=</code> keyword argument of <code>timeit</code>.</p>
<p>The <code>timeit</code> module also can be used from the command line. Here, I’ll benchmark the exact same code as in <a href="#listing20-42" id="listinganchor20-42">Listing 20-42</a>, but in a UNIX terminal. The responses are inline:</p>
<pre><code>$ <b>python3 -m timeit -n 10000000 'x, y, z = "foo", "bar", "baz"'</b>
10000000 loops, best of 5: 20.8 nsec per loop
$ <b>python3 -m timeit -n 10000000 'x = "foo"; y = "bar"; z = "baz"'</b>
10000000 loops, best of 5: 19.1 nsec per loop</code></pre>
<p>The <code>-n</code> argument is where I specify how many times the code is executed. The last argument is the required one: the Python code to run, as a string. (If you’re using Bash, remember to wrap the string in single quotes, rather than double quotes, to prevent Bash from trying to interpret anything in the Python code.)</p>
<h3 id="h2-500920c20-0020">Profiling with cProfile or profile</h3>
<p class="BodyFirst">While benchmarking produces a single measurement for each code snippet measured, profiling generates a table of measurements, allowing you to see what parts of the code take the most time to run.</p>
<p>Python offers two tools for conducting in-depth code profiling: <code>cProfile</code> and <code>profile</code>. These both have exactly the same interface, but while <code>cProfile</code> is written as a C extension, thereby minimizing overhead and bypassing the GIL, the <code>profile</code> module is written purely in Python and has considerably more overhead as a result. For this reason, I use <code>cProfile</code> whenever possible and only use <code>profile</code> when <code>cProfile</code> is not available, such as when I’m using an alternative Python implementation.</p>
<p>Unlike <code>timeit</code>, the <code>cProfile</code> and <code>profile</code> modules are aware of their own surroundings and can call any functions or methods available in the current namespace.</p>
<p>You <em>can</em> perform benchmarks with <code>cProfile</code> or <code>profile</code>, merely by running the two competing statements or function calls in separate calls to <code>run()</code>. However, <code>timeit</code> is usually better suited for this purpose. I’m instead going to use <code>cProfile</code> for the purpose it’s best suited to: identifying possible performance bottlenecks.</p>
<p>I’ll call <code>cProfile</code> on the <code>main()</code> function from the <code>textproof </code>package’s default entry point, like this:</p>
<pre><code><var># --snip--</var>

if __name__ == "__main__":
    # main()
    <b>import cProfile</b>
    <b>cProfile.run('main()')</b></code></pre>
<p class="CodeListingCaption"><a id="listing20-43">Listing 20-43</a>: <em>src/textproof/__main__.py:1b</em></p>
<p><span epub:type="pagebreak" title="614" id="Page_614"/>Since this is temporary code, I import <code>cProfile</code> right here, instead of at the top of the file. Both <code>cProfile</code> and <code>profile</code> provide identical methods, including <code>run()</code>. If you use <code>profile</code> instead of <code>cProfile</code>, everything else in my examples is the same.</p>
<p>I pass a string containing the Python statement to <code>profile</code>. In this case, I want to profile the entire program by calling the <code>main()</code> function.</p>
<p>Now I can install and invoke my program. I must not use the usual entry point provided by <code>textproof</code>, as that will bypass this whole if <code>__name__</code> clause. Instead, I need to execute the package directly:</p>
<pre><code>venv/bin/pip install -e .
venv/bin/python3 -m textproof fixme.txt --output fixmeout.txt</code></pre>
<p>The program will start as normal, and I can interact with it.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2>	<p class="BoxBodyFirst">This is why I still like having a default package entry point via <code>if __name__ == "__main__"</code>. It provides me with a place to make temporary changes to how the program runs, for experimentation, debugging, and testing purposes, without affecting the primary entry point(s) provided by <em>setup.cfg</em>.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>After I finish using the program and it exits, <code>cProfile</code> displays a report on the terminal. However, this report is huge, difficult to navigate, and unhelpfully sorted by name. I need to sort on something more useful, such as, say, the number of calls.</p>
<p>The class <code>cProfile.Profile()</code> provides a bit more control. Ordinarily, I can use it like this, although there’s one critical problem particular to my code that I’ll come back to:</p>
<pre><code>if __name__ == "__main__":
    # main()
    import cProfile<b>, pstats</b>
    <b>pr = cProfile.Profile()</b>
<b>    pr.enable()</b>
<b>    main()</b>
<b>    pr.disable()</b>
<b>    stats = pstats.Stats(pr)</b>
<b>    stats.strip_dirs()</b>
<b>    stats.sort_stats(pstats.SortKey.CUMULATIVE)</b>
<b>    stats.print_stats(10)</b></code></pre>
<p class="CodeListingCaption"><a id="listing20-44">Listing 20-44</a>: <em>src/textproof/__main__.py:1c</em></p>
<p>I create a new <code>cProfile.Profile</code> object and bind it to the name <code>pr</code>. I enable it with <code>pr.enable()</code>, after which I have the code I want to profile. When I’m done, I disable the profiler in the same manner, with <code>pr.disable()</code>.</p>
<p>To sort the profiling results, I create a <code>pstats.Stats()</code> object. I strip out the path information with <code>strip_dirs()</code>, so I see only module names. Then I sort by the <em>cumulative runtime</em> of each function with <code>sort_stats()</code>, meaning the total time the program spent running that function.</p>
<p><span epub:type="pagebreak" title="615" id="Page_615"/>Finally, I print out the stats with <code>print_stats()</code>, specifying that I only want to see the first 10 lines of output, instead of the hundreds that would be displayed. I could also pass a floating-point number here, representing a percentage of lines to display.</p>
<p>As of Python 3.8, <code>cProfile.Profile</code> is also a context manager, so I can use this syntax instead of manually enabling and disabling:</p>
<pre><code>if __name__ == "__main__":
    # main()
    import cProfile, pstats
    <b>with cProfile.Profile() as pr:</b>
        main()
    stats = pstats.Stats(pr)
    stats.strip_dirs()
    stats.sort_stats(pstats.SortKey.CUMULATIVE)
    stats.print_stats(10)</code></pre>
<p class="CodeListingCaption"><a id="listing20-45">Listing 20-45</a>: <em>src/textproof/__main__.py:1d</em></p>
<p>If you try to run the code from either <a href="#listing20-44" id="listinganchor20-44">Listing 20-44</a> or <a href="#listing20-45" id="listinganchor20-45">Listing 20-45</a>, you’ll notice that <em>there is no output</em>. I spent about half an hour scratching my head over this one. I finally realized that, because I decorated <code>main()</code> with <code>@click.command()</code>, Click causes the program to exit immediately at the end of <code>main()</code>, instead of returning here to finish up. This sort of problem isn’t exclusive to Click. In real-world applications, there are many situations that will cause the program to terminate without returning from <code>main()</code> or another function normally. Perhaps the user closes a window or clicks the Quit button.</p>
<p>In this case, I can get the best results by moving the logic right into my <code>main()</code> function:</p>
<pre><code>#!/usr/bin/env python3

import click
from textproof.fileio import FileIO
from textproof.checked_text import CheckedText

@click.command()
@click.argument('path')
@click.option('--output', default=None, help="the path to write to")
def main(path, output):
    <b>import cProfile, pstats</b>
    <b>with cProfile.Profile() as pr:</b>
        file = FileIO(path, output)
        <var># --snip--</var>

        file.save()<b/>
<b>    stats = pstats.Stats(pr)</b>
<b>    stats.strip_dirs()</b>
<b>    stats.sort_stats(pstats.SortKey.CUMULATIVE)</b>
<b>    stats.print_stats(10)</b>


<span epub:type="pagebreak" title="616" id="Page_616"/>if __name__ == "__main__":
<b>    main()</b></code></pre>
<p class="CodeListingCaption"><a id="listing20-46">Listing 20-46</a>: <em>src/textproof/__main__.py:1e</em></p>
<p>Executing that will <em>finally</em> give me some useful output:</p>
<pre><code>       7146 function calls (7110 primitive calls) in 3.521 seconds

 Ordered by: cumulative time
 List reduced from 652 to 10 due to restriction &lt;10&gt;

 ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      1    0.000    0.000    2.693    2.693 checked_text.py:15(fix_typos)
      9    0.000    0.000    2.693    0.299 typo.py:30(select_fix)
      9    0.000    0.000    2.692    0.299 typo.py:15(get_choice)
      9    2.691    0.299    2.691    0.299 {built-in method builtins.input}
      1    0.000    0.000    0.827    0.827 checked_text.py:6(__init__)
      1    0.000    0.000    0.827    0.827 api.py:4(api_query)
      1    0.000    0.000    0.825    0.825 api.py:107(post)
      1    0.000    0.000    0.825    0.825 api.py:16(request)
      1    0.000    0.000    0.824    0.824 sessions.py:463(request)
      1    0.000    0.000    0.820    0.820 sessions.py:614(send)</code></pre>
<p>The columns here are the number of calls (<code>ncalls</code>), the total time spent in the function itself (<code>tottime</code>), the average time spent in the function (<code>percall</code>), the total time spent in the function and anything it calls (<code>cumtime</code>), and the average thereof (<code>percall</code>). The most insightful of these is <code>cumtime</code>, which I sorted on.</p>
<p>I might have expected the API call to take the longest, but in fact, it’s sixth on this list, with a cumulative runtime of <code>0.827</code> seconds. The method <code>fix_typos()</code> from <em>checked_text.py</em> is the winner, at <code>2.693</code> seconds, but on closer examination, I can see that virtually all this time was spent in the <code>input()</code> function. The program’s runtime is IO-bound, but since it feels perfectly responsive, it needs no further attention.</p>
<p>I could increase the number of results displayed and continue to work my way through it, looking for possible bottlenecks, but you get the idea.</p>
<p>You can also invoke <code>cProfile</code> or <code>profile</code> from the command line. By itself, this does not provide a means of showing only a segment of results, which makes seeing the results decidedly non-trivial. Instead, you can view the results graphically with the tool <em>SnakeViz</em>, installable from pip as <code>snakeviz</code>. Then, I use it like this:</p>
<pre><code>venv/bin/python3 -m cProfile <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> -o profile_out venv/bin/textproof fixme.txt --output fixmeout.txt
venv/bin/snakeviz profile_out</code></pre>
<p>I invoke cProfile directly on the command line, specifying that the profiling results will be saved in the file <em>profile_out</em> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, I open <em>profile_out</em> with <code>snakeviz</code>, which will open an interactive graph of the results in your default web browser.</p>
<p><span epub:type="pagebreak" title="617" id="Page_617"/>You can learn more about SnakeViz at <a href="https://jiffyclub.github.io/snakeviz/" class="LinkURL">https://jiffyclub.github.io/snakeviz/</a>. There’s quite a lot more to profiling on Python. The official documentation does an excellent job of demonstrating how to perform effective profiling and the various considerations that go into it: <a href="https://docs.python.org/3/library/profile.html" class="LinkURL">https://docs.python.org/3/library/profile.html</a>.</p>
<h3 id="h2-500920c20-0021">tracemalloc</h3>
<p class="BodyFirst">If <code>cProfile</code> or <code>profile</code> gives you a picture of time complexity in your code, what about space complexity? If you’re using CPython, you can use <em>tracemalloc</em> to examine how memory is allocated on the system and see what parts of your code are using the most memory.</p>
<p>Bearing in mind the logistical issues I mentioned with <code>cProfile</code>, the documentation is more than sufficient to demonstrate how this works: <a href="https://docs.python.org/3/library/tracemalloc.html" class="LinkURL">https://docs.python.org/3/library/tracemalloc.html</a>.</p>
<h2 id="h1-500920c20-0012">Wrapping Up</h2>
<p class="BodyFirst">Testing is a critical component of any production-grade project. The Python ecosystem offers many tools for testing code, as well as tools for checking code coverage and automating testing in different environments. In practice, it takes a bit of work to get all these components to work together seamlessly, although using an <code>src</code>-based project structure helps. Once your test system is working smoothly, it becomes easier to continually verify that each change you make to the code is a step in the right direction.</p>
<p>The project structure I’ve demonstrated also works well with <em>continuous integration</em> tools, like GitHub Actions, Travis CI, CircleCI, and Jenkins, which automatically run tests on repository commits or pull requests.</p>
<p>In addition to this, you can gain insights on the performance of your code by benchmarking with <code>timeit</code>, profiling with <code>cProfile</code> or <code>profile</code>, and checking memory allocation with <code>tracemalloc</code>.</p>
<p>I’ve also got some incredible news for you: if you’ve been following me since <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, you’ve now seen, learned, and practiced nearly every essential component of the core language, a good chunk of the standard library, and much of the Python ecosystem as a whole. We now have just one more stop to go on our tour.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="619" id="Page_619"/>21</span><br/>
<span class="ChapterTitle">The Parting of the Ways</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">You’ve reached an important milestone on your programming journey: you now know Python! You’ve become familiar with the syntax and patterns, and you’ve learned how to structure, design, and ship production-quality software in the Python language. Equipped with this foundational knowledge, you’ll be able to understand the official documentation and even participate in the pedantic discussions so common among Python developers.</p>
<p>However, there is a profound difference between knowing a language and mastering it. Only by writing real-world code can you truly <em>think</em> in Python. If you’ve been working on an actual project while reading this book, you may already have reached this milestone. Otherwise, your next step is quite simple and yet incredibly complicated: go build something!</p>
<p><span epub:type="pagebreak" title="620" id="Page_620"/>“Yes, but what?” you might say. “I know how Python works now, but what can I really make with it?”</p>
<p>You’re at a crossroads. From here, you can go in many directions. In this chapter, I’ll point out several of the best-traveled roads and suggest further resources for the next leg of your journey, whatever that may be. Finally, I’ll show you how to get plugged into the Python community as a whole.</p>
<h2 id="h1-500920c21-0001">About the Future</h2>
<p class="BodyFirst">Python is under perpetual development. Each version brings new features, and each new feature typically starts life as a PEP, which can stem from conversations anywhere in the community. From there, the PEP may be debated, adjusted, reworked, and ultimately either accepted or rejected.</p>
<p>Due to the nature of software development, not all changes to the language are smooth. When a package is under consideration for addition to the standard library, it may be marked as a <em>provisional package</em> or <em>provisional API</em>, meaning it may change at any time, without regard to backward compatibility. The documentation will warn you of provisional packages, according to the rules outlined in PEP 411.</p>
<p>On occasion, when a feature is slated to be released in a later version of Python but the core developers want to allow users of the language to test a preview version in live code in advance, the feature will be added to a special module called <code>__future__</code>. The upcoming feature can be imported from that module and used as if it had already been made part of the language. As of the date of this writing, there’s only one upcoming feature in <code>__future__</code>: postponed evaluation of annotations (PEP 563), which is a feature of Python 3.10.</p>
<p>If you want an insider’s view of possible new features and the future of the language, sign up for the official forums at <a href="https://discuss.python.org/" class="LinkURL">https://discuss.python.org/</a> and subscribe to the <code>python-dev</code> mailing list at <a href="https://mail.python.org/mailman3/lists/python-dev.python.org/" class="LinkURL">https://mail.python.org/mailman3/lists/python-dev.python.org/</a>.</p>
<h2 id="h1-500920c21-0002">Where Do You Go from Here?</h2>
<p class="BodyFirst">Python’s versatility is a key reason it remains one of the most popular programming languages. Yet it’s essential to remember: you cannot learn everything, nor should you attempt it! Programming is not like riding a bike. Knowledge, once gained, must be regularly practiced or it will be lost.</p>
<p>The better route is to find a problem that you care about solving and build a solution for it. The purpose of this section is to give you a sampling of the sorts of problems Python is commonly used to solve.</p>
<p>The future is in your hands. What will you build?</p>
<h3 id="h2-500920c21-0001"><span epub:type="pagebreak" title="621" id="Page_621"/>Application Development in Python</h3>
<p class="BodyFirst">I personally enjoy building GUI-based user applications in Python. Whether you’re developing for the desktop or mobile, Python is a great language for application development because of its intuitive syntax and wide selection of frameworks.</p>
<p>Even in this internet age, desktop and mobile applications still have a firm place in the market. Services like Spotify and Dropbox provide client applications (both written in Python!) with additional device integration. Desktop applications are still reliable workhorses in many fields and workflows, from graphics design to data visualization. They are also in a position to fully utilize system resources and hardware in ways that may be more challenging in the browser.</p>
<p>There are a number of GUI frameworks available for Python, including <em>Tkinter</em>, the Python binding for the Tk framework. It’s one of the easiest GUI frameworks to pick up, but its default graphics style is noticeably outdated. Tkinter is included in the Python standard library, although some Linux distributions distribute it as a separate package.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">If you want to use Tkinter on macOS 10.6 through at least 10.14, you’ll need to install a newer version of Python than the one that ships with the operating system. There are serious bugs in the version of Tkinter that ships with the Apple-provided Python distribution.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>One of the most prominent GUI frameworks is Qt (officially pronounced “cute”), which provides everything you need to build clean, modern applications across a spectacular array of environments and devices. There are two Python bindings for the Qt framework: <em>PySide2</em> (Qt 5) and <em>PySide6</em> (Qt 6), the official bindings maintained by The Qt Company; and <em>PyQt5</em> or <em>PyQt6</em>, which are maintained by Riverbank Computing.</p>
<p>Another popular GUI framework is <em>GTK</em>, a mature and robust framework that is particularly prominent on Linux. <em>PyGObject</em> is the Python binding for GTK3 and GTK4.</p>
<p><em>Kivy</em> is a GUI toolkit that works across major desktop and mobile operating systems. It’s especially geared toward touch screen devices (although it supports keyboard and mouse) and is particularly well-suited for game development. As of this writing, it’s particularly difficult (and not fully supported) to package a Kivy application for Linux. Some improvements made in Kivy 2.0 are promising on this front, but I still strongly recommend that you figure out your packaging <em>before</em> you start building.</p>
<p>There are quite a few more GUI frameworks, such as <em>wxPython</em> and <em>Flexx</em>, but there are far too many to enumerate here. You can find a fairly up-to-date list here: <a href="https://wiki.python.org/moin/GuiProgramming" class="LinkURL">https://wiki.python.org/moin/GuiProgramming</a>.</p>
<p>If you don’t know where to start with GUI applications, I recommend you start with Qt. If you prefer a guided approach, check out <em>Create GUI <span epub:type="pagebreak" title="622" id="Page_622"/>Applications with Python &amp; Qt5</em> by Martin Fitzpatrick. He has editions of the book for both PySide2 and PyQt5. Visit his website at <a href="https://www.learnpyqt.com/" class="LinkURL">https://www.learnpyqt.com/</a> for more information, plus tutorials and examples.</p>
<h3 id="h2-500920c21-0002">Game Development in Python</h3>
<p class="BodyFirst">Although it’s not as robust as many game engines, Python lends itself to fairly streamlined game development. Prominent games like <em>Civilization IV</em>, <em>EVE Online</em>, <em>Frets on Fire</em>, and <em>Toontown Online</em> were all built with Python. Depending on the game, you may be able to get by with one of the general-purpose GUI frameworks, but for best results, you’ll often want to pick up a dedicated game development library.</p>
<p><em>PyGame</em> is one of the oldest and most frequently cited Python game development libraries. It’s primarily a wrapper around the <em>Simple DirectMedia Layer (SDL2)</em>, which provides cross-platform access to the hardware for working with graphics, sound, and devices. It also interfaces with other graphics APIs, like <em>OpenGL</em>, <em>Direct3D</em>, and <em>Vulkan</em>.</p>
<p>There are more options beyond PyGame, depending on the sort of game you want to build. <em>Wasabi2D</em> and <em>pyglet</em> both work with OpenGL, which is the underpinning of most major game engines. <em>Panda3D</em> and <em>Ogre</em> are two popular options for creating real-time 3D games. There are many other libraries besides.</p>
<p>Whichever game development framework you want to use, its documentation is the best place to start. Alternatively, if you’d prefer a shallow learning curve with plenty of guided examples, check out Al Sweigart’s <em>Invent Your Own Computer Games with Python,</em> 4th Edition (No Starch Press, 2016), which will get you acclimated to PyGame and, more importantly, the different concepts associated with game development.</p>
<h3 id="h2-500920c21-0003">Web Development in Python</h3>
<p class="BodyFirst">Python excels as a server-side language, especially for rapidly developing web applications and APIs. There are three libraries in the spotlight at present for this: <em>Django</em>, <em>Flask</em>, and <em>FastAPI</em>.</p>
<p><em>Django</em> is the batteries-included option. It employs a Model View Template (MVT) architecture, and it includes database integration, an object-relational mapper (ORM), and just about everything you could need to build a web application or API in Python. Django is used by BitBucket, Instagram, the Public Broadcasting Service (PBS), and the <em>Washington Times,</em> among others. To get started with Django, visit their website at <a href="https://www.djangoproject.com/" class="LinkURL">https://www.djangoproject.com/</a>. Django Girls also has a particularly excellent tutorial at <a href="https://tutorial.djangogirls.org/" class="LinkURL">https://tutorial.djangogirls.org/</a>.</p>
<p><em>Flask</em>, by contrast, is the minimalist option. It’s lightweight, providing the bare-minimum framework and leaving it to the developer to choose what tools and components to use. The Flask community provides a wide variety of extensions for adding functionality on par with Django, all of which are selected and installed separately. Flask emphasizes leaving as much control in the hands of the developer as possible. Websites like Pinterest and LinkedIn <span epub:type="pagebreak" title="623" id="Page_623"/>are built in Flask. If you want to learn Flask, their documentation will guide you through the entire process of setting up, getting started, and working with every part of the framework: <a href="https://flask.palletsprojects.com/" class="LinkURL">https://flask.palletsprojects.com/</a>.</p>
<p><em>FastAPI</em> is a framework aimed at web API design specifically. It is designed for performance and stability, and it is fully compliant with the OpenAPI (Swagger) and JSON Schema. See the documentation at <a href="https://fastapi.tiangolo.com/" class="LinkURL">https://fastapi.tiangolo.com/</a>.</p>
<h3 id="h2-500920c21-0004">Client-Side Python</h3>
<p class="BodyFirst">You may wonder if it is possible to run Python in the browser, client-side. At present, there are a few implementations of Python attempting exactly that. Here are just a few.</p>
<p><em>Brython</em>, which is short for <em>Browser Python</em>, is the more mature of the two options. It works by transpiling Python to JavaScript. Brython is designed to work with the W3C Document Object Model (DOM). More information and full documentation are available at <a href="https://www.brython.info/" class="LinkURL">https://www.brython.info/</a> and on the project’s GitHub at <a href="https://github.com/brython-dev/brython" class="LinkURL">https://github.com/brython-dev/brython</a>. </p>
<p><em>Skulpt</em> is a newer solution; it’s intended to be a complete implementation of the Python language in JavaScript, as opposed to a transpiler. As of this writing, Skulpt is still missing a lot of core language features. More information is at <a href="https://skulpt.org/" class="LinkURL">https://skulpt.org/</a>.</p>
<p><em>Pyodide</em> is a third option. It’s a port of CPython to WebAssembly and Emscripten, and has support for many C extensions. More information and documentation can be found at <a href="https://pyodide.org/en/stable/" class="LinkURL">https://pyodide.org/en/stable/</a>.</p>
<h3 id="h2-500920c21-0005">Data Science in Python</h3>
<p class="BodyFirst">Python is one of the leading languages in the field of <em>data science</em>, which focuses on gaining insights and extracting information by aggregating and analyzing data. Data science is considered applied statistics and related to but distinct from computer science. The task of distilling information out of a data set is sometimes referred to as <em>data mining</em>. The term <em>big data</em> refers to work with particularly large data sets.</p>
<p>There is a vast ecosystem geared especially toward data science, although many of these tools are also useful in software development.</p>
<h4 id="h3-500920c21-0001">The Data Science Environment</h4>
<p class="BodyFirst"><em>Jupyter Notebook</em> is perhaps the single most important tool in the data science ecosystem. It is a complete interactive-development environment and is particularly well-suited to data science and scientific computing, as it combines executable Python code with Markdown-formatted text, mathematics equations, live charts and graphs, and other rich media. A <em>notebook document</em> is a single Jupyter Notebook file, ending in the file extension <em>.ipynb</em> (for IPython Notebook, the former name of Jupyter Notebook). In addition to supporting Python, Jupyter works with the other two most popular languages in data science, namely <em>Julia</em> and <em>R</em>. You can learn more about Jupyter Notebook and its related projects at <a href="https://jupyter.org/" class="LinkURL">https://jupyter.org/</a>.</p>
<p><span epub:type="pagebreak" title="624" id="Page_624"/><em>Anaconda</em> is a distinct Python distribution geared specifically toward data science and scientific computing. It ships with over 250 of the most common data science libraries and tools preinstalled, including Jupyter Notebook. It also comes with its own integrated development environment, <em>Anaconda Navigator</em>, and a dedicated package manager, <em>conda</em>. In addition to all this, Anaconda offers a data science–oriented cloud service with both free and paid plans. More information can be found at <a href="https://anaconda.org/" class="LinkURL">https://anaconda.org/</a>.</p>
<h4 id="h3-500920c21-0002">Data Science Packages</h4>
<p class="BodyFirst">There are hundreds of packages for data science in Python, but there are a handful of particularly notable ones, many of which consistently lead the pack:</p>
<ol class="none">
<li><em>Pandas</em> is considered essential for processing data. It supplies <em>dataframes</em>, which allow you to select, merge, reshape, and process data from databases, spreadsheets, tables, CSV files, and more, similar to the R language. Learn more at <a href="https://pandas.pydata.org/" class="LinkURL">https://pandas.pydata.org/</a>.</li>
<li><em>NumPy</em> is the leading package for handling numeric computing, everything from mathematics to statistical analysis, and even performing advanced processing of lists and arrays. Learn more at <a href="https://numpy.org/about" class="LinkURL">https://numpy.org/about</a><em>/</em>.</li>
<li><em>SciPy</em> (the library) expands on NumPy, offering additional numeric routines for scientific computing, including linear algebra and numerical optimization. It is part of the <em>SciPy ecosystem</em>, along with NumPy, pandas, and several other tenants of this list. Learn more at <a href="https://scipy.org/" class="LinkURL">https://scipy.org/</a>.</li>
<li><em>Matplotlib</em> is one of the most popular libraries for generating plots, charts, graphs, and other data visualizations. Learn more at <a href="https://matplotlib.org/." class="LinkURL">https://matplotlib.org/.</a></li>
<li><em>Seaborn</em> expands on Matplotlib and is integrated with pandas, to provide more advanced data visualization tools (with all the pretty colors!) Learn more at <a href="https://seaborn.pydata.org/." class="LinkURL">https://seaborn.pydata.org/.</a></li>
<li><em>Bokeh</em> is another popular visualization library, independent of Matplotlib, that allows you to create interactive data visualizations that can be embedded in web pages and Jupyter notebooks. Learn more at <a href="https://bokeh.org/." class="LinkURL">https://bokeh.org/.</a></li>
<li><em>Dask</em> is a Python parallelism library that is built specifically for working with major packages in data science and related fields. It allows you to speed up the execution time, especially when working with large data sets or CPU-intensive analysis. Learn more at <a href="https://dask.org/." class="LinkURL">https://dask.org/.</a></li>
<li><em>Kedro</em> is relatively new to the party, but it fulfills an important role in data science: the need for a framework to keep data pipelines scalable, easily maintainable, and production ready. Learn more at <a href="https://kedro.readthedocs.io/." class="LinkURL">https://kedro.readthedocs.io/.</a></li>
</ol>
<p>There are plenty of subtopics in the realm of data science, including <em>geographic information systems (GIS)</em> and the many branches of <em>scientific computing</em>. These fields often have their own common libraries and tools.</p>
<p><span epub:type="pagebreak" title="625" id="Page_625"/>Also worth a mention is <em>Numba</em>, a just-in-time (JIT) compiler for Python and NumPy, which allows you to compile specific, selected parts of your Python program to machine code.</p>
<p>One way to learn more about the Anaconda ecosystem, including many of the libraries listed here, is to read <em>Doing Science with Python</em> by Lee Vaughan (No Starch Press, 2022).</p>
<h3 id="h2-500920c21-0006">Machine Learning in Python</h3>
<p class="BodyFirst">Another popular topic in Python is <em>machine learning</em>, which is at the heart of artificial intelligence. Machine learning is the process by which an algorithm can be made to improve automatically over time, based on data and feedback provided to it. This is a process known as <em>training</em>. For example, your smartphone uses machine learning to improve its autocompletion suggestions while you type. The more you use your smartphone, the better that algorithm gets at suggesting the word you’re typing.</p>
<p>Machine learning works using <em>neural networks</em>, which are data structures that replicate the structure and behavior of biological neural networks, such as the brain you are using right now. When you layer neural networks together, you get into the topic of <em>deep learning</em>.</p>
<p>The structure of a neural network isn’t particularly difficult to comprehend, but there is a fair bit of advanced mathematics involved, including linear algebra, multivariate calculus, and probability. If you’re interested in machine learning, invest some time in understanding this math well. Don’t worry about doing the math on paper; focus on mastering the concepts and let the computer do the number crunching for you.</p>
<p>Machine learning is often closely associated with data science. (The data used to train the neural network has to come from somewhere!) Therefore, you’ll find many of the same packages used across both specialties.</p>
<p>Here are the five most popular machine learning packages:</p>
<ol class="none">
<li><em>TensorFlow</em> is a C++ and Python symbolic math library behind some of today’s larger machine learning projects, including artificial intelligence work at Google, where it got its start. It’s harder to learn than many of the other options, but it’s widely used, especially due to its speed. Learn more at <a href="https://www.tensorflow.org/" class="LinkURL">https://www.tensorflow.org/</a>.</li>
<li><em>Keras</em> is a deep- learning API that expands on TensorFlow, and it is generally considered easier to use besides. If you’re looking for a place to start, this is an excellent option. Learn more at <a href="https://keras.io/" class="LinkURL">https://keras.io/</a>.</li>
<li><em>Scikit-learn</em> is a simpler machine learning library built atop NumPy. It is particularly useful for predictive data analysis and other data science applications. Learn more at <a href="https://scikit-learn.org/" class="LinkURL">https://scikit-learn.org/</a>.</li>
<li><em>PyTorch</em> is based on Facebook’s Torch framework. It independently brings the same functionality you’d get out of NumPy, SciPy, and Scikit-learn. PyTorch offers acceleration via the GPU, and it can work with deep neural networks. Learn more at <a href="https://pytorch.org/" class="LinkURL">https://pytorch.org/</a>.</li>
<li><em>Aesera</em> is a Python-only machine learning library that tightly integrates with NumPy and focuses primarily on some of the mathematics involved. <span epub:type="pagebreak" title="626" id="Page_626"/>Although it can be used by itself, it’s most often employed alongside other options, like Keras. Aesera is a continuation of the <em>Theano</em> library. Learn more at <a href="https://aesara.readthedocs.io/en/latest/" class="LinkURL">https://aesara.readthedocs.io/en/latest/</a>.</li>
</ol>
<p>Within the arena of machine learning are a number of other specialties, including natural language processing and computer vision. Once you understand the basics of machine learning, you can branch out into whatever subtopics you find interesting.</p>
<p>If you’re interested in this field, two books to get you started are <em>Deep Learning: A Visual Approach</em> by Andrew Glassner (No Starch Press, 2021) and <em>Practical Deep Learning</em> by Ronald T. Kneusel (No Starch Press, 2021). If you prefer to learn as you go, start with Keras or Scikit-learn.</p>
<h3 id="h2-500920c21-0007">Security</h3>
<p class="BodyFirst">Python is increasingly popular in the field of <em>information security</em>, or <em>infosec</em>, which focuses on ensuring data, software, and computer systems are safe and secure.</p>
<p>A word of caution is prudent here. The techniques used to find flaws in security that need to be shored up are the same techniques used to exploit those flaws. The entire field of infosec operates on a fine legal and ethical line, which separates ethical (“white hat”) hackers from criminal (“black hat”) hackers. Both sides know how to construct and deploy malware, reverse engineer software, and hack into systems: the difference is that the ethical hackers use these techniques to find and report or close security holes before criminal hackers can exploit them. For example, the infamous Heartbleed and Spectre bugs were discovered and reported by ethical hackers before they could be exploited.</p>
<p>Two of the best books about Python and infosec are <em>Black Hat Python</em>, 2nd Edition, by Justin Seitz and Tim Arnold (No Starch Press, 2021) and <em>Gray Hat Python</em>, also by Justin Seitz (No Starch Press, 2009). (The titles are deliberately ironic.) If you’re interested in this field, those books provide the best place to start.</p>
<p>But once again, let me remind you: it is your responsibility to use your powers for good. Using computers to commit crimes or cause trouble is <em>never</em> okay, and doing so will earn you the derision of the entire Python community. Keep your hacking ethical.</p>
<h3 id="h2-500920c21-0008">Embedded Development in Python</h3>
<p class="BodyFirst">If maker culture is more your speed, you’ll be pleased to know that Python is currently the fastest-growing language in <em>embedded development</em>, wherein code is shipped directly on the hardware it controls. This means you can use Python for robotics, Internet-of-Things devices, and many other hardware projects.</p>
<p>Python works with Raspberry Pi, which comes with the <em>Thonny</em> Python IDE preinstalled. More information can be found at <a href="https://www.raspberrypi.com/documentation/computers/os.html" class="LinkURL">https://www.raspberrypi.com/documentation/computers/os.html</a>.</p>
<p>Python can be used to program the <em>Arduino</em> microcontroller via <em>pyserial</em>: <a href="https://pythonhosted.org/pyserial/" class="LinkURL">https://pythonhosted.org/pyserial/</a>.</p>
<p><span epub:type="pagebreak" title="627" id="Page_627"/><em>MicroPython</em> is a separate implementation of Python that is geared specifically toward embedded development. It works best with the <em>pyboard</em> microcontroller. You can learn more about MicroPython and pyboard at <a href="https://micropython.org/" class="LinkURL">https://micropython.org/</a>.</p>
<p><em>CircuitPython</em> is another Python implementation. It is based on MicroPython but geared primarily toward <em>Adafruit</em> microcontrollers. It can also be used on a number of Raspberry Pi and Ardunio microcontrollers, as well as hardware from many other brands. Device-specific downloads and links to documentation, tutorials, and guides can be found at <a href="https://circuitpython.org/" class="LinkURL">https://circuitpython.org/</a>.</p>
<h3 id="h2-500920c21-0009">Scripting</h3>
<p class="BodyFirst">With all these vast and impressive uses of Python, it’s easy to forget that one of the reasons this language exists is to facilitate automation and scripting. Countless libraries exist to allow Python to interact with all sorts of software, operating systems, and hardware. If you have a repetitive task that needs a clean solution, there’s a good chance that Python can help with that.</p>
<p>Two excellent books for learning how to automate with Python are <em>Real-World Python</em> by Lee Vaughan (No Starch Press, 2020) and <em>Automate the Boring Stuff</em> <em>with Python</em>, 2nd Edition, by Al Sweigart (No Starch Press, 2019).</p>
<h2 id="h1-500920c21-0003">Python Flavors</h2>
<p class="BodyFirst">As you’ve probably gathered, the default implementation of Python, known formally as <em>CPython</em>, isn’t the only implementation out there. Quite a few others exist, most of them with special uses.</p>
<p>I have to start by mentioning a highly specialized implementation, <em>RPython</em>, which is geared toward building interpreted languages. It’s a restricted subset of the Python language with a <em>just-in-time (JIT) compiler</em>, meaning the language is built to machine code immediately before execution, instead of being interpreted during execution by an interpreter. RPython is extensively documented at <a href="https://rpython.readthedocs.io/" class="LinkURL">https://rpython.readthedocs.io/</a>.</p>
<p><em>PyPy</em> is another implementation, and it is notable for being quite a bit faster than CPython. It is implemented on RPython, instead of C. It owes its speed to the fact that it is JIT compiled, instead of interpreted, allowing it to reach performance comparable to C++ or Java. PyPy is always several versions behind CPython—as of this writing, it is up to Python 3.6—but for projects where performance matters, this is an acceptable compromise. Additionally, because PyPy does not rely on C, it typically doesn’t work with binary extensions, except for some built to that purpose in CFFI.</p>
<p><em>Stackless Python</em> is another peculiar implementation of Python that offers some unique tools for improved concurrency and code structure. Stackless is its own beast in many ways, and it must be learned as such. The best place to start is with its wiki, which has links to further reading and resources: <a href="https://github.com/stackless-dev/stackless/wiki" class="LinkURL">https://github.com/stackless-dev/stackless/wiki</a>.</p>
<p>Earlier, I mentioned <em>Brython</em> (<a href="https://www.brython.info/" class="LinkURL">https://www.brython.info/</a>), <em>Skulpt</em> (<a href="https://skulpt.org/" class="LinkURL">https://skulpt.org/</a>), and <em>Pyodide</em> (<a href="https://pyodide.org/en/stable/" class="LinkURL">https://pyodide.org/en/stable/</a>), which are in-browser <span epub:type="pagebreak" title="628" id="Page_628"/>implementations of Python geared toward web development. I also mentioned <em>MicroPython</em> (<a href="https://micropython.org/" class="LinkURL">https://micropython.org/</a>) and <em>CircuitPython </em>(<a href="https://circuitpython.org/" class="LinkURL">https://circuitpython.org/</a>), which are implementations for embedded development.</p>
<p>Besides these, there are a handful of implementations of the Python interpreter built in different languages. The four most notable of these are RustPython, implemented in Rust; IronPython and <em>Python.NET</em>, both of which integrate tightly with the .NET framework; and <em>Jython</em>, which is written in Java for integration with the <em>Java Virtual Machine (JVM)</em>. As of this writing, RustPython supports up to Python 3.9, and Python.NET supports up to Python 3.8, while IronPython is only on Python 3.4, and Jython is still in line with Python 2.7. You can learn more about RustPython at <a href="https://rustpython.github.io/" class="LinkURL">https://rustpython.github.io/</a>, IronPython at <a href="https://ironpython.net/" class="LinkURL">https://ironpython.net/</a>, Python.NET at <a href="https://pythonnet.github.io/" class="LinkURL">https://pythonnet.github.io/</a>, and Jython at <a href="https://www.jython.org/" class="LinkURL">https://www.jython.org/</a>.</p>
<p>No matter what implementation you use, remember that the official implementation, CPython, serves as the baseline for all of them. Even if you plan to spend most of your time in another implementation, it’s important to know how to use CPython well.</p>
<h2 id="h1-500920c21-0004">Developing for Python</h2>
<p class="BodyFirst">The Python ecosystem itself is maintained by thousands of developers around the world. Some write libraries to answer specific needs, while others extend and improve the Python language in all its different implementations.</p>
<p>If you’d like to become involved in the development of Python, it would be helpful for you to have some experience or interest in other branches of development, so you’ll understand what needs exist and how to best address them. Very few developers set out to work on Python; rather, they drift into it after recognizing an area of need in their own work. Even so, when you’re able to contribute to the Python ecosystem, it’s a great feeling indeed.</p>
<h3 id="h2-500920c21-0010">Developing Python Packages and Tools</h3>
<p class="BodyFirst">The techniques you’ve learned in this book have fully prepared you to build and ship production-quality packages, libraries, and development tools. Maybe you have some ideas already, or maybe you’re still pondering what you could build.</p>
<p>In either case, I strongly recommend learning more about the existing tools and packages you use on a regular basis. A large majority of projects are maintained by a handful of volunteers, often thanklessly, and issues sometimes come in faster than the volunteers can resolve them. Before you set out to build a brand-new thing, consider if you could instead improve an existing solution. Contributing to open source projects is an incredible way to build your skills and make new professional connections. Your contributions don’t even have to be massive. Whether you’re performing code reviews on backlogged pull requests, fixing minor bugs, doing small “housekeeping” tasks, tidying up the documentation, or polishing the packaging, it all helps!</p>
<p>There are also a number of projects that are abandoned or otherwise unmaintained and are in need of a new maintainer to step up and take over. <span epub:type="pagebreak" title="629" id="Page_629"/>When you adopt an abandoned project, you get the benefits of a working code base (for some definitions of “working”) and an existing user base. Often, projects are abandoned because they need to be ported to Python 3. Also, working with legacy code can be a very rewarding experience. </p>
<p>Nearly all packages on the Python Package Index (PyPI) have links to the official website, source code, and issue tracker. Other packages list an email address for the present maintainer. When you find a package that you use regularly, you should seriously consider getting involved in its development and maintenance.</p>
<p>As for new projects, if you find yourself building a tool or library for solving a problem you’re having in your development efforts, consider publishing it for the rest of the world to use!</p>
<h3 id="h2-500920c21-0011">Developing Python Extensions</h3>
<p class="BodyFirst"><em>Binary extension modules</em>, often just called <em>extension modules</em> or <em>extensions</em>, add new functionality atop the CPython interpreter and allow you to integrate CPython with C and C++ code.</p>
<p><em>Wrapper modules</em> expose C libraries to Python. PyGObject is an example of this, as it wraps the GTK C library and several others besides, and it makes them available to Python. Extensions can also wrap C++ and FORTRAN libraries, among others.</p>
<p>Another common use case for extensions is to provide low-level access to the operating system, hardware, or the CPython runtime.</p>
<p><em>Accelerator modules</em> offer equivalent behavior to a pure Python module, but they are actually written in C. One particular advantage of accelerator modules is that they can be written to bypass the Global Interpreter Lock, since they run as compiled machine code. These modules should provide a pure Python fallback module for situations where the extension may not work.</p>
<p>There are quite a few ways to develop extensions. Traditionally, you can include the <em>Python.h</em> header file in your C code and build from there. Details and documentation about this can be found at <a href="https://docs.python.org/3/extending/index.html" class="LinkURL">https://docs.python.org/3/extending/index.html</a>.</p>
<p>However, working directly with <em>Python.h</em> is no longer considered the best approach. Aside from this technique being quite clunky and error-prone, extensions built this way often have significant difficulty working with PyPy and other implementations of Python. Instead, there are a number of third-party tools for building extensions, which are far simpler and more obvious in their usage.</p>
<p>The <em>C Foreign Function Interface</em> (<em>CFFI</em>) is one of the more popular options. Unlike some other tools, CFFI doesn’t require you to learn an additional specialty language. Instead, it uses purely C and Python. It works with both CPython and PyPy. You can learn more about CFFI from its extensive official documentation: <a href="https://cffi.readthedocs.io/" class="LinkURL">https://cffi.readthedocs.io/</a>.</p>
<p>CFFI does not work with C++, so if you need C++ and Python interoperability, check out <em>cppyy</em>. Official documentation lives at <a href="https://cppyy.readthedocs.io/" class="LinkURL">https://cppyy.readthedocs.io/</a>.</p>
<p><span epub:type="pagebreak" title="630" id="Page_630"/>Cython is a separate programming language that is a superset of Python and provides direct access to C and C++. You compile your Cython code up front, as you would with C. More information and official documentation can be found at <a href="https://cython.org/" class="LinkURL">https://cython.org/</a>.</p>
<p><em>Simplified Wrapper and Interface Generator (SWIG)</em> is a tool for interoperability between over a dozen programming languages, including Python, C, C++, Java, C#, Perl, JavaScript, and Ruby. It can be used to create Python binary extensions. Information, documentation, and tutorials can be found on its official website at <a href="http://www.swig.org/" class="LinkURL">http://www.swig.org/</a>.</p>
<p>Development of Python binary extensions is a particularly deep topic, especially as it involves the C language. The Python Packaging Authority has an excellent guide that explores binary extension development, particularly from a packaging standpoint: <a href="https://packaging.python.org/guides/packaging-binary-extensions/" class="LinkURL">https://packaging.python.org/guides/packaging-binary-extensions/</a>.</p>
<h3 id="h2-500920c21-0012">Contributing to Python</h3>
<p class="BodyFirst">Python is an open source project with a rich community and a well-maintained development pipeline. If you’re passionate about Python, the language itself always welcomes new contributors! Your contributions could include fixing bugs, testing patches, implementing new features, and updating documentation. Even if you don’t have incredible C-coding skills, there’s plenty for you to do. If you want to get started contributing to Python, read through the official Python Developer’s Guide at <a href="https://devguide.python.org/" class="LinkURL">https://devguide.python.org/</a>.</p>
<p>If Java or .NET is more your speed, or if you’re fascinated with RPython, you can instead contribute to Jython, RustPython, Python.NET, IronPython, or PyPy. These are all considered important implementations in the Python ecosystem, and there’s always more to do.</p>
<h4 id="h3-500920c21-0003">Changing the Language</h4>
<p class="BodyFirst">Because Python is built by the community, you can propose changes to the Python language or its standard library. This will involve a considerable amount of work on your part, along with quite a bit of discussion, diplomacy, debate, and testing. Somewhere along the way, you will need to create a PEP outlining your proposed changes and all the discussion that’s gone into it so far.</p>
<p>Don’t embark on this process lightly! Even if your idea seems obvious to you, you are likely underestimating the depth or merit of other viewpoints. We all want Python to be the best it can be, and that means factoring in the wildly divergent needs and perspectives of our diverse user base. That’s why proposing a PEP is a significant time investment.</p>
<p>If you’re certain you’re up for the challenge, see the official guides: <a href="https://devguide.python.org/langchanges/" class="LinkURL">https://devguide.python.org/langchanges/</a> for language changes and <a href="https://devguide.python.org/stdlibchanges/" class="LinkURL">https://devguide.python.org/stdlibchanges/</a> for standard library changes.</p>
<h4 id="h3-500920c21-0004"><span epub:type="pagebreak" title="631" id="Page_631"/>Becoming a Core Developer</h4>
<p class="BodyFirst">Once you’ve been making quality contributions to CPython for some time, you can apply to become a <em>core developer</em>, which brings with it additional authority and responsibility. Core developers are involved in leading Python development, and their opinions regarding language direction and proposed changes bear much weight.</p>
<p>If you want to become a Python core developer, start by contributing <em>patches</em>, which consist of code fixing a bug or implementing an approved feature, to CPython. Keep at this until a core developer offers you commit privileges. They’ll keep an eye on your work after that and help mentor you in the Python development process. Eventually, if you do this well, you may be offered an official opportunity to become a core developer.</p>
<p>The entire process and all the responsibilities and steps involved are outlined in the guide at <a href="https://devguide.python.org/coredev/" class="LinkURL">https://devguide.python.org/coredev/</a>, which itself is based on the Python Language Governance policies outlined in PEP 13.</p>
<h2 id="h1-500920c21-0005">Getting Involved with Python</h2>
<p class="BodyFirst">Wherever you go from here, I strongly recommend getting involved in the Python community! You will learn a lot from your fellow Python developers, and you can greatly benefit from helping and mentoring others. There are a number of official and unofficial communities around the internet, including the following:</p>
<ul>
<li>The DEV Community: <a href="https://dev.to/t/python" class="LinkURL">https://dev.to/t/python</a></li>
<li>Discord: <a href="https://pythondiscord.com/" class="LinkURL">https://pythondiscord.com/</a></li>
<li>Forums (Official): <a href="https://www.python.org/community/forums/" class="LinkURL">https://www.python.org/community/forums/</a></li>
<li>Libera.Chat IRC (Official): <a href="https://www.python.org/community/irc/" class="LinkURL">https://www.python.org/community/irc/</a></li>
<li>Mailing Lists/Newsgroups (Official): <a href="https://www.python.org/community/lists/" class="LinkURL">https://www.python.org/community/lists/</a></li>
<li>Reddit: <a href="https://www.reddit.com/r/learnpython/" class="LinkURL">https://www.reddit.com/r/learnpython/</a></li>
<li>Slack: <a href="https://pyslackers.com/web" class="LinkURL">https://pyslackers.com/web</a></li>
</ul>
<p>Of the ones on this list, my personal favorites are DEV, where this book got its start, and Libera.Chat IRC, where I met most of my technical editors.</p>
<h3 id="h2-500920c21-0013">Asking Questions</h3>
<p class="BodyFirst">The primary reason developers first join a community is to ask questions. This can feel intimidating at first, no matter what platform you’re on! Here are a few principles for asking questions and getting help in the Python community. These guidelines are true across most programming communities, but especially in Python!</p>
<p><span epub:type="pagebreak" title="632" id="Page_632"/>First, do some research and experimentation yourself. <em>Read the documentation</em>. Try out some possible solutions and take note of what doesn’t work. We in the Python community are happy to help you, but we want to see you bring your own efforts to the table, too.</p>
<p>Second, be specific. The more information you can provide, the better we can help you. When possible, give us code we can inspect and run, the exact text of error messages or wrong output, details about your environment (operating system, Python version, and library versions), and insight into the outcomes of your own experimentation. When providing all this information, be careful to follow community rules regarding large pastes. Many platforms, including Libera.Chat IRC, ask that you use a paste-sharing tool like <em>bpaste.net</em>, instead of dumping pastes into chat, where they will clog up the backlog. Never paste multiple lines of code or output directly into chat!</p>
<p>Third, be prepared for unexpected threads of feedback. If a bug is precipitating from poor design, incorrect assumptions, or nonidiomatic practice, we’d much rather help you fix the design than the bug. We aren’t interested in <em>working</em> code, so much as <em>idiomatic</em> code. You will likely be asked things like “What is your goal, why are you doing it this way, and is there a reason you aren’t doing X?” Stay calm and work with us.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">Expect us to challenge your implementation and goals! We are not making comments about you or your skills, only about your your code. Getting combative is the surest way to burn bridges and minimize your chances of getting help, now or later. We’re challenging you because we believe you to be smart and capable enough to handle it; we expect to be treated the same by our peers.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Fourth, be polite and patient. All the online communities I’ve mentioned are staffed by volunteers who give freely of their time and effort to help others. It may take time to get an answer. Just ask your question outright in the public space—never “ask to ask” or inquire after an expert in such and such, as it only wastes people’s time—and then wait for someone to respond. In the case of IRC, <em>stay logged in</em> or you’ll miss our response! In any chat-based medium, if your message gets completely buried in backlog (I’m talking three or more desktop screen pages), calmly repost it. On forum-like platforms, resist the temptation to “bump” the thread.</p>
<p>When you get a response, read it thoroughly and answer thoughtfully. We will probably have many more questions for you as we try to home in on the solution.</p>
<h3 id="h2-500920c21-0014">Answering Questions</h3>
<p class="BodyFirst">Having made it through <em>Dead Simple Python</em>, you now know quite a lot about Python! As a result, you will encounter questions from other community members that you may be able to answer. This is a great way to give back to the community and build relationships with other developers. You’ll learn quite a bit in the process, too. Even so, when you’re getting started, it can feel intimidating. Here are a few tips.</p>
<p><span epub:type="pagebreak" title="633" id="Page_633"/>First, don’t be afraid of making mistakes. If you feel like you can answer a question, give it your best shot. This is a benefit of answering questions in the community: if you get something wrong, someone else will often be there to correct you. Python developers love pedantic correctness! (Seriously; you should see some comments I’ve gotten from my technical editors.) In the worst-case scenario, you’ll walk away from the encounter having learned something. No one worthwhile will think less of you for it, I promise.</p>
<p>Second, more than half of the process of answering a question is <em>asking more questions</em>. Like The Zen of Python says, “In the face of ambiguity, refuse the temptation to guess.” Ultimately, your goal should be to guide the asker toward the most Pythonic solution to the problem they’re trying to solve.</p>
<p>Third, it’s important to be kind. The only things up for critique are <em>code</em> and <em>practice</em>, never people. Resist the temptation to deploy put-downs or shutdowns, no matter how clever or “funny” they may be.</p>
<p>On that note, be careful of issuing “read the documentation” admonishments. Documentation can be infamously obtuse and difficult to parse, especially for a beginner. It’s okay to share a link to the relevant page or section, or to any other helpful resource, but you should <em>never</em> shame anyone for not having previously read or understood the documentation or other material. The same goes for web search results—it can sometimes take real skill to determine which keywords are the best or which results are relevant. In any case, be prepared in case they say that the link doesn’t solve their problem; you may need to ask more questions to better understand what issue they’re stuck on.</p>
<h3 id="h2-500920c21-0015">User Groups</h3>
<p class="BodyFirst">Online communities are excellent resources, but nothing beats in-person networking and collaboration! There are over 1,600 Python user groups worldwide, providing opportunities for developers of all backgrounds and skill levels to exchange knowledge, especially through events like social meetings, speaking presentations, hack sessions, and even local conferences.</p>
<p>A complete list of Python user groups is maintained on the official Python wiki: <a href="https://wiki.python.org/moin/LocalUserGroups" class="LinkURL">https://wiki.python.org/moin/LocalUserGroups</a>. Consider connecting with one in your area. If you don’t have a nearby user group, you may consider starting one yourself! The wiki has a guide for that, too: <a href="https://wiki.python.org/moin/StartingYourUsersGroup" class="LinkURL">https://wiki.python.org/moin/StartingYourUsersGroup</a>.</p>
<h3 id="h2-500920c21-0016">PyLadies</h3>
<p class="BodyFirst">Of particular note is <em>PyLadies</em>, a group organized by the Python Software Foundation, which focuses on supporting and mentoring female developers in the Python community.</p>
<p>PyLadies organizes meetups and other events, and it provides resources. In addition to the international online community, there are a number of local PyLadies groups all over the world. If there isn’t one near you, perhaps you could organize one. More information about PyLadies is available at <a href="https://pyladies.com/" class="LinkURL">https://pyladies.com/</a>. The official list of PyLadies groups is maintained here: <a href="https://pyladies.com/locations/" class="LinkURL">https://pyladies.com/locations/</a>.</p>
<h3 id="h2-500920c21-0017"><span epub:type="pagebreak" title="634" id="Page_634"/>Conferences</h3>
<p class="BodyFirst">Attending conferences is an incredible way to learn and grow as a developer, while connecting with the larger Python community. There are a number of fantastic conferences in the Python world, including PyCon US (the official conference), Pyjamas, SciPy, Python Pizza, and PyData. There are also versions of PyCon in many countries.</p>
<p>The first thing that comes to mind when you think of a conference is probably all the lectures. Talks are certainly among the highlights, especially keynote presentations from important people in the Python community, but they’re not the only thing going on. <em>Workshops</em> present opportunities to get hands-on with a new topic. <em>Lightning talk</em> sessions are a lot of fun, too: they let anyone present a 5- or 10-minute talk, sometimes improvised right on the spot. Some presentations are amazingly insightful, and others are downright hilarious. Many conferences also have <em>sprints</em>, collaborative coding sessions (think “hackathon”) where attendees can freely join teams to build or improve code.</p>
<p>While attending a conference can be a lot of fun, getting involved can be even more exciting! If you want to present a talk at a conference, be on the lookout for the <em>Call for Proposals (CFP)</em>, when you can submit a proposal for a talk or workshop. If you’re brand-new to speaking, you may consider presenting to your local Python User Group or giving a lightning talk. You could also submit a project for a sprint, which can be an excellent way to get new contributors and users while improving your code.</p>
<p>Most conferences rely pretty heavily on volunteers, so consider contacting any conference you’re thinking about attending, and then see how you can help out. You’ll get to meet a lot of great people that way, and volunteering is really fun.</p>
<p>If you want to attend a conference but can’t afford to go, you can check if there are scholarships or other financial aid available, especially if you’re a volunteer. If you’re employed as a programmer, your employer may also be willing to help with some of your conference expenses. After all, when you get smarter, they benefit!</p>
<p>A list of Python conferences is maintained on the Python wiki: <a href="https://www.python.org/community/workshops/" class="LinkURL">https://www.python.org/community/workshops/</a><em>.</em></p>
<h3 id="h2-500920c21-0018">Joining the Python Software Foundation</h3>
<p class="BodyFirst">The <em>Python Software Foundation (PSF)</em> is the nonprofit organization that officially manages the Python language. They’re responsible for all the major decisions, and they help to grow the community worldwide.</p>
<p>The Python Software Foundation is an open-membership organization, meaning anyone can join for free. Basic members need only sign up and agree to the PSF Code of Conduct, which is the set of guidelines that the entire Python community operates on. Members are subscribed to the Python Software Foundation newsletter.</p>
<p>There are three special types of members, all of whom get to vote in the PSF Board of Directors elections. <em>Supporting members</em> donate to the PSF annually. <em>Managing members</em> volunteer at least five hours a month in the <span epub:type="pagebreak" title="635" id="Page_635"/>Python community, including helping to organize events and user groups or volunteering on Python Software Foundation projects. <em>Contributing members</em> volunteer at least five hours a month on free, publicly available open source projects that advance the mission of the PSF. You can learn more about PSF membership at <a href="https://www.python.org/psf/membership/" class="LinkURL">https://www.python.org/psf/membership/</a>.</p>
<h2 id="h1-500920c21-0006">And the Road Goes Ever On . . . </h2>
<p class="BodyFirst">This, dear reader, is where I leave you. The direction you take from here is up to you! I am certain there are many adventures ahead of you. I send you forward into the brave frontier beyond with three final pieces of advice. If you’ve been coding for a while, you may already know these things, but they are always worth hearing again.</p>
<p>First, <em>it is dangerous to go alone</em>. Shiny new solutions call to you from the shadows, tempting you to stray from time-tested development paths. Clever solutions lure you away as they steal time and sanity from your future self and your colleagues. Bugs lurk in the dark recesses of your code, waiting for midnight on a Friday to leap out at you with bared teeth and inexplicable log files. The comradeship of your fellow Python developers is the surest defense against these and many more dangers! There is safety in numbers. I could never have written <em>Dead Simple Python</em> without the all the support, insight, debate, and encouragement from the Python community. We need each other to thrive.</p>
<p>Second, <em>embrace the adventure of making mistakes!</em> You will always learn more from solving a bug, working through a difficult problem, or making a mistake, than you will ever learn from writing or reading the best code in the world. I love how my colleague Wilfrantz Dede puts it whenever he embarks on a new task: “I’m going to go write some bugs.” Mistakes are an inevitable part of the learning process. Learn to expect them, embrace them, conquer them, and laugh at them! Share your coding mistakes with your colleagues. I promise you that most will think more of you for it, not less, and anyone who <em>would</em> look down on you is merely covering up their own egregious errors.</p>
<p>Third and finally, <em>you are a real programmer</em>. Never again question that! No matter how long you’re in this industry, you will always have more to learn. There are even expert developers who have been programming for decades but still feel the call of knowledge not yet gained.</p>
<p>The journey is never really over. There is always one more crest of the hill, one more bend in the road, and one more vast plain stretching ahead! Embrace every step of the adventure. It never gets old.</p>
</section>
</div></body></html>