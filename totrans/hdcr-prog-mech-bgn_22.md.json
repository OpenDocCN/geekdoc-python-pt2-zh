["```py\n<node_id>: (<x_coord>, <y_coord>) (<external_constraints>)\n```", "```py\n1: (250, 400) (xy)\n```", "```py\n<node_id> -> (<Fx>, <Fy>)\n```", "```py\n3 -> (500, -1000)\n```", "```py\n<bar_id>: (<start_node_id> -> <end_node_id>) <A> <E>\n```", "```py\n1: (1 -> 2) 30 20000000\n```", "```py\n<section_name>\n```", "```py\nnodes\n1: (0, 0)     (xy)\n2: (0, 200)   (xy)\n3: (400, 200) ()\n\nloads\n3 -> (500, -1000)\n\nbars\n1: (1 -> 2) 5 10\n2: (2 -> 3) 5 10\n3: (1 -> 3) 5 10\n```", "```py\nimport re\n\nfrom geom2d import Point\nfrom structures.model.node import StrNode\n\n__NODE_REGEX = r'(?P<id>\\d+)\\s*:\\s*' \\\n               r'\\((?P<pos>[\\d\\s\\.,\\-]+)\\)\\s*' \\\n               r'\\((?P<ec>[xy]{0,2})\\)'\n\ndef parse_node(node_str: str):\n ➊ match = re.match(__NODE_REGEX, node_str)\n    if not match:\n        raise ValueError(\n            f'Cannot parse node from string: {node_str}'\n        )\n\n ➋ _id = int(match.group('id'))\n ➌ [x, y] = [\n        float(num)\n        for num in match.group('pos').split(',')\n    ]\n ➍ ext_const = match.group('ec')\n\n ➎ return StrNode(\n        _id,\n        Point(x, y),\n        None,\n        'x' in ext_const,\n        'y' in ext_const\n    )\n```", "```py\nmatch.group('pos').split(',')\n```", "```py\n[x, y] = [\n    float(num)\n    for num in match.group('pos').split(',')\n]\n```", "```py\n>>> 'hardcore' in 'hardcore programming for mechanical engineers'\nTrue\n\n>>> 3 in [1, 2]\nFalse\n```", "```py\nimport unittest\n\nfrom geom2d import Point\nfrom structures.parse.node_parse import parse_node\n\nclass NodeParseTest(unittest.TestCase):\n ➊ node_str = '1 : (25.0, 45.0)   (xy)'\n ➋ node = parse_node(node_str)\n\n    def test_parse_id(self):\n        self.assertEqual(1, self.node.id)\n\n    def test_parse_position(self):\n        expected = Point(25.0, 45.0)\n        self.assertEqual(expected, self.node.position)\n\n    def test_parse_dx_external_constraint(self):\n        self.assertTrue(self.node.dx_constrained)\n\n   def test_parse_dy_external_constraint(self):\n        self.assertTrue(self.node.dy_constrained)\n```", "```py\n$ python3 -m unittest structures/tests/node_parse_test.py\n```", "```py\nimport re\nfrom structures.model.bar import StrBar\n\n__BAR_REGEX = r'(?P<id>\\d+)\\s*:\\s*' \\\n              r'\\((?P<start_id>\\d+)\\s*->\\s*(?P<end_id>\\d+)\\)\\s*' \\\n              r'(?P<sec>[\\d\\.]+)\\s+' \\\n              r'(?P<young>[\\d\\.]+)'\n\ndef parse_bar(bar_str: str, nodes_dict):\n ➊ match = re.match(__BAR_REGEX, bar_str)\n    if not match:\n        raise ValueError(\n            f'Cannot parse bar from string: {bar_str}'\n        )\n\n ➋ _id = int(match.group('id'))\n ➌ start_id = int(match.group('start_id'))\n ➍ end_id = int(match.group('end_id'))\n ➎ section = float(match.group('sec'))\n ➏ young_mod = float(match.group('young'))\n\n ➐ start_node = nodes_dict[start_id]\n    if start_node is None:\n        raise ValueError(f'Node with id: ${start_id} undefined')\n\n    end_node = nodes_dict[end_id]\n    if end_node is None:\n        raise ValueError(f'Node with id: ${start_id} undefined')\n\n ➑ return StrBar(_id, start_node, end_node, section, young_mod)\n```", "```py\nimport unittest\n\nfrom structures.parse.bar_parse import parse_bar\n\nclass BarParseTest(unittest.TestCase):\n ➊ bar_str = '1: (3 -> 5) 25.0 20000000.0'\n ➋ nodes_dict = {\n        3: 'Node 3',\n        5: 'Node 5'\n    }\n ➌ bar = parse_bar(bar_str, nodes_dict)\n\n    def test_parse_id(self):\n        self.assertEqual(1, self.bar.id)\n\n    def test_parse_start_node(self):\n        self.assertEqual('Node 3', self.bar.start_node)\n\n    def test_parse_end_node_id(self):\n        self.assertEqual('Node 5', self.bar.end_node)\n\n    def test_parse_section(self):\n        self.assertEqual(25.0, self.bar.cross_section)\n\n    def test_parse_young_modulus(self):\n        self.assertEqual(20000000.0, self.bar.young_mod)\n```", "```py\n$ python3 -m unittest structures/tests/bar_parse_test.py\n```", "```py\nimport re\n\nfrom geom2d import Vector\n\n__LOAD_REGEX = r'(?P<node_id>\\d+)\\s*->\\s*' \\\n               r'\\((?P<vec>[\\d\\s\\.,\\-]+)\\)'\n\ndef parse_load(load_str: str):\n ➊ match = re.match(__LOAD_REGEX, load_str)\n    if not match:\n        raise ValueError(\n            f'Cannot parse load from string: \"{load_str}\"'\n        )\n\n ➋ node_id = int(match.group('node_id'))\n ➌ [fx, fy] = [\n        float(num)\n        for num in match.group('vec').split(',')\n    ]\n\n ➍ return node_id, Vector(fx, fy)\n```", "```py\nimport unittest\n\nfrom geom2d import Vector\nfrom structures.parse.load_parse import parse_load\n\nclass LoadParseTest(unittest.TestCase):\n\n    load_str = '1 -> (250.0, -3500.0)'\n    (node_id, load) = parse_load(load_str)\n\n    def test_parse_node_id(self):\n        self.assertEqual(1, self.node_id)\n\n    def test_parse_load_vector(self):\n        expected = Vector(250.0, -3500.0)\n        self.assertEqual(expected, self.load)\n```", "```py\n$ python3 -m unittest structures/tests/load_parse_test.py\n```", "```py\nnodes\n1: (0, 0)     (xy)\n2: (0, 200)   (xy)\n3: (400, 200) ()\n\nloads\n3 -> (500, -1000)\n\nbars\n1: (1 -> 2) 5 10\n2: (2 -> 3) 5 10\n3: (1 -> 3) 5 10\n```", "```py\n# only node with a load applied\n3: (400, 200) ()\n```", "```py\n__COMMENT_INDICATOR = '#'\n\ndef __should_ignore_line(line: str):\n    stripped = line.strip()\n    return len(stripped) == 0 or \\\n           stripped.startswith(__COMMENT_INDICATOR)\n```", "```py\nimport re\n\nfrom .bar_parse import parse_bar\nfrom .load_parse import parse_load\nfrom .node_parse import parse_node\n\n__COMMENT_INDICATOR = '#'\n__NODES_HEADER = 'nodes'\n__LOADS_HEADER = 'loads'\n__BARS_HEADER = 'bars'\n\ndef __parse_lines(lines: [str]):\n ➊ reading = ''\n ➋ result = {'nodes': {}, 'loads': [], 'bars': []}\n\n    for i, line in enumerate(lines):\n     ➌ if __should_ignore_line(line):\n            continue\n\n        # <--- header ---> #\n     ➍ if re.match(__NODES_HEADER, line):\n            reading = 'nodes'\n        elif re.match(__BARS_HEADER, line):\n            reading = 'bars'\n        elif re.match(__LOADS_HEADER, line):\n            reading = 'loads'\n\n        # <--- definition ---> #\n     ➎ elif reading == 'nodes':\n            node = parse_node(line)\n            result['nodes'][node.id] = node\n        elif reading == 'bars':\n            bar = parse_bar(line, result['nodes'])\n            result['bars'].append(bar)\n        elif reading == 'loads':\n            load = parse_load(line)\n            result['loads'].append(load)\n        else:\n            raise RuntimeError(\n                f'Unknown error in line ${i}: ${line}'\n            )\n\n    return result\n\ndef __should_ignore_line(line: str):\n\n    --snip--\n```", "```py\nresult['nodes'][node.id] = node\n```", "```py\nresult['bars'].append(bar)\n```", "```py\nimport re\n\nfrom structures.model.structure import Structure\nfrom .bar_parse import parse_bar\nfrom .load_parse import parse_load\nfrom .node_parse import parse_node\n\n__COMMENT_INDICATOR = '#'\n__NODES_HEADER = 'nodes'\n__LOADS_HEADER = 'loads'\n__BARS_HEADER = 'bars'\n\ndef parse_structure(structure_string: str):\n ➊ lines = structure_string.split('\\n')\n    return parse_structure_from_lines(lines)\n\ndef parse_structure_from_lines(lines: [str]):\n ➋ parsed = __parse_lines(lines)\n    nodes_dict = parsed['nodes']\n    loads = parsed['loads']\n    bars = parsed['bars']\n\n ➌__apply_loads_to_nodes(loads, nodes_dict)\n\n   return Structure(\n     ➍ list(nodes_dict.values()),\n        bars\n    )\n\ndef __apply_loads_to_nodes(loads, nodes):\n ➎ for node_id, load in loads:\n        nodes[node_id].add_load(load)\n\n--snip--\n```", "```py\n1 -> (500, -1000)\n```", "```py\n(1, Vector(500, -1000))\n```", "```py\nimport re\n\nfrom structures.model.structure import Structure\nfrom .bar_parse import parse_bar\nfrom .load_parse import parse_load\nfrom .node_parse import parse_node\n\n__COMMENT_INDICATOR = '#'\n__NODES_HEADER = 'nodes'\n__LOADS_HEADER = 'loads'\n__BARS_HEADER = 'bars'\n\ndef parse_structure(structure_string: str):\n    lines = structure_string.split('\\n')\n    return parse_structure_from_lines(lines)\n\ndef parse_structure_from_lines(lines: [str]):\n    parsed = __parse_lines(lines)\n    nodes_dict = parsed['nodes']\n    loads = parsed['loads']\n    bars = parsed['bars']\n\n    __apply_loads_to_nodes(loads, nodes_dict)\n\n    return Structure(\n        list(nodes_dict.values()),\n        bars\n    )\n\ndef __apply_loads_to_nodes(loads, nodes):\n    for node_id, load in loads:\n        nodes[node_id].add_load(load)\n\ndef __parse_lines(lines: [str]):\n    reading = ''\n    result = {'nodes': {}, 'loads': [], 'bars': []}\n\n    for i, line in enumerate(lines):\n        if __should_ignore_line(line):\n            continue\n\n        # <--- header ---> #\n        if re.match(__NODES_HEADER, line):\n            reading = 'nodes'\n        elif re.match(__BARS_HEADER, line):\n            reading = 'bars'\n        elif re.match(__LOADS_HEADER, line):\n            reading = 'loads'\n\n        # <--- definition ---> #\n        elif reading == 'nodes':\n            node = parse_node(line)\n            result['nodes'][node.id] = node\n        elif reading == 'bars':\n            bar = parse_bar(line, result['nodes'])\n            result['bars'].append(bar)\n        elif reading == 'loads':\n            load = parse_load(line)\n            result['loads'].append(load)\n        else:\n            raise RuntimeError(\n                f'Unknown error in line ${i}: ${line}'\n            )\n\n    return result\n\ndef __should_ignore_line(line: str):\n    stripped = line.strip()\n    return len(stripped) == 0 or \\\n           stripped.startswith(__COMMENT_INDICATOR)\n```", "```py\nfrom .str_parse import parse_structure\n```", "```py\nfrom structures.parse import parse_structure\n```", "```py\nfrom structures.parse.str_parse import parse_structure\n```", "```py\n# Nodes\nnodes\n1: (0.0, 0.0)      (xy)\n2: (200.0, 150.0)  ()\n3: (400.0, 0.0)    (y)\n\n# Loads\nloads\n2 -> (2500.0, -3500.0)\n\n# Bars\nbars\n1: (1 -> 2) 25 20000000\n2: (2 -> 3) 25 20000000\n3: (1 -> 3) 25 20000000\n```", "```py\nimport unittest\n\nimport pkg_resources as res\n\nfrom structures.parse import parse_structure\n\nclass StructureParseTest(unittest.TestCase):\n\n    def setUp(self):\n        str_bytes = res.resource_string(__name__, 'test_str.txt')\n        str_string = str_bytes.decode(\"utf-8\")\n        self.structure = parse_structure(str_string)\n```", "```py\nimport unittest\n\nimport pkg_resources as res\n\nfrom geom2d import Point\nfrom structures.parse import parse_structure\n\nclass StructureParseTest(unittest.TestCase):\n    --snip--\n\n    def test_parse_nodes_count(self):\n        self.assertEqual(3, self.structure.nodes_count)\n\n    def test_parse_nodes(self):\n     ➊ nodes = self.structure._Structure__nodes\n        self.assertEqual(\n            Point(0, 0),\n            nodes[0].position\n        )\n        self.assertEqual(\n            Point(200, 150),\n            nodes[1].position\n        )\n        self.assertEqual(\n            Point(400, 0),\n            nodes[2].position\n        )\n\n    def test_parse_node_constraints(self):\n        nodes = self.structure._Structure__nodes\n\n        self.assertTrue(nodes[0].dx_constrained)\n        self.assertTrue(nodes[0].dy_constrained)\n\n        self.assertFalse(nodes[1].dx_constrained)\n        self.assertFalse(nodes[1].dy_constrained)\n\n        self.assertFalse(nodes[2].dx_constrained)\n        self.assertTrue(nodes[2].dy_constrained)\n```", "```py\n$ python3 -m unittest structures/tests/str_parse_test.py\n```", "```py\nclass StructureParseTest(unittest.TestCase):\n    --snip--\n\n    def test_parse_bars_count(self):\n        self.assertEqual(3, self.structure.bars_count)\n\n    def test_parse_bars(self):\n        bars = self.structure._Structure__bars\n\n        self.assertEqual(1, bars[0].start_node.id)\n        self.assertEqual(2, bars[0].end_node.id)\n\n        self.assertEqual(2, bars[1].start_node.id)\n        self.assertEqual(3, bars[1].end_node.id)\n\n        self.assertEqual(1, bars[2].start_node.id)\n        self.assertEqual(3, bars[2].end_node.id)\n```", "```py\n$ python3 -m unittest structures/tests/str_parse_test.py\n```", "```py\nimport unittest\n\nimport pkg_resources as res\n\nfrom geom2d import Point, Vector\nfrom structures.parse import parse_structure\n\nclass StructureParseTest(unittest.TestCase):\n    --snip--\n\n    def test_parse_loads_count(self):\n        self.assertEqual(1, self.structure.loads_count)\n\n    def test_apply_load_to_node(self):\n        node = self.structure._Structure__nodes[1]\n        self.assertEqual(\n            Vector(2500, -3500),\n            node.net_load\n        )\n```", "```py\n$ python3 -m unittest structures/tests/str_parse_test.py\n```", "```py\nRan 7 tests in 0.033s\n\nOK\n```", "```py\nimport unittest\n\nimport pkg_resources as res\n\nfrom geom2d import Point, Vector\nfrom structures.parse import parse_structure\n\nclass StructureParseTest(unittest.TestCase):\n\n    def setUp(self):\n        str_bytes = res.resource_string(__name__, 'test_str.txt')\n        str_string = str_bytes.decode(\"utf-8\")\n        self.structure = parse_structure(str_string)\n\n    def test_parse_nodes_count(self):\n        self.assertEqual(3, self.structure.nodes_count)\n\n    def test_parse_nodes(self):\n        nodes = self.structure._Structure__nodes\n        self.assertEqual(\n            Point(0, 0),\n            nodes[0].position\n        )\n        self.assertEqual(\n            Point(200, 150),\n            nodes[1].position\n        )\n        self.assertEqual(\n            Point(400, 0),\n            nodes[2].position\n        )\n\n    def test_parse_node_constraints(self):\n        nodes = self.structure._Structure__nodes\n\n        self.assertTrue(nodes[0].dx_constrained)\n        self.assertTrue(nodes[0].dy_constrained)\n\n        self.assertFalse(nodes[1].dx_constrained)\n        self.assertFalse(nodes[1].dy_constrained)\n\n        self.assertFalse(nodes[2].dx_constrained)\n        self.assertTrue(nodes[2].dy_constrained)\n\n    def test_parse_bars_count(self):\n        self.assertEqual(3, self.structure.bars_count)\n\n    def test_parse_bars(self):\n        bars = self.structure._Structure__bars\n\n        self.assertEqual(1, bars[0].start_node.id)\n        self.assertEqual(2, bars[0].end_node.id)\n\n        self.assertEqual(2, bars[1].start_node.id)\n        self.assertEqual(3, bars[1].end_node.id)\n\n        self.assertEqual(1, bars[2].start_node.id)\n        self.assertEqual(3, bars[2].end_node.id)\n\n    def test_parse_loads_count(self):\n        self.assertEqual(1, self.structure.loads_count)\n\n    def test_apply_load_to_node(self):\n        node = self.structure._Structure__nodes[1]\n        self.assertEqual(\n            Vector(2500, -3500),\n            node.net_load\n        )\n```"]