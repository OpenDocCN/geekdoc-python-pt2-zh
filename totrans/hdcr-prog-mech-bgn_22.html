<html><head></head><body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_465"/><span class="big">17</span><br/>READING INPUT FROM A FILE</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Any engineering application we develop will require some data input. For example, to solve a truss structure using the algorithm we developed in the previous chapter, we first need to construct the structure model. It’d be tedious to manually instantiate the classes to construct the model every time we want to solve a structure; it’d be more convenient to simply pass our app a plaintext file that follows a given and well-defined scheme defining the structure we want to solve. In this chapter, we’ll equip our app with a file parser function that reads text files, interprets them, and constructs the model that the app uses internally.</p>&#13;
<h3 class="h3" id="ch00lev1sec101"><strong>Defining the Input Format</strong></h3>&#13;
<p class="noindent">For our application to work, the files we feed it need to have a well-defined structure. The text file has to include the definition of the nodes, the loads <span epub:type="pagebreak" id="page_466"/>applied to them, and the bars of the structure. Let’s decide on a format for each of these parts.</p>&#13;
<h4 class="h4" id="ch00lev2sec177"><strong><em>The Nodes Format</em></strong></h4>&#13;
<p class="noindent">Each node will be defined in its own line, following this format,</p>&#13;
<pre><span class="codeitalic1">&lt;node_id&gt;</span>: (<span class="codeitalic1">&lt;x_coord&gt;</span>, <span class="codeitalic1">&lt;y_coord&gt;</span>) (<span class="codeitalic1">&lt;external_constraints&gt;</span>)</pre>&#13;
<p class="noindent">where</p>&#13;
<ul>&#13;
<li class="noindent"><em>node_id</em> is the ID given to the node.</li>&#13;
<li class="noindent"><em>x_coord</em> is the x position of the node.</li>&#13;
<li class="noindent"><em>y_coord</em> is the y position of the node.</li>&#13;
<li class="noindent"><em>external_constraints</em> is a set of the constrained movements.</li>&#13;
</ul>&#13;
<p class="noindent">Here’s an example:</p>&#13;
<pre>1: (250, 400) (xy)</pre>&#13;
<p class="noindent">This defines a node with an ID of 1, at position (250, 400), with its x and y displacements externally constrained.</p>&#13;
<h4 class="h4" id="ch00lev2sec178"><strong><em>The Loads Format</em></strong></h4>&#13;
<p class="noindent">Loads will be defined separately from the nodes they’re applied to, so we’ll have to indicate the ID of the node where the load is applied. Having the nodes and loads defined in different lines allows us to simplify the input parsing process by using two simple regular expressions (one for the nodes and another for the loads) instead of one long and complicated regular expression. Each load will be defined on a separate line.</p>&#13;
<p class="indent">Let’s use the following format for loads,</p>&#13;
<pre><span class="codeitalic1">&lt;node_id&gt;</span> -&gt; (<span class="codeitalic1">&lt;Fx&gt;</span>, <span class="codeitalic1">&lt;Fy&gt;</span>)</pre>&#13;
<p class="noindent">where</p>&#13;
<ul>&#13;
<li class="noindent"><em>node_id</em> is the node where the load is applied.</li>&#13;
<li class="noindent"><em>Fx</em> is the x component of the load.</li>&#13;
<li class="noindent"><em>Fy</em> is the y component of the load.</li>&#13;
</ul>&#13;
<p class="indent">Here’s an example:</p>&#13;
<pre>3 -&gt; (500, -1000)</pre>&#13;
<p class="noindent">This defines a load ⟨500,–1000⟩ applied to the node with an ID of 3. We’re using the <span class="literal">-&gt;</span> character sequence to separate the node ID from the load components instead of a colon so that it’s clear we’re not assigning an ID to the load itself. Rather, we’re applying the load to the node with that ID.</p>&#13;
<h4 class="h4" id="ch00lev2sec179"><span epub:type="pagebreak" id="page_467"/><strong><em>The Bars Format</em></strong></h4>&#13;
<p class="noindent">Bars are defined between two nodes and have a section and Young’s modulus. As with nodes and loads, each bar will be defined on its own line. We can give bars the following format,</p>&#13;
<pre><span class="codeitalic1">&lt;bar_id&gt;</span>: (<span class="codeitalic1">&lt;start_node_id&gt;</span> -&gt; <span class="codeitalic1">&lt;end_node_id&gt;</span>) <span class="codeitalic1">&lt;A&gt; &lt;E&gt;</span></pre>&#13;
<p class="noindent">where</p>&#13;
<ul>&#13;
<li class="noindent"><em>bar_id</em> is the ID given to the bar.</li>&#13;
<li class="noindent"><em>start_node_id</em> is the ID of the start node.</li>&#13;
<li class="noindent"><em>end_node_id</em> is the ID of the end node.</li>&#13;
<li class="noindent"><em>A</em> is the cross-section area.</li>&#13;
<li class="noindent"><em>E</em> is the Young’s modulus.</li>&#13;
</ul>&#13;
<p class="indent">Here’s an example:</p>&#13;
<pre>1: (1 -&gt; 2) 30 20000000</pre>&#13;
<p class="noindent">This defines a bar between nodes 1 and 2, with a cross section of 30 and a Young’s modulus of <span class="literal">20000000</span>. This bar is given an ID of 1.</p>&#13;
<h4 class="h4" id="ch00lev2sec180"><strong><em>The File Format</em></strong></h4>&#13;
<p class="noindent">Now that we’ve come up with a format for the nodes, loads, and bars, let’s see how we can put them all together in one file. We’re looking for a file structure that’s simple to write by hand but that’s also easy to parse.</p>&#13;
<p class="indent">One interesting idea is to divide the file into sections, each opened by a header:</p>&#13;
<pre><span class="codeitalic1">&lt;section_name&gt;</span></pre>&#13;
<p class="noindent">Each section should contain only the lines defining entities of the same type.</p>&#13;
<p class="indent">Given that our structure definition files will have three different kinds of entities—nodes, loads, and bars—they’ll need three different sections. For example, the structure we used for the unit tests in the previous chapter, included here as <a href="ch17.xhtml#ch17fig1">Figure 17-1</a>, would be defined as follows:</p>&#13;
<div class="image"><img src="../images/17fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch17fig1"><em>Figure 17-1: Structure from previous chapter’s unit tests</em><span epub:type="pagebreak" id="page_468"/></p>&#13;
<pre>nodes&#13;
1: (0, 0)     (xy)&#13;
2: (0, 200)   (xy)&#13;
3: (400, 200) ()&#13;
&#13;
&#13;
loads&#13;
3 -&gt; (500, -1000)&#13;
&#13;
&#13;
bars&#13;
1: (1 -&gt; 2) 5 10&#13;
2: (2 -&gt; 3) 5 10&#13;
3: (1 -&gt; 3) 5 10</pre>&#13;
<p class="indent">Now that we’ve defined a format for our structure definition files, we need to work on a parser. A <em>parser</em> is a component (a function or class) that reads text, interprets it, and translates it into a data structure or model. In this case, the model is our truss structure class: <span class="literal">Structure</span>. We’ll use regular expressions, as we did in <a href="ch09.xhtml#ch09">Chapter 9</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec102"><strong>Finding the Regular Expressions</strong></h3>&#13;
<p class="noindent">If we know the structure ahead of time, regular expressions are a reliable way of extracting all the information we need from plaintext. We’ll need three different regular expressions: one for the nodes, one for the loads, and one for the bars. If you need a refresher on regular expressions, take a moment to review “Regular Expressions” on <a href="ch01.xhtml#page_9">page 9</a>. Let’s design these regular expressions.</p>&#13;
<h4 class="h4" id="ch00lev2sec181"><strong><em>The Nodes Regex</em></strong></h4>&#13;
<p class="noindent">To match nodes defined in our format, we can use the following regular expression:</p>&#13;
<p class="pre2">/(?P&lt;id&gt;\d+)\s*:\s*<br/>\((?P&lt;pos&gt;[\d\s\.,\-]+)\)\s*<br/>\((?P&lt;ec&gt;[xy]{0,2})\)/</p>&#13;
<p class="indent">This is one scary regular expression. It’s split between several lines because it was too long to fit in a single line, but you can imagine it as being just one line. Let’s break down this regular expression into its parts.</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">(?P&lt;id&gt;\d+)</span> This matches the node’s ID, a number with one or more digits (<span class="literal">\d+</span>), and captures it in a group named <span class="literal">id</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">\s*:\s*</span> This matches the colon after the ID with arbitrary and optional spaces around it (<span class="literal">\s*</span>).</p>&#13;
<p class="noindentin"><span class="codestrong">\((?P&lt;pos&gt;[\d\s\.,\-]+)\)</span> This matches the node’s position coordinates inside the parentheses and captures them in a group named <span class="literal">pos</span>. Note <span epub:type="pagebreak" id="page_469"/>that we match the whole expression between the parentheses; that includes the two coordinates and the comma that separates them. We’ll split the two numbers in code. We do it this way so that our already monstrous regular expression doesn’t become even scarier. Combining regular expressions with Python’s string manipulation methods is a powerful technique.</p>&#13;
<p class="noindentin"><span class="codestrong">\s*</span> This matches zero or more spaces separating the coordinates group from the external constraints group.</p>&#13;
<p class="noindentin"><span class="codestrong">\((?P&lt;ec&gt;[xy]{0, 2})\)</span> This last part matches the external constraints defined between parentheses and captures them in a group named <span class="literal">ec</span>. The contents inside the parentheses are limited to the character group <span class="literal">[xy]</span>, that is, the characters “x” and “y.” There’s also a constraint in the number of characters allowed, which is any number between 0 and 2 (<span class="literal">{0, 2}</span>).</p>&#13;
</div>&#13;
<p class="indent">We’ll see this regular expression in action soon. <a href="ch17.xhtml#ch17fig2">Figure 17-2</a> may help you understand each of the subparts in the regular expression.</p>&#13;
<div class="image"><img src="../images/17fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch17fig2"><em>Figure 17-2: Node regular expression visualized</em></p>&#13;
<p class="indent">Let’s take a look at how to parse the loads.</p>&#13;
<h4 class="h4" id="ch00lev2sec182"><strong><em>The Loads Regex</em></strong></h4>&#13;
<p class="noindent">To match loads written with the format we defined, we’ll use the following regular expression:</p>&#13;
<p class="pre2">    /(?P&lt;node_id&gt;\d+)\s*-&gt;\s*\((?P&lt;vec&gt;[\d\s\.,\-]+)\)/</p>&#13;
<p class="indent">This regular expression isn’t quite as scary as the previous one; let’s break it down into its subparts.</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">(?P&lt;node_id&gt;\d+)</span> This matches the node ID and captures it in a group named <span class="literal">node_id</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">\s*-&gt;\s*</span> This matches the <span class="literal">-&gt;</span> character sequence and the optional blank spaces around it.</p>&#13;
<p class="noindentin"><span class="codestrong">\((?P&lt;vec&gt;[\d\s\.,\-]+)\)</span> This matches the entire expression between the parentheses, where the force vector components are defined. The character set <span class="literal">[\d\s\.,\-]</span> inside the parentheses is allowed; this includes digits, spaces, dots, commas, and minus signs. Whatever is captured is stored in a capture group named <span class="literal">vec</span>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_470"/><a href="ch17.xhtml#ch17fig3">Figure 17-3</a> is a breakdown of the regular expression’s different parts. Make sure you understand each of them.</p>&#13;
<div class="image"><img src="../images/17fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch17fig3"><em>Figure 17-3: Load regular expression visualized</em></p>&#13;
<p class="indent">Lastly, let’s take a look at the regular expression for the bars.</p>&#13;
<h4 class="h4" id="ch00lev2sec183"><strong><em>The Bars Regex</em></strong></h4>&#13;
<p class="noindent">To match bars written using the format we defined earlier, we’ll use the following regular expression:</p>&#13;
<p class="pre2">/(?P&lt;id&gt;\d+)\s*:\s*<br/>\((?P&lt;start_id&gt;\d+)\s*-&gt;\s*(?P&lt;end_id&gt;\d+)\)\s*<br/>(?P&lt;sec&gt;[\d\.]+)\s+<br/>(?P&lt;young&gt;[\d\.]+)/</p>&#13;
<p class="indent">This regular expression was also broken down into several lines because of its length, but you can imagine it as being written in one line. Let’s break it down piece by piece:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">(?P&lt;id&gt;\d+)</span> This matches the ID assigned to the bar and captures it in the group named <span class="literal">id</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">\s*:\s*</span> This matches the colon character and the optional blank space around it.</p>&#13;
<p class="noindentin"><span class="codestrong">\((?P&lt;start_id&gt;\d+)\s*-&gt;\s*(?P&lt;end_id&gt;\d+)\)</span> This matches the two node IDs separated by the <span class="literal">-&gt;</span> character sequence and the optional space around it. The IDs are captured in the groups named <span class="literal">start_id</span> and <span class="literal">end_id</span>. This whole expression is required to appear between parentheses.</p>&#13;
<p class="noindentin"><span class="codestrong">\s*</span> This matches the optional blank space between the last parenthesis and the next value, the section.</p>&#13;
<p class="noindentin"><span class="codestrong">(?P&lt;sec&gt;[\d\.]+)</span> This captures a decimal number and assigns it to the group named <span class="literal">sec</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">\s+</span> This matches the required blank space between the last parenthesis and the next value, the Young modulus. Recall that, in this case we need at least one space. Otherwise, there would be no way to know where the value for the section ends and the value for the Young modulus begins.</p>&#13;
<p class="noindentin"><span class="codestrong">(?P&lt;young&gt;[\d\.]+)</span> This captures a decimal number and assigns it to the group named <span class="literal">young</span>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_471"/>This is the largest and most complex regular expression we’ve seen in the book. <a href="ch17.xhtml#ch17fig4">Figure 17-4</a> should help you identify each of its parts.</p>&#13;
<div class="image"><img src="../images/17fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch17fig4"><em>Figure 17-4: Bar regular expression visualized</em></p>&#13;
<p class="indent">Now that we have our regular expressions, let’s start writing the code to parse our structure files.</p>&#13;
<h3 class="h3" id="ch00lev1sec103"><strong>Setup</strong></h3>&#13;
<p class="noindent">Right now, our <em>structures</em> package has the following subdirectories:</p>&#13;
<p class="pre2">    structures<br/>      |- model<br/>      |- solution<br/>      |- tests</p>&#13;
<p class="indent">Let’s create a new package folder named <em>parse</em> by right-clicking <em>structures</em> and choosing <strong>New</strong> ▸ <strong>Python Package</strong>. If you’re doing this from outside the IDE, don’t forget to create an empty <em>__init__.py</em> file in the folder. Our <em>structures</em> package directory should look like the following:</p>&#13;
<p class="pre2">    structures<br/>      |- model<br/>      |- parse<br/>      |- solution<br/>      |- tests</p>&#13;
<p class="indent">We’re ready to start implementing the code. We’ll first implement the logic for parsing nodes, loads, and bars. Each will be defined in its own function along with unit tests. Then, we’ll put it all together in a function that reads the entire file’s contents, splits it into lines, and parses each line into the right model class.</p>&#13;
<h3 class="h3" id="ch00lev1sec104"><strong>Parsing Nodes</strong></h3>&#13;
<p class="noindent">We’ll start with the nodes. In <em>structures/parse</em>, create a new file named <em>node_parse.py</em>. In this file, enter the code in <a href="ch17.xhtml#ch17lis1">Listing 17-1</a>.<span epub:type="pagebreak" id="page_472"/></p>&#13;
<pre>import re&#13;
&#13;
from geom2d import Point&#13;
from structures.model.node import StrNode&#13;
&#13;
__NODE_REGEX = r'(?P&lt;id&gt;\d+)\s*:\s*' \&#13;
               r'\((?P&lt;pos&gt;[\d\s\.,\-]+)\)\s*' \&#13;
               r'\((?P&lt;ec&gt;[xy]{0,2})\)'&#13;
&#13;
&#13;
def parse_node(node_str: str):&#13;
 <span class="ent">➊</span> match = re.match(__NODE_REGEX, node_str)&#13;
    if not match:&#13;
        raise ValueError(&#13;
            f'Cannot parse node from string: {node_str}'&#13;
        )&#13;
&#13;
 <span class="ent">➋</span> _id = int(match.group('id'))&#13;
 <span class="ent">➌</span> [x, y] = [&#13;
        float(num)&#13;
        for num in match.group('pos').split(',')&#13;
    ]&#13;
 <span class="ent">➍</span> ext_const = match.group('ec')&#13;
&#13;
 <span class="ent">➎</span> return StrNode(&#13;
        _id,&#13;
        Point(x, y),&#13;
        None,&#13;
        'x' in ext_const,&#13;
        'y' in ext_const&#13;
    )</pre>&#13;
<p class="caption"><a id="ch17lis1"/><em>Listing 17-1: Parsing a node from a string</em></p>&#13;
<p class="indent">We start by defining the regular expression we saw earlier. It needs to be broken down into multiple lines because it’s too long for a single line, but since we’re using the continuation backslash character (<span class="literal">\</span>), Python will read all the contents into a single line.</p>&#13;
<p class="indent">Then comes the <span class="literal">parse_node</span> function, which accepts a string parameter as input. This string should be formatted following the node’s format we defined earlier. We look for a match in the <span class="literal">node_str</span> string against the node’s regular expression <span class="ent">➊</span>. If there’s no match, we raise a <span class="literal">ValueError</span> with a message that includes the offending string so that it’s easier to debug errors.</p>&#13;
<p class="indent">Then we extract the ID from the capture group named <span class="literal">id</span> and store it in the <span class="literal">_id</span> variable <span class="ent">➋</span>.</p>&#13;
<p class="indent">Next, we parse the x and y position coordinates: we read the contents of the <span class="literal">pos</span> capture group and split the string using the comma character.</p>&#13;
<pre>match.group('pos').split(',')</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_473"/>This yields the two strings representing the numbers defining the node’s position.</p>&#13;
<p class="indent">Using a list comprehension, we map each of the strings to a <span class="literal">float</span> number:</p>&#13;
<pre>[x, y] = [&#13;
    float(num)&#13;
    for num in match.group('pos').split(',')&#13;
]</pre>&#13;
<p class="noindent">Then we destructure the result into variables <span class="literal">x</span> and <span class="literal">y</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The last named capture group is <span class="literal">ec</span>. It contains the definition of the external constraints. We read its contents and store them in the variable <span class="literal">ext_const</span> <span class="ent">➍</span>. Lastly, we create the node instance passing it all the parameters it expects <span class="ent">➎</span>. We pass the ID, the position point, a <span class="literal">None</span> for the loads (this will be added later), and the external constraints. The external constraints are added by checking whether the character “x” or “y” is in the constraints string. For this, we use Python’s <span class="literal">in</span> operator, which checks whether a given value exists in a sequence. Here’s an example:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'hardcore' in 'hardcore programming for mechanical engineers'</span>&#13;
True&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">3 in [1, 2]</span>&#13;
False</pre>&#13;
<p class="indent">Let’s use some unit tests to make sure our code parses nodes correctly.</p>&#13;
<h4 class="h4" id="ch00lev2sec184"><strong><em>Testing the Node Parser</em></strong></h4>&#13;
<p class="noindent">Let’s create a new test file in the <em>structures/tests</em> directory named <em>node_parse _test.py</em>. In the file, enter the code in <a href="ch17.xhtml#ch17lis2">Listing 17-2</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d import Point&#13;
from structures.parse.node_parse import parse_node&#13;
&#13;
&#13;
class NodeParseTest(unittest.TestCase):&#13;
 <span class="ent">➊</span> node_str = '1 : (25.0, 45.0)   (xy)'&#13;
 <span class="ent">➋</span> node = parse_node(node_str)&#13;
&#13;
    def test_parse_id(self):&#13;
        self.assertEqual(1, self.node.id)&#13;
&#13;
    def test_parse_position(self):&#13;
        <span epub:type="pagebreak" id="page_474"/>expected = Point(25.0, 45.0)&#13;
        self.assertEqual(expected, self.node.position)&#13;
&#13;
    def test_parse_dx_external_constraint(self):&#13;
        self.assertTrue(self.node.dx_constrained)&#13;
&#13;
   def test_parse_dy_external_constraint(self):&#13;
        self.assertTrue(self.node.dy_constrained)</pre>&#13;
<p class="caption"><a id="ch17lis2"/><em>Listing 17-2: Testing the parsing of a node</em></p>&#13;
<p class="indent">This file defines a new test class: <span class="literal">NodeParseTest</span>. We’ve defined a string with the correct format so we can test whether we can parse all of its parts. That string is <span class="literal">node_str</span> <span class="ent">➊</span>. We’ve written all of our tests to work with the node that results when we parse the string <span class="ent">➋</span>; we did this to avoid repeating the same parsing operation in every test.</p>&#13;
<p class="indent">Then we have a test to ensure the ID is correctly set in the resulting node, another one that checks the node’s position, and two more to test whether the external constraints have been added or not.</p>&#13;
<p class="indent">Let’s run our tests to make sure they all pass. You can do so from the IDE or from the shell with the following command:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/node_parse_test.py</span></pre>&#13;
<p class="indent">Let’s now work on parsing the bars.</p>&#13;
<h3 class="h3" id="ch00lev1sec105"><strong>Parsing Bars</strong></h3>&#13;
<p class="noindent">In <em>structures/parse</em>, create a new file named <em>bar_parse.py</em>. In this file, enter the code in <a href="ch17.xhtml#ch17lis3">Listing 17-3</a>.</p>&#13;
<pre>import re&#13;
from structures.model.bar import StrBar&#13;
&#13;
__BAR_REGEX = r'(?P&lt;id&gt;\d+)\s*:\s*' \&#13;
              r'\((?P&lt;start_id&gt;\d+)\s*-&gt;\s*(?P&lt;end_id&gt;\d+)\)\s*' \&#13;
              r'(?P&lt;sec&gt;[\d\.]+)\s+' \&#13;
              r'(?P&lt;young&gt;[\d\.]+)'&#13;
&#13;
&#13;
def parse_bar(bar_str: str, nodes_dict):&#13;
 <span class="ent">➊</span> match = re.match(__BAR_REGEX, bar_str)&#13;
    if not match:&#13;
        raise ValueError(&#13;
            f'Cannot parse bar from string: {bar_str}'&#13;
        )&#13;
&#13;
 <span class="ent">➋</span> _id = int(match.group('id'))&#13;
 <span class="ent">➌</span> start_id = int(match.group('start_id'))&#13;
 <span epub:type="pagebreak" id="page_475"/><span class="ent">➍</span> end_id = int(match.group('end_id'))&#13;
 <span class="ent">➎</span> section = float(match.group('sec'))&#13;
 <span class="ent">➏</span> young_mod = float(match.group('young'))&#13;
&#13;
 <span class="ent">➐</span> start_node = nodes_dict[start_id]&#13;
    if start_node is None:&#13;
        raise ValueError(f'Node with id: ${start_id} undefined')&#13;
&#13;
    end_node = nodes_dict[end_id]&#13;
    if end_node is None:&#13;
        raise ValueError(f'Node with id: ${start_id} undefined')&#13;
&#13;
 <span class="ent">➑</span> return StrBar(_id, start_node, end_node, section, young_mod)</pre>&#13;
<p class="caption"><a id="ch17lis3"/><em>Listing 17-3: Parsing a bar from a string</em></p>&#13;
<p class="indent">The regular expression to match the bar definition (<span class="literal">__BAR_REGEX</span>) is a bit long and complex. Make sure you enter it carefully. We’ll write some unit tests later, so any error here will come to light there.</p>&#13;
<p class="indent">We’ve written the <span class="literal">parse_bar</span> function, which takes two parameters: the string defining the bar and a dictionary of nodes. In this dictionary, the keys are the IDs of the nodes, and the values are the nodes themselves. The bar needs to have a reference to its end nodes, so these have to be parsed first and then passed to the <span class="literal">parse_bar</span> function. This adds a constraint in the way we parse structure files: nodes should appear first.</p>&#13;
<p class="indent">As with the nodes, we start by matching the passed-in string against our regular expression <span class="ent">➊</span>. If there is no match, we raise a <span class="literal">ValueError</span> with a helpful message including the string that couldn’t be parsed.</p>&#13;
<p class="indent">Next, we retrieve and parse the capture groups: <span class="literal">id</span> parsed as an integer <span class="ent">➋</span>, <span class="literal">start_id</span> <span class="ent">➌</span> and <span class="literal">end_id</span> <span class="ent">➍</span> parsed as integers, and <span class="literal">sec</span> <span class="ent">➎</span> and <span class="literal">young</span> <span class="ent">➏</span> parsed as floats.</p>&#13;
<p class="indent">Then we look for the start node in the nodes dictionary <span class="ent">➐</span> and raise an error if it’s not found: we can’t build a bar whose nodes don’t exist. We do the same thing for the end node, and then we create and return the bar instance in the last line <span class="ent">➑</span>, passing it all the parsed values.</p>&#13;
<p class="indent">Let’s test this code.</p>&#13;
<h4 class="h4" id="ch00lev2sec185"><strong><em>Testing the Bar Parser</em></strong></h4>&#13;
<p class="noindent">To test the bar parsing process, create a new file in <em>structures/tests</em> named <em>bar_parse_test.py</em>. Enter the new tests in <a href="ch17.xhtml#ch17lis4">Listing 17-4</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from structures.parse.bar_parse import parse_bar&#13;
&#13;
&#13;
class BarParseTest(unittest.TestCase):&#13;
 <span class="ent">➊</span> bar_str = '1: (3 -&gt; 5) 25.0 20000000.0'&#13;
 <span epub:type="pagebreak" id="page_476"/><span class="ent">➋</span> nodes_dict = {&#13;
        3: 'Node 3',&#13;
        5: 'Node 5'&#13;
    }&#13;
 <span class="ent">➌</span> bar = parse_bar(bar_str, nodes_dict)&#13;
&#13;
    def test_parse_id(self):&#13;
        self.assertEqual(1, self.bar.id)&#13;
&#13;
    def test_parse_start_node(self):&#13;
        self.assertEqual('Node 3', self.bar.start_node)&#13;
&#13;
    def test_parse_end_node_id(self):&#13;
        self.assertEqual('Node 5', self.bar.end_node)&#13;
&#13;
    def test_parse_section(self):&#13;
        self.assertEqual(25.0, self.bar.cross_section)&#13;
&#13;
    def test_parse_young_modulus(self):&#13;
        self.assertEqual(20000000.0, self.bar.young_mod)</pre>&#13;
<p class="caption"><a id="ch17lis4"/><em>Listing 17-4: Testing the parsing of a bar</em></p>&#13;
<p class="indent">In this test, we define a bar using its string representation <span class="ent">➊</span>. The <span class="literal">parse</span> <span class="literal">_bar</span> function requires a dictionary containing the nodes by ID as its second argument; we create a dummy (recall the types from the 16 <a href="ch16.xhtml#ch00lev1sec97">page 447</a>) called <span class="literal">nodes_dict</span> <span class="ent">➋</span>. This dictionary contains the two node IDs mapped to a string. Our parsing code doesn’t really do anything with the nodes or even check their types; it simply adds them to the bar instance. So for the tests, a string mocking the node is enough.</p>&#13;
<p class="indent">Again, we parse <span class="ent">➌</span> first and store the result in the <span class="literal">bar</span> variable. We then create five tests that check that we’ve correctly parsed the ID, both start and end nodes, the cross section, and Young’s modulus.</p>&#13;
<p class="indent">Run the tests to make sure they all pass. You can do so from the shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/bar_parse_test.py</span></pre>&#13;
<p class="indent">Lastly, we need to parse the loads.</p>&#13;
<h3 class="h3" id="ch00lev1sec106"><strong>Parsing Loads</strong></h3>&#13;
<p class="noindent">We’ll now write a function to parse the load strings, but we won’t apply the loads to the nodes here. That’ll happen later when we put all the pieces together.</p>&#13;
<p class="indent">Create a new file in <em>structures/parse</em> named <em>load_parse.py</em>. Enter the code in <a href="ch17.xhtml#ch17lis5">Listing 17-5</a>.<span epub:type="pagebreak" id="page_477"/></p>&#13;
<pre>import re&#13;
&#13;
from geom2d import Vector&#13;
&#13;
__LOAD_REGEX = r'(?P&lt;node_id&gt;\d+)\s*-&gt;\s*' \&#13;
               r'\((?P&lt;vec&gt;[\d\s\.,\-]+)\)'&#13;
&#13;
&#13;
def parse_load(load_str: str):&#13;
 <span class="ent">➊</span> match = re.match(__LOAD_REGEX, load_str)&#13;
    if not match:&#13;
        raise ValueError(&#13;
            f'Cannot parse load from string: "{load_str}"'&#13;
        )&#13;
&#13;
 <span class="ent">➋</span> node_id = int(match.group('node_id'))&#13;
 <span class="ent">➌</span> [fx, fy] = [&#13;
        float(num)&#13;
        for num in match.group('vec').split(',')&#13;
    ]&#13;
&#13;
 <span class="ent">➍</span> return node_id, Vector(fx, fy)</pre>&#13;
<p class="caption"><a id="ch17lis5"/><em>Listing 17-5: Parsing a load from a string</em></p>&#13;
<p class="indent">In this listing we define the regular expression that matches the loads as <span class="literal">__LOAD_REGEX</span>. Then comes the <span class="literal">parse_load</span> function, which first looks for a match in the passed-in string (<span class="literal">load_str</span>) <span class="ent">➊</span>. We raise an error if the string doesn’t match <span class="literal">__LOAD_REGEX</span>.</p>&#13;
<p class="indent">The regular expression defines two capturing groups: <span class="literal">node_id</span> and <span class="literal">vec</span>. The first group is the ID of the node where the load needs to be applied. We convert the value for this first group into an integer and store it in the <span class="literal">node_id</span> variable <span class="ent">➋</span>.</p>&#13;
<p class="indent">To extract the force components, we split the value matched by the <span class="literal">vec</span> capture group and then parse each part, convert it to a float value, and use destructuring to extract the components into the <span class="literal">fx</span> and <span class="literal">fy</span> variables <span class="ent">➌</span>.</p>&#13;
<p class="indent">Lastly, we return a tuple of the node ID and a vector with the force components <span class="ent">➍</span>.</p>&#13;
<p class="indent">Let’s test this logic to make sure it parses loads correctly.</p>&#13;
<h4 class="h4" id="ch00lev2sec186"><strong><em>Testing the Load Parser</em></strong></h4>&#13;
<p class="noindent">In the <em>structures/tests</em> folder, create a new file named <em>load_parse_test.py</em>. Enter the test code in <a href="ch17.xhtml#ch17lis6">Listing 17-6</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d import Vector&#13;
<span epub:type="pagebreak" id="page_478"/>from structures.parse.load_parse import parse_load&#13;
&#13;
&#13;
class LoadParseTest(unittest.TestCase):&#13;
&#13;
    load_str = '1 -&gt; (250.0, -3500.0)'&#13;
    (node_id, load) = parse_load(load_str)&#13;
&#13;
    def test_parse_node_id(self):&#13;
        self.assertEqual(1, self.node_id)&#13;
&#13;
    def test_parse_load_vector(self):&#13;
        expected = Vector(250.0, -3500.0)&#13;
        self.assertEqual(expected, self.load)</pre>&#13;
<p class="caption"><a id="ch17lis6"/><em>Listing 17-6: Testing the parsing of a load</em></p>&#13;
<p class="indent">This test defines a string representing a load applied to a node with an ID of 1 and whose components are ⟨250.0,–3500.0⟩. The string is stored in the <span class="literal">load_str</span> variable and passed to the <span class="literal">parse_load</span> function.</p>&#13;
<p class="indent">In the first test, we check that we’ve correctly parsed the node ID, which is returned by the function as the tuple’s first value. Then, we check that we’ve correctly parsed the tuple’s second value, the vector. These two simple tests are enough to make sure our function does its job.</p>&#13;
<p class="indent">Run the tests from the IDE or from the shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/load_parse_test.py</span></pre>&#13;
<p class="indent">Now that we have functions that can parse the structure’s individual parts from their string representations, it’s time to put them together. In the next section, we’ll work on a function that reads all the lines of a structure definition file and generates the corresponding model.</p>&#13;
<h3 class="h3" id="ch00lev1sec107"><strong>Parsing the Structure</strong></h3>&#13;
<p class="noindent">Our structure files define each entity on its own line, and entities appear grouped by sections. If you recall, we defined three sections for the three different entities we need to parse: nodes, bars, and loads. Here’s the previous example of a structure file:</p>&#13;
<pre>nodes&#13;
1: (0, 0)     (xy)&#13;
2: (0, 200)   (xy)&#13;
3: (400, 200) ()&#13;
&#13;
loads&#13;
3 -&gt; (500, -1000)&#13;
&#13;
bars&#13;
<span epub:type="pagebreak" id="page_479"/>1: (1 -&gt; 2) 5 10&#13;
2: (2 -&gt; 3) 5 10&#13;
3: (1 -&gt; 3) 5 10</pre>&#13;
<p class="indent">Because these files will mostly be written by hand, it would be nice if we allowed the inclusion of comments: lines that are ignored by the parsing mechanism but explain something to someone reading the file, just like comments in code.</p>&#13;
<p class="indent">Here’s an example:</p>&#13;
<pre># only node with a load applied&#13;
3: (400, 200) ()</pre>&#13;
<p class="indent">We’ll borrow Python’s syntax and use the <span class="literal">#</span> symbol to mark the start of a comment. Comments will have to appear on their own lines.</p>&#13;
<h4 class="h4" id="ch00lev2sec187"><strong><em>Overview</em></strong></h4>&#13;
<p class="noindent">Because we’ll need to write a few functions, it may be helpful to have a diagram of the structure parsing process with the function names annotated after the steps. Take a look at <a href="ch17.xhtml#ch17fig5">Figure 17-5</a>.</p>&#13;
<div class="image"><img src="../images/17fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch17fig5"><em>Figure 17-5: Structure parsing process</em></p>&#13;
<p class="indent">In this diagram, we show each step of the parsing process. We start with a structure file defining the structure in plaintext following our standard format.</p>&#13;
<p class="indent">The first step is to read the file contents into a string. We’ll implement this part in our application in <a href="ch19.xhtml#ch19">Chapter 19</a>.</p>&#13;
<p class="indent">The second step consists of splitting the big string into multiple lines.</p>&#13;
<p class="indent">The third step is parsing those lines into a dictionary of the structural primitives. This step is handled by the private <span class="literal">__parse_lines</span> function.</p>&#13;
<p class="indent">The fourth and final step is aggregating those parsed structural items into a structure instance.</p>&#13;
<p class="indent">The <span class="literal">parse_structure_from_lines</span> function is a combination of steps 3 and 4: it transforms a list of definition lines into a complete structure. The <span class="literal">parse</span> <span class="literal">_structure</span> <span epub:type="pagebreak" id="page_480"/>function goes one step further and splits a single string into multiple lines.</p>&#13;
<h4 class="h4" id="ch00lev2sec188"><strong><em>Setup</em></strong></h4>&#13;
<p class="noindent">In the <em>structures/parse</em> directory, create a new file named <em>str_parse.py</em>. The <em>structures</em> package should now look like this:</p>&#13;
<p class="pre2">    structures<br/>      |- model<br/>      |    | ...<br/>      |- parse<br/>      |    |- __init__.py<br/>      |    |- bar_parse.py<br/>      |    |- load_parse.py<br/>      |    |- node_parse.py<br/>      |    |- str_parse.py<br/>      |- solution<br/>      |    | ...<br/>      |- tests<br/>      |    | ...</p>&#13;
<p class="indent">Let’s start the implementation with a function that determines whether a line in the file is blank or a comment. This function will let us know whether a given line can be ignored or whether it has to be parsed.</p>&#13;
<h4 class="h4" id="ch00lev2sec189"><strong><em>Ignoring Blank Lines and Comments</em></strong></h4>&#13;
<p class="noindent">In <em>str_parse.py</em>, enter the code in <a href="ch17.xhtml#ch17lis7">Listing 17-7</a>.</p>&#13;
<pre>__COMMENT_INDICATOR = '#'&#13;
&#13;
&#13;
def __should_ignore_line(line: str):&#13;
    stripped = line.strip()&#13;
    return len(stripped) == 0 or \&#13;
           stripped.startswith(__COMMENT_INDICATOR)</pre>&#13;
<p class="caption"><a id="ch17lis7"/><em>Listing 17-7: Function to determine the lines that need to be ignored</em></p>&#13;
<p class="indent">We define a constant, <span class="literal">__COMMENT_INDICATOR</span>, with the <span class="literal">#</span> character for its value. If we ever want to change the way comments are identified, we’ll simply need to edit this line.</p>&#13;
<p class="indent">Next is the <span class="literal">__should_ignore_line</span> function. This function receives a string and removes any surrounding blank spaces (in other words, it strips the string). Then, if the line has a length of zero or starts with the comment indicator, the function returns a <span class="literal">True</span> value, and a <span class="literal">False</span> otherwise.</p>&#13;
<h4 class="h4" id="ch00lev2sec190"><span epub:type="pagebreak" id="page_481"/><strong><em>Parsing the Lines</em></strong></h4>&#13;
<p class="noindent">Now that we have a way to filter out the lines that don’t need to be parsed, let’s look at the ones that do. We’re going to define a function that receives a list of strings representing the lines and identifies whether the line is a section header (“nodes,” “bars,” or “loads”) or an entity. In the case of a section header, the function will set a flag to keep track of the current section being read. The rest of the function will take care of parsing each line using the corresponding parser.</p>&#13;
<p class="indent">In the file <em>str_parse.py</em>, enter the code in <a href="ch17.xhtml#ch17lis8">Listing 17-8</a>.</p>&#13;
<pre>import re&#13;
&#13;
from .bar_parse import parse_bar&#13;
from .load_parse import parse_load&#13;
from .node_parse import parse_node&#13;
&#13;
__COMMENT_INDICATOR = '#'&#13;
__NODES_HEADER = 'nodes'&#13;
__LOADS_HEADER = 'loads'&#13;
__BARS_HEADER = 'bars'&#13;
&#13;
&#13;
def __parse_lines(lines: [str]):&#13;
 <span class="ent">➊</span> reading = ''&#13;
 <span class="ent">➋</span> result = {'nodes': {}, 'loads': [], 'bars': []}&#13;
&#13;
    for i, line in enumerate(lines):&#13;
     <span class="ent">➌</span> if __should_ignore_line(line):&#13;
            continue&#13;
&#13;
        # &lt;--- header ---&gt; #&#13;
     <span class="ent">➍</span> if re.match(__NODES_HEADER, line):&#13;
            reading = 'nodes'&#13;
        elif re.match(__BARS_HEADER, line):&#13;
            reading = 'bars'&#13;
        elif re.match(__LOADS_HEADER, line):&#13;
            reading = 'loads'&#13;
&#13;
        # &lt;--- definition ---&gt; #&#13;
     <span class="ent">➎</span> elif reading == 'nodes':&#13;
            node = parse_node(line)&#13;
            result['nodes'][node.id] = node&#13;
        elif reading == 'bars':&#13;
            bar = parse_bar(line, result['nodes'])&#13;
            result['bars'].append(bar)&#13;
        elif reading == 'loads':&#13;
            load = parse_load(line)&#13;
            <span epub:type="pagebreak" id="page_482"/>result['loads'].append(load)&#13;
        else:&#13;
            raise RuntimeError(&#13;
                f'Unknown error in line ${i}: ${line}'&#13;
            )&#13;
&#13;
    return result&#13;
&#13;
&#13;
def __should_ignore_line(line: str):&#13;
&#13;
    <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch17lis8"/><em>Listing 17-8: Parsing the lines</em></p>&#13;
<p class="indent">We first add three variables with the names of the file headers: <span class="literal">__NODES</span> <span class="literal">_HEADER</span>, <span class="literal">__LOADS_HEADER</span>, and <span class="literal">__BARS_HEADER</span>. These constants define the names of the sections.</p>&#13;
<p class="indent">Then comes the <span class="literal">__parse_lines</span> function definition, which takes one parameter: the list of lines in the structure file. The function declares a variable named <span class="literal">reading</span> <span class="ent">➊</span>. This variable indicates what structure section the later loop is currently in. For example, when its value is ’<span class="literal">bars</span>’, the subsequent lines should be parsed using the <span class="literal">parse_bar</span> function until the end of the file or a new section is encountered.</p>&#13;
<p class="indent">Next comes the definition of the <span class="literal">result</span> dictionary <span class="ent">➋</span>. It’s initialized with three keys: ’<span class="literal">nodes</span>’, ’<span class="literal">loads</span>’, and ’<span class="literal">bars</span>’. We’ll add the parsed elements to this dictionary, in their corresponding key’s collection. Loads and bars are stored in a list and nodes in a dictionary, with the keys being their IDs. We store nodes mapped to their keys in a dictionary because both loads and bars refer to them by ID in the structure file; thus, when we link them, it’ll be more convenient to look them up by ID.</p>&#13;
<p class="indent">Next is the loop that iterates over the lines’ enumeration. Recall that Python’s <span class="literal">enumerate</span> function returns an iterable sequence that includes the original objects along with their index. We’ll use the index only if we encounter an error, using the line number in the error message to make looking for the error in the input file easier. The first thing we do with each line is check whether it’s blank or a comment <span class="ent">➌</span>, in which case we skip it using the <span class="literal">continue</span> statement.</p>&#13;
<p class="indent">Next, we have a couple of <span class="literal">if-else</span> statements. The first block of them is for matching header lines <span class="ent">➍</span>. When a line is found to match one of the three possible headers, we set the <span class="literal">reading</span> variable to the header’s value. The later <span class="literal">if-else</span> statements evaluate <span class="literal">reading</span> to determine which structural element to parse <span class="ent">➎</span>. If <span class="literal">reading</span> has the value ’<span class="literal">nodes</span>’, we use the <span class="literal">parse_node</span> function to parse the line and store the result in the <span class="literal">result</span> dictionary, under the ’<span class="literal">nodes</span>’ key:</p>&#13;
<pre>result['nodes'][node.id] = node</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_483"/>The same goes for bars and loads, but remember that in their case, they’re stored in a list:</p>&#13;
<pre>result['bars'].append(bar)</pre>&#13;
<p class="indent">The function then returns the <span class="literal">result</span> dictionary.</p>&#13;
<p class="indent">We’ve implemented a function that reads a sequence of text lines and converts each of them into a structure class instance (what we know as parsing). These instances represent the nodes, bars, and loads of the structure. The function returns a dictionary that bundles these instances by type. The next step is using these parsed objects to construct a <span class="literal">Structure</span> instance.</p>&#13;
<h4 class="h4" id="ch00lev2sec191"><strong><em>Splitting the Lines and Instantiating the Structure</em></strong></h4>&#13;
<p class="noindent">Given the contents of a structure file as a string, we want to split this string into its lines. We’ll pass those lines to the <span class="literal">__parse_lines</span> function we wrote earlier, and using the parsed objects we can construct an instance of our <span class="literal">Structure</span> class.</p>&#13;
<p class="indent">In the <em>str_parse.py</em> file, before the <span class="literal">__parse_lines</span> function, enter the code in <a href="ch17.xhtml#ch17lis9">Listing 17-9</a>.</p>&#13;
<pre>import re&#13;
&#13;
<span class="codestrong1">from structures.model.structure import Structure</span>&#13;
from .bar_parse import parse_bar&#13;
from .load_parse import parse_load&#13;
from .node_parse import parse_node&#13;
&#13;
__COMMENT_INDICATOR = '#'&#13;
__NODES_HEADER = 'nodes'&#13;
__LOADS_HEADER = 'loads'&#13;
__BARS_HEADER = 'bars'&#13;
&#13;
&#13;
def parse_structure(structure_string: str):&#13;
 <span class="ent">➊</span> lines = structure_string.split('\n')&#13;
    return parse_structure_from_lines(lines)&#13;
&#13;
&#13;
def parse_structure_from_lines(lines: [str]):&#13;
 <span class="ent">➋</span> parsed = __parse_lines(lines)&#13;
    nodes_dict = parsed['nodes']&#13;
    loads = parsed['loads']&#13;
    bars = parsed['bars']&#13;
&#13;
 <span class="ent">➌</span>__apply_loads_to_nodes(loads, nodes_dict)&#13;
&#13;
   return Structure(&#13;
     <span epub:type="pagebreak" id="page_484"/><span class="ent">➍</span> list(nodes_dict.values()),&#13;
        bars&#13;
    )&#13;
&#13;
&#13;
def __apply_loads_to_nodes(loads, nodes):&#13;
 <span class="ent">➎</span> for node_id, load in loads:&#13;
        nodes[node_id].add_load(load)&#13;
&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch17lis9"/><em>Listing 17-9: Splitting the lines</em></p>&#13;
<p class="indent">We’ve written three new functions. The first of them, <span class="literal">parse_structure</span>, splits the passed-in string into its lines <span class="ent">➊</span> and forwards those lines to the <span class="literal">parse_structure_from_lines</span> function defined afterward.</p>&#13;
<p class="indent">This second function, <span class="literal">parse_structure_from_lines</span>, passes the lines to <span class="literal">__parse_lines</span> and saves the result in a variable called <span class="literal">parsed</span> <span class="ent">➋</span>. It then extracts the contents of this result dictionary to the variables: <span class="literal">nodes_dict</span>, <span class="literal">loads</span>, and <span class="literal">bars</span>.</p>&#13;
<p class="indent">The loads are defined separately from the nodes they’re applied to; thus, we need to add each load to its respective node <span class="ent">➌</span>. To do this, we’ve written another small function: <span class="literal">__apply_loads_to_nodes</span>. Recall that the loads were defined using the format</p>&#13;
<pre>1 -&gt; (500, -1000)</pre>&#13;
<p class="noindent">and are parsed by our <span class="literal">parse_load</span> function as a tuple consisting of the node ID and the load components as a vector:</p>&#13;
<pre>(1, Vector(500, -1000))</pre>&#13;
<p class="indent">It’s important to keep this in mind to understand the loop in <span class="literal">__apply</span> <span class="literal">_loads_to_nodes</span> <span class="ent">➎</span>. The loop iterates over the load tuples, and on each iteration, it stores the node ID and load vector into the <span class="literal">node_id</span> and <span class="literal">load</span> variables, respectively. Because our nodes are stored in a dictionary whose keys are the node IDs, applying the loads is a piece of cake.</p>&#13;
<p class="indent">Once the loads have been applied to the nodes (back in <span class="literal">parse_structure</span> <span class="literal">_from_lines</span>), the last step is to return an instance of the <span class="literal">Structure</span> class. The class’s constructor expects a list of nodes and a list of bars. The bars are already parsed as a list, but the nodes were in a dictionary. To turn the values of a dictionary into a list, we simply need to use Python’s <span class="literal">list</span> function on the dictionary values, which we extract using the <span class="literal">values()</span> method <span class="ent">➍</span>.</p>&#13;
<p class="indent">With this, our parsing logic is ready!</p>&#13;
<h4 class="h4" id="ch00lev2sec192"><strong><em>The Result</em></strong></h4>&#13;
<p class="noindent">For your reference, <a href="ch17.xhtml#ch17lis10">Listing 17-10</a> shows the complete code for <em>str_parse.py</em>.<span epub:type="pagebreak" id="page_485"/></p>&#13;
<pre>import re&#13;
&#13;
from structures.model.structure import Structure&#13;
from .bar_parse import parse_bar&#13;
from .load_parse import parse_load&#13;
from .node_parse import parse_node&#13;
&#13;
__COMMENT_INDICATOR = '#'&#13;
__NODES_HEADER = 'nodes'&#13;
__LOADS_HEADER = 'loads'&#13;
__BARS_HEADER = 'bars'&#13;
&#13;
&#13;
def parse_structure(structure_string: str):&#13;
    lines = structure_string.split('\n')&#13;
    return parse_structure_from_lines(lines)&#13;
&#13;
&#13;
def parse_structure_from_lines(lines: [str]):&#13;
    parsed = __parse_lines(lines)&#13;
    nodes_dict = parsed['nodes']&#13;
    loads = parsed['loads']&#13;
    bars = parsed['bars']&#13;
&#13;
    __apply_loads_to_nodes(loads, nodes_dict)&#13;
&#13;
    return Structure(&#13;
        list(nodes_dict.values()),&#13;
        bars&#13;
    )&#13;
&#13;
&#13;
def __apply_loads_to_nodes(loads, nodes):&#13;
    for node_id, load in loads:&#13;
        nodes[node_id].add_load(load)&#13;
&#13;
&#13;
def __parse_lines(lines: [str]):&#13;
    <span epub:type="pagebreak" id="page_486"/>reading = ''&#13;
    result = {'nodes': {}, 'loads': [], 'bars': []}&#13;
&#13;
    for i, line in enumerate(lines):&#13;
        if __should_ignore_line(line):&#13;
            continue&#13;
&#13;
        # &lt;--- header ---&gt; #&#13;
        if re.match(__NODES_HEADER, line):&#13;
            reading = 'nodes'&#13;
        elif re.match(__BARS_HEADER, line):&#13;
            reading = 'bars'&#13;
        elif re.match(__LOADS_HEADER, line):&#13;
            reading = 'loads'&#13;
&#13;
        # &lt;--- definition ---&gt; #&#13;
        elif reading == 'nodes':&#13;
            node = parse_node(line)&#13;
            result['nodes'][node.id] = node&#13;
        elif reading == 'bars':&#13;
            bar = parse_bar(line, result['nodes'])&#13;
            result['bars'].append(bar)&#13;
        elif reading == 'loads':&#13;
            load = parse_load(line)&#13;
            result['loads'].append(load)&#13;
        else:&#13;
            raise RuntimeError(&#13;
                f'Unknown error in line ${i}: ${line}'&#13;
            )&#13;
&#13;
    return result&#13;
&#13;
&#13;
def __should_ignore_line(line: str):&#13;
    stripped = line.strip()&#13;
    return len(stripped) == 0 or \&#13;
           stripped.startswith(__COMMENT_INDICATOR)</pre>&#13;
<p class="caption"><a id="ch17lis10"/><em>Listing 17-10: Parsing the structure</em></p>&#13;
<p class="indent">Before we move to the next section, open the <em>__init__.py</em> file in <em>parse</em>, and enter the following import:</p>&#13;
<pre>from .str_parse import parse_structure</pre>&#13;
<p class="noindent">This allows us to import the <span class="literal">parse_structure</span> function like this,</p>&#13;
<pre>from structures.parse import parse_structure</pre>&#13;
<p class="noindent">instead of this slightly longer version:</p>&#13;
<pre>from structures.parse.str_parse import parse_structure</pre>&#13;
<p class="indent">Let’s make sure our parsing function is working correctly by implementing some automated tests.</p>&#13;
<h4 class="h4" id="ch00lev2sec193"><span epub:type="pagebreak" id="page_487"/><strong><em>Testing the Structure Parser</em></strong></h4>&#13;
<p class="noindent">To make sure the <span class="literal">parse_structure</span> function works as expected, we’ll now add a few unit tests. First, we want to create a structure definition file to use in the test. In the <em>structures/tests</em> directory, create a new file, <em>test_str.txt</em>, with the following contents:</p>&#13;
<pre># Nodes&#13;
nodes&#13;
1: (0.0, 0.0)      (xy)&#13;
2: (200.0, 150.0)  ()&#13;
3: (400.0, 0.0)    (y)&#13;
&#13;
&#13;
&#13;
# Loads&#13;
loads&#13;
2 -&gt; (2500.0, -3500.0)&#13;
&#13;
&#13;
# Bars&#13;
bars&#13;
1: (1 -&gt; 2) 25 20000000&#13;
2: (2 -&gt; 3) 25 20000000&#13;
3: (1 -&gt; 3) 25 20000000</pre>&#13;
<p class="indent">We’ve added comment lines and some extra blank lines; our function should ignore those. Create a new test file: <em>str_parse_test.py</em> (<a href="ch17.xhtml#ch17lis11">Listing 17-11</a>).</p>&#13;
<pre>import unittest&#13;
&#13;
import pkg_resources as res&#13;
&#13;
from structures.parse import parse_structure&#13;
&#13;
&#13;
class StructureParseTest(unittest.TestCase):&#13;
&#13;
    def setUp(self):&#13;
        str_bytes = res.resource_string(__name__, 'test_str.txt')&#13;
        str_string = str_bytes.decode("utf-8")&#13;
        self.structure = parse_structure(str_string)</pre>&#13;
<p class="caption"><a id="ch17lis11"/><em>Listing 17-11: Setting up the structure parsing test</em></p>&#13;
<p class="indent">The file defines a new test class: <span class="literal">StructureParseTest</span>. In the <span class="literal">setUp</span> method, we load the <em>test_str.txt</em> file as bytes using the <span class="literal">resource_string</span> function. Then, we decode those bytes into a UTF-8 encoded Python string. Lastly, using <span class="literal">parse_structure</span>, we parse the structure string and store the result in a class attribute: <span class="literal">self.structure</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec93"><span epub:type="pagebreak" id="page_488"/><strong>Testing the Node Parser</strong></h5>&#13;
<p class="noindent">Let’s add some test cases to ensure the structure that we parsed from the <em>test_str.txt</em> file contains the expected nodes. After the <span class="literal">setUp</span> method, enter the first tests (<a href="ch17.xhtml#ch17lis12">Listing 17-12</a>).</p>&#13;
<pre>import unittest&#13;
&#13;
import pkg_resources as res&#13;
&#13;
<span class="codestrong1">from geom2d import Point</span>&#13;
from structures.parse import parse_structure&#13;
&#13;
&#13;
class StructureParseTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_parse_nodes_count(self):&#13;
        self.assertEqual(3, self.structure.nodes_count)&#13;
&#13;
    def test_parse_nodes(self):&#13;
     <span class="ent">➊</span> nodes = self.structure._Structure__nodes&#13;
        self.assertEqual(&#13;
            Point(0, 0),&#13;
            nodes[0].position&#13;
        )&#13;
        self.assertEqual(&#13;
            Point(200, 150),&#13;
            nodes[1].position&#13;
        )&#13;
        self.assertEqual(&#13;
            Point(400, 0),&#13;
            nodes[2].position&#13;
        )&#13;
&#13;
    def test_parse_node_constraints(self):&#13;
        nodes = self.structure._Structure__nodes&#13;
&#13;
        self.assertTrue(nodes[0].dx_constrained)&#13;
        self.assertTrue(nodes[0].dy_constrained)&#13;
&#13;
        self.assertFalse(nodes[1].dx_constrained)&#13;
        self.assertFalse(nodes[1].dy_constrained)&#13;
&#13;
        self.assertFalse(nodes[2].dx_constrained)&#13;
        self.assertTrue(nodes[2].dy_constrained)</pre>&#13;
<p class="caption"><a id="ch17lis12"/><em>Listing 17-12: Testing the structure parsing: the nodes</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_489"/>We’ve written three tests. The first one checks that there are three nodes in the structure. The next test ensures that those three nodes have the correct position.</p>&#13;
<p class="indent">There’s one interesting thing to note here. Since the <span class="literal">__nodes</span> list is private to the <span class="literal">Structure</span> class, Python uses a trick to try to hide it from us. Python prepends an underscore and the name of the class to the name of its private attributes. The <span class="literal">__nodes</span> attribute will therefore be called <span class="literal">_Structure__nodes</span>, and not <span class="literal">__nodes</span> as we’d expect. This is why, to access it from our tests, we use this name <span class="ent">➊</span>.</p>&#13;
<p class="indent">The third and last test checks if the external constraints in the nodes have the right values as defined in the structure definition file. Let’s run the tests. You can click the green play button in the IDE or use the shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/str_parse_test.py</span></pre>&#13;
<p class="indent">A success message should be displayed in the shell.</p>&#13;
<h5 class="h5" id="ch00lev3sec94"><strong>Testing the Bar Parser</strong></h5>&#13;
<p class="noindent">Let’s now test if the bars are also parsed correctly. After the test cases we just wrote, enter the ones in <a href="ch17.xhtml#ch17lis13">Listing 17-13</a>.</p>&#13;
<pre>class StructureParseTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_parse_bars_count(self):&#13;
        self.assertEqual(3, self.structure.bars_count)&#13;
&#13;
    def test_parse_bars(self):&#13;
        bars = self.structure._Structure__bars&#13;
&#13;
        self.assertEqual(1, bars[0].start_node.id)&#13;
        self.assertEqual(2, bars[0].end_node.id)&#13;
&#13;
        self.assertEqual(2, bars[1].start_node.id)&#13;
        self.assertEqual(3, bars[1].end_node.id)&#13;
&#13;
        self.assertEqual(1, bars[2].start_node.id)&#13;
        self.assertEqual(3, bars[2].end_node.id)</pre>&#13;
<p class="caption"><a id="ch17lis13"/><em>Listing 17-13: Testing the structure parsing: the bars</em></p>&#13;
<p class="indent">The first test asserts that there are three bars in the structure. The second test checks that every bar in the structure is linked to the correct node IDs. Same as before, to access the private list of bars, we need to prepend <span class="literal">_Structure</span> to the attribute name: <span class="literal">_Structure__bars</span>.</p>&#13;
<p class="indent">I invite you to add two more tests that check that the values for the cross section and Young’s modulus are correctly parsed into the bars. We won’t include them here for brevity reasons.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_490"/>Run the test class again to make sure our new tests also pass. From the shell, run this:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/str_parse_test.py</span></pre>&#13;
<h5 class="h5" id="ch00lev3sec95"><strong>Testing the Load Parser</strong></h5>&#13;
<p class="noindent">Let’s add the two last tests to ensure the loads are properly parsed. Enter the code in <a href="ch17.xhtml#ch17lis14">Listing 17-14</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
import pkg_resources as res&#13;
&#13;
from geom2d import Point, Vector&#13;
from structures.parse import parse_structure&#13;
&#13;
&#13;
class StructureParseTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_parse_loads_count(self):&#13;
        self.assertEqual(1, self.structure.loads_count)&#13;
&#13;
    def test_apply_load_to_node(self):&#13;
        node = self.structure._Structure__nodes[1]&#13;
        self.assertEqual(&#13;
            Vector(2500, -3500),&#13;
            node.net_load&#13;
        )</pre>&#13;
<p class="caption"><a id="ch17lis14"/><em>Listing 17-14: Testing the structure parsing: the loads</em></p>&#13;
<p class="indent">In these two last tests, we check that the number of loads in the structure is 1 and that it’s being correctly applied to the second node.</p>&#13;
<p class="indent">Let’s run all the tests to make sure all pass:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/str_parse_test.py</span></pre>&#13;
<p class="indent">If your code is well implemented, all the tests should pass, and you should see the following in the shell:</p>&#13;
<pre>Ran 7 tests in 0.033s&#13;
&#13;
OK</pre>&#13;
<h5 class="h5" id="ch00lev3sec96"><strong>Test Class Result</strong></h5>&#13;
<p class="noindent">We’ve done a few tests, so <a href="ch17.xhtml#ch17lis15">Listing 17-15</a> shows the resulting test class for your reference.<span epub:type="pagebreak" id="page_491"/></p>&#13;
<pre>import unittest&#13;
&#13;
import pkg_resources as res&#13;
&#13;
from geom2d import Point, Vector&#13;
from structures.parse import parse_structure&#13;
&#13;
&#13;
class StructureParseTest(unittest.TestCase):&#13;
&#13;
    def setUp(self):&#13;
        str_bytes = res.resource_string(__name__, 'test_str.txt')&#13;
        str_string = str_bytes.decode("utf-8")&#13;
        self.structure = parse_structure(str_string)&#13;
&#13;
    def test_parse_nodes_count(self):&#13;
        self.assertEqual(3, self.structure.nodes_count)&#13;
&#13;
    def test_parse_nodes(self):&#13;
        nodes = self.structure._Structure__nodes&#13;
        self.assertEqual(&#13;
            Point(0, 0),&#13;
            nodes[0].position&#13;
        )&#13;
        self.assertEqual(&#13;
            Point(200, 150),&#13;
            nodes[1].position&#13;
        )&#13;
        self.assertEqual(&#13;
            Point(400, 0),&#13;
            nodes[2].position&#13;
        )&#13;
&#13;
    def test_parse_node_constraints(self):&#13;
        nodes = self.structure._Structure__nodes&#13;
&#13;
        self.assertTrue(nodes[0].dx_constrained)&#13;
        self.assertTrue(nodes[0].dy_constrained)&#13;
&#13;
        self.assertFalse(nodes[1].dx_constrained)&#13;
        self.assertFalse(nodes[1].dy_constrained)&#13;
&#13;
        self.assertFalse(nodes[2].dx_constrained)&#13;
        self.assertTrue(nodes[2].dy_constrained)&#13;
&#13;
    def test_parse_bars_count(self):&#13;
        self.assertEqual(3, self.structure.bars_count)&#13;
&#13;
    <span epub:type="pagebreak" id="page_492"/>def test_parse_bars(self):&#13;
        bars = self.structure._Structure__bars&#13;
&#13;
        self.assertEqual(1, bars[0].start_node.id)&#13;
        self.assertEqual(2, bars[0].end_node.id)&#13;
&#13;
        self.assertEqual(2, bars[1].start_node.id)&#13;
        self.assertEqual(3, bars[1].end_node.id)&#13;
&#13;
        self.assertEqual(1, bars[2].start_node.id)&#13;
        self.assertEqual(3, bars[2].end_node.id)&#13;
&#13;
    def test_parse_loads_count(self):&#13;
        self.assertEqual(1, self.structure.loads_count)&#13;
&#13;
    def test_apply_load_to_node(self):&#13;
        node = self.structure._Structure__nodes[1]&#13;
        self.assertEqual(&#13;
            Vector(2500, -3500),&#13;
            node.net_load&#13;
        )</pre>&#13;
<p class="caption"><a id="ch17lis15"/><em>Listing 17-15: Testing the structure parsing</em></p>&#13;
<p class="indent">Our structure parsing logic is ready and tested!</p>&#13;
<h3 class="h3" id="ch00lev1sec108"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we first defined a format for our structure files. It’s a simple plaintext format that can be written by hand.</p>&#13;
<p class="indent">We then implemented functions to parse each of the lines in our structure files into its appropriate structural element: nodes, loads, and bars. Regular expressions were the stars of the show; with them, parsing well-structured text was a breeze.</p>&#13;
<p class="indent">Lastly, we put everything together into a function that splits a big string into its lines and decides which parser to use for each line. We’ll use this function to read structure files and create the structural model that our truss resolution application will work with.</p>&#13;
<p class="indent">It’s now time to work on producing the output diagrams for the structure solution. That’s exactly what we’ll do in the next chapter.</p>&#13;
</body></html>