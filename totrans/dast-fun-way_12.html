<html><head></head><body>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_199" title="199"/>12</span><br/>
<span class="ChapterTitle">B-trees</span></h1>
</header>
<figure class="opener">
<img alt="" height="99" src="image_fi/book_art/chapterart.png" width="98"/>
</figure>
<p class="ChapterIntro"><span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> showed how the cost of memory access can vary across mediums. In this chapter, we’ll discuss how this problem extends beyond accessing individual values to the cost of accessing new blocks of data, introducing a new data structure to handle this situation.</p>
<p>Computer science is full of instances where accessing data within a block is cheap, but retrieving a new block is comparatively expensive. A computer might read an entire block of information, known as a <em>page</em>, from the hard drive and store it in memory. In the days of floppy disk–based video games, you might see a message directing you to “Insert disk 5 of 7” or wait while the game loaded the next chunk of data from a CD. Similarly, online applications might download coherent blocks of data from a server across the internet, allowing you to start watching a video before you’ve downloaded the entire thing.</p>
<p>This chapter covers the <em>B-tree</em>, a self-balancing tree-based data structure that computer scientists Rudolf Bayer and Edward McCreight designed to account for the cost of retrieving new blocks of data. B-trees store multiple <span epub:type="pagebreak" id="Page_200" title="200"/>pieces of data in a single node, allowing us to pay the expensive retrieval cost exactly once to extract all those values. Once the node is in local memory, we can quickly access the values within it. The tradeoff is additional complexity when dealing with the nodes.</p>
<p>In the computational domain, we may run into this problem when trying to index a massive data set. Consider the index for a literally astronomical data set that contains pointers to images of every star, galaxy, nebula, comet, asteroid, and other celestial body ever observed. The data set is still larger than the index, but the index itself might need to reside across many blocks of slow storage. B-trees provide an inventive way of combining the indexing and keys while minimizing retrieval costs.</p>
<p>B-trees are also one example of how to define trees’ operations in such a way that they don’t become horribly imbalanced. As we will see later in the chapter, the B-tree always remains perfectly balanced with all the leaf nodes at exactly the same depth. </p>
<h2 id="h1-502604c12-0001">B-tree Structure</h2>
<p class="BodyFirst">B-trees apply the multi-way branching structure that we saw in tries or quadtrees to storing individual keys. Practically, this means that they allow internal nodes many more than two branches, so they’re practically bristling with pointers. They also need to store more than a single key in each node. B-tree nodes are packed with keys, allowing them to both track multi-way partitions and, more importantly, maximize the amount of data we can retrieve by fetching a single node. </p>
<p>We see the benefit of packing multiple items into a node in the everyday context of online shipping. We pay a cost for every box shipped, and these costs can add up quickly if we are shipping many small boxes. This is the equivalent of retrieving many small tree nodes from expensive storage. If we pack several items into the same box, however, we can reduce the cost by shipping them together. Similarly, B-trees reduce the cost of retrieving multiple keys by retrieving a block of them together.</p>
<p>Formally, we define the size of B-tree node with a size parameter <em>k</em>, which provides bounds on how many elements a non-root node can store. All non-root nodes store between <em>k</em> and 2<em>k</em> keys in sorted order. The root node is more flexible and is allowed to contain between 0 and 2<em>k</em> keys. Like a binary search tree, internal nodes use the values of these keys to define the ranges for the branches. Internal nodes store pointers for each possible split point, before and after each key in the node, allowing for between <em>k</em> + 1 and 2<em>k</em> + 1 children for all internal nodes except the root node, which can have between 0 to 2<em>k</em> + 1 children. These split points are conceptually the same as what we do in a binary search tree—they divide the space into keys that come before the split and keys that come after. </p>
<p><a href="#figure12-1" id="figureanchor12-1">Figure 12-1</a> shows an example of this structure. The node with keys 12, 31, and 45 defines four separate partitions: keys that come before 12, keys <span epub:type="pagebreak" id="Page_201" title="201"/>after 12 but before 31, keys after 31 but before 45, and keys after 45. The subtree containing 13, 17, and 26 is defined by two split points in the parent node. All the keys in that node must be greater than 12 since their node’s child pointer is to the right of key 12. Similarly, the keys must all be less than 31 since the pointer is to the left of key 31.</p>
<figure>
<img alt="The example B‐tree has 3 layers. The top node has a single key (51) and pointers to 2 children. The left child has keys 12, 31, and 45 and pointers to 4 children, one of which is a subtree containing 13, 17, 26." class="" height="153" src="image_fi/502604c12/f12001.png" width="564"/>
<figcaption><p><a id="figure12-1">Figure 12-1</a>: An example B-tree</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p> 	The notation used to describe the parameters of a B-tree varies from reference to reference, such as defining the size parameter as the maximum number of keys (or children) per node or varying how the children are indexed relative to the keys. When comparing implementations, it is important to account for these differences.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Picture this structure in the context of indexing the vast collection at the Comprehensive Museum of Fun and Informative Collectibles. In an attempt to allow a dynamic collection, we store the index entry to each item on a small paper card with the name, a brief description, and the location in our massive collectibles warehouse. We can fit nine hundred cards into a single binder, so, for our collection of a hundred million items, we need over a hundred thousand binders to store the entire index. </p>
<p>While we would like to store the entire index locally, we simply lack enough space in our office. Once we have requisitioned and retrieved a binder containing a slice of the index, we can browse through its entries relatively easily. However, asking for each new volume involves a trip to the archives and a requisition form.</p>
<p>In this organization scheme, each index card corresponds to a single entry in the B-tree where the name string is the key. The binders correspond to B-tree nodes, each with 900 pockets and thus holding a maximum of 900 keys. The entries within the binder are in sorted order, allowing us to search for a key with a linear scan or binary search. In addition, we keep one more piece of data in each of the binder’s pockets, a pointer to the binder containing entries between the current index card’s key and the key of the previous index card. As shown in <a href="#figure12-2" id="figureanchor12-2">Figure 12-2</a>, if we are looking for the target “Caffeine Unlimited Coffee Mug,” we would first scan past “Caffeine Ten Coffee Mug," which comes before our target in alphabetical order, and then hit “Jeremy’s Gourmet High-Caffeine Experience,” which comes after the target. At this point, we have passed the potential location for our target key and know that we need to search the binder before the current entry. </p>
<span epub:type="pagebreak" id="Page_202" title="202"/><figure>
<img alt="Three entries from our collectibles index: Caffeine Ten Coffee Mug, Jeremy’s Gourmet High‐Caffeine Experience Coffee Mug, and Morning Zap Brand Coffee Mug . Each entry has two pointers, an item pointer and a binder pointer. The binder pointer for Jeremy’s Gourmet High‐Caffeine Experience Coffee Mug is shown as an arrow." class="" height="252" src="image_fi/502604c12/f12002.png" width="439"/>
<figcaption><p><a id="figure12-2">Figure 12-2</a>: The binder pointer in our index cards indicates which binder to use to continue our search.</p></figcaption>
</figure>
<p>We store a single additional pointer at the very back of the binder that points to another binder containing only keys that come after the last key in the current binder. In total, our binder can contain up to 900 keys (with their pointers to the associated collectibles) and 901 pointers to other binders.</p>
<p>As with the other tree-based data structures, we define B-tree structure using both a top-level composite data structure and a node-specific data structure:</p>
<pre><code>BTree {
    BTreeNode: root
    Integer: k
}

BTreeNode {
    Integer: k
    Integer: size
    Boolean: is_leaf
    Array of Type: keys
    Array of BTreeNodes: children
}</code></pre>
<p class="BodyContinued">In this data structure and the examples below, we store and retrieve individual keys to keep the code simple. As with the other data structures we have introduced, in most cases it will be useful to store a composite data structure with both the key and a pointer to the key’s data, such as with the item pointers in <a href="#figure12-2">Figure 12-2</a>.</p>
<p>One complication of the B-tree structure is that we store the keys and children in two differently sized arrays. This means that we need to define how a key at index <em>i</em> maps to its adjacent child pointers. For any given index <em>i</em>, we can access the key at <em>keys</em>[<em>i</em>], but we also need to be able to access the node pointers before and after that key. We define the pointers such that the value of all keys in or below <em>children</em>[<em>i</em>] are less than <em>keys</em>[<em>i</em>] and greater than <em>keys</em>[<em>i</em> <em>− </em>1] (if <em>i</em> &gt; 0), as shown in <a href="#figure12-3" id="figureanchor12-3">Figure 12-3</a>. </p>
<span epub:type="pagebreak" id="Page_203" title="203"/><figure>
<img alt="The keys array contains 12, 31, and 45. The children array has 4 pointers: keys less than 12, keys less than 31 and greater than 12, keys less than 45 and greater than 31, and keys greater than 45." class="" height="170" src="image_fi/502604c12/f12003.png" width="302"/>
<figcaption><p><a id="figure12-3">Figure 12-3</a>: A mapping from the entries in the keys array to the corresponding elements in the children array</p></figcaption>
</figure>
<p>By definition, B-trees are balanced data structures. Every leaf node is exactly the same depth from the root. In a later section, we’ll show how this structure is maintained by updating nodes as we insert and delete new keys. </p>
<h2 id="h1-502604c12-0002">Searching B-trees</h2>
<p class="BodyFirst">We search the B-tree using the same general procedure that we use for all tree-based data structures: we start at the top of the tree and work our way down until we find the key of interest. The main difference between the B-tree and a binary search tree is that we might need to check more than one key per node. We scan along the keys in each node until we either find the target key or find a key with a value larger than our target. In the latter case, if we are at an internal node, we drop down to the appropriate child and continue the search, as follows:</p>
<pre><code>BTreeSearch(BTree: tree, Type: target):
    return BTreeNodeSearch(tree.root, target)

BTreeNodeSearch(BTreeNode: node, Type: target):
    # Search the node's key list for the target.
    Integer: i = 0
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> WHILE i &lt; node.size AND target &gt;= node.keys[i]:
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> IF target == node.keys[i]:
            return node.keys[i]
        i = i + 1

    # Descend to the correct child.
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> IF node.is_leaf:
        return null
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> return BTreeNodeSearch(node.children[i], target)</code></pre>
<p>The code for this search starts by scanning through the keys stored at the current node using a <code>WHILE</code> loop <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The loop continues until it hits the end of the key list (<code>i == node.size</code>) or hits a key larger than the target (<code>target &lt; node.keys[i]</code>). The code checks whether it has found a matching key in the current node, and, if so, returns that key <span aria-label="annotation2" class="CodeAnnotation">❷</span>. While the example code uses a linear scan to search the node for the purpose of simplicity in this example, we could also use binary search for better efficiency.</p>
<p><span epub:type="pagebreak" id="Page_204" title="204"/>If the code does not find a match in the current node and the current node is a leaf, there is no match in the tree, and the code returns <code>null</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Otherwise, the code recursively explores the correct child node. It can access the correct child directly with the loop iterator <code>i</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>, because the loop stops when either <code>i</code> represents the last child or <code>key[i] &gt; target</code>. </p>
<p>Consider the example of searching the B-tree shown earlier in <a href="#figure12-1">Figure 12-1</a> for key 17. In the root node, we check the first key (51) and see that it is greater than 17, so we drop down a level using the first child pointer. At the next level, we check two keys: 12 is less than our target, so we proceed past it; 31 is greater than our target, so we drop down to the child node whose keys come before 31 using the second child pointer. This process continues at the leaf node. <a href="#figure12-4" id="figureanchor12-4">Figure 12-4</a> illustrates this search, indicating with gray the array bins we have accessed and compared.</p>
<figure>
<img alt="The search of the B‐tree visits the key 51 in the top node, 12 and 31 in the second‐level child, and 13 and 17 in the third‐level child." class="" height="153" src="image_fi/502604c12/f12004.png" width="564"/>
<figcaption><p><a id="figure12-4">Figure 12-4</a>: An example search of a B-tree. The shaded cells are the ones checked by the algorithm.</p></figcaption>
</figure>
<p>We should consider how searching the keys within a node impacts the runtime: instead of dropping down to the next level after a single comparison, we might now have to perform multiple comparisons per node. This is an acceptable tradeoff for two reasons. First, remember the B-tree is optimized to reduce the number of nodes fetched. In comparison, the data accesses within a node are expected to be relatively cheap because they are happening in local memory and do not require us to fetch another block of data from the expensive storage. Second, and equally important, the branching structure of the B-tree still provides ample opportunities for pruning. Each comparison still eliminates entire subtrees. And, like the current node, each skipped node may contain up to 2<em>k</em> keys and 2<em>k</em> + 1 children.</p>
<p>Returning to our collectibles example, consider a search for a particular collectible. We start at the root binder. Since the keys are stored in alphabetical order, we can rapidly skim down the rows until we find our desired key or pass where it should be. If we don’t see our desired key, we know it isn’t in this binder. We mumble a few choice words about the unfairness of finite storage space and note the first key we encounter that comes after our target key has an item pointer reading “Binder #300.” We mumble a few more complaints and ask the archivist for binder #300.</p>
<p>Let’s contrast this storage approach with what happens if we instead store all our index cards in sorted order. Binder #1 contains the first set of cards <em>Aa</em> through <em>Ab</em>, binder #2 contains <em>Ac</em> through <em>Ad</em>, and so forth. This could work well for a static data set. We could perform a binary search over the binders, requesting the middle binder in our current range each time <span epub:type="pagebreak" id="Page_205" title="205"/>and limiting ourselves to a logarithmic number of requests. However, this approach begins to break down as we add or remove cards. Binders become overfull, requiring us to shift cards from one binder to the next. Updates to our collection might require cascading updates to many binders as cards must be shifted over. In the worst case, if we pack our binders full, we could end up needing to access every binder in our index. As we will see next, B-trees structures facilitate dynamic changes to the data set. </p>
<h2 id="h1-502604c12-0003">Adding Keys</h2>
<p class="BodyFirst">Adding keys to a B-tree is more complex than adding to the tree-based data structures we’ve previously considered. In this case, we need to keep the structure balanced and limit the number of keys stored in each node (between <em>k</em> and 2<em>k</em>). There are two approaches for handling full nodes. First, we could split as we proceed down the tree, making sure we never call insertion on a full node. Second, we can temporarily insert into a full node (allowing it to be overfull) and then split it on the way back up. We’ll explore the later approach, which results in a two-stage algorithm for inserting new keys. </p>
<p>To perform insertions, we first proceed down the tree, searching for the position to insert the new key. Second, we return back up the tree, splitting nodes that have become overfull. Each split increases the branching factor of a node, but not necessarily the height. In fact, the only time we increase the height of the tree is when we split the root node itself. Because we only increase the height by splitting the root node (adding a depth of 1 to every leaf simultaneously), we can guarantee that the tree always remains balanced. </p>
<h3 id="h2-502604c12-0001">The Addition Algorithm</h3>
<p class="BodyFirst">During the first stage of the algorithm, we recursively descend the tree, searching for the correct location to insert the new key. If we find a matching key along the way, we can update that key’s data. Otherwise, we proceed down to a leaf node, where we insert the key into our array. </p>
<p>We start off by defining a simple helper function <code>BTreeNodeAddKey</code> to insert a key into a non-full node. For convenience, we also take a pointer to a child node (representing the child <em>after</em> the new key) so that we can reuse this function when splitting nodes. If we are at a leaf node, which doesn’t store pointers to children, this <code>next_child</code> pointer is ignored.</p>
<pre><code>BTreeNodeAddKey(BTreeNode: node, Type: key, 
                BTreeNode: next_child):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> Integer: i = node.size - 1
    WHILE i &gt;= 0 AND key &lt; node.keys[i]:
        node.keys[i+1] = node.keys[i]
        IF NOT node.is_leaf:
            node.children[i+2] = node.children[i+1]
        i = i - 1

<span epub:type="pagebreak" id="Page_206" title="206"/>    # Insert both the key and the pointer to the child node.
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> node.keys[i+1] = key
    IF NOT node.is_leaf:
        node.children[i+2] = next_child
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> node.size = node.size + 1</code></pre>
<p>The code starts at the <em>end</em> of the <code>keys</code> array (index <code>node.size – 1</code>) and proceeds toward index 0 using a <code>WHILE</code> loop <span aria-label="annotation1" class="CodeAnnotation">❶</span>. At each step, it checks whether the new key should be inserted here and, if not, shifts the current element of both <code>keys</code> and <code>children</code> back one space. The loop terminates when it has gone one step past the correct location, which might be the start of the array. Once we have found the correct location for the new key, we have already moved that and the following elements out of the way. We can directly insert the new key and child <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The code finishes by adjusting the size of the node to account for the insertion <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p>Here we may gasp in dismay at the cost of linearly shifting down items in the array to make room for our new element, as shown in <a href="#figure12-5" id="figureanchor12-5">Figure 12-5</a>. This is everything we warned about in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. But remember, we are trading off these (bounded) linear costs to minimize node accesses. We are willing to put up with the hassle of moving down the cards within our binder to minimize future requisitions to other binders.</p>
<figure>
<img alt="An array for four spots. The key 26 is inserted into the second spot in the array, and the following two keys 31 and 45 are each shifted back one position." class="" height="104" src="image_fi/502604c12/f12005.png" width="85"/>
<figcaption><p><a id="figure12-5">Figure 12-5</a>: Shifting the elements over to insert 26 in <span class="LiteralInCaption"><code>BTreeNodeAddKey</code></span></p></figcaption>
</figure>
<p>We require a few more helper functions to handle the case where a node fills up. Remember that we are restricted to at most 2<em>k</em> elements per node—any more than that means we need to split the node. First, we start with a simple accessor function <code>BTreeNodeIsOverFull</code>, which returns a Boolean indicating whether the node contains more than 2<em>k</em> items:</p>
<pre><code>BTreeNodeIsOverFull(BTreeNode: node):
    return node.size == (2 * node.k + 1)</code></pre>
<p class="BodyContinued">This is equivalent to checking if we have used up all the pockets in our binder.</p>
<p>We also add a second helper <code>BTreeNodeSplit</code>, which takes a node and the index of a child and splits that child. Everything before that index is retained in the original child. Everything after that index is cleared from the child and added to a newly created sibling node. The key at the index itself is cleared from the child and added to the current (parent) node.</p>
<pre><code><span epub:type="pagebreak" id="Page_207" title="207"/>BTreeNodeSplit(BTreeNode: node, Integer: child_index): 
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> BTreeNode: old_child = node.children[child_index]
    BTreeNode: new_child = BTreeNode(node.k)
    new_child.is_leaf = old_child.is_leaf

    # Get the index and key used for the split.
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Integer: split_index = Floor(old_child.size / 2.0)
    Type: split_key = old_child.keys[split_index]    

    # Copy the larger half of the keys (and their children) to 
    # new_child and erase them from old_child.
    Integer: new_index = 0
    Integer: old_index = split_index + 1
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> WHILE old_index &lt; old_child.size:
        new_child.keys[new_index] = old_child.keys[old_index]
        old_child.keys[old_index] = null

        IF NOT old_child.is_leaf:
            new_child.children[new_index] = old_child.children[old_index]
            old_child.children[old_index] = null
        new_index = new_index + 1
        old_index = old_index + 1

    # Copy the remaining child (after the last key).
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> IF NOT old_child.is_leaf:
        new_child.children[new_index] = old_child.children[old_child.size]
        old_child.children[old_child.size] = null

    # Remove the key at index and add it to the current node.
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> old_child.keys[split_index] = null
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> BTreeNodeAddKey(node, split_key, new_child)

    # Update the sizes of the nodes.
  <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> new_child.size = old_child.size - split_index - 1
    old_child.size = split_index</code></pre>
<p>The code for <code>BTreeNodeSplit</code> starts by looking up the node to split (<code>old_child</code>) and creating a new (empty) sibling node (<code>new_child</code>) <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This node will be at the same level as the child to split, so we copy over the value of <code>is_leaf</code>. Next the code determines what index and key to use as a split point for <code>old_child</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The code then uses a <code>WHILE</code> loop to copy everything after <code>split_index</code> from both the <code>keys</code> and <code>children</code> in <code>old_child</code> to the corresponding arrays in <code>new_child</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The code uses a pair of indices to capture the index of the old location (<code>old_index</code>) and the corresponding new location (<code>new_index</code>). At the same time, the code removes the elements from <code>old_child</code>’s arrays by setting the entries to <code>null</code>. Because the <code>children</code> array is one element longer, we need to copy that last element separately <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Finally, we remove the key at <code>split_index</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span>, add both <code>split_key</code> and the new child pointer to the current node <span aria-label="annotation6" class="CodeAnnotation">❻</span>, and set both the children’s sizes <span aria-label="annotation7" class="CodeAnnotation">❼</span>.</p>
<p><span epub:type="pagebreak" id="Page_208" title="208"/>Let’s view this operation in the context of our collectibles storage index as shown in <a href="#figure12-6" id="figureanchor12-6">Figure 12-6</a>. When a binder reaches capacity, we repartition its contents into two binders. First, we buy a new empty binder. This sibling will store approximately half the contents of the overfull binder. Second, we carefully relocate the back half of the overfull binder’s contents into the new binder, preserving the sorted ordering. Third, we remove the single index card whose key lies between the keys in each binder and insert it in the parent binder in order to indicate the divide between the two child binders. The previously overfull child binder will contain cards whose keys come before this split, and the new binder will contain cards whose keys come after this split.  </p>
<figure>
<img alt="A row  with three entries: Caffeine Ten Coffee Mug, Jeremy’s Gourmet High‐Caffeine Experience Coffee Mug, and Morning Zap Brand Coffee Mug. An arrow indicates that the card on the left (and all preceding cards) stays in the binder. A second arrow indicates the middle card goes to the parent binder. A third arrow indicates that the card on the right and all following cards goes to the new binder." class="" height="304" src="image_fi/502604c12/f12006.png" width="439"/>
<figcaption><p><a id="figure12-6">Figure 12-6</a>: We repartition the binder by splitting it on the key of the middle card. </p></figcaption>
</figure>
<p>Given these helpers, we can now define an insertion function that performs the recursive search and the subsequent addition. We perform the addition at the leaf node. As the recursion returns up the tree, we check whether the recently accessed child node is full and thus needs to be split.</p>
<pre><code>BTreeNodeInsert(BTreeNode: node, Type: key):
    Integer: i = 0
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> WHILE i &lt; node.size AND key &gt;= node.keys[i]:
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> IF key == node.keys[i]:
            Update data.
            return
        i = i + 1

    IF node.is_leaf:
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> BTreeNodeAddKey(node, key, null)
    ELSE:
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> BTreeNodeInsert(node.children[i], key)
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> IF BTreeNodeIsOverFull(node.children[i]):
          <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> BTreeNodeSplit(node, i)</code></pre>
<p>The code starts by finding the correct location for <code>key</code> in the <code>keys</code> array <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <code>WHILE</code> loop iterates through the array until it hits the end of the key <span epub:type="pagebreak" id="Page_209" title="209"/>list (<code>i == node.size</code>) or hits a key that is larger than the target (<code>key &lt; node.keys[i]</code>). If the code finds an exact match, it updates any data for this key and returns <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Otherwise, it needs to insert new data.</p>
<p>If the key is being inserted into a leaf, the code uses the <code>BTreeNodeAddKey</code> function <span aria-label="annotation3" class="CodeAnnotation">❸</span>, which shifts the array elements over and adds the new key to the correct location. If the key is being inserted into an internal node, the index <code>i</code> provides the pointer of the correct child for insertion. The code recursively inserts into that child <span aria-label="annotation4" class="CodeAnnotation">❹</span>, then checks whether it broke the properties of a B-tree (specifically the size of nodes falling between <em>k</em> and 2<em>k</em>) with the insertion <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</p>
<p>The code breaks the B-tree property if it inserts too many elements into a node. We can use our helper function <code>BTreeNodeIsOverFull</code> to check if the recently modified node has too many elements. The code conducts this check from the parent node, so we can keep the logic of repairing the B-tree simple. It uses <code>BTreeNodeSplit</code> to split the overfull child into two nodes <span aria-label="annotation6" class="CodeAnnotation">❻</span>. In the process of this insertion, we might break the current node when inserting the new separating key, but that’s okay; we’ll take care of it when we return to this node’s parent.</p>
<p>We use a little extra storage in order to simplify the code. The code allows a node to temporarily overfill, storing 2<em>k</em> + 1 keys and 2<em>k</em> + 2 children while waiting for its parent node to call <code>BTreeNodeSplit</code>. We can create this buffer by simply allocating large enough arrays for the keys and children.</p>
<p>We can think of the first phase of the code as receiving a new coffee mug for our collection. We create an index card for the mug and insert it into our indexing binders. We start at the root binder and search for the location to put the card. During our search, we follow the appropriate pointers to child binders. Once we end up at a leaf binder, with no children indicated on the index cards, we add the new card there. We check whether the binder is now (over)full and, if it is, start repartitioning its contents. Afterward, we return the binders to storage in the reverse order that we requisitioned them. If we just split a binder and thus transferred a new card to its parent, we also check whether we need to split the parent binder. This process continues until we’ve returned to the root binder.</p>
<p>We need to define one additional special case for the root node. Remember that splitting the root node is the only way we are allowed to increase the height of the tree. We need to define a wrapper function to do exactly that. Luckily, we can reuse our previous helper functions:</p>
<pre><code>BTreeInsert(BTree: tree, Type: key): 
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> BTreeNodeInsert(tree.root, key)

  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> IF BTreeNodeIsOverFull(tree.root):
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> BTreeNode: new_root = BTreeNode(tree.k)
        new_root.is_leaf = False
        new_root.size = 0

      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> new_root.children[0] = tree.root
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> BTreeNodeSplit(new_root, 0)
      <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> tree.root = new_root</code></pre>
<p><span epub:type="pagebreak" id="Page_210" title="210"/>The code starts by inserting the <code>key</code> into the root node using <code>BTreeNodeInsert</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This function recursively descends the tree, finds the correct location to insert the new key, and returns through the levels fixing the broken B-tree property at all but the root node. Then the code checks if the root node has too many elements by using <code>BTreeNodeIsOverFull</code> on the root node <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If the root node has too many elements, the code adds a level to the tree by creating a new empty root node <span aria-label="annotation3" class="CodeAnnotation">❸</span>, assigning the old root to be the first child of the new root <span aria-label="annotation4" class="CodeAnnotation">❹</span>, splitting this (overfull) child <span aria-label="annotation5" class="CodeAnnotation">❺</span>, and updating the tree’s root <span aria-label="annotation6" class="CodeAnnotation">❻</span>. After a split, the new root node will contain exactly one key and two children.</p>
<p>In the process of inserting a key, we complete a single round trip from the root node to a leaf node and back. The number of nodes we need to access (and modify) is thus proportional to the depth of the tree. Since our B-tree always remains balanced, with all leaf nodes at the same depth, and the branching factor of all non-root, internal nodes is at least <em>k</em> + 1, the node retrievals scales logarithmically in <em>N</em>. The total work also includes linear operations within the node, such as copying or shifting keys, so the total work required scales proportional to <em>k</em> <span class="NSSymbol">×</span> log<sub><em>k</em></sub>(<em>N</em>).</p>
<h3 id="h2-502604c12-0002">Examples of Adding Keys</h3>
<p class="BodyFirst">Let’s consider a few examples to better understand the functions we just covered. First, take the simplest case, shown in <a href="#figure12-7" id="figureanchor12-7">Figure 12-7</a>, of adding a key to leaf node that will not be overfull. Suppose <em>k</em> = 2, where our non-root nodes can contain between 2 and 2<em>k</em> = 4 items. If we add the key 30 to the subtree in <a href="#figure12-7">Figure 12-7</a>(a), we simply proceed down to the leaf node and add the new key in the correct part of the array with the <code>BTreeNodeAddKey</code> helper function. Since the leaf has four elements, we do not need to split it. We get the subtree shown in <a href="#figure12-7">Figure 12-7</a>(b).</p>
<figure>
<img alt="Figure A shows a subtree with one internal node and four leaf nodes. The second leaf node has keys 13, 17, and 26. Figure B shows the same tree but with the key 30 added to the end of the second child node. That node now has keys 13, 17, 26, and 30." class="" height="335" src="image_fi/502604c12/f12007.png" width="303"/>
<figcaption><p><a id="figure12-7">Figure 12-7</a>: Inserting the key 30 into a non-full B-tree leaf (a) results in a leaf node with four elements (b).</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_211" title="211"/>The logic becomes more complex as we fill up nodes. Consider the example shown in <a href="#figure12-8" id="figureanchor12-8">Figure 12-8</a>(a) of adding the key 29 to the same tree. After inserting the new key in <a href="#figure12-8">Figure 12-8</a>(b), the leaf node is overfull. We handle this by identifying the split point of the overfull node (key = 26) and promoting that to the parent node. We then use the helper function <code>BTreeNodeSplit</code> to divide the leaf into two siblings as shown in <a href="#figure12-8">Figure 12-8</a>(c). If the promotion of the middle element fills up the internal node, we need to split that as well.</p>
<figure>
<img alt="Figure A shows a subtree with one internal node and four leaf nodes. The second leaf node has keys 13, 17, 26, and 30. In figure B, the key 29 has been added to the second child, and the node is overfull with keys 13, 17, 26, 29, and 30. In Figure C, the second child has been split into two nodes (13, 17) and (29, 30), and the key 26 has been promoted to its parent." class="" height="507" src="image_fi/502604c12/f12008.png" width="324"/>
<figcaption><p><a id="figure12-8">Figure 12-8</a>: Inserting the key 29 into an already-full leaf node (a) gives the leaf too many elements (b). We must split the overfull leaf to restore the B-tree conditions (c).</p></figcaption>
</figure>
<p>Finally, consider what happens if our splits propagate all the way back to the root node. Suppose that, after an insertion, the root node itself overfills as shown in <a href="#figure12-9" id="figureanchor12-9">Figure 12-9</a>(a). We solve this problem in <a href="#figure12-9">Figure 12-9</a>(b) by splitting the root node and creating a new level for the tree. The new root node contains exactly one element, the middle key of the previous root node. Note that, unlike all the other nodes, the root node is allowed to have less than <em>k</em> items. In fact, every time we split the root node, we create a new root with exactly one item.</p>
<p>As the examples in this section show, the modifications to the B-tree are limited to only those nodes explored during the initial search for the insertion location. Since we do not need to update or repair other branches, the total number of modified nodes is limited by the depth of the tree and thus scales proportional to log<sub><em>k</em></sub>(<em>N</em>). </p>
<span epub:type="pagebreak" id="Page_212" title="212"/><figure>
<img alt="Figure A shows a B‐tree with an overfull root node containing the keys 12, 31, 51, 61, and  86. The root node has five children, which are all leaves. Figure B shows the resulting tree after the split, with a new root node with key 51 and two children. The root's left child contains keys 12 and 31. The root’s right child contains keys 61 and 86. The tree has the same five leaves." class="" height="331" src="image_fi/502604c12/f12009.png" width="386"/>
<figcaption><p><a id="figure12-9">Figure 12-9</a>: When the root node of a B-tree becomes overfull (a), we split it into two siblings and promote the middle element to the new root node (b).</p></figcaption>
</figure>
<h2 id="h1-502604c12-0004">Removing Keys</h2>
<p class="BodyFirst">Removing keys follows a similar approach to adding keys. We again need to keep the structure balanced and limit the number of keys stored in each node (between <em>k</em> and 2<em>k</em>). This results in a multi-stage algorithm for deleting keys. First, we proceed down the tree as though we were searching for the key. Once we find it, we delete the key. Finally, we return back up the tree checking for and fixing nodes with too few keys. Since we never remove a node except an empty root node (decreasing the depth of all the leaves by one), we again guarantee that the tree always remains balanced. </p>
<h3 id="h2-502604c12-0003">Fixing Under-full Nodes</h3>
<p class="BodyFirst">When we remove keys from a B-tree, we run the risk of nodes dropping below the minimum of <em>k</em> keys. We can check this condition with a simple helper function:</p>
<pre><code>BTreeNodeIsUnderFull(BTreeNode: node):
    return node.size &lt; node.k</code></pre>
<p>Depending on the structure of the B-tree, there are two different approaches we may need to use to fix an under-full node, both of which I’ll discuss in this section. Each approach relies on augmenting the node’s keys with keys from an adjacent sibling. In the first case, we directly merge two small sibling nodes into a single node. In the second case, we transfer a key from a larger sibling to the under-full node. Which function we use depends on how many keys in total the two siblings have. Both of these helper functions are called from the parent node with the index for the key that separates the adjacent sibling nodes.</p>
<p><span epub:type="pagebreak" id="Page_213" title="213"/>The merge operation takes two adjacent sibling nodes, along with the key separating them, and concatenates them into a single large child node. As such, it requires that the combined number of keys in the two siblings be <em>less</em> than 2<em>k</em> so that the new child is guaranteed to be valid. <a href="#figure12-10" id="figureanchor12-10">Figure 12-10</a> shows this procedure, with  <a href="#figure12-10">Figure 12-10</a>(a) depicting a subtree before the merge operation, where the middle child has a single key. <a href="#figure12-10">Figure 12-10</a>(b) shows the same subtree after the merge.</p>
<figure>
<img alt="Figure A shows a node with three leaves and a single internal node. The internal node has keys 26 and 31. The middle leaf has only a single key 29, and the right‐most leaf has two keys 32 and 42. Figure B shows a node with two leaves. The internal node now has a single key, 26. The right‐most node now has keys 29, 31, 32, and 42." class="" height="135" src="image_fi/502604c12/f12010.png" width="306"/>
<figcaption><p><a id="figure12-10">Figure 12-10</a>: The merge operation on B-tree nodes</p></figcaption>
</figure>
<p><a href="#listing12-1" id="listinganchor12-1">Listing 12-1</a> shows the code for merging two adjacent siblings.</p>
<pre><code>BTreeNodeMerge(BTreeNode: node, Integer: index):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> BTreeNode: childL = node.children[index]
    BTreeNode: childR = node.children[index + 1]

    # Copy over the parent's key and the right child's first child pointer.
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Integer: loc = childL.size
    childL.keys[loc] = node.keys[index]
    IF NOT childL.is_leaf:
        childL.children[loc + 1] = childR.children[0]
    loc = loc + 1

  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> # Copy over the right child's keys and children.
    Integer: i = 0
    WHILE i &lt; childR.size:
        childL.keys[loc + i] = childR.keys[i]
        IF NOT childL.is_leaf:
            childL.children[loc + i + 1] = childR.children[i + 1]
        i = i + 1
    childL.size = childL.size + childR.size + 1

    # Remove the key from the current node.
    i = index
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> WHILE i &lt; node.size - 1:
        node.keys[i] = node.keys[i + 1]
        node.children[i + 1] = node.children[i + 2]
        i = i + 1
    node.keys[i] = null
    node.children[i + 1] = null
    node.size = node.size – 1</code></pre>
<p class="CodeListingCaption"><a id="listing12-1">Listing 12-1</a>: Code for merging two child nodes</p>
<p>The code appends the keys from the right child and the separating key from the parent onto the left child. It starts by retrieving both child nodes, which we call <code>childL</code> and <code>childR</code> for left and right respectively <span aria-label="annotation1" class="CodeAnnotation">❶</span>. By <span epub:type="pagebreak" id="Page_214" title="214"/>definition, any key in <code>childL</code> is less than the separating key, and any key in <code>childR</code> is greater than the separating key. The code then appends the separating key from the parent and the first child pointer from the right child to the end of the left child <span aria-label="annotation2" class="CodeAnnotation">❷</span>. It uses a <code>WHILE</code> loop to copy the remaining keys and pointers from the right child <span aria-label="annotation3" class="CodeAnnotation">❸</span>. It also updates the left child’s size. At this point, it has successfully created the merged node out of the two children. The merged child’s pointer is stored in <code>node.children[index]</code>.</p>
<p>The code finishes by cleaning up the parent node <span aria-label="annotation4" class="CodeAnnotation">❹</span>. It removes the previous separating key and the pointer to the right child by shifting the subsequent keys and pointers over, setting the final bins to <code>null</code>, and updating the current node’s size. </p>
<p>In the process of merging two nodes, we are taking a key from their parent. This could leave the parent node with less than <em>k</em> keys, and our repairs would need to continue at the next higher level of the tree.</p>
<p>This process is directly analogous to merging binders in our storage indexing example. If an index binder contains too few keys, it is a waste of space and requisition time. We wouldn’t want to requisition a binder with a single index card. Merging binders consists of taking the cards from one child binder, along with the separating card from the parent binder, and putting them in the other child binder in the correct order. Since we have already requisitioned the parent and one child (and thus have them in local memory), we can do this merge quickly with only a single additional requisition for the other child. </p>
<p>The second approach to fixing an under-full node is to shift one of the keys (and potentially children) from its adjacent sibling. This works only when the sibling can afford to lose a key and thus applies to cases where the combined number of keys of the siblings must be at least 2<em>k</em>. While we could merge and optimally resplit the adjacent siblings, for illustrative purposes we use a simpler approach of transferring only one key. Since we only ever remove a single key from a node during deletion or the merge operation, transferring a single key is sufficient to fix our under-full node. </p>
<p>However, as shown in <a href="#figure12-11" id="figureanchor12-11">Figure 12-11</a>, we can’t just take a key from one child and give it to the other. The separating key in the parent node enforces the bounds of the split. Instead, we do a two-stage transfer. First, we transfer the current separating key from the parent to the under-full node. Second, we replace the separating key in the parent node with a key from the other sibling.</p>
<figure>
<img alt="Figure A shows a node with three leaves and one internal node. The internal node has keys 26 and 31. The middle leaf has only a single key 29, and the right‐most leaf has three keys 32, 42, and 45. Figure B shows the same subtree. The internal node now has keys 26 and 32. The middle leaf now has two keys 29 and 31, and the right‐most node has two keys 42 and 45." class="" height="135" src="image_fi/502604c12/f12011.png" width="317"/>
<figcaption><p><a id="figure12-11">Figure 12-11</a>: The transfer left operation on B-tree nodes</p></figcaption>
</figure>
<p>As shown in <a href="#listing12-2" id="listinganchor12-2">Listing 12-2</a>, we break the code into two helper functions, one to transfer a key from the right child to the left child and one to transfer <span epub:type="pagebreak" id="Page_215" title="215"/>the other way. The code to transfer a key from the right child to the left child transfers two keys: one from the right child to the parent and one from the parent to the left child.</p>
<pre><code>BTreeNodeTransferLeft(BTreeNode: node, Integer: index):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> BTreeNode: childL = node.children[index]
    BTreeNode: childR = node.children[index + 1]
    Type: middle_key = node.keys[index]

  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> node.keys[index] = childR.keys[0]
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> childL.keys[childL.size] = middle_key
    IF NOT childR.is_leaf:
        childL.children[childL.size + 1] = childR.children[0]
    childL.size = childL.size + 1

  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> Integer: i = 0
    WHILE i &lt; childR.size - 1:
        childR.keys[i] = childR.keys[i + 1]
        IF NOT childR.is_leaf:
            childR.children[i] = childR.children[i + 1]
        i = i + 1
  
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> childR.keys[i] = null
    IF NOT childR.is_leaf:
        childR.children[i] = childR.children[i + 1]
        childR.children[i + 1] = null
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> childR.size = childR.size – 1</code></pre>
<p class="CodeListingCaption"><a id="listing12-2">Listing 12-2</a>: Code for transferring a key and child pointer to an under-full node from its right-hand sibling</p>
<p>The code starts by retrieving the two adjacent siblings and the separating key <span aria-label="annotation1" class="CodeAnnotation">❶</span>. It moves the first key from the right-hand child to replace the previous separating key <span aria-label="annotation2" class="CodeAnnotation">❷</span>. It adds the previous separating key from the parent (<code>middle_key</code>) and the first child pointer from the right-hand child to the end of the arrays in the left-hand child <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Both the left-hand child and parent are now updated. The code then cleans up the right-hand child. It uses a <code>WHILE</code> loop to shift over the remaining elements <span aria-label="annotation4" class="CodeAnnotation">❹</span>, marks the now empty spots as <code>null</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span>, and adjusts the size <span aria-label="annotation6" class="CodeAnnotation">❻</span>.</p>
<p>The code for transferring a key from the left child to the right child is similar to that shown in <a href="#listing12-3" id="listinganchor12-3">Listing 12-3</a>. The two-key transfer works in the opposite direction: one from the left child to the parent and one from the parent to the right child.</p>
<pre><code>BTreeNodeTransferRight(BTreeNode: node, Integer: index):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> BTreeNode: childL = node.children[index]
    BTreeNode: childR = node.children[index + 1]
    Type: middle_key = node.keys[index]

    # Make space in childR for the new key and pointer.
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Integer: i = childR.size - 1
    WHILE i &gt;= 0:
        childR.keys[i+1] = childR.keys[i]
<span epub:type="pagebreak" id="Page_216" title="216"/>        IF NOT childR.is_leaf:
            childR.children[i+2] = childR.children[i+1]
        i = i – 1
    IF NOT childR.is_leaf:
        childR.children[1] = childR.children[0]

  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> childR.keys[0] = middle_key
    IF NOT childR.is_leaf:
        childR.children[0] = childL.children[childL.size]
    childR.size = childR.size + 1

  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> node.keys[index] = childL.keys[childL.size – 1]

  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> childL.keys[childL.size - 1] = null
    IF NOT childL.is_leaf:
        childL.children[childL.size] = null
    childL.size = childL.size – 1</code></pre>
<p class="CodeListingCaption"><a id="listing12-3">Listing 12-3</a>: Code for transferring a key and child pointer to an under-full node from its left-hand sibling</p>
<p>The code again starts by retrieving the two adjacent siblings and the separating key <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The code then shifts over the keys and children in the right-hand node to make room for the new addition <span aria-label="annotation2" class="CodeAnnotation">❷</span>. It appends the previous separating key from the parent (<code>middle_key</code>) and the last child pointer from the left child to the <em>beginning</em> of the right-hand node <span aria-label="annotation3" class="CodeAnnotation">❸</span>, increasing its size by 1. The code then moves the last key in the left-hand child to replace the separating key in the parent <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The code completes by cleaning up the left-hand child by marking the now empty entries <code>null</code> and updating the size <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</p>
<p>Unlike the merge operation, neither transfer operation reduces the number of keys in the parent. Thus, we do not need to perform repairs at higher levels of the tree. The physical corollary of these transfer operations is requesting a sibling storage binder and shifting two index cards between the two children and the parent. We take the intermediate card (that falls between the range of the two binders) from the parent and add it to the less full child binder. We replace this card in the parent with the appropriate one from the child that has more cards. </p>
<p>We can encapsulate all three of these repair functions as well as the logic to choose them into a helper function that takes in the current node and the index of the under-full child:</p>
<pre><code>BTreeNodeRepairUnderFull(BTreeNode: node, Integer: child):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> IF child == node.size:
        child = child - 1
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Integer: total = (node.children[child].size + 
                      node.children[child + 1].size)
 
    IF total &lt; 2 * node.k:
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> BTreeNodeMerge(node, child)
        return

<span epub:type="pagebreak" id="Page_217" title="217"/>  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> IF node.children[child].size &lt; node.children[child + 1].size:
        BTreeNodeTransferLeft(node, child)
    ELSE:
        BTreeNodeTransferRight(node, child)</code></pre>
<p>To know which repair strategy to employ, the code needs to find an adjacent sibling and check the two children’s total number of keys. Here, for illustrative purposes, we use a simplistic strategy of always using the next child (<code>child + 1</code>) as the sibling unless we are repairing the last child in the array <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If we are repairing the last child in the array, we use the previous child for its sibling. The code checks the total count of keys in these two child nodes <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If the number of keys is small enough (under 2<em>k</em>), it merges those nodes with the <code>BTreeNodeMerge</code> function <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Otherwise, if the nodes have 2<em>k</em> or more keys, the code uses either <code>BTreeNodeTransferLeft</code> or <code>BTreeNodeTransferRight</code> to move a single key to the smaller node <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>
<h3 id="h2-502604c12-0004">Finding the Minimum Value Key</h3>
<p class="BodyFirst">We use one more helper function as part of the deletion operation—code to find and return the minimum key at or below a given node. This code, in <a href="#listing12-4" id="listinganchor12-4">Listing 12-4</a>, can also be useful in its own right, such as for computing the bounds of the keys in the B-tree.</p>
<pre><code>BTreeNodeFindMin(BTreeNode: node):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> IF node.size == 0:
        return null
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> IF node.is_leaf:
        return node.keys[0]
    ELSE:
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> return BTreeNodeFindMin(node.children[0])</code></pre>
<p class="CodeListingCaption"><a id="listing12-4">Listing 12-4</a>: Code to find the minimum key at or below a given node</p>
<p>The code consists of three possible conditions. If the node is empty, the code returns <code>null</code> to indicate that there is no minimum key there <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This should occur only in an empty root node, as all other nodes will have at least <em>k</em> keys. If the node is a non-empty leaf, the code returns the first (and thus minimum) key in the node’s array <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Finally, if the node is internal, the code recursively checks the first child <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<h3 id="h2-502604c12-0005">The Removal Algorithm</h3>
<p class="BodyFirst">We start the description of the deletion algorithm with the top-level wrapper function. This function is relatively simple. It calls the recursive deletion function using the tree’s root node.</p>
<pre><code>BTreeDelete(BTree: tree, Type: key):
    BTreeNodeDelete(tree.root, key)

    IF tree.root.size == 0 AND NOT tree.root.is_leaf:
        tree.root = tree.root.children[0]</code></pre>
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_218" title="218"/>Just as we added a level only when we split the node, we remove a level from the tree only when the root node becomes empty. If the B-tree is not completely empty, the empty root node will still have a single valid child in array position 0. We use this child to replace the former root node.</p>
<p>The core deletion algorithm recursively descends the tree, searching for the key to delete. Since we might reduce the number of keys below the required <em>k</em>, we need to know check whether the modified child is now under-full and, if so, repair it.</p>
<pre><code>BTreeNodeDelete(BTreeNode: node, Type: key):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> Integer: i = 0
    WHILE i &lt; node.size AND key &gt; node.keys[i]:
        i = i + 1

    # Deletion from a leaf node.
    IF node.is_leaf:
        IF i &lt; node.size AND key == node.keys[i]:
          <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> WHILE i &lt; node.size - 1:
                node.keys[i] = node.keys[i + 1]
                i = i + 1
            node.keys[i] = null
            node.size = node.size - 1
        return

    # Deletion at an internal node.
    IF i &lt; node.size AND key == node.keys[i]:
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> Type: min_key = BTreeNodeFindMin(node.children[i+1])
        node.keys[i] = min_key

      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> BTreeNodeDelete(node.children[i+1], min_key)
        IF BTreeNodeIsUnderFull(node.children[i+1]):
            BTreeNodeRepairUnderFull(node, i+1)
    ELSE:
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> BTreeNodeDelete(node.children[i], key)
        IF BTreeNodeIsUnderFull(node.children[i]):
            BTreeNodeRepairUnderFull(node, i)</code></pre>
<p>The code starts by searching for the key to delete in the current node by scanning across the array of keys <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If there is a matching key in this node, the <code>WHILE</code> loop terminates such that <code>i</code> is the index matching the key.</p>
<p>The code then considers the leaf case. If the node is a leaf and the key is found, the code deletes it by shifting over the keys <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The code also sets the last element to <code>null</code> and updates the size. The code doesn’t need to change the child pointers because they are not set for leaf nodes. If the node is a leaf and the key is not found, then the code simply returns.</p>
<p>The code next handles the case of internal nodes. There are two cases to consider: the key is in the node, or it is not. If the code finds the key in the internal node, it replaces the key with the key that immediately <em>follows</em> the target key in sorted order <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The code finds this subsequent key <span epub:type="pagebreak" id="Page_219" title="219"/>using <code>BTreeNodeFindMin</code> from <a href="#listing12-4">Listing 12-4</a>, called on the child node immediately after the target key. The code deletes this following key from the child’s subtree by calling <code>BTreeNodeDelete</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The code then checks whether the child node is under-full and, if so, fixes it.</p>
<p>If the target key is not in an internal node, then the code recursively calls <code>BTreeNodeDelete</code> on the appropriate child <span aria-label="annotation5" class="CodeAnnotation">❺</span>. Again, it needs to check whether that child node is now under-full and, if so, fix it.</p>
<p>As with insertion, our goal is to limit the number of nodes retrieved during this operation. Deletion will make at most a single pass from the root node to a leaf. Even if we delete from an internal node, the subsequent replacement and deletion operations still only continue the trek to a single leaf. We pay one additional requisition whenever we repair a node to retrieve the under-full node’s sibling.</p>
<h3 id="h2-502604c12-0006">Examples of Removing Keys</h3>
<p class="BodyFirst">Let’s look at a few examples of the removals that we just covered. First, take the simplest case, shown in <a href="#figure12-12" id="figureanchor12-12">Figure 12-12</a>, of removing a key from a leaf node with more than <em>k </em>+ 1 keys. Suppose <em>k</em> = 2, where our non-root nodes can contain between 2 and 2<em>k</em> = 4 items. If we remove key 5 from the subtree in <a href="#figure12-12">Figure 12-12</a>(a), we simply proceed down to the leaf node and remove the key in the array. Since the resulting leaf has three elements, we do not need to repair it. We get the subtree shown in <a href="#figure12-12">Figure 12-12</a>(b).</p>
<figure>
<img alt="Figure A shows a subtree with one internal node and five leaf nodes. The first leaf has keys 1, 3, 5, and 6. Figure B shows the same tree as Figure A with the key 5 deleted from the middle of the first leaf node. The node now contains keys 1, 3, and 6." class="" height="307" src="image_fi/502604c12/f12012.png" width="334"/>
<figcaption><p><a id="figure12-12">Figure 12-12</a>: Deleting the key 5 from a B-tree leaf (a) results in a leaf node with three elements (b).</p></figcaption>
</figure>
<p>Next, we consider the case of removing a key from an internal node without needing repairs as shown in <a href="#figure12-13" id="figureanchor12-13">Figure 12-13</a>. If we remove key 45 from the subtree in <a href="#figure12-13">Figure 12-13</a>(a), we find that key in an internal node. To remove it, we replace it with the next key in order, which is 47. Since the resulting nodes all have at least two elements, we do not need to perform any repairs. We get the subtree shown in <a href="#figure12-13">Figure 12-13</a>(b).</p>
<span epub:type="pagebreak" id="Page_220" title="220"/><figure>
<img alt="Figure A shows a subtree with one internal node and five leaf nodes. The internal node contains keys 12, 26, 31, and 45. The fifth (right‐most) leaf contains keys 47, 48, and 49. Figure B shows the same tree as Figure A with the key 45 deleted from the internal node. The key 47, which previously resided in the right‐most node in Figure A, replaces the key 45. The fifth leaf node has keys 48 and 49." class="" height="307" src="image_fi/502604c12/f12013.png" width="334"/>
<figcaption><p><a id="figure12-13">Figure 12-13</a>: Deleting the key 45 from an internal B-tree node (a) results in taking a key from one of the children (b).</p></figcaption>
</figure>
<p>Finally, we consider the different cases where removing a key requires us to repair an under-full node. <a href="#figure12-14" id="figureanchor12-14">Figure 12-14</a> shows a case where we can merge two nodes.  We start by deleting the key 32 in <a href="#figure12-14">Figure 12-14</a>(a). <a href="#figure12-14">Figure 12-14</a>(b) shows the keys that we use for the merge operation: the keys in the under-full node, the keys in its right-hand adjacent sibling, and the key in the parent separating the two. <a href="#figure12-14">Figure 12-14</a>(c) shows the repaired tree. The new child node has four keys, and the previous parent has three.</p>
<figure>
<img alt="Figure A shows a subtree with one internal node and five leaf nodes. The internal node contains keys 12, 26, 31, and 45. The fourth leaf contains keys 32 and 42. The fifth leaf contains keys 47 and 48. In Figure A, the key 32 is removed from a leaf node, leaving a single key 42. Figure B shows a dashed line around the right‐most two children and the separating key 45. Figure C shows the final tree with the merged child. The internal node now has four children and contains the keys 12, 26, and 31. The right‐most leaf node has keys 42, 45, 47, and 48." class="" height="480" src="image_fi/502604c12/f12014.png" width="326"/>
<figcaption><p><a id="figure12-14">Figure 12-14</a>: Deleting the key 32 from an almost empty node (a) gives the leaf too few elements (b). We must merge with an adjacent sibling to restore the B-tree conditions (c). </p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_221" title="221"/><a href="#figure12-15" id="figureanchor12-15">Figure 12-15</a> shows a case where we can transfer a key from a larger sibling node.  We start by deleting the key 32 in <a href="#figure12-15">Figure 12-15</a>(a). <a href="#figure12-15">Figure 12-15</a>(b) shows the keys that we use to restore balance: the keys in the under-full node, the keys in its right-hand adjacent sibling, and the key in the parent separating the two. <a href="#figure12-15">Figure 12-15</a>(c) shows which keys will move and where. The repaired tree is shown in <a href="#figure12-15">Figure 12-15</a>(d).</p>
<figure>
<img alt="Figure A shows a subtree with one internal node and five leaf nodes. The internal node contains keys 12, 26, 31, and 45. The fourth leaf contains keys 32 and 42. The fifth leaf contains keys 47, 48, and 49. In Figure A, the key 32 is removed from a leaf node, leaving a single key 42. Figure B shows a dashed line around the right‐most two children and the separating key 45. Figure C includes arrows showing the key 47 from the right‐most child will move into the parent and key 45 from the parent will move to the under‐full child. The final tree is shown in Figure D. The internal node has four children and contains the keys 12, 26, 31, and 47. The fourth leaf node contains keys 42 and 45. The fifth leaf node contains keys 48 and 49." class="" height="652" src="image_fi/502604c12/f12015.png" width="345"/>
<figcaption><p><a id="figure12-15">Figure 12-15</a>: Deleting the key 32 from an almost empty node (a) gives the leaf too few elements (b). We can repair this by taking a key from an adjacent sibling (c) to restore the B-tree conditions (d).</p></figcaption>
</figure>
<p>Finally, <a href="#figure12-16" id="figureanchor12-16">Figure 12-16</a> shows a case where we remove a level from the tree by merging the only two children below the root. <a href="#figure12-16">Figure 12-16</a>(b) shows that after the merge, we are left with an empty root node. Its one key has been moved to the merged node. We repair this in <a href="#figure12-16">Figure 12-16</a>(c) by removing the old root node and promoting that node’s single child to be the new root node.</p>
<p>Unlike addition, where the modifications to the B-tree are limited to only those nodes explored during the initial search for the insertion location, deletion can modify nodes in other branches. Both merging nodes and transferring keys use a sibling node at the same level. However, the <span epub:type="pagebreak" id="Page_222" title="222"/>total number of nodes modified is still limited by the depth of the tree. At most, we access one sibling node per level, and the number of nodes accessed scales logarithmically with <em>N</em>. </p>
<figure>
<img alt="In Figure A, the root node has the key 51 and has two children with keys 12 and 31 in the left node and key 61 in the right node. Figure B shows the result of the merge operation. The root is empty and has a single child with keys 12, 31, 51, and 61. Figure C shows the final tree where the old root node has been removed. The new root is the node with keys 12, 31, 51, and 61." class="" height="533" src="image_fi/502604c12/f12016.png" width="314"/>
<figcaption><p><a id="figure12-16">Figure 12-16</a>: Merging the only two children under the root node (a) results in an empty root (b). We repair this by promoting the root node’s only child to be the new root (c).</p></figcaption>
</figure>
<h2 id="h1-502604c12-0005">Why This Matters</h2>
<p class="BodyFirst">B-trees illustrate a few important concepts. First, they show how we can adapt the behavior of previous data structures to handle cases where memory accesses between nodes are more expensive than accesses within a node. B-trees combine indexing and storage in such a way as minimize the number of accesses we need. This is critical for large data sets that might keep information on a disk or an external server. By enforcing a minimum of <em>k</em> keys for each non-root node, we ensure a branching factor of at least <em>k</em> + 1 at each node and thus flatten out the overall data structure. This helps limit the overall depth of the tree and thus the number of retrievals needed for search, insertion, or deletion. We also guarantee that each non-root node always remains at least half-full, meaning that we do not waste time retrieving nodes with only a few elements (except possibly the root).</p>
<p>It is useful to contrast the B-tree’s approach with a more specialized indexing scheme for our collectibles. We could develop a data structure that initially splits on category. The top-level index maps the collectible’s category, such as coffee-related collectibles, to a binder for that specific <span epub:type="pagebreak" id="Page_223" title="223"/>category. Each category’s binder then maps to all the subcategories, such as coffee mugs or coffee posters. And so forth. This is also a valid approach that builds off the branching structures we have seen throughout this book. The tradeoff becomes one of generalizability versus efficiency. In many cases, we can further optimize a data structure to a particular task at hand but lose the ability to apply it to other problems. In some cases, this tradeoff might be worth it. In others, it might not. Compared to a categorical focused indexing scheme, B-trees provide a more general approach that can work for any sortable set of keys.</p>
<p>The second concept B-trees illustrate is a second level of dynamism within the data structure itself. The B-tree constantly rearranges its structure to adapt to the distribution of data it stores and thus remain balanced. As we saw in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, we lose the advantages of the tree-based structure if our tree becomes highly unbalanced. B-trees programmatically prevent this through a combination of bounds on the number of keys in each node (<em>k</em> to 2<em>k</em>) and a guarantee that all leaf nodes have exactly the same depth. They adapt to “bad” distributions of input data by rebalancing—fixing nodes with too many or too few items. While there are a wide range of other balancing strategies for trees, B-trees provide a simple and clear example of how we can use additional structure (in this case, multiple keys per node) to avoid worst-case scenarios. </p>
</section>
</div></body></html>