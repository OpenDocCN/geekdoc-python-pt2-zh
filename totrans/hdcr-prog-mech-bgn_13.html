<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_265"/><span class="big">10</span><br/>GRAPHICAL USER INTERFACES AND THE CANVAS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Before we dive into simulations, we need to understand the basics of graphical user interfaces (GUIs). This is a massive topic, and we’ll barely scratch the surface, but we’ll see enough for us to present our simulations to the user.</p>&#13;
<p class="indent">GUIs typically consist of a parent window (or windows) containing <em>widgets</em> the user can interact with, such as buttons or text fields. For our goal of drawing simulations, the widget we’re most interested in is the <em>canvas</em>. In a canvas we can draw geometric primitives, and we can redraw them many times per second, something that we’ll use to create the perception of motion.</p>&#13;
<p class="indent">In this chapter, we’ll cover how to lay out a GUI using Tkinter, a package shipped with Python’s Standard Library. Once we’ve got that down, we’ll implement a class that will make drawing our geometric primitives to the canvas convenient. This class will also include an affine transformation as part of its state. We’ll use this to affect how all primitives are drawn to the canvas, which will allow us to do things such as flip the drawing vertically so that the y-axis points up.</p>&#13;
<h3 class="h3" id="ch00lev1sec62"><span epub:type="pagebreak" id="page_266"/><strong>Tkinter</strong></h3>&#13;
<p class="noindent">Tkinter is a package that ships with Python’s Standard Library. It’s used for building graphical user interfaces. It provides the visual components, in other words, the widgets, such as buttons, text fields, and windows. It also provides the canvas, which we’ll use to draw the frames of our simulations.</p>&#13;
<p class="indent">Tkinter is a feature-rich library; there are entire books written on it (see, for example, [7]). We’ll only cover what we need for our purposes, but if you enjoy creating GUIs, I recommend you spend some time looking through Tkinter’s documentation online; there’s a lot you can learn that will help you build fancy GUIs for your programs.</p>&#13;
<h4 class="h4" id="ch00lev2sec119"><strong><em>Our First GUI Program</em></strong></h4>&#13;
<p class="noindent">Let’s create a new package in the <em>graphic</em> folder where we’ll place our simulation code. Right-click <em>graphic</em>, choose <strong>New</strong> ▸ <strong>Python Package</strong>, name it <em>simulation</em>, and click <strong>OK</strong>. The folder structure in your project should look like this:</p>&#13;
<p class="pre2">        Mechanics<br/>          |- apps<br/>          |    |- circle_from_points<br/>          |- geom2d<br/>          |    |- tests<br/>          |- graphic<br/>          |    |- simulation<br/>          |    |- svg<br/>          |- utils</p>&#13;
<p class="indent">Let’s now create our first GUI program to get acquainted with Tkinter. In the newly created <em>simulation</em> folder, add a new Python file named <em>hello_tkinter.py</em>. Enter the code in <a href="ch10.xhtml#ch10lis1">Listing 10-1</a>.</p>&#13;
<pre>from tkinter import Tk&#13;
&#13;
tk = Tk()&#13;
tk.title("Hello Tkinter")&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch10lis1"/><em>Listing 10-1: Hello Tkinter</em></p>&#13;
<p class="indent">To execute the code in the file, right-click it in the Project tree panel and choose <strong>Run ‘hello_tkinter’</strong> from the menu that appears. When you execute the code, an empty window with the title “Hello Tkinter” opens, as shown in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_267"/><img src="../images/10fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig1"><em>Figure 10-1: The empty Tkinter window</em></p>&#13;
<p class="indent">Let’s review the code we’ve just written. We start by importing the <span class="literal">Tk</span> class from <span class="literal">tkinter</span>. The <span class="literal">tk</span> variable holds an instance of <span class="literal">Tk</span>, which represents the main window in a Tkinter program. This window is also referred to as <em>root</em> in the documentation and examples online.</p>&#13;
<p class="indent">We then set the title of the window to <span class="literal">Hello Tkinter</span> and run the <em>main loop</em>. Notice that the main window won’t appear on the screen until the main loop starts. In a GUI program, the main loop is an infinite loop: it runs the entire time the program is being executed; as it runs, it collects user events in its windows and reacts to them.</p>&#13;
<p class="indent">Graphical user interfaces are different than the other programs we’ve been writing so far in that they’re <em>event driven</em>. This means that graphic components can be configured to run some code whenever they receive an event of the desired type. For example, we can tell a button to write a message when it receives a click event, that is, when it gets clicked. The code that reacts to an event is commonly known as an <em>event handler</em>.</p>&#13;
<p class="indent">Let’s add a text field where the user can write their name, and let’s add a button to greet them by name. Modify your <em>hello_tkinter.py</em> file to include the code in <a href="ch10.xhtml#ch10lis2">Listing 10-2</a>. Pay attention to the new imports on top of the file.</p>&#13;
<pre>  from tkinter import Tk, <span class="codestrong1">Label, Entry, Button, StringVar</span>&#13;
&#13;
  tk = Tk()&#13;
  tk.title("Hello Tkinter")&#13;
&#13;
<span class="ent">➊</span> Label(tk, text='Enter your name:').grid(row=0, column=0)&#13;
<span class="ent">➋</span> name = StringVar()&#13;
<span class="ent">➌</span> Entry(tk, width=20, textvariable=name).grid(row=1, column=0)&#13;
<span class="ent">➍</span> Button(tk, text='Greet me').grid(row=1, column=1)&#13;
&#13;
  tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch10lis2"/><em>Listing 10-2: Hello Tkinter widgets</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>To add the label “Enter your name:” we’ve instantiated the <span class="literal">Label</span> class from <span class="literal">tkinter</span> <span class="ent">➊</span>. We pass the constructor the reference to the program’s main window (<span class="literal">tk</span>) and a named argument with the text to display: <span class="literal">text=</span>’<span class="literal">Enter your name:</span>’. Before the label can appear in the window, we need to tell it where to place itself in the window.</p>&#13;
<p class="indent">On the created instance of <span class="literal">Label</span>, we call <span class="literal">grid</span> with the named arguments <span class="literal">row</span> and <span class="literal">column</span>. This method places the widget in an invisible grid in the window, in the given row and column indices. Cells in the grid adapt their size to fit their contents. As you can see in the code, we call this method on every widget to assign them a position in the window. <a href="ch10.xhtml#ch10fig2">Figure 10-2</a> shows our UI’s grid. There are other ways of placing components in windows, but we’ll use this one for now because it’s flexible enough for us to easily arrange components.</p>&#13;
<div class="image"><img src="../images/10fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig2"><em>Figure 10-2: Tkinter grid</em></p>&#13;
<p class="indent">The input field in Tkinter is known as <span class="literal">Entry</span> <span class="ent">➌</span>. To have access to the contents of the field (the text written to it), we must first create a <span class="literal">StringVar</span>, which we’ll call <span class="literal">name</span> <span class="ent">➋</span>. This variable is passed to the <span class="literal">Entry</span> component using the <span class="literal">textvariable</span> argument. We can get the string written in the field by invoking <span class="literal">get</span> on the instance, as we’ll do shortly. Lastly, we create a button with the text “Greet me” <span class="ent">➍</span>; this button does nothing if clicked (we’ll add that functionality shortly).</p>&#13;
<p class="indent">Run the file. You should now see a label, a text field, and a button, as in <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>.</p>&#13;
<div class="image"><img src="../images/10fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig3"><em>Figure 10-3: Some Tkinter widgets</em></p>&#13;
<p class="indent">Let’s finish our program by adding an event handler to the button’s click, which opens a new dialog with a greeting message. Modify your code so that it looks like <a href="ch10.xhtml#ch10lis3">Listing 10-3</a>.</p>&#13;
<pre>  from tkinter import Tk, Label, Entry, Button, StringVar, <span class="codestrong1">messagebox</span>&#13;
&#13;
  tk = Tk()&#13;
  tk.title("Hello Tkinter")&#13;
&#13;
<span epub:type="pagebreak" id="page_269"/><span class="ent">➊</span> <span class="codestrong1">def greet_user():</span>&#13;
      <span class="codestrong1">messagebox.showinfo(</span>&#13;
         <span class="codestrong1">'Greetings',</span>&#13;
         <span class="codestrong1">f'Hello, {name.get()}'</span>&#13;
      <span class="codestrong1">)</span>&#13;
&#13;
&#13;
  Label(tk, text='Enter your name:').grid(row=0, column=0)&#13;
  name = StringVar()&#13;
  Entry(tk, width=20, textvariable=name).grid(row=1, column=0)&#13;
  Button(&#13;
     tk,&#13;
     text='Greet me',&#13;
   <span class="ent">➋</span> <span class="codestrong1">command=greet_user</span>&#13;
  ).grid(row=1, column=1)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch10lis3"/><em>Listing 10-3: Hello Tkinter that greets users</em></p>&#13;
<p class="indent">We’ve added a function named <span class="literal">greet_user</span> <span class="ent">➊</span>. This function opens an information dialog with the title “Greetings” and a message saying hello to the name the user entered in the text field. Note that we import <span class="literal">messagebox</span> from <span class="literal">tkinter</span> to call the <span class="literal">showinfo</span> function. This function does the actual work of opening the dialog. To connect the button click event to our <span class="literal">greet_user</span> function, we need to pass it to <span class="literal">Button</span>’s constructor in a parameter named <span class="literal">command</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Run the file now. Don’t forget to close our application’s window and rerun the program every time you want your new code to be executed. Enter your name in the text field and click the button. The program should open a new dialog with a personalized greeting, something similar to <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>.</p>&#13;
<div class="image"><img src="../images/10fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig4"><em>Figure 10-4: Our Tkinter greeter program</em></p>&#13;
<p class="indent">There’s much more Tkinter can do, but we won’t need that much for this book. We’re mostly interested in using its canvas component, which we’ll explore in the next section. If you want to learn more about Tkinter, you have lots of great resources online. You can also refer to [7], as mentioned earlier.</p>&#13;
<h4 class="h4" id="ch00lev2sec120"><span epub:type="pagebreak" id="page_270"/><strong><em>The Canvas</em></strong></h4>&#13;
<p class="noindent">A canvas is a surface to paint on. In Tkinter’s digital world, it’s the same. The canvas component is represented by the <span class="literal">Canvas</span> class in <span class="literal">tkinter</span>.</p>&#13;
<p class="indent">Let’s create a new Tkinter application where we can experiment with drawing to the canvas. In the <em>simulation</em> folder, create a new file named <em>hello_canvas.py</em> and enter the code in <a href="ch10.xhtml#ch10lis4">Listing 10-4</a>.</p>&#13;
<pre>from tkinter import Tk, Canvas&#13;
&#13;
tk = Tk()&#13;
tk.title("Hello Canvas")&#13;
&#13;
canvas = Canvas(tk, width=600, height=600)&#13;
canvas.grid(row=0, column=0)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch10lis4"/><em>Listing 10-4: Hello Canvas</em></p>&#13;
<p class="indent">The code creates a Tkinter application with its main window and a 600 by 600–pixel canvas. If you run the file, you should see an empty window with the title “Hello Canvas.” The canvas is there; it’s just that there’s nothing drawn yet.</p>&#13;
<h5 class="h5" id="ch00lev3sec58"><strong>Drawing Lines</strong></h5>&#13;
<p class="noindent">Let’s start easy and draw a line on the canvas. Just between creating the canvas and starting the main loop, add the following line:</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
canvas.create_line(0, 0, 300, 300)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="indent">The arguments passed to <span class="literal">create_line</span> are, respectively, the x- and y-coordinates of the start point and the x- and y-coordinates of the end point.</p>&#13;
<p class="indent">Run the file again. There should be a line segment going from the upper-left corner, (0, 0), to the center of the screen, (300, 300). As you can guess, the origin of coordinates is in the upper-left corner of the screen with the y-axis pointing downward. Later when we’re animating simulations, we’ll use affine transformations to fix this.</p>&#13;
<p class="indent">By default, lines are drawn with a width of 1 pixel and painted in black, but we can change this. Try the following:</p>&#13;
<pre>canvas.create_line(&#13;
    0, 0, 300, 300,&#13;
    width=3,&#13;
    fill='#aa3355'&#13;
)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_271"/>The line is now thicker and has a reddish color. Your result should look like <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>.</p>&#13;
<div class="image"><img src="../images/10fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig5"><em>Figure 10-5: A line on a Tkinter canvas</em></p>&#13;
<h5 class="h5" id="ch00lev3sec59"><strong>Drawing Ovals</strong></h5>&#13;
<p class="noindent">Let’s draw a circle in the middle of our application’s window using the same color as the previous line:</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
canvas.create_oval(&#13;
    200, 200, 400, 400,&#13;
    width=3,&#13;
    outline='#aa3355'&#13;
)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="noindent">The arguments passed to <span class="literal">create_oval</span> are the x- and y-coordinates of the upper-left vertex of the rectangle that contains the oval, and the x- and y-coordinates of the lower-right vertex. These are followed by the named arguments used to determine the line’s width and color: <span class="literal">width</span> and <span class="literal">outline</span>.</p>&#13;
<p class="indent">If you run the file, you’ll see a circle in the center of the window. Let’s turn it into a proper oval by making it 100 pixels wider, maintaining its height of 400 pixels:</p>&#13;
<pre>canvas.create_oval(&#13;
    200, 200, 500, 400,&#13;
    width=3,&#13;
    outline='#aa3355'&#13;
)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_272"/>By changing the x-coordinate of the lower-right corner from 400 to 500, the circle turns into an oval. The application now has a canvas with both a line and an oval, as in <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>.</p>&#13;
<div class="image"><img src="../images/10fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig6"><em>Figure 10-6: An oval added to our Tkinter canvas</em></p>&#13;
<p class="indent">If we wanted to add a fill color to the oval, we could do so using the named argument <span class="literal">fill=</span>’<span class="literal">...</span>’. Here’s an example:</p>&#13;
<pre>canvas.create_oval(&#13;
    200, 200, 500, 400,&#13;
    width=3,&#13;
    outline='#aa3355',&#13;
    fill='#cc3355',&#13;
)</pre>&#13;
<p class="indent">There’s one limitation, though: Tkinter doesn’t support transparency, which means all of our fills and strokes will be completely opaque. The color format <span class="literal">#rrggbbaa</span> where <span class="literal">aa</span> is the value for the <em>alpha</em> (transparency) is not supported in Tkinter.</p>&#13;
<h5 class="h5" id="ch00lev3sec60"><strong>Drawing Rectangles</strong></h5>&#13;
<p class="noindent">Drawing rectangles is also pretty straightforward. Enter this code in the file:</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
canvas.create_rectangle(&#13;
    40, 400, 500, 500,&#13;
    width=3,&#13;
    outline='#aa3355'&#13;
)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_273"/>The mandatory arguments to <span class="literal">create_rectangle</span> are the x- and y-coordinates of the upper-left corner of the rectangle and the x- and y-coordinates of the lower-right corner.</p>&#13;
<p class="indent">Run the file; the result should look like <a href="ch10.xhtml#ch10fig7">Figure 10-7</a>.</p>&#13;
<div class="image"><img src="../images/10fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig7"><em>Figure 10-7: A rectangle added to our Tkinter canvas</em></p>&#13;
<p class="indent">Nice! The resulting image is getting weirder, but isn’t it easy and fun to draw on the canvas?</p>&#13;
<h5 class="h5" id="ch00lev3sec61"><strong>Drawing Polygons</strong></h5>&#13;
<p class="noindent">The last geometric primitive we need to know how to draw is a generic polygon. After the code you added to draw the rectangle, write the following:</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
canvas.create_polygon(&#13;
    [40, 200, 300, 450, 600, 0],&#13;
    width=3,&#13;
    outline='#aa3355',&#13;
    fill=''&#13;
)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="noindent">The first parameter to <span class="literal">create_polygon</span> is a list of vertex coordinates. The rest are the named parameters that affect its style. Notice that we pass an empty string to the <span class="literal">fill</span> parameter; by default polygons get filled, but we want ours to be only an outline. Run the file to see the result. It should resemble <a href="ch10.xhtml#ch10fig8">Figure 10-8</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_274"/><img src="../images/10fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig8"><em>Figure 10-8: A polygon added to our Tkinter canvas</em></p>&#13;
<p class="indent">We created a triangle with vertices (40, 200), (300, 450), and (600, 0). Try adding a fill color and seeing what results.</p>&#13;
<h5 class="h5" id="ch00lev3sec62"><strong>Drawing Text</strong></h5>&#13;
<p class="noindent">It isn’t a geometric primitive, but we may also need to draw some text to the canvas. Doing so is easy using the <span class="literal">create_text</span> method. Add the following to <em>hello_canvas.py</em>:</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
canvas.create_text(&#13;
    300, 520,&#13;
    text='This is a weird drawing',&#13;
    fill='#aa3355',&#13;
    font='Helvetica 20 bold'&#13;
)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="noindent">The first two parameters are the x and y position for the center of the text. The named parameter <span class="literal">text</span> is where we set the actual text we want to draw; we can change its font using <span class="literal">font</span>. Run the file one last time to see the complete drawing, as shown in <a href="ch10.xhtml#ch10fig9">Figure 10-9</a>.</p>&#13;
<p class="indent">If we can draw lines, circles, rectangles, generic polygons, and text, we can draw pretty much anything. We could also use arcs and splines, but we’ll manage to do our simulations using only these simple primitives.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_275"/><img src="../images/10fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig9"><em>Figure 10-9: Text added to our Tkinter canvas</em></p>&#13;
<p class="indent">Your final code should look like <a href="ch10.xhtml#ch10lis5">Listing 10-5</a>.</p>&#13;
<pre>from tkinter import Tk, Canvas&#13;
&#13;
tk = Tk()&#13;
tk.title("Hello Canvas")&#13;
&#13;
canvas = Canvas(tk, width=600, height=600)&#13;
canvas.grid(row=0, column=0)&#13;
&#13;
canvas.create_line(&#13;
    0, 0, 300, 300,&#13;
    width=3,&#13;
    fill='#aa3355'&#13;
)&#13;
canvas.create_oval(&#13;
    200, 200, 500, 400,&#13;
    width=3,&#13;
    outline='#aa3355'&#13;
)&#13;
canvas.create_rectangle(&#13;
    40, 400, 500, 500,&#13;
    width=3,&#13;
    outline='#aa3355'&#13;
)&#13;
canvas.create_polygon(&#13;
    [40, 200, 300, 450, 600, 0],&#13;
    width=3,&#13;
    outline='#aa3355',&#13;
    fill=''&#13;
)&#13;
canvas.create_text(&#13;
    <span epub:type="pagebreak" id="page_276"/>300, 520,&#13;
    text='This is a weird drawing',&#13;
    fill='#aa3355',&#13;
    font='Helvetica 20 bold'&#13;
)&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch10lis5"/><em>Listing 10-5: Final drawing code</em></p>&#13;
<p class="indent">Now that we know how to draw simple primitives to the canvas, let’s come up with a way of drawing our <em>geom2d</em> library’s geometric primitives directly to the canvas.</p>&#13;
<h3 class="h3" id="ch00lev1sec63"><strong>Drawing Our Geometric Primitives</strong></h3>&#13;
<p class="noindent">Drawing a circle to the canvas was easy using its <span class="literal">create_oval</span> method. This method is, nevertheless, not convenient; to define the circle, you need to pass the coordinates of two vertices that define a rectangle where the circle or oval is inscribed. On the other hand, our class <span class="literal">Circle</span> is defined by its center point and radius, and it has some useful methods and can be transformed using instances of <span class="literal">AffineTransform</span>. It would be nice if we could directly draw our circles like so:</p>&#13;
<pre>circle = Circle(Point(2, 5), 10)&#13;
canvas.draw_circle(circle)</pre>&#13;
<p class="indent">We definitely want to work with our geometry primitives. Similar to how we created SVG representations of them in <a href="ch08.xhtml#ch08">Chapter 8</a>, we’ll need a way to draw them to the canvas.</p>&#13;
<p class="indent">Here’s the plan: we’ll create a wrapper for Tkinter’s <span class="literal">Canvas</span> widget. We’ll create a class that contains an instance of the canvas where we want to draw but whose methods allow us to pass our own geometric primitives. To leverage our powerful affine transformation implementation, we’ll associate a transformation to our drawing so that all primitives we pass will first be transformed.</p>&#13;
<h4 class="h4" id="ch00lev2sec121"><strong><em>The Canvas Wrapper Class</em></strong></h4>&#13;
<p class="noindent">A wrapper class is simply a class that contains an instance of another class (what it’s wrapping) and is used to provide a similar functionality as the wrapped class, but with a different interface and some added functionality. It’s a simple yet powerful concept.</p>&#13;
<p class="indent">In this case, we’re wrapping a Tkinter canvas. Our canvas wrapper goal is to allow us to draw our geometric primitives with a simple and clean interface: we want methods that directly accept instances of our primitives. This wrapper will save us from the repetitive task of adapting the representation of the geometric classes to the inputs expected by the Tkinter canvas’s <span epub:type="pagebreak" id="page_277"/>drawing methods. Not only that, but we’ll also apply an affine transformation to everything that we draw. <a href="ch10.xhtml#ch10fig10">Figure 10-10</a> depicts this process.</p>&#13;
<p class="indent">In the <em>simulation</em> package, create a new file named <em>draw.py</em>. Enter the code in <a href="ch10.xhtml#ch10lis6">Listing 10-6</a>.</p>&#13;
<pre>from tkinter import Canvas&#13;
&#13;
from geom2d import AffineTransform&#13;
&#13;
&#13;
class CanvasDrawing:&#13;
&#13;
    def __init__(self, canvas: Canvas, transform: AffineTransform):&#13;
        self.__canvas = canvas&#13;
        self.outline_color = '#aa3355'&#13;
        self.outline_width = 3&#13;
        self.fill_color = ''&#13;
        self.transform = transform&#13;
&#13;
    def clear_drawing(self):&#13;
        self.__canvas.delete('all')</pre>&#13;
<p class="caption"><a id="ch10lis6"/><em>Listing 10-6: Canvas wrapper class</em></p>&#13;
<p class="indent">The class <span class="literal">CanvasDrawing</span> is defined as a wrapper to the Tkinter canvas. An instance of the canvas is passed to the initializer and stored in a private variable, <span class="literal">__canvas</span>. Making <span class="literal">__canvas</span> private means we don’t want anyone using <span class="literal">CanvasDrawing</span> to access it directly. It now belongs to the wrapper class instance, and it should only be used with its methods.</p>&#13;
<p class="indent">An instance of <span class="literal">AffineTransform</span> is also passed to the initializer. We’ll apply this affine transformation to all geometric primitives before we draw them to Tkinter’s canvas. The transformation is stored in a public variable: <span class="literal">transform</span>. This means we’re allowing users of <span class="literal">CanvasDrawing</span> instances to directly manipulate and edit this property, which is part of the state of the instance. We do this so that it’s simple to alter the affine transformation applied to the drawing, by reassigning the <span class="literal">transform</span> property to a different transformation.</p>&#13;
<p class="indent">The state of an instance defines its behavior: if the state changes, the instance’s behavior changes as well. In this case, it’s clear that if the property <span class="literal">transform</span> is reassigned a different affine transformation, all subsequent drawing commands will produce results in accordance with it.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10fig10">Figure 10-10</a> is a diagram representing the behavior of our canvas wrapper class. It’ll receive draw requests for different geometric primitives, apply the affine transformation to them, and then call the Tkinter’s canvas methods to draw into it.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_278"/><img src="../images/10fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig10"><em>Figure 10-10: The canvas wrapper class</em></p>&#13;
<p class="indent">There are other state variables defined in the initializer: <span class="literal">outline_color</span>, which defines the color used for the outline of geometries, <span class="literal">outline_width</span> for the width of the outlines, and <span class="literal">fill_color</span> for the color used to fill the geometries. These are given default values in the initializer (those used in our example in the previous section) but are also public and accessible for users of the instance to change them. Like before, it should be clear that these properties are part of the state of the instance: if we edit <span class="literal">outline_color</span>, for example, all subsequent drawings will use that color for the outlines.</p>&#13;
<p class="indent">We’ve defined only one method in the class: <span class="literal">clear_drawing</span>. This method will clean the canvas for us before drawing each of the frames. Let’s now focus on the drawing commands.</p>&#13;
<h4 class="h4" id="ch00lev2sec122"><strong><em>Drawing Segments</em></strong></h4>&#13;
<p class="noindent">Let’s start with the simplest primitive to draw: the segment. In the <span class="literal">Canvas</span> <span class="literal">Drawing</span> class, enter the method in <a href="ch10.xhtml#ch10lis7">Listing 10-7</a>. For this code you first need to update the imports from <em>geom2d</em> to include the <span class="literal">Segment</span> class.</p>&#13;
<pre>from tkinter import Canvas&#13;
&#13;
from geom2d import <span class="codestrong1">Segment</span>, AffineTransform&#13;
&#13;
&#13;
class CanvasDrawing:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def draw_segment(self, segment: Segment):&#13;
       segment_t = self.transform.apply_to_segment(segment)&#13;
       self.__canvas.create_line(&#13;
           segment_t.start.x,&#13;
           segment_t.start.y,&#13;
           segment_t.end.x,&#13;
           segment_t.end.y,&#13;
           fill=self.outline_color,&#13;
           width=self.outline_width&#13;
       <span epub:type="pagebreak" id="page_279"/>)</pre>&#13;
<p class="caption"><a id="ch10lis7"/><em>Listing 10-7: Drawing a segment</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Note how we’re passing the</em> <span class="literal">self.outline_color</span> <em>value to the</em> <span class="literal">fill</span> <em>parameter. That looks like an error, but unfortunately, Tkinter picked a bad name. The</em> <span class="literal">fill</span> <em>attribute is used for the stroke’s color in a</em> <span class="literal">create_line</span> <em>command. A better name would have been</em> <span class="literal">outline</span> <em>or, even better,</em> <span class="literal">stroke-color</span>.</p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">draw_segment</span> method does two things: first it transforms the given segment using the current affine transformation and stores the result in <span class="literal">segment_t</span>. Then it calls the <span class="literal">create_line</span> method from the canvas instance. For the outline color and width, we use the state variables of the instance.</p>&#13;
<p class="indent">Let’s move on to polygons, circles, and rectangles.</p>&#13;
<h4 class="h4" id="ch00lev2sec123"><strong><em>Drawing Polygons</em></strong></h4>&#13;
<p class="noindent">If you recall from “Transform Segments and Polygons” on <a href="ch07.xhtml#ch00lev2sec82">page 179</a>, once an affine transformation is applied to a circle or rectangle, the result is a generic polygon. This means that all three polygons will be drawn using the <span class="literal">create_polygon</span> method from the canvas.</p>&#13;
<p class="indent">Let’s create a private method that draws a polygon to the canvas, forgetting about the affine transformation; that part will be handled by each of the public drawing methods.</p>&#13;
<p class="indent">In your <span class="literal">CanvasDrawing</span> class, enter the private method in <a href="ch10.xhtml#ch10lis8">Listing 10-8</a>.</p>&#13;
<pre><span class="codestrong1">from functools import reduce</span>&#13;
from tkinter import Canvas&#13;
&#13;
from geom2d import <span class="codestrong1">Polygon</span>, Segment, AffineTransform&#13;
&#13;
&#13;
class CanvasDrawing:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __draw_polygon(self, polygon: Polygon):&#13;
        vertices = reduce(&#13;
            list.__add__,&#13;
            [[v.x, v.y] for v in polygon.vertices]&#13;
        )&#13;
&#13;
        self.__canvas.create_polygon(&#13;
            vertices,&#13;
            fill=self.fill_color,&#13;
            outline=self.outline_color,&#13;
            width=self.outline_width&#13;
        )</pre>&#13;
<p class="caption"><a id="ch10lis8"/><em>Listing 10-8: Drawing a polygon to the canvas</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_280"/>For this code you need to add the following import,</p>&#13;
<pre>from functools import reduce</pre>&#13;
<p class="noindent">and update the imports from <span class="literal">geom2d</span>:</p>&#13;
<pre>from geom2d import Polygon, Segment, AffineTransform</pre>&#13;
<p class="indent">The <span class="literal">__draw_polygon</span> method first prepares the vertex coordinates of the polygon to meet the expectations of the canvas widget’s <span class="literal">create_polygon</span> method. This is done by reducing a list of lists of vertex coordinates with Python’s list <span class="literal">__add__</span> method, which, if you recall, is the method that overloads the + operator.</p>&#13;
<p class="indent">Let’s break this down. First, the polygon’s vertices are mapped using a list comprehension:</p>&#13;
<pre>[[v.x, v.y] for v in polygon.vertices]</pre>&#13;
<p class="noindent">This creates a list with the x- and y-coordinates from each vertex. If the vertices of the polygon were (0, 10), (10, 0), and (10, 10), the list comprehension shown earlier would result in the following list:</p>&#13;
<pre>[[0, 10], [10, 0], [10, 10]]</pre>&#13;
<p class="noindent">This list then needs to be <em>flattened</em>: all values in the inner lists (the numeric coordinates) have to be concatenated into a single list. The result of flattening the previous list would be as follows:</p>&#13;
<pre>[0, 10, 10, 0, 10, 10]</pre>&#13;
<p class="noindent">This is the list of vertex coordinates the method <span class="literal">create_polygon</span> expects. This final flattening step is achieved by the <span class="literal">reduce</span> function; we pass it the <span class="literal">list</span> <span class="literal">.__add__</span> operator, and it produces a new list that results from concatenating both list operands. To see that in action, you can test the following in Python’s shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">[1, 2] + [3, 4]</span>&#13;
[1, 2, 3, 4]</pre>&#13;
<p class="indent">Once the list of vertex coordinates is ready, drawing it to the canvas is straightforward: we simply pass the list to the canvas’s <span class="literal">create_polygon</span> method. Now that the hardest part is done, drawing our polygons should be easier. Enter the code in <a href="ch10.xhtml#ch10lis9">Listing 10-9</a> to your class.</p>&#13;
<pre>from functools import reduce&#13;
from tkinter import Canvas&#13;
&#13;
<span epub:type="pagebreak" id="page_281"/>from geom2d import <span class="codestrong1">Circle</span>, Polygon, Segment, <span class="codestrong1">Rect</span>, AffineTransform&#13;
&#13;
&#13;
class CanvasDrawing:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def draw_circle(self, circle: Circle, divisions=30):&#13;
       self.__draw_polygon(&#13;
           self.transform.apply_to_circle(circle, divisions)&#13;
       )&#13;
&#13;
   def draw_rectangle(self, rect: Rect):&#13;
       self.__draw_polygon(&#13;
           self.transform.apply_to_rect(rect)&#13;
       )&#13;
&#13;
   def draw_polygon(self, polygon: Polygon):&#13;
       self.__draw_polygon(&#13;
           self.transform.apply_to_polygon(polygon)&#13;
       )</pre>&#13;
<p class="caption"><a id="ch10lis9"/><em>Listing 10-9: Drawing circles, rectangles, and generic polygons</em></p>&#13;
<p class="indent">Don’t forget to add the missing imports from <em>geom2d</em>:</p>&#13;
<pre>from geom2d import <span class="codestrong1">Circle</span>, Polygon, Segment, <span class="codestrong1">Rect</span>, AffineTransform</pre>&#13;
<p class="indent">In all three methods, the process is the same: call the private method <span class="literal">__draw_polygon</span> and pass it the result of applying the current affine transformation to the geometry. Don’t forget that in the case of a circle, we need to pass the number of divisions we’ll use to approximate it to the <span class="literal">transform</span> method.</p>&#13;
<h4 class="h4" id="ch00lev2sec124"><strong><em>Drawing Arrows</em></strong></h4>&#13;
<p class="noindent">Let’s now draw arrows following the same approach we used in <a href="ch08.xhtml#ch08">Chapter 8</a> for SVG images.</p>&#13;
<p class="indent">The arrow’s head will be drawn on the end point <em>E</em> of a segment and will be made of two segments at an angle meeting at such an end point. To allow some flexibility, we’ll use two dimensions to define the arrow’s geometry: a length and a height (see <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>).</p>&#13;
<p class="indent">As you can see in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a> (repeated from <a href="ch08.xhtml#ch08">Chapter 8</a>), to draw the arrow’s head, we need to figure out points <em>C</em><sub>1</sub> and <em>C</em><sub>2</sub>. With those two points, we can easily draw the segments between <em>C</em><sub>1</sub> and <em>E</em> and between <em>C</em><sub>2</sub> and <em>E</em>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_282"/><img src="../images/10fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch10fig11"><em>Figure 10-11: Key points in an arrow</em></p>&#13;
<p class="indent">To find out where those points lie in the plane, we’ll be computing three vectors: <img class="inline" src="../images/vlvictorit.jpg" alt="Image"/>, which has the same length as the arrow’s head and is going in the opposite direction of the segment’s direction vector, and <img class="inline" src="../images/vh1victorit.jpg" alt="Image"/> and <img class="inline" src="../images/vh2victorit.jpg" alt="Image"/>, which are perpendicular to the segment and both have a length equal to half the arrow’s head height. <a href="ch10.xhtml#ch10fig11">Figure 10-11</a> shows these vectors. The point <em>C</em><sub>1</sub> can be computed by creating a displaced version of <em>E</em> (the segment’s end point),</p>&#13;
<div class="equationc"><img src="../images/f00282-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">and similarly, <em>C</em><sub>2</sub>:</p>&#13;
<div class="equationc"><img src="../images/f00282-p2.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s write the method. In the <span class="literal">CanvasDrawing</span> class, enter the code in <a href="ch10.xhtml#ch10lis10">Listing 10-10</a>.</p>&#13;
<pre>class CanvasDrawing:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def draw_arrow(&#13;
            self,&#13;
            segment: Segment,&#13;
            length: float,&#13;
            height: float&#13;
    ):&#13;
        director = segment.direction_vector&#13;
        v_l = director.opposite().with_length(length)&#13;
        v_h1 = director.perpendicular().with_length(height / 2.0)&#13;
        v_h2 = v_h1.opposite()&#13;
&#13;
        self.draw_segment(segment)&#13;
        self.draw_segment(&#13;
            Segment(&#13;
                segment.end,&#13;
             <span class="ent">➊</span> segment.end.displaced(v_l + v_h1)&#13;
            )&#13;
        )&#13;
        self.draw_segment(&#13;
            <span epub:type="pagebreak" id="page_283"/>Segment(&#13;
                segment.end,&#13;
             <span class="ent">➋</span> segment.end.displaced(v_l + v_h2)&#13;
            )&#13;
        )</pre>&#13;
<p class="caption"><a id="ch10lis10"/><em>Listing 10-10: Drawing an arrow</em></p>&#13;
<p class="indent">We start by computing the three vectors we need to figure out points <em>C</em><sub>1</sub> and <em>C</em><sub>2</sub> using the previous equations. As you can see, this is pretty straightforward thanks to the methods we implemented in our <span class="literal">Vector</span> class. For example, to obtain <img class="inline" src="../images/vlvictorit.jpg" alt="Image"/>, we use the opposite vector of the segment’s direction vector and scale it to have the desired length. We use similar operations to calculate the remaining elements of our equations.</p>&#13;
<p class="indent">Then we three segments: the base line, which is the segment passed as the argument; the segment going from <em>E</em> to <em>C</em><sub>1</sub> <span class="ent">➊</span> ; and the one going from <em>E</em> to <em>C</em><sub>2</sub> <span class="ent">➋</span>.</p>&#13;
<p class="indent">For reference, your <em>drawing.py</em> file should look like <a href="ch10.xhtml#ch10lis11">Listing 10-11</a>.</p>&#13;
<pre>from functools import reduce&#13;
from tkinter import Canvas&#13;
&#13;
from geom2d import Circle, Polygon, Segment, Rect, AffineTransform&#13;
&#13;
&#13;
class CanvasDrawing:&#13;
&#13;
    def __init__(self, canvas: Canvas, transform: AffineTransform):&#13;
        self.__canvas = canvas&#13;
        self.outline_color = '#aa3355'&#13;
        self.outline_width = 3&#13;
        self.fill_color = ''&#13;
        self.transform = transform&#13;
&#13;
    def clear_drawing(self):&#13;
        self.__canvas.delete('all')&#13;
&#13;
    def draw_segment(self, segment: Segment):&#13;
        segment_t = self.transform.apply_to_segment(segment)&#13;
        <span epub:type="pagebreak" id="page_284"/>self.__canvas.create_line(&#13;
            segment_t.start.x,&#13;
            segment_t.start.y,&#13;
            segment_t.end.x,&#13;
            segment_t.end.y,&#13;
            outline=self.outline_color,&#13;
            width=self.outline_width&#13;
        )&#13;
&#13;
    def draw_circle(self, circle: Circle, divisions=30):&#13;
        self.__draw_polygon(&#13;
            self.transform.apply_to_circle(circle, divisions)&#13;
        )&#13;
&#13;
    def draw_rectangle(self, rect: Rect):&#13;
        self.__draw_polygon(&#13;
            self.transform.apply_to_rect(rect)&#13;
        )&#13;
&#13;
    def draw_polygon(self, polygon: Polygon):&#13;
        self.__draw_polygon(&#13;
            self.transform.apply_to_polygon(polygon)&#13;
        )&#13;
&#13;
    def __draw_polygon(self, polygon: Polygon):&#13;
        vertices = reduce(&#13;
            list.__add__,&#13;
            [[v.x, v.y] for v in polygon.vertices]&#13;
        )&#13;
&#13;
        self.__canvas.create_polygon(&#13;
            vertices,&#13;
            fill=self.fill_color,&#13;
            outline=self.outline_color,&#13;
            width=self.outline_width&#13;
        )&#13;
&#13;
    def draw_arrow(&#13;
            self,&#13;
            segment: Segment,&#13;
            length: float,&#13;
            height: float&#13;
    ):&#13;
        director = segment.direction_vector&#13;
        v_l = director.opposite().with_length(length)&#13;
        v_h1 = director.perpendicular().with_length(height / 2.0)&#13;
        v_h2 = v_h1.opposite()&#13;
&#13;
        self.draw_segment(segment)&#13;
        self.draw_segment(&#13;
            Segment(&#13;
                segment.end,&#13;
                segment.end.displaced(v_l + v_h1)&#13;
            )&#13;
        )&#13;
        self.draw_segment(&#13;
            Segment(&#13;
                segment.end,&#13;
                <span epub:type="pagebreak" id="page_285"/>segment.end.displaced(v_l + v_h2)&#13;
            )&#13;
        )</pre>&#13;
<p class="caption"><a id="ch10lis11"/><em>Listing 10-11: <span class="codeitalic1">CanvasDrawing</span> class result</em></p>&#13;
<p class="indent">We now have a convenient way of drawing our geometric primitives, but they’re not moving at all, and we need motion to produce simulations. What’s the missing ingredient to bring those geometries to life? That’s the topic of the next chapter. Matters are getting more and more exciting!</p>&#13;
<h3 class="h3" id="ch00lev1sec64"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we covered the basics of creating graphical user interfaces using Python’s Tkinter package. We saw how to lay widgets on the main window using the <span class="literal">grid</span> system. We also learned how to make a button respond to being clicked and how to read the contents of a text field. Most importantly, we learned about the <span class="literal">Canvas</span> class and its methods that we can use to draw simple primitives to it.</p>&#13;
<p class="indent">We finished the chapter by creating a class of our own that wraps Tkinter’s canvas and allows us to draw our geometric primitives directly. The class also includes an affine transformation that applies to the primitives before being drawn. The class has properties that define the stroke width and color as well as the fill color. These are the width and colors applied to the primitives we draw with it. Now it’s time to put those static geometries into motion.<span epub:type="pagebreak" id="page_286"/></p>&#13;
</body></html>