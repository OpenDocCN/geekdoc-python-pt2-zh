# 8

网格

![](img/chapterart.png)

本章中，我们将探讨当我们考虑多维值和目标时会发生什么。到目前为止，我们所研究的数据结构都共享一个共同的约束——它们基于单一值来组织数据。许多现实世界中的问题涉及多个重要维度，因此我们需要扩展我们的数据结构，以处理这种数据上的搜索。

本章首先介绍最近邻搜索，它将作为我们多维数据的激励性应用案例。正如我们将看到的，最近邻搜索的普适性使其非常灵活，适用于各种空间和非空间问题。它可以帮助我们找到离我们当前位置最近的咖啡店，或者最适合我们口味的品牌。

然后我们介绍网格数据结构，并展示它如何在二维空间上促进最近邻搜索，利用数据中的空间关系来修剪掉不可行的搜索区域。我们还简要讨论了这些方法如何扩展到二维以上的情况。我们将看到这些数据结构的不足之处，并为进一步的空间数据结构提供动机。

## 介绍最近邻搜索

正如其名字所示，*最近邻搜索*的核心是找到离给定搜索目标最近的特定数据点——例如，离我们当前位置最近的咖啡店。形式上，我们将最近邻搜索定义如下：

> 给定一组*N*个数据点 *X* = {*x*[1], *x*[2], … , *x*[N]}，一个目标值 *x*’，以及一个距离函数 *dist*(*x*,*y*)，找到数据点 *x*[*i*] ∈ *X*，使得 *dist*(*x*’，*x*[*i*])最小。

最近邻搜索与我们在第二章中用来激发二分搜索的目标值搜索密切相关。两者的算法都是在数据集中搜索特定的数据点。关键的区别在于成功标准。二分搜索是测试数据集中是否存在确切匹配，而最近邻搜索只关注找到最接近的匹配。

这种框架使得最近邻搜索对许多类型的多维数据都非常有用。我们可能在搜索地图上的附近咖啡店，查找与当前日期相似的历史温度，或者搜索某个单词的“近似”拼写。只要我们能够定义搜索目标与其他值之间的距离，就能找到最近邻。

在过去的章节中，我们主要考虑了像二叉搜索树和堆中存储的数字值这样的目标。虽然我们有时也包括辅助数据，但目标本身仍然很简单。相比之下，最近邻搜索在处理多维数据时最为有趣，这些数据可能存储在各种其他数据结构中，例如数组、元组或复合数据结构。在本章后面，我们将介绍二维搜索问题及其目标。现在，让我们先介绍一种基本的搜索算法。

### 使用线性扫描的最近邻搜索

作为最近邻搜索的基线算法，我们从第二章的线性扫描算法的修改版开始。线性扫描算法并不特别激动人心；你可以用大多数编程语言通过一个简单的循环来实现它。然而，正因为它的简单性，线性扫描提供了一个很好的起点，帮助我们检视更复杂和高效的算法。

考虑使用绝对距离的最近邻搜索问题：*dist*(*x*,*y*) = |*x* – *y*|。给定一组数字和一个搜索目标，我们想找到列表中最接近的数字。也许我们在一个新的城市醒来，需要找个地方喝早晨的第一杯咖啡。酒店的礼宾部提供了同一条街上的咖啡店列表，并附上了一张有用的地图。由于我们不认识任何这些商店，我们决定优先选择方便的咖啡店，去离酒店最近的那一家。

我们可以通过图 8-1 中的数字线来可视化这个搜索。图中的点代表不同的咖啡店及其相对于地图起点的位置，而 X 则代表我们的酒店，距离街道上的 2.2 英里处。

![一条包含七个候选邻居和一个目标点的数字线。目标点位于 2.2，最近邻居在 2.6 处。](img/f08001.png)

图 8-1：表示为数字线的一个维度最近邻搜索

在程序中，图 8-1 中的点可能表示数组中的未排序值。然而，在最近邻搜索的上下文中，将这些值可视化为实数轴有两个优点。首先，它明确了距离的重要性：我们可以看到目标值与每个数据点之间的间隔。其次，它帮助我们将技巧推广到多维度，正如我们将在下一节中看到的那样。

目前，线性扫描会按照图 8-2 所示，逐个遍历每个数据点，计算当前数据点的距离，并与迄今为止找到的最小距离进行比较。在这里，我们按排序顺序考虑这些点，因为它们已经沿着数字线排列，但线性扫描并不要求特定的排序。它使用数据在列表中的顺序。

![线性扫描计算每个数据点到目标点的距离。若干数轴展示了每对点及其对应的距离。](img/f08002.png)

图 8-2：一维最近邻搜索中的数据点线性扫描

在图 8-2 中的第一次比较中，我们找到了一个距离为 1.8 的点。到目前为止，这成为了我们的最佳选择，即我们的*候选最近邻*。它可能不是一个*理想的*邻居——1.8 英里对于我们早上的咖啡来说，走路有点远——但它是我们见过的最好的。接下来的两步分别发现了距离 1.2 和 0.4 的更好候选点。遗憾的是，剩余的四次比较并没有找到更好的候选点；距离 0.4 的点仍然是我们找到的最近邻。在最终，算法返回了我们的数字轴上第三个点作为最近邻。我们信心满满地前往咖啡店，确信我们正在前往街上最接近的那一家。

列表 8-1 展示了使用任意距离函数的线性扫描代码。我们在一维情况下使用浮点值，但可以通过使用复合数据结构或其他表示方法将该函数扩展到多维情况。

```py
LinearScanClosestNeighbor(Array: A, Float: target, Function: dist):
    Integer: N = length(A)
  ❶ IF N == 0:
        return null

  ❷ Float: candidate = A[0]
    Float: closest_distance = dist(target, candidate)

    Integer: i = 1
  ❸ WHILE i < N:
        Float: current_distance = dist(target, A[i])
      ❹ IF current_distance < closest_distance:
            closest_distance = current_distance
            candidate = A[i]
        i = i + 1
  ❺ return candidate
```

列表 8-1：线性扫描最近邻算法的代码

代码首先检查数组是否为空，如果为空，则返回`null` ❶，因为没有最近邻点。接下来，代码将数组中的第一个项目选为初始的候选最近邻，并计算该点到目标的距离 ❷。这为我们的搜索提供了一个起点：我们将所有后续的点与当前最佳候选和距离进行比较。代码的其余部分使用`WHILE`循环遍历数组中的剩余元素 ❸，计算它们到目标的距离，并与当前找到的最佳距离进行比较。每当找到更近的候选时，代码会更新最佳候选和最佳距离 ❹，最后返回最接近的邻居 ❺。

除了提供简单的最近邻查找实现外，线性扫描算法还轻松支持不同的距离函数，甚至是更高维度的点。首先，让我们来看一些在这个二维空间中的示例问题。

### 搜索空间数据

想象一下，你已经驾驶几个小时，进行着一次横跨国家的公路旅行，并且迫切需要一杯咖啡续杯。你猛然意识到，自己没有规划好沿途的最佳咖啡店，恐慌涌上心头。你深吸一口气，拿出图 8-3 中展示的地图，找到多个有已知咖啡店的城镇。你把效率放在首位，决心找到最近的咖啡馆。

![一个二维城镇地图。目标点位于中左侧，靠近 Gridville、Cartesian 和 Fort Fortran 等城镇。](img/f08003.png)

图 8-3：作为二维数据示例的地图

数据由二维点组成——带有 *x* 和 *y* 坐标的城镇。这些数据点可以存储为一个有序元组（*x*, *y*）；一个小型固定大小的数组 [*x*, *y*]；甚至可以使用复合数据结构来表示二维空间点：

```py
Point {
    Float: x
    Float: y
}
```

在确定哪个城镇最接近时，我们将仅关注与咖啡店的直线距离。在任何现实世界的导航任务中，我们还需要考虑我们和咖啡之间的障碍物。然而，目前，我们只考虑到咖啡店的欧几里得距离。如果当前点是 (*x*[1]*, y*[1])，而咖啡店在 (*x*[2]*, y*[2]) 处，那么距离为：

![G08001](img/G08001.png)

我们可以使用清单 8-1 中的线性扫描算法。该算法计算从目标到每个候选点的距离，如图 8-4 所示。

![一张插图，展示了从目标点到地图上 11 个城镇的距离计算。距离通过从目标点到各城镇的虚线表示。](img/f08004.png)

图 8-4：线性扫描最近邻搜索计算从目标到每个候选点的距离。

与目标的距离最小的点，如图 8-5 所示，就是目标的最近邻。虚线表示与最近点的距离，虚线圆圈显示的是我们地图上距离最近点（或等于最近点）的区域。没有其他点的距离比最近邻点更近。

![一张从目标点到最近邻之间有虚线，并且有一个虚线圆圈表示此半径范围内的区域的地图。](img/f08005.png)

图 8-5：与目标的距离最小的点就是该目标的最近邻。

然而，正如我们多次看到的那样，当点的数量增加时，这种类型的线性扫描搜索会迅速变得低效。如果《咖啡爱好者指南》当前版本列出了 10 万个咖啡馆，逐一检查每个咖啡馆将会是一个不必要的时间消耗。

我们不应该需要查看二维空间中的每一个数据点。有些点距离太远，不需要考虑。当我们驾驶穿越佛罗里达时，我们不会考虑阿拉斯加的咖啡店。这并不是贬低阿拉斯加的咖啡馆——我相信有许多咖啡馆在口味和质量上与佛罗里达的同类相匹配。这仅仅是为了效率考虑。我们无法在没有咖啡的情况下生存一个小时，更别提几天的驾车旅行了。如果我们在北佛罗里达驾驶，我们需要关注的是北佛罗里达的咖啡馆。

正如我们在二分查找中所见，我们常常可以利用数据中的结构来帮助排除大量候选项。我们甚至可以将二分查找法改编为在一维空间中寻找最近邻。不幸的是，简单的排序在二维情况下并不奏效。如果我们按照 x 轴或 y 轴排序并进行搜索，如图 8-6 所示，结果是错误的——一维空间中的最近邻与二维空间中的最近邻并不相同。

我们需要利用所有相关维度的信息来做出准确的剪枝决策。在某一维度上接近目标的点，在其他维度上可能相距非常远。如果我们按照纬度对咖啡店列表进行排序，搜索位于我们当前佛罗里达北部纬度附近的地点时，可能会返回来自休斯顿的一些“接近”结果。类似地，如果我们按经度排序，可能会收到来自克利夫兰的条目。我们需要探索新的方法，借鉴我们在一维数据中的经验，同时也利用高维度固有的结构。

![左侧是图 8-3 中地图点在 Y 轴上的投影。右侧是点在 X 轴上的投影。在这两种情况下，单一维度上的最近邻与二维空间中的最近邻并不相同。](img/f08006b.png)

图 8-6：将数据投影到单一维度（左侧为 y 轴，右侧为 x 轴）会丢失关于另一个维度的重要空间信息。

## 网格

*网格*是用于存储二维数据的数据结构。像数组一样，网格由一组固定的*区间*或*单元格*组成。由于我们最初处理的是二维数据，因此我们使用二维的区间排列，并用两个数字*xbin*和*ybin*来索引每个区间，分别表示 x 轴和 y 轴上的区间编号。图 8-7 展示了一个网格示例。

![地图上的二维网格。X 轴和 Y 轴上的标记分别为 0 和 1，共有四个象限。](img/f08007.png)

图 8-7：一个 2×2 的空间数据点网格

与数组不同，我们不能将每个区间限制为仅存储一个值。网格单元是由空间边界定义的——每个维度上的高低边界。无论我们如何精细地绘制网格，多个点可能会落在同一个单元格内，因此我们需要让每个区间能够存储多个元素。每个区间存储一个包含该区间范围内*所有*数据点的列表。

我们可以将网格和数组之间的区别形象化为冰箱存储的不同形式。蛋盒是一个数组，每个蛋都有一个独立的空间。相比之下，蔬菜抽屉更像是一个网格箱，它包含了多种相同类型的物品，全部是蔬菜。我们可能把一个抽屉塞满二十五个洋葱。另一方面，蛋盒只包含固定数量的鸡蛋，每个鸡蛋都有指定的位置。而蔬菜抽屉可能会引发关于番茄或黄瓜应该存放在哪里的激烈讨论，但网格单元的边界是通过数学精确定义的。

网格使用点的坐标来确定它们的存储方式，使我们能够利用数据的空间结构来限制搜索范围。为了理解这一点，我们首先需要考虑网格结构的细节。

### 网格结构

我们网格的顶层数据结构包含一些额外的记录信息。如图 8-8 所示，我们需要在每个维度上包含多项信息。除了 x 和 y 维度上的箱子数量，我们还必须跟踪每个维度的空间边界。我们使用 `x_start` 和 `x_end` 来表示网格中包含的 x 的最小值和最大值。类似地，`y_start` 和 `y_end` 捕捉 y 的空间边界。

![该网格从 x_start 到 x_end 跨越 x 轴，从 y_start 到 y_end 跨越 y 轴。网格在每个维度上有 6 个箱子，结果箱子的宽度如图所示。](img/f08008.png)

图 8-8：一个沿每个维度指定起始和结束值的网格

我们可以从箱子数量和空间边界中推导出一些顶层信息，但为了方便起见，我们通常希望存储有关网格的额外信息。预计算每个维度上箱子的宽度可以简化后续的代码：

```py
x_bin_width = (x_end – x_start) / num_x_bins
y_bin_width = (y_end – y_start) / num_y_bins
```

其他有用的信息可能包括存储在网格中的总点数或空箱子的数量。我们可以在一个复合数据结构中跟踪所有这些信息。对于二维数据，我们典型的数据结构可能如下所示：

```py
Grid {
    Integer: num_x_bins
    Integer: num_y_bins
    Float: x_start
    Float: x_end
 Float: x_bin_width
    Float: y_start
    Float: y_end
    Float: y_bin_width
    Matrix of GridPoints: bins
}
```

对于固定大小的网格，我们可以通过简单的数学计算，将一个点的空间坐标映射到网格的箱子中：

```py
xbin = Floor((x – x_start) / x_bin_width)
ybin = Floor((y – y_start) / y_bin_width)
```

从“一个箱子，一个值”到“空间划分”的转换不仅对索引映射有重要影响，还意味着我们不能再将数据存储为计算机内存中的一组固定箱子。每个方格可能包含任意数量的数据点。每个网格方格需要拥有自己的内部数据结构来存储其数据点。存储箱子内数据点的一种常见且有效的数据结构是链表，如图 8-9 所示。

![一个网格显示为四个箱子的列表（一个扁平化的矩阵），每个箱子指向一个数据点链表的起始位置。前三个箱子包含三个点，而最后一个箱子（xbin = 1，ybin = 1）包含两个点。](img/f08009.png)

图 8-9：用于存储网格中点的结构表示

每个箱子存储指向链表头部的指针，链表包含该箱子中的所有点。我们通过另一个内部数据结构来存储每个点，从而实现这一点：

```py
GridPoint {
    Float: x
    Float: y
    GridPoint: next
}
```

另外，我们也可以使用第三章中的`LinkedListNode`数据结构，存储一个表示* x *，* y *坐标的对。

### 构建网格并插入点

我们通过分配一个空的网格数据结构并使用一个单独的`FOR`循环遍历数据点，逐步插入点来构建数据集的网格。网格本身的高级结构（每个维度的空间边界和箱子的数量）在创建时是固定的，并不会随着添加的数据发生变化。

如列表 8-2 所示，插入点的过程包括找到正确的箱子并将新点添加到该箱子的链表的开头。

```py
GridInsert(Grid: g, Float: x, Float: y):
  ❶ Integer: xbin = Floor((x - g.x_start) / g.x_bin_width)
    Integer: ybin = Floor((y - g.y_start) / g.y_bin_width)

    # Check that the point is within the grid.
  ❷ IF xbin < 0 OR xbin >= g.num_x_bins:
        return False
    IF ybin < 0 OR ybin >= g.num_y_bins:
        return False

    # Add the point to the front of the list. 
  ❸ GridPoint: next_point = g.bins[xbin][ybin]
    g.bins[xbin][ybin] = GridPoint(x, y)
    g.bins[xbin][ybin].next = next_point

  ❹ return True
```

列表 8-2：插入新点到网格中的函数

代码首先计算新点的 x 和 y 箱子 ❶，并确认新点落在有效的箱子内 ❷。虽然在使用数组时始终重要的是确认你访问的是一个有效的数组索引，但空间数据结构还涉及额外的注意事项。我们可能无法为每一个可能的未来点预定义一个固定的、有限的网格。因此，考虑到当之前未见过的点落在空间数据结构所覆盖的范围之外时会发生什么，是非常重要的。在这个例子中，我们返回一个布尔值，表示该点是否能够被插入 ❹。然而，根据不同的编程语言，你可能更喜欢其他机制，比如抛出异常。

一旦我们确定该点适合我们的网格，代码就会找到合适的箱子。如果该箱子之前是空的，代码会将新点添加到列表的前端，并创建一个新的列表 ❸。函数最后通过返回`True` ❹来结束。

### 删除点

我们可以使用类似的插入方法来删除网格中的点。一个额外的难题是确定在箱子中要删除哪个点。在许多应用场景中，用户可能会向网格中插入任意接近甚至重复的点。例如，如果我们存储的是可供购买的地面咖啡列表，可能会为同一家咖啡店插入多个点。理想情况下，我们会使用其他识别信息，如咖啡的名称或 ID 编号，来确定删除哪个点。在这一部分，我们展示了删除链表中第一个匹配点的简单通用方法。

由于浮点变量的精度有限，我们也可能无法使用直接的相等测试。在列表 8-3 中，我们使用一个辅助函数来查找一个足够接近的点。`approx_equal`函数在两个点在两个维度上都在阈值距离内时返回`True`。

```py
approx_equal(Float: x1, Float: y1, Float: x2, Float: y2):
    IF abs(x1 – x2) > threshold:
        return False
    IF abs(y1 – y2) > threshold:
        return False
    return True
```

示例 8-3：检查是否两个数据点（表示为一对浮动小数）相等的代码

该代码独立检查每个维度，并将距离与阈值进行比较。阈值将取决于使用场景和编程语言的数值精度。通常，我们希望这些阈值足够大，以便能够考虑浮动小数的数值精度。

删除操作包括找到正确的桶，遍历链表直到找到匹配项，然后通过将其从链表中切除来删除该匹配项。如果找到并删除了一个点，我们的删除函数返回`True`，否则返回`False`。

```py
GridDelete(Grid: g, Float: x, Float: y):
  ❶ Integer: xbin = Floor((x - g.x_start) / g.x_bin_width)
    Integer: ybin = Floor((y - g.y_start) / g.y_bin_width)

    # Check that the point is within the grid.
  ❷ IF xbin < 0 OR xbin >= g.num_x_bins:
        return False
    IF ybin < 0 OR ybin >= g.num_y_bins:
        return False

    # Check if the bin is empty.
  ❸ IF g.bins[xbin][ybin] == null:
        return False

    # Find the first matching point and remove it.
  ❹ GridPoint: current = g.bins[xbin][ybin]
    GridPoint: previous = null
    WHILE current != null:
      ❺ IF approx_equal(x, y, current.x, current.y):
          ❻ IF previous == null:
                g.bins[xbin][ybin] = current.next
            ELSE:
                previous.next = current.next
 return True
      ❼ previous = current
        current = current.next
    return False
```

代码首先计算新点的 x 和 y 桶 ❶，并确认新点位于有效的桶内 ❷。接着，它检查目标桶是否为空 ❸，如果为空则返回`False`。

如果有需要检查的点，代码会遍历列表 ❹。与插入代码不同，我们跟踪当前节点和前一个节点，以便能够从列表中将目标节点切除。该代码使用来自示例 8-3 的`approx_equal`辅助函数测试每个点 ❺。当找到匹配的点时，它会将其从列表中切除，并正确处理列表中第一个节点的特殊情况 ❻，然后返回`True`。因此，只有列表中*第一个*匹配的点被删除。如果当前点不匹配，搜索将继续到列表中的下一个节点 ❼。如果搜索完成整个列表，函数返回`False`，表示没有删除匹配的节点。

## 网格搜索

现在我们已经学会了如何构造网格数据结构，让我们使用它们来改善最近邻搜索。首先，我们检查修剪远离的网格单元的问题，这将使我们避免在网格单元内进行不必要的计算。接着，我们考虑两种基本的搜索方式：对所有桶的线性扫描和扩展搜索。

### 修剪桶

网格的空间结构使我们能够限制需要检查的点的数量，排除掉那些不在我们感兴趣的范围内（佛罗里达州北部）。一旦我们得到了候选邻居及其相关的距离，我们可以利用这个距离来*修剪桶*。在检查桶内的点之前，我们会问是否*任何*位于桶空间范围内的点比当前最佳距离更近。如果没有，我们就可以忽略这个桶。

*确定桶内*任何*点是否在给定的距离内，可能听起来像是一个艰巨的任务。然而，如果我们使用欧几里得距离 ![i08001](img/i08001.png)，我们可以将其封装在这个简单的辅助函数中：

```py
euclidean_dist(Float: x1, Float: y1, Float: x2, Float: y2):
    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))
```

然后，测试简化为简单的数学运算。我们首先找到网格单元中最接近的点，并将其用于剪枝测试。具体而言，如果网格单元中最接近的点距离当前最佳候选点更远，则没有理由检查存储在该单元格中的任何实际点。它们都必须更远。如果目标点位于单元格内——也就是说，如果其 x 和 y 值分别在单元格的 x 和 y 范围内——则到单元格的距离（因此最接近的点的距离）为零。

如果点位于单元格外部，则单元格中最接近的点必须位于单元格的边缘。图 8-10 显示了网格单元外的多种点以及单元格内相应的最接近点。对于网格单元外的点，我们需要计算到最近边缘点的距离。

![八个目标点显示为灰色圆圈，它们在单元格内的最接近点。单元格外的目标点的最接近点位于单元格的边界。](img/f08010.png)

图 8-10：网格单元外的点（灰色圆圈）及单元格内相应的最接近点（实心圆圈）

我们可以通过分别考虑每个维度，计算一个点到网格单元边缘的欧几里得距离。我们找到将 x 值移到单元格范围内所需的最小距离，以及将 y 值移到单元格范围内所需的最小距离。对于网格单元格（*xbin*，*ybin*），最小和最大 x 和 y 维度为：

```py
x_min = x_start + xbin * x_bin_width
x_max = x_start + (xbin + 1) * x_bin_width
y_min = y_start + ybin * y_bin_width
y_max = y_start + (ybin + 1) * y_bin_width
```

我们可以按如下方式计算距离（以欧几里得距离为例）：

![g08002](img/g08002.png)

其中

如果 *x* < *x*_*min*，则 *x*[dist] *= x*_*min* − *x*

如果 *x*_*min* ≤ *x* ≤ *x*_*max*，则 *x*[dist] = 0

如果 *x* > *x*_*max*，则 *x*[dist] = *x* – *x*_*max*

以及

如果 *y* < *y_min*，则 *y*[dist] = *y_min* − *y*

如果 *y_min* ≤ *y* ≤ *y_max*，则 *y*[dist] = 0

如果*y* > *y_max*，则 *y*[dist] = *y* − *y_max*

如果到单元格中任何可能点的最小距离大于当前最接近点的距离，则单元格中的任何内容都无法替代当前的最接近点。我们可以忽略整个单元格！

计算点到单元格最小距离的代码可以封装成以下帮助函数。该函数实现了上述数学逻辑。

```py
MinDistToBin(Grid: g, Integer: xbin, Integer: ybin, Float: x, Float: y):
    # Check that the bin is valid.
  ❶ IF xbin < 0 OR xbin >= g.num_x_bins:
        return Inf
    IF ybin < 0 OR ybin >= g.num_y_bins:
        return Inf

  ❷ Float: x_min = g.x_start + xbin * g.x_bin_width
    Float: x_max = g.x_start + (xbin + 1) * g.x_bin_width
    Float: x_dist = 0
    IF x < x_min:
      x_dist = x_min - x
    IF x > x_max:
      x_dist = x - x_max

  ❸ Float: y_min = g.y_start + ybin * g.y_bin_width
    Float: y_max = g.y_start + (ybin + 1) * g.y_bin_width
    Float: y_dist = 0
    IF y < y_min:
      y_dist = y_min - y
    IF y > y_max:
      y_dist = y - y_max
    return sqrt(x_dist*x_dist + y_dist*y_dist)
```

列表 8-4：一个帮助函数，用于计算目标点到给定单元格的最短距离

代码首先检查容器索引是否有效 ❶。在这个例子中，我们使用无穷大作为距离，表示函数的调用者引用了一个无效的容器。这种逻辑使得我们可以在剪枝计算中使用此查找函数，查找可能涉及无效容器的情况。然而，这可能会导致混淆：为什么对于无效的容器，函数会返回某个距离？根据使用情况，可能更倾向于抛出错误，指出容器索引无效。无论哪种方式，函数的行为应当清晰地记录在文档中，供用户参考。

代码接下来按照上述的距离逻辑继续执行 x 和 y 维度的计算（❷ 和 ❸）。代码计算容器的最小值和最大值，将它们与点在该维度上的值进行比较，并计算距离。

为了直观地理解这个距离测试，想象一下，一个喧闹的接球游戏把球扔过我们的栅栏，落到我们友好但极其懒惰的邻居院子里。他们当然会把球扔回来，但不会付出超过绝对必要的任何努力。他们需要扔球的最短距离是多少，才能（勉强）把球送回我们的院子？如果他们的经度已经在我们院子的范围内，他们会朝纯粹的北方或南方扔球，以避免增加不必要的东西/西方向的距离。最终，他们的投掷总是正好落在栅栏上，使得球重新掉回我们的财产。我们的邻居虽然懒惰，但投掷技巧可真是惊人。

### 线性扫描过容器

搜索网格的最简单方法是使用线性扫描遍历所有网格容器，并只检查那些可能包含潜在最近邻居的容器。这不是一个特别好的算法，但它提供了一个简单的引入，帮助理解如何操作和剪枝容器。

线性搜索算法简单地对每个容器应用前述的最小距离测试，然后检查其内容：

```py
GridLinearScanNN(Grid: g, Float: x, Float: y): 
  ❶ Float: best_dist = Inf
    GridPoint: best_candidate = null

    Integer: xbin = 0
  ❷ WHILE xbin < g.num_x_bins:
        Integer: ybin = 0
        WHILE ybin < g.num_y_bins:

            # Check if we need to process the bin.
          ❸ IF MinDistToBin(g, xbin, ybin, x, y) < best_dist:

                # Check every point in the bin's linked list.
                GridPoint: current = g.bins[xbin][ybin]
              ❹ WHILE current != null:
                    Float: dist = euclidean_dist(x, y, current.x, current.y)
                  ❺ IF dist < best_dist:
                        best_dist = dist
                        best_candidate = current
                    current = current.next
            ybin = ybin + 1
        xbin = xbin + 1
  ❻ return best_candidate
```

列表 8-5：使用线性扫描过网格容器并在每个容器上进行剪枝测试的最近邻搜索。

代码首先将最佳距离设置为无穷大，表示目前尚未找到最佳点 ❶。然后，算法使用一对嵌套的`WHILE`循环对每个容器进行扫描，循环遍历 x 和 y 容器 ❷。在检查容器中的各个点之前，代码先执行最小距离测试，以检查容器中的*任何*点是否可能是更好的邻居 ❸。如果容器可能包含更好的邻居，代码使用第三个`WHILE`循环来遍历容器中点的链表 ❹。它测试与每个点的距离，并将其与迄今为止找到的最佳距离进行比较 ❺。函数最后返回找到的最佳候选点，如果网格为空，则可能返回`null` ❻。

清单 8-5 中的算法允许我们在确定某个箱子内的任何点到目标点的最小距离大于目前为止找到的最佳点的距离时，剔除整个箱子及其包含的所有点。如果每个箱子中的点数较多，这将带来显著的节省。然而，如果网格稀疏，我们可能会花费更多的时间去检查每个箱子，而不是逐个检查每个点。

与清单 8-2 中的`GridInsert`函数不同，我们的线性扫描可以处理网格空间边界内外的目标点。`GridLinearScanNN`不需要将目标点映射到某个箱子，因此不关心目标是否位于网格本身。它仍然会返回网格中的最近邻点（如果网格为空，则返回`null`）。这为我们的最近邻搜索提供了额外的灵活性，特别是在遇到新的、非典型的目标时。

### 理想的箱子扩展搜索

虽然线性扫描算法允许我们根据目标点的最小距离剔除整个箱子，但我们仍然没有充分利用手头的所有空间信息。通过测试距离目标点较远的箱子，我们浪费了大量计算。如果我们根据箱子与目标的接近程度来优先搜索箱子，先搜索离目标点最近的箱子，并在剩余的箱子距离我们找到的最近邻点更远时停止搜索，这样会更有效。我们称之为*扩展搜索*，因为我们实际上是从包含目标点的箱子扩展出去，直到找到最近的邻居。

为了形象地说明这种改进的扫描方法，想象一下早晨慌乱地寻找车钥匙。我们从车钥匙应该放置的区域开始（类似于一个网格单元）。我们仔细检查了厨房台面，直到承认钥匙肯定被放错了地方。然后，我们开始检查家中的其他地方（即其他箱子），先检查咖啡桌和地板附近的地方，随后继续向更远的地方搜索。这个搜索不断进行，探索那些不太可能的地方，直到我们发现钥匙神奇地出现在袜子抽屉里。

以图 8-11 为例，考虑我们的地图上叠加了一个四乘四的网格。我们通过问“我们的目标点落在哪个箱子里？”并使用网格索引映射公式来找到离目标点最近的箱子。由于目标点可能位于网格外部，我们还可能需要将计算出的箱子索引调整到有效范围内。在图 8-11 中，目标点位于最左列第三个箱子里（在我们的符号中，*xbin* = 0，*ybin* = 2）。

![图 8-3 中的地图点，放置在四乘四的网格中。](img/f08011.png)

图 8-11：一个二维点的 4×4 网格

我们可以从目标点所在的格子开始搜索，并测试该格子中的每个点。只要该格子不为空，我们就能找到我们的第一个*候选*最近邻，如图 8-12 所示。不幸的是，由于我们没有在每个格子内对点进行组织或排序，因此在这种情况下，我们无法比对该格子中的点进行线性扫描更高效。当然，如果初始格子为空，我们必须向外扩展搜索到相邻的格子，逐步尝试更远的格子，直到找到包含数据点的格子作为我们的候选最近邻。

![图 8-11 中的四×四网格地图点，带有虚线指向候选最近邻。第一个候选点位于同一个格子内。](img/f08012.png)

图 8-12：在与目标点相同的格子中找到的初始候选最近邻

一旦我们获得了这个初步的最近邻候选点，我们还没有完成。这个候选点仅仅是一个候选。很可能在相邻的格子中存在一个更近的点。如果目标点靠近格子的边缘，这种情况更为可能。在图 8-13 中，虚线圆圈表示所有比当前候选点更近或距离相等的点的空间。任何落在圆圈内的点都有可能是实际的最近邻。被阴影标示的网格单元就是与该区域重叠的部分。

![图 8-11 中的四×四网格地图点，带有虚线圆圈，显示距离当前候选邻居相等或更近的区域。与此圆圈重叠的四个网格单元被阴影标示，表明它们可能包含更近的邻居。](img/f08013.png)

图 8-13：候选最近邻和可能包含比目标点更近的点的网格单元

为了帮助理解为什么我们需要继续检查其他格子，假设你想在一个户外派对上找出离你最近的人。你正在讲一个特别尴尬的故事，涉及将变质的牛奶放入咖啡中，你希望确保只有目标听众能听到。站在房子旁边的最好朋友看起来可能离你最近，但如果你靠近围栏，你还需要考虑另一边的人。如果你的邻居正在沿着他们那边的围栏种花，他们可能实际上离你更近，能听到所有那些令人羞愧的细节。你不能因为围栏挡住了视线就忽视他们。这就是为什么我们总是检查相邻的格子——也就是为什么你在公共场合讲尴尬故事时需要小心。

我们继续扩展搜索，包含*所有*附近的单元格，直到可以保证剩余的单元格中没有比我们候选的最近邻更近的点。一旦我们检查了所有在最近邻半径范围内的单元格，就可以忽略超出该范围的单元格，甚至不需要检查它们的距离。

这种改进的网格搜索的权衡是算法复杂度。我们不再扫描每一个单元格——这个算法可以通过嵌套的`FOR`循环来实现——而是优化后的搜索从一个单元格开始螺旋式向外扩展，逐步探查更远的区域，直到我们能够证明没有未探索的单元格可能包含更好的邻居。这需要在搜索顺序（外向螺旋）、边界检查（避免测试网格边缘外的单元格）和终止条件（知道何时停止）中增加额外的逻辑。下一节将展示一个简化扩展搜索的简单示例，用于说明目的。

### 简化的扩展搜索

让我们考虑一个简化版（且未优化）的扩展搜索，该搜索以菱形模式向外移动。与从初始单元格执行完美的螺旋扩展不同，搜索使用了从初始单元格开始的逐步增大的距离。为了简化实现，我们将使用网格索引上的曼哈顿距离，它计算网格单元之间的步数：

*d* = |*xbin*[1] − *xbin*[2]| + |*ybin*[1] − *ybin*[2]|

虽然这种搜索模式对于在每个维度上具有显著不同单元格宽度的网格效率较低，但它提供了一个易于理解的示例。

图 8-14 显示了搜索的前四次迭代。在图 8-14(a)的第一次迭代中，我们搜索包含目标点的单元格（距离为零步）。在接下来的图 8-14(b)迭代中，我们搜索所有距离一步的单元格。在每次后续的迭代中，我们搜索所有距离目标点更远的一步单元格。

![扩展搜索的四次迭代示例。在第一次迭代中，包含目标点的单元格被阴影标记。在第二次迭代中，四个单元格，它们距离目标点一步之遥，被阴影标记。在第三次迭代中，八个单元格，它们距离目标点两步之遥，被阴影标记。](img/f08014.png)

图 8-14：网格上简化扩展搜索的前四次迭代

我们首先编写一个辅助函数，检查指定单元格内的任何点是否比给定的`threshold`更接近目标点(`x`, `y`)。这个函数实现了对单元格点的线性扫描。如果至少有一个点比`threshold`更近，函数将返回距离最近的点。使用阈值可以让我们使用此辅助函数将单元格的点与其他单元格的最佳候选进行比较。

```py
GridCheckBin(Grid: g, Integer: xbin, Integer: ybin, 
             Float: x, Float: y, Float: threshold):
    # Check that it is a valid bin and within the pruning threshold.
  ❶ IF xbin < 0 OR xbin >= g.num_x_bins:
        return null
    IF ybin < 0 OR ybin >= g.num_y_bins:
        return null

 # Check each of the points in the bin one by one.
    GridPoint: best_candidate = null
  ❷ Float: best_dist = threshold
    GridPoint: current = g.bins[xbin][ybin]
  ❸ WHILE current != null:
      ❹ Float: dist = euclidean_dist(x, y, current.x, current.y)
        IF dist < best_dist:
            best_dist = dist
            best_candidate = current
        current = current.next
  ❺ return best_candidate
```

示例 8-6：一个辅助函数，返回距离目标点最近的单元格，只要该单元格低于给定的阈值

代码首先进行安全检查，确保我们正在访问一个有效的区域 ❶。若无效，则返回`null`，表示没有有效的点。接着，代码使用`WHILE`循环遍历该区域内的每个点 ❸，计算其与目标点的距离，将其与迄今为止看到的最佳距离进行比较，并在更近时保存为新的最佳候选点 ❹。最后，代码返回最接近的点 ❺。由于代码在检查任何点之前，已将`best_dist`设置为`threshold`值 ❷，因此只有距离小于`threshold`的点才会被标记为新的候选点。如果该区域内没有点距离小于`threshold`，函数将返回`null`。

执行扩展搜索的代码通过不同步长的迭代，检查在该步长内可以到达的所有区域。与之前的搜索一样，我们会跟踪目前为止看到的最佳候选点。如果在*d*次迭代后，没有任何有效的网格单元在*d*步之内能包含一个更近的邻居，搜索就会结束。

```py
GridSearchExpanding(Grid: g, Float: x, Float: y):
    Float: best_d = Inf
    GridPoint: best_pt = null

  ❶ # Find the starting x and y bins for our search.
    Integer: xb = Floor((x - g.x_start) / g.x_bin_width)
    IF xb < 0:
        xb = 0
    IF xb >= g.num_x_bins:
        xb = g.num_x_bins - 1

    Integer: yb = Floor((y - g.y_start) / g.y_bin_width)
    IF yb < 0:
        yb = 0
    IF yb >= g.num_y_bins:
        yb = g.num_y_bins - 1

 Integer: steps = 0
    Boolean: explore = True
  ❷ WHILE explore:
        explore = False

      ❸ Integer: xoff = -steps
        WHILE xoff <= steps:
          ❹ Integer: yoff = steps - abs(xoff)
          ❺ IF MinDistToBin(g, xb + xoff, yb - yoff, x, y) < best_d:
              ❻ GridPoint: pt = GridCheckBin(g, xb + xoff, yb - yoff, 
                                             x, y, best_d)
                IF pt != null:
                    best_d = euclidean_dist(x, y, pt.x, pt.y)
                    best_pt = pt
              ❼ explore = True

          ❽ IF (MinDistToBin(g, xb + xoff, yb + yoff, x, y) < best_d
                AND yoff != 0):
                GridPoint: pt = GridCheckBin(g, xb + xoff, yb + yoff, 
                                             x, y, best_d)
                IF pt != null:
                    best_d = euclidean_dist(x, y, pt.x, pt.y)
                    best_pt = pt
              ❾ explore = True

            xoff = xoff + 1
        steps = steps + 1
    return best_pt
```

这段代码首先通过查找网格中离目标点最近的区域来开始，特别注意将网格外的目标点映射到网格内最近的区域 ❶。得到的区域（`xb`，`yb`）将作为搜索的起始点。通过将网格外的区域映射到有效区域，函数可以返回网格外目标点的最近邻。

接着，代码通过使用`WHILE`循环，从这个初始区域开始逐步向外扩展 ❷。变量`steps`跟踪当前迭代使用的步长。`WHILE`循环的条件由变量`explore`控制，这表示下一次迭代可能会包含一个有效的区域，因此我们应该继续在下一个步长值下进行探索。正如我们稍后会看到的，`WHILE`循环会在完成一次迭代后终止，如果*没有*一个区域的邻居比当前的更近。

在主`WHILE`循环中，代码会遍历从`-steps`到`steps`的不同 x 索引偏移，就像是在网格上水平扫描一样❸。x 方向和 y 方向的总步数由`steps`确定，因此代码可以通过编程计算在（正向或负向）y 方向上还需使用的步数❹。从负 y 方向开始，代码使用来自 Listing 8-4 的`MinDistToBin`来检查桶的索引是否有效，如果有效，则确定到该桶的距离❺。它可以跳过任何无效的或距离太远的桶。如果该桶可能包含比当前候选点更接近的点，代码会使用来自 Listing 8-6 的`GridCheckBin`来检查是否存在这样的点❻。每当找到更接近的点时，代码将其保存为新的最近候选点，并更新其对最短距离的估计。第二个`IF`块在 y 方向正向的情况下执行相同的检查，只要 y 偏移不为零（如果为零，则已经检查过负 y 方向的桶）❽。

在外部`WHILE`循环的一个迭代过程中❷，代码将`explore`重置为`False`。如果任何调用`MinDistToBin`的结果表明某个桶可能包含更接近的邻居（❼和❾），代码会将`explore`更新为`True`。因此，外部循环会继续，直到达到一个步骤数，在这个步骤数下，每个桶要么距离`best_d`更远，要么位于网格之外（因此是无效的）。虽然其他终止条件可能提供更精确的测试并提前终止，但由于其简便性，我们在代码中使用了这个规则。

## 网格大小的重要性

我们网格中桶的大小对搜索效率有巨大的影响。桶越大，我们可能需要检查每个桶中的更多点。记住，我们的网格搜索仍然会对每个访问到的桶中的点执行线性扫描。然而，将网格划分为更细的桶在内存和可能遇到的空桶数量上都有权衡。当我们缩小网格桶的大小时，我们通常需要搜索更多的单个桶，才能找到第一个候选最近邻，而且检查桶的成本也会增加。

Figure 8-15 显示了一个极端的情况，其中网格太细。

![图 8-3 中的地图点被放置在一个 17x17 的网格中。现在有 36 个桶比最近的邻居更近。](img/f08015.png)

图 8-15：一个细致的网格，其中大多数桶是空的

在 Figure 8-15 中，我们必须搜索 36 个桶才能找到最近的邻居。这显然比 Figure 8-13 中的例子更昂贵，在那个例子中我们只需要检查四个桶和两个单独的点。遗憾的是，它甚至可能比线性扫描搜索更昂贵，后者检查了所有 11 个数据点。

将其置于我们寻找咖啡店的背景下。如果我们将空间划分得过于精细，比如 1 米 × 1 米的方格，那么我们将面临一个大多数单元格都是空的网格。如果我们将空间划分得更粗糙，比如 5 公里 × 5 公里的方格，那么我们可能会将整个城市及其成群的咖啡店归为一个单元格，而仍然留下（令人震惊）大量几乎为空的单元格。

最优的网格大小通常取决于多个因素，包括点的数量及其分布。更复杂的技术，例如非均匀网格，可以用来动态适应数据。在下一章中，我们将讨论几种基于树的数据结构，它们能够动态地实现这种适应。

## 超越二维

为二维开发的基于网格的技术也可以扩展到高维数据。我们可能需要在一个多层的办公大楼中寻找最近的可用会议室。我们可以通过将 *z* 坐标纳入距离计算来搜索三维数据中的最近邻：

![g08003](img/g08003.png)

或者，更一般地，我们可以定义 *d* 维数据的欧几里得距离为：

![g08004](img/g08004.png)

其中 *x*[i][*d*] 是第 *i* 个数据点的 *d* 维度。

高维数据为我们在本章中讨论的基于网格的方法带来了另一个挑战：它要求我们沿更多维度划分空间。随着我们考虑更高维度，存储这种数据结构所需的空间会迅速爆炸。对于 *D* 维数据和每维 *K* 个单元格，我们需要 *K*^(*D*) 个单独的单元格！这可能需要大量的内存。图 8-16 展示了一个三维示例，一个 5×5×5 的网格，它已经包含了大量的单元格。

更糟的是，随着我们增加网格的单元数，我们可能会增加空单元格的比例。检查这些空单元格是浪费的工作。因此，网格方法并不适用于更高维度的问题。在下一章中，我们将介绍一种更好的方法来处理高维数据——k-d 树。

虽然很难想象一个日常空间问题会使用超过三维的数据，但我们可以将最近邻的思想应用于超越空间点的数据。在下一节中，我们将看到如何使用最近邻搜索帮助我们找到相似的咖啡馆或具有相似天气条件的日子。

![A five‐by‐five‐by‐five grid for three‐dimensional points.](img/f08016.png)

图 8-16：三维点的网格

## 超越空间数据

空间数据，如地图上的位置，为最近邻搜索和网格本身提供了一个简单的可视化示例。我们习惯于以接近度来思考位置，因为我们经常问自己类似“最近的加油站在哪里？”或“离会议中心最近的酒店在哪里？”这样的问题。然而，最近邻问题不仅仅局限于空间数据。

让我们考虑一个关键问题：当我们最喜欢的咖啡品牌缺货时，如何选择下一个最佳品牌。为了找到与我们最喜欢的咖啡相似的品牌，我们可以考虑喜欢的咖啡属性，比如强度或酸度，然后寻找其他具有相似属性的咖啡。我们可以扩展最近邻搜索来找到这些“接近”的咖啡。为此，我们首先记录下每一款曾品尝过的咖啡，记录其属性，如强度和酸度，如图 8-17 所示。

多年来，我们建立了一个全面的咖啡地理图谱。对这些数据执行最近邻搜索可以帮助我们找到与目标值相似的咖啡品种。需要寻找一种浓郁、低酸度的咖啡来为紧张的截止日期前的匆忙工作提供能量？我们能准确想象出我们想要的咖啡，那款我们曾在夏威夷品尝过的绝妙咖啡。不幸的是，接下来的截止日期没有足够的时间来支持我们去夏威夷一趟。但不用担心！我们利用对咖啡属性的全面分析（记录在我们的咖啡日志中）来定义搜索目标，然后寻找一个可能足够相似的本地品牌。

![左图是一个二维数据点的图，x 轴标记为强度，y 轴标记为酸度。右图是相同的点，覆盖了一个网格。](img/f08017b.png)

图 8-17：咖啡属性作为二维数据的示例（左图）以及这些点在网格中的位置（右图）

为了执行此搜索，我们只需要一种计算咖啡强度或酸度等属性距离的方法。最近邻算法依赖于我们区分“近”邻居和“远”邻居的能力。虽然有可能为其他类型（如字符串）定义距离度量，但为了保持一致性，本章将讨论实际值属性。

对于空间数据点，我们有简单的标准度量来计算两个点（*x*[1]*, y*[1]）和（*x*[2]*, y*[2]）之间的距离，例如之前使用的欧几里得距离*。* 但任何问题的最优距离度量将取决于问题本身。当评估咖啡品牌时，我们可能希望在不同的情况下以不同的方式加权各个属性。在即将到来的截止日期之前，咖啡因含量比酸度等因素更为重要。

一种常见的非空间数据距离度量是加权欧几里得距离：

![g08005](img/g08005.png)

其中，*x*[*i*][*d*]表示第*i*个数据点的第*d*维度，*w*[*d*]表示第*d*维度的权重。这个公式允许我们对不同维度的影响进行加权。在这种情况下，我们可以将咖啡因含量的权重设置为酸度的两倍，从而将搜索偏向于咖啡因含量相似的咖啡。我们甚至可以根据每次搜索的需求调整权重。

当然，我们的搜索无法保证咖啡的其他方面是否适合。我们仅仅是在衡量指定维度上的接近度。如果我们只通过强度和酸度来匹配寻找日常咖啡，那么我们不会考虑烘焙程度、批次大小、种植条件、咖啡因含量，甚至土壤中的营养物质浓度。如果最近的邻居是无咖啡因的咖啡，我们的搜索将无法考虑到这一灾难。我们只会得到低质量的咖啡和失望的泪水。确保你的距离计算考虑到所有相关维度是很重要的。

## 为什么这很重要

最近邻搜索使我们能够找到与某个目标值“接近”的点，无论是空间的还是非空间的。从算法角度来看，最近邻搜索使我们从寻找精确目标转向基于距离度量进行搜索。当我们从一维数据集进入多维数据领域时，搜索的细节变得更加复杂。正如我们从数组到网格的转变所看到的，这种扩展带来了许多新的问题，涉及我们如何组织和搜索数据。我们不再能够像对一维数据进行二分查找时那样考虑简单的排序。我们需要将数据结构调整为一种新的多维结构类型。网格提供了一种新的数据组织方式，通过将相同空间区域内的点聚集到同一个桶中来结构化数据。

与我们在数组中看到的“一个桶一个值”的结构不同，网格展示了一种不同的结构。网格使用链表或其他内部数据结构在每个桶中存储多个值，这是我们将在未来章节中复用的一种技术。通过使用这种结构，网格还引入了一个新的权衡需要考虑——桶的大小。通过增加桶的大小，我们可以将成本从评估多个小桶转移到扫描每个桶中的大量数据点。选择合适数量的桶是*调优*数据结构以解决具体问题的一个常见任务。

在下一章中，我们将通过将树的自适应特性与网格的空间特性结合，进一步探讨空间划分。这样做，我们将解决网格的一些主要缺点——并使寻找一杯好咖啡的过程显著更高效。
