["```py\nimport urllib.request\n\ndef url_to_html(url):\n    html = urllib.request.urlopen(url).read()\n    return html\n```", "```py\n<a href='nostarch.com'>**<span>**Python One-Liners</a>\n```", "```py\n<a href='nostarch.com'><span>Python One-Liners</span></a>\n```", "```py\n<a href='nostarch.com'>\n    <span>\n        Python One-Liners\n    </span>\n</a>\n```", "```py\nimport urllib.request\nimport re\n\ndef url_to_html(url):\n    html = urllib.request.urlopen(url).read()\n    return html\n\ndef prettify_html(html):\n    return re.sub('<\\s+', '<', html)\n\ndef fix_missing_tags(html):\n    if not re.match('<!DOCTYPE html>', html):\n        html = '<!DOCTYPE html>\\n' + html\n    return html\n\ndef display_html(url):\n    html = url_to_html(url)\n    fixed_html = fix_missing_tags(html)\n    prettified_html = prettify_html(fixed_html)\n    return prettified_html\n```", "```py\nprint(display_html('https://finxter.com'))\n```", "```py\n<!DOCTYPE html>\n<a href=\"https://finxter.com\">Solve next Puzzle</a>\n```", "```py\ndef display_html(url):\n    html = urllib.request.urlopen(url).read()\n    if not re.match('<!DOCTYPE html>', html):\n        html = '<!DOCTYPE html>\\n' + html\n    html = re.sub('<\\s+', '<', html)\n    return html\n```", "```py\n> import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\n**Simple is better than complex.**\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n```", "```py\nimport numpy as np\n\ndef calculate_average_age(*args):\n    a = np.array(args)\n    return np.average(a)\n\nprint(calculate_average_age(19, 20, 21))\n# 20.0\n```", "```py\ndef average(*args):\n    return sum(args) / len(args)\n\nprint(average(19, 20, 21))\n# 20.0\n```", "```py\nProperty Number,Date,Brand,Model,Color,Stolen,Stolen From,Status,Incident number,Agency\nP13827,01/06/2016,HI POINT,9MM,BLK,Stolen Locally,Vehicle,Recovered Locally,B16-00694,BPD\nP14174,01/15/2016,JENNINGS J22,,COM,Stolen Locally,Residence,Not Recovered,B16-01892,BPD\nP14377,01/24/2016,CENTURY ARMS,M92,,Stolen Locally,Residence,Recovered Locally,B16-03125,BPD\nP14707,02/08/2016,TAURUS,PT740 SLIM,,Stolen Locally,Residence,Not Recovered,B16-05095,BPD\nP15042,02/23/2016,HIGHPOINT,CARBINE,,Stolen Locally,Residence,Recovered Locally,B16-06990,BPD\nP15043,02/23/2016,RUGAR,,,Stolen Locally,Residence,Recovered Locally,B16-06990,BPD\nP15556,03/18/2016,HENRY ARMS,.17 CALIBRE,,Stolen Locally,Residence,Recovered Locally,B16-08308,BPD\n```", "```py\nFrom sklearn.datasets import fetch_olivetti_faces\nFrom numpy.random import RandomState\n\nrng = RandomState(0)\n\n# Load faces data\nfaces, _ = fetch_olivetti_faces(...)\n```", "```py\n## Dependencies\nimport re\n\n## Data\npage = '''\n<!DOCTYPE html>\n<html>\n<body>\n\n<h1>My Programming Links</h1>\n<a href=\"https://app.finxter.com/\">test your Python skills</a>\n<a href=\"https://blog.finxter.com/recursion/\">Learn recursion</a>\n<a href=\"https://nostarch.com/\">Great books from NoStarchPress</a>\n<a href=\"http://finxter.com/\">Solve more Python puzzles</a>\n\n</body>\n</html>\n'''\n\n## One-Liner\npractice_tests = re.findall(\"(<a.*?finxter.*?(test|puzzle).*?>)\", page)\n\n## Result\nprint(practice_tests)\n# [('<a href=\"https://app.finxter.com/ \">test your Python skills</a>', 'test'),\n#  ('<a href=\"http://finxter.com/\">Solve more Python puzzles</a>', 'puzzle')]\n```", "```py\ndef your_life_expectancy():\n    age = int(input('how old are you? '))\n\n    if age<85:\n        exp_years = 72 - 0.8 * age\n    else:\n        exp_years = 22 - 0.2 * age\n\n    print(f'People your age have on average {exp_years} years left - use them wisely!')\n\nyour_life_expectancy()\n```", "```py\n> how old are you? 10\nPeople your age have on average 64.0 years left - use them wisely!\n> how old are you? 20\nPeople your age have on average 56.0 years left - use them wisely!\n> how old are you? 77\nPeople your age have on average 10.399999999999999 years left - use them wisely!\n```", "```py\n# Functionality\ndef your_life_expectancy(age):\n    if age<85:\n        return 72 - 0.8 * age\n    return 22 - 0.2 * age\n\n# User Interface\nage = int(input('how old are you? '))\n\n# Combine user input with functionality and print result\nexp_years = your_life_expectancy(age)\nprint(f'People your age have on average {exp_years} years left - use them wisely!')\n```", "```py\nimport matplotlib.pyplot as plt\n\ndef your_life_expectancy(age):\n    '''Returns the expected remaining number of years.'''\n    if age<85:\n return 72 - 0.8 * age\n    return 22 - 0.2 * age\n\n# Plot for first 100 years\nplt.plot(range(100), [your_life_expectancy(i) for i in range(100)])\n\n# Style plot\nplt.xlabel('Age')\nplt.ylabel('No. Years Left')\nplt.grid()\n\n# Show and save plot\nplt.savefig('age_plot.jpg')\nplt.savefig('age_plot.pdf')\nplt.show()\n```", "```py\ndef insert_sort(lst):\n\n    # Check if the list is empty\n    if not lst:\n        return []\n\n    # Start with sorted 1-element list\n    new = [lst[0]]\n\n    # Insert each remaining element\n    for x in lst[1:]:\n        i = 0\n        while i<len(new) and x>new[i]:\n            i = i + 1\n        new.insert(i, x)\n\n    return new\n\nprint(insert_sort([42, 11, 44, 33, 1]))\nprint(insert_sort([0, 0, 0, 1]))\nprint(insert_sort([4, 3, 2, 1]))\n```", "```py\ndef average(*args):\n    print(sum(args)/len(args))\n\naverage(1, 2, 3)\n# 2.0\n```", "```py\ndef average(*args):\n    return sum(args)/len(args)\n\navg = average(1, 2, 3)\nprint(avg)\n# 2.0\n```", "```py\ndef bubblesort(l):\n    for boundary in range(len(l)-1, 0, -1):\n        for i in range(boundary):\n            if l[i] > l[i+1]:\n                l[i], l[i+1] = l[i+1], l[i]\n    return l\n\nl = [5, 3, 4, 1, 2, 0]\nprint(bubblesort(l))\n# [0, 1, 2, 3, 4, 5]\n```", "```py\ndef bubblesort_clever(l):\n    for boundary in range(len(l)-1, 0, -1):\n        for i in range(boundary):\n            l[i], l[i+1] = (l[i+1], l[i]) if l[i] > l[i+1] else (l[i], l[i+1])            \n    return l    \n\nprint(bubblesort_clever(l))\n# [0, 1, 2, 3, 4, 5]\n```", "```py\ndef classify(wave):\n    # Do the classification\n    word = wave_to_word(wave)    # to be implemented\n\n    # Check if another wave\n # results in the same word\n    if duplicate_check(wave, word):\n\n        # Do not return a random guess\n # and hide the error!\n        raise ClassificationError('Not Understood')\n\n    return word\n```"]