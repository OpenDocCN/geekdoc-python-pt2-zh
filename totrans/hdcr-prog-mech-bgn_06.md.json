["```py\nimport math\n\ndef are_close_enough(a, b, tolerance=1e-10):\n    return math.fabs(a - b) < tolerance\n```", "```py\nare_close_enough(num, 1.0, 1e-5)\n```", "```py\nare_close_enough(num, 0.0, 1e-5)\n```", "```py\n--snip--\n\ndef is_close_to_zero(a, tolerance=1e-10):\n    return are_close_enough(a, 0.0, tolerance)\n\ndef is_close_to_one(a, tolerance=1e-10):\n    return are_close_enough(a, 1.0, tolerance)\n```", "```py\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n```", "```py\nimport math\n\nclass Point:\n    --snip--\n\n    def distance_to(self, other):\n        delta_x = other.x - self.x\n        delta_y = other.y - self.y\n        return math.sqrt(delta_x ** 2 + delta_y ** 2)\n```", "```py\n>>> from geom2d.point import Point\n>>> p = Point(1, 3)\n>>> q = Point(2, 4)\n>>> p.distance_to(q)\n1.4142135623730951\n```", "```py\n>>> p\n<geom2d.point.Point object at 0x10f8a2588>\n\n>>> p.__dict__\n{'x': 1, 'y': 3}\n```", "```py\nclass Point:\n    --snip--\n\n   def __add__(self, other):\n       return Point(\n           self.x + other.x,\n           self.y + other.y\n       )\n\n   def __sub__(self, other):\n       return Point(\n           self.x - other.x,\n           self.y - other.y\n       )\n```", "```py\nclass Vector:\n    def __init__(self, u, v):\n        self.u = u\n        self.v = v\n```", "```py\nimport math\n\nfrom geom2d.vector import Vector\n\nclass Point:\n    --snip--\n\n    def __sub__(self, other):\n        return Vector(\n            self.x - other.x,\n            self.y - other.y\n        )\n```", "```py\nclass Vector:\n    --snip--\n\n    def __add__(self, other):\n        return Vector(\n            self.u + other.u,\n            self.v + other.v\n        )\n\n    def __sub__(self, other):\n        return Vector(\n            self.u - other.u,\n            self.v - other.v\n        )\n```", "```py\nclass Vector:\n    --snip--\n\n   def scaled_by(self, factor):\n       return Vector(factor * self.u, factor * self.v)\n```", "```py\nclass Point:\n    --snip--\n\n   def displaced(self, vector: Vector, times=1):\n       scaled_vec = vector.scaled_by(times)\n       return Point(\n           self.x + scaled_vec.u,\n           self.y + scaled_vec.v\n       )\n```", "```py\n>>> from geom2d.point import Point\n>>> from geom2d.vector import Vector\n\n>>> p = Point(2, 3)\n>>> v = Vector(10, 20)\n>>> p_prime = p.displaced(v, 2)\n>>> p_prime.__dict__\n{'x': 22, 'y': 43}\n```", "```py\nimport math\n\nfrom geom2d import nums\n\nclass Vector:\n    --snip--\n\n    @property\n    def norm(self):\n        return math.sqrt(self.u ** 2 + self.v ** 2)\n\n    @property\n    def is_normal(self):\n        return nums.is_close_to_one(self.norm)\n```", "```py\nclass Vector:\n    --snip--\n\n   def normalized(self):\n       return self.scaled_by(1.0 / self.norm)\n\n   def with_length(self, length):\n       return self.normalized().scaled_by(length)\n```", "```py\ndef normalize(self):\n   norm = self.norm\n    self.x = self.x / norm\n    self.y = self.y / norm\n```", "```py\ndef normalize(self):\n    self.x = self.x / self.norm\n    self.y = self.y / self.norm\n```", "```py\nclass Vector:\n    --snip--\n\n   def dot(self, other):\n       return (self.u * other.u) + (self.v * other.v)\n```", "```py\nclass Vector:\n    --snip--\n\n   def projection_over(self, direction):\n       return self.dot(direction.normalized())\n```", "```py\nclass Vector:\n    --snip--\n\n   def cross(self, other):\n       return (self.u * other.v) - (self.v * other.u)\n```", "```py\nclass Vector:\n    --snip--\n\n   def is_parallel_to(self, other):\n       return nums.is_close_to_zero(\n           self.cross(other)\n       )\n\n   def is_perpendicular_to(self, other):\n       return nums.is_close_to_zero(\n           self.dot(other)\n       )\n```", "```py\nclass Vector:\n    --snip--\n\n   def angle_value_to(self, other):\n       dot_product = self.dot(other)\n       norm_product = self.norm * other.norm\n       return math.acos(dot_product / norm_product)\n\n   def angle_to(self, other):\n       value = self.angle_value_to(other)\n       cross_product = self.cross(other)\n       return math.copysign(value, cross_product)\n```", "```py\n>>> from geom2d.vector import Vector\n>>> u = Vector(1, 0)\n>>> v = Vector(1, 1)\n\n>>> v.angle_value_to(u)\n0.7853981633974484 # result in radians\n\n>>> v.angle_to(u)\n-0.7853981633974484 # result in radians\n```", "```py\nclass Vector:\n    --snip--\n\n   def rotated_radians(self, radians):\n       cos = math.cos(radians)\n       sin = math.sin(radians)\n       return Vector(\n           self.u * cos - self.v * sin,\n           self.u * sin + self.v * cos\n       )\n```", "```py\nclass Vector:\n    --snip--\n\n   def perpendicular(self):\n       return Vector(-self.v, self.u)\n```", "```py\nclass Vector:\n    --snip--\n\n   def opposite(self):\n       return Vector(-self.u, -self.v)\n```", "```py\nclass Vector:\n    --snip--\n\n    @property\n    def sine(self):\n        return self.v / self.norm\n\n    @property\n    def cosine(self):\n        return self.u / self.norm\n```", "```py\n  >>> from geom2d.point import Point\n  >>> p = Point(1, 0)\n  >>> p == p\n➊  True\n\n  >>> q = Point(1, 0)\n  >>> p == q\n➋  False\n```", "```py\n>>> p\n<geom2d.point.Point object at 0x10baa3f60>\n\n>>> q\n<geom2d.point.Point object at 0x10c63b438>\n```", "```py\nimport math\n\nfrom geom2d import nums\n\nclass Point:\n   --snip--\n\n   def __eq__(self, other):\n      if self is other:\n           return True\n\n       if not isinstance(other, Point):\n           return False\n\n       return nums.are_close_enough(self.x, other.x) and \\\n              nums.are_close_enough(self.y, other.y)\n```", "```py\nimport math\n\nfrom geom2d import nums\n\nclass Vector:\n   --snip--\n\n   def __eq__(self, other):\n      if self is other:\n           return True\n\n       if not isinstance(other, Vector):\n           return False\n\n       return nums.are_close_enough(self.u, other.u) and \\\n              nums.are_close_enough(self.v, other.v)\n```", "```py\n>>> from geom2d.point import Point\n>>> p = Point(1, 0)\n>>> p == p\nTrue\n\n>>> q = Point(1, 0)\n>>> p == q\nTrue\n```", "```py\n>>> from geom2d.vector import Vector\n>>> v = Vector(2, 3)\n>>> v\n<geom2d.vector.Vector object at 0x10c63b438>\n```", "```py\n>>> str(p)\n'<geom2d.vector.Vector object at 0x10c63b438>'\n```", "```py\n>>> str(p)\n'(2, 5) with norm 5.385164807134504'\n```", "```py\nclass Point:\n   --snip--\n\n   def __str__(self):\n       return f'({self.x}, {self.y})'\n```", "```py\nclass Vector:\n   --snip--\n\n   def __str__(self):\n       return f'({self.u}, {self.v}) with norm {self.norm}'\n```", "```py\nf'({self.x}, {self.y})'\n```", "```py\n\"(\" + str(self.x) + \", \" + str(self.y) + \")\"\n```", "```py\n>>> from geom2d.vector import Vector\n>>> v = Vector(2, 3)\n>>> str(v)\n'(2, 3) with norm 3.605551275463989'\n```", "```py\n    make_vector_between(p, q)\n```", "```py\n    Vector(q.x - p.x, q.y - p.y)\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.vector import Vector\n\ndef make_vector_between(p: Point, q: Point):\n    return q - p\n\ndef make_versor(u: float, v: float):\n    return Vector(u, v).normalized()\n\ndef make_versor_between(p: Point, q: Point):\n    return make_vector_between(p, q).normalized()\n```", "```py\n  import unittest\n\n  from geom2d.point import Point\n\n➊ class TestPoint(unittest.TestCase):\n\n   ➋ def test_distance_to(self):\n          p = Point(1, 2)\n          q = Point(4, 6)\n          expected = 5\n          actual = p.distance_to(q)\n\n       ➌ self.assertAlmostEqual(expected, actual)\n```", "```py\n--snip--\n\nRan 1 test in 0.001s\n\nOK\n\nProcess finished with exit code 0\n```", "```py\n$ python3 -m unittest geom2d/point_test.py\n```", "```py\nRan 1 tests in 0.000s\n\nOK\n```", "```py\nexpected = 567\n```", "```py\nRan 1 test in 0.006s\n\nFAILED (failures=1)\n\nFailure\nTraceback (most recent call last):\n  --snip--\n  File \".../geom2d/tests/point_test.py\", line 14, in test_distance_to\n    self.assertAlmostEqual(expected, actual)\n  --snip--\n\nAssertionError: 567 != 5.0 within 7 places (562.0 difference)\n```", "```py\nimport unittest\n\nfrom geom2d.vector import Vector\n\nclass TestVector(unittest.TestCase):\n    u = Vector(1, 2)\n    v = Vector(4, 6)\n\n    def test_plus(self):\n        expected = Vector(5, 8)\n        actual = self.u + self.v\n        self.assertEqual(expected, actual)\n\n    def test_minus(self):\n        expected = Vector(-3, -4)\n        actual = self.u - self.v\n        self.assertEqual(expected, actual)\n```", "```py\n<geom2d.vector.Vector object at 0x10fd8d198> !=\n<geom2d.vector.Vector object at 0x10fd8d240>\n\nExpected :<geom2d.vector.Vector object at 0x10fd8d240>\nActual   :<geom2d.vector.Vector object at 0x10fd8d198>\n```", "```py\nimport unittest\n\nfrom geom2d.vector import Vector\n\nclass TestVector(unittest.TestCase):\n\n    --snip--\n\n    def test_dot_product(self):\n        expected = 16\n        actual = self.u.dot(self.v)\n        self.assertAlmostEqual(expected, actual)\n\n    def test_cross_product(self):\n        expected = -2\n        actual = self.u.cross(self.v)\n        self.assertAlmostEqual(expected, actual)\n```", "```py\nimport unittest\n\nfrom geom2d.vector import Vector\n\nclass TestVector(unittest.TestCase):\n\n    --snip--\n\n    def test_are_parallel(self):\n        self.assertTrue(self.u.is_parallel_to(self.u))\n\n    def test_are_not_parallel(self):\n        self.assertFalse(self.u.is_parallel_to(self.v))\n```", "```py\nimport unittest\n\nfrom geom2d.vector import Vector\n\nclass TestVector(unittest.TestCase):\n\n    --snip--\n\n    def test_are_perpendicular(self):\n        perp = Vector(-2, 1)\n        self.assertTrue(self.u.is_perpendicular_to(perp))\n\n    def test_are_not_perpendicular(self):\n        self.assertFalse(self.u.is_perpendicular_to(self.v))\n```", "```py\ndef test_are_perpendicular(self):\n    perp = Vector(-2, 1)\n    self.assertTrue(self.u.is_perpendicular_to(perp))\n```", "```py\ndef test_are_perpendicular(self):\n    perp = u.perpendicular()\n    self.assertTrue(self.u.is_perpendicular_to(perp))\n```", "```py\nclass TestSwitch(unittest.TestCase):\n\n   switch = Switch()\n\n   def test_switch_on(self):\n    self.switch.on()\n    self.assertTrue(self.switch.is_on())\n\n   def test_switch_off(self):\n    # Last test should have switched on\n    self.switch.toggle()\n    self.assertTrue(self.switch.is_off())\n```"]