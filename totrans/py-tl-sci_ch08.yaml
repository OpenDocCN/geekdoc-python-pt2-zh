- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: VARIABLES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Variables are one of the most important concepts for beginning programmers to
    understand, so this chapter explores these features in detail. Technically speaking,
    a variable is a reserved memory location used to store values. It’s a reference,
    or *pointer*, to an object in memory, but it’s not the object itself. Variables
    let you access and manipulate each object’s associated metadata (*attributes*)
    and functionality (*methods*).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是初学编程者需要理解的最重要概念之一，因此本章详细探讨了这些特性。从技术角度讲，变量是一个用来存储值的保留内存位置。它是指向内存中对象的引用或*指针*，但它本身不是对象。变量让你能够访问和操作每个对象的相关元数据（*属性*）和功能（*方法*）。
- en: In the previous chapter, you learned how to assign variables. In this chapter,
    you’ll learn more about assignment statements, discover how to name variables
    clearly, use a built-in function to get a user’s input, and practice comparing
    one variable to another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，你学习了如何赋值给变量。在这一章，你将进一步了解赋值语句，学习如何清晰地命名变量，使用内建函数获取用户输入，并练习比较一个变量和另一个变量。
- en: '**Variables Have Identities**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变量具有标识**'
- en: Python encapsulates data and the functions that operate on that data into named
    entities known as *objects*. As the fundamental building block for the language,
    everything in Python is an object, and every object has an *identity* (memory
    address), a *type*, and a *value*. The number 42 is an object as well as the sentence
    “Hello, world!” An object’s identity and type never change, but its values can
    sometimes be changed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将数据和操作这些数据的函数封装到被称为*对象*的命名实体中。作为语言的基本构建块，Python 中的一切都是对象，每个对象都有一个*标识*（内存地址）、*类型*和*值*。数字
    42 是一个对象，句子“Hello, world!”也是一个对象。对象的标识和类型永远不会改变，但它的值有时是可以改变的。
- en: Variables can be thought of as labels for objects. Just as you can be referred
    to by multiple names and nicknames ([Figure 8-1](ch08.xhtml#ch08fig1)), an object
    in Python can be referenced by many variables.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以被看作是对象的标签。就像你可以有多个名字和昵称（[图 8-1](ch08.xhtml#ch08fig1)），Python 中的一个对象也可以通过多个变量进行引用。
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig01.jpg)'
- en: '*Figure 8-1: We can go by multiple names; so can objects in Python.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：我们可以有多个名字；Python 中的对象也是如此。*'
- en: When you use an assignment statement, such as `x = 5`, the variable `x` is initialized
    as a reference to the object on the right-hand side of the equal sign. It’s also
    given an integer number as an identity. This number is unique for all existing
    objects. You can view this number with the built-in `id()` function that ships
    with Python. Note that the ID numbers you see on your computer might be different
    from mine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用赋值语句，比如 `x = 5`，变量 `x` 会被初始化为引用等号右侧的对象。它还会被赋予一个作为标识的整数。这个数字对于所有现有对象都是唯一的。你可以通过
    Python 内建的 `id()` 函数查看这个数字。注意，你在电脑上看到的 ID 号码可能与你看到的不同。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can overwrite a variable by assigning it a new value:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过赋予一个新值来覆盖一个变量：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reassigned `x` now has a new identity. In the first example, the variable
    `x` is a reference to an integer object with a value of `5`. When you overwrite
    `x` with the new value of `15`, the old object continues to exist, but if no variable
    is referencing it, its *reference count* goes to zero. At this point, it’s subject
    to *garbage collection*, the process by which Python periodically reclaims blocks
    of memory that are no longer in use. In some other languages, you must manually
    designate and free memory allocations in your code. Python’s ability to automatically
    manage memory and “clean up its own mess” makes it a very friendly language!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重新赋值后的 `x` 现在有了新的标识。在第一个例子中，变量 `x` 是对一个值为 `5` 的整数对象的引用。当你用新值 `15` 覆盖 `x` 时，旧对象继续存在，但如果没有其他变量引用它，它的*引用计数*将归零。此时，它将进入*垃圾回收*过程，Python
    会定期回收不再使用的内存块。在一些其他语言中，你必须手动指定并释放内存分配。而 Python 能够自动管理内存并“清理自己的垃圾”，这使得它成为一个非常友好的语言！
- en: 'Because variables are just references, multiple variables can point to the
    same object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量只是引用，所以多个变量可以指向同一个对象：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By assigning `x` to `y` in line `In [7]`, both variables now reference the same
    object, as evidenced by their having the same identity. This type of memory-efficient
    behavior is called *aliasing*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `In [7]` 行将 `x` 赋值给 `y`，两个变量现在都引用同一个对象，这从它们具有相同标识可以看出。这种内存高效的行为叫做*别名*。
- en: 'If you overwrite `x`, its identity will change, but `y` will still point to
    the “old” object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你覆盖了`x`，它的身份会改变，但`y`仍然指向“旧”对象：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As a result, the old object has a reference count greater than one, so it will
    not be deleted during garbage collection and will hang around for you to use in
    expressions, functions, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，旧对象的引用计数大于一，因此它不会在垃圾回收时被删除，并且会保留供你在表达式、函数等中使用。
- en: '**Assigning Variables**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**赋值变量**'
- en: Assigning a value to a variable is known as *binding* in Python. In addition
    to the straightforward “x = y” method for assigning variables, you can also do
    so using expressions, operator overloading, functions, and more. Basically, both
    values and things that return values can be assigned to a variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 给变量赋值在 Python 中被称为*绑定*。除了直接使用“x = y”方法赋值外，你还可以使用表达式、操作符重载、函数等进行赋值。基本上，既可以赋值给变量值，也可以赋值给返回值的东西。
- en: '***Using Expressions***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用表达式***'
- en: 'The result of expressions can be assigned to a variable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的结果可以赋值给一个变量：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***Operator Overloading***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作符重载***'
- en: Likewise, you can use operator overloading when assigning variables. As discussed
    in the previous chapter, operator overloading refers to the ability of an operator
    to work in a different manner with different data types. The classic example is
    using the `+` sign to add numbers *and* concatenate strings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以在赋值变量时使用操作符重载。正如前一章所讨论的，操作符重载是指操作符能够以不同的方式与不同的数据类型一起工作。经典的例子是使用`+`号既用于加法运算*也*用于字符串连接。
- en: 'Operator overloading works directly with strings or with other variables. Here,
    we use it with strings:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符重载直接作用于字符串或其他变量。这里，我们与字符串一起使用它：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here, with variables:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用变量的示例：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In line `In [20]`, notice how I added a space between names. Without it, the
    printout would be `HariSeldon`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`In [20]`这一行，注意我在名称之间添加了空格。没有它，输出将会是`HariSeldon`。
- en: 'Here’s another example of operator overloading:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个操作符重载的例子：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how you can use precedence with the operators. To see the impact, run
    line `In [22]` again *without* the parentheses and print the result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你可以使用操作符的优先级来控制顺序。要查看效果，可以再次运行`In [22]`，*去掉*括号并打印结果。
- en: '***Using Functions***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用函数***'
- en: 'Although we haven’t covered them yet, you can use functions in assignment statements.
    Here, we’ll use the built-in `count()` string method with an assignment statement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尚未讲解它们，你可以在赋值语句中使用函数。在这里，我们将使用内建的`count()`字符串方法与赋值语句结合：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the `count()` method returned the value `1`, which was then stored
    in the variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`count()`方法返回了值`1`，然后将其存储在变量中。
- en: '***Chained Assignment and Internment***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***链式赋值与内存驻留***'
- en: 'You can simultaneously assign the same value to multiple variables using a
    *chained assignment*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过*链式赋值*同时将相同的值赋给多个变量：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Interestingly, Python doesn’t create a new object for each of these variables;
    they all have the same identity:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Python 并不会为这些变量创建新的对象；它们都共享相同的身份：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To improve processing speed, Python creates a small cache of memory addresses
    at startup. It uses some of these for a list of small integer values (`-5` to
    `256`). The programming practice of using references in place of copies of equal
    objects is called *interning*. Larger values not in the cache will get new addresses.
    For example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高处理速度，Python 在启动时会创建一个小型的内存地址缓存。它会为一些小整数值（`-5`到`256`）使用这些缓存中的地址。将引用用于等价对象副本的编程实践被称为*内存驻留*。不在缓存中的较大值将会得到新的地址。例如：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Some strings are also interned by Python as an optimization. As Python code
    is compiled, identifiers such as variable names, function names, and class names
    are interned. Other strings may be interned, as well. Python automatically makes
    this determination on a code-by-code basis.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符串也会被 Python 自动驻留，以优化性能。当 Python 代码被编译时，诸如变量名、函数名和类名这样的标识符会被驻留。其他字符串也可能被驻留。Python
    会基于代码逐行地自动决定是否驻留。
- en: An advantage of string interning is that when you’re comparing two variables
    Python can compare *memory addresses*. This is faster than comparing each string
    character by character.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串驻留的一个优点是，当你比较两个变量时，Python 可以比较*内存地址*。这比逐个字符比较字符串要快。
- en: Generally, Python’s default interning is more than sufficient, but you should
    never rely on it. If you ever need to *ensure* that a string is interned, import
    the system module (`import sys`) and use the `sys.intern()` method, with your
    string in the parentheses (see *[https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html)*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Python 默认的字符串驻留机制已经足够，但你不应依赖它。如果你需要*确保*字符串被驻留，可以导入系统模块（`import sys`），并使用
    `sys.intern()` 方法，将字符串放在括号内（请参阅 *[https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html)*）。
- en: '***Using f-Strings***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 f-Strings***'
- en: 'You can use f-strings (see the section “String Formatting” on [page 192](ch07.xhtml#ch00lev3sec19))
    with variables. Just prefix the assignment with `f`, followed by a starting single
    or double quotation mark. Place the variables that you want to use within curly
    brackets and then add the ending quotation mark. Here’s an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在变量中使用 f-strings（请参阅第 192 页的“字符串格式化”部分）。只需在赋值前加上 `f`，然后是一个单引号或双引号。将你想要使用的变量放入大括号中，然后添加结束引号。以下是一个示例：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can even format the strings within the assignment statement. For example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在赋值语句中格式化字符串。例如：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, we called the `title()` string method on each variable in the
    curly brackets. This method capitalizes the first letter in a word and converts
    the remaining letters to lowercase.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在大括号中的每个变量上调用了 `title()` 字符串方法。此方法将单词的第一个字母大写，并将剩余字母转换为小写。
- en: '**Naming Variables**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**命名变量**'
- en: Programs are read far more often than they’re written. Your code should be as
    readable as possible, and not just for other users, but for yourself. It’s all
    too common to return to a program you wrote months ago and have no idea how it
    works.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 程序被读取的频率远高于编写的频率。你的代码应该尽可能易于阅读，不仅是为了其他用户，也为了你自己。很多时候，我们会回到几个月前编写的程序，根本不记得它是如何工作的。
- en: A common saying is that “code should be self-documenting.” This means that readers
    should be able to understand your code without relying on explanatory comments.
    To make your code “self-documenting,” you’ll want to pay a lot of attention to
    how you name variables. This involves ensuring that your names are legal and making
    them as logical and compact as possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有句常见的话说“代码应该是自文档化的。”这意味着读者应该能够理解你的代码，而不依赖解释性注释。为了让代码“自文档化”，你需要特别注意变量命名。这包括确保你的名字合法，并尽可能地使它们逻辑清晰、简洁。
- en: 'There are three main rules for naming variables:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 命名变量时有三条主要规则：
- en: Variables can contain only letters, numbers, or underscores (`_`)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量只能包含字母、数字或下划线 (`_`)
- en: The first character cannot be a number
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字符不能是数字
- en: The name cannot be a *reserved keyword*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不能是*保留关键字*
- en: '***Reserved Keywords***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保留关键字***'
- en: Python reserves a set of keywords for its own use ([Table 8-1](ch08.xhtml#ch08tab1)).
    You cannot use these as variable names, function names, or as any other identifiers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 为其自身保留了一组关键字（[表 8-1](ch08.xhtml#ch08tab1)）。你不能将这些作为变量名、函数名或其他标识符。
- en: '**Table 8-1:** Python’s Reserved Keywords'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1:** Python 的保留关键字'
- en: '| **Keyword** | **Description** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **描述** |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `and` | Logical operator |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `and` | 逻辑运算符 |'
- en: '| `as` | Used to alias an imported module or tool |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `as` | 用于给导入的模块或工具起别名 |'
- en: '| `assert` | Used in debugging |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `assert` | 用于调试 |'
- en: '| `async` | Used to define an asynchronous function |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `async` | 用于定义异步函数 |'
- en: '| `await` | Specifies the point in an asynchronous function at which control
    is given back to an event loop |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `await` | 指定在异步函数中将控制权交回事件循环的点 |'
- en: '| `break` | Breaks out of a loop |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 跳出循环 |'
- en: '| `class` | For defining a class in object-oriented programming |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `class` | 用于定义面向对象编程中的类 |'
- en: '| `continue` | Continue to the next iteration of a loop |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `continue` | 继续到下一次循环迭代 |'
- en: '| `def` | Define a function |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `def` | 定义一个函数 |'
- en: '| `del` | Delete an object |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `del` | 删除一个对象 |'
- en: '| `elif` | Else-if conditional statement |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `elif` | Else-if 条件语句 |'
- en: '| `else` | Conditional statement |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `else` | 条件语句 |'
- en: '| `except` | Instructions on how to handle an exception |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `except` | 处理异常的指令 |'
- en: '| `False` | Boolean value |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `False` | 布尔值 |'
- en: '| `finally` | Used for a block of code that executes in spite of exceptions
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `finally` | 用于一个代码块，无论是否有异常都会执行 |'
- en: '| `for` | Creates a for loop |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `for` | 创建一个 for 循环 |'
- en: '| `from` | Imports specific parts of a module |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `from` | 导入模块的特定部分 |'
- en: '| `global` | Declares a global variable |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `global` | 声明一个全局变量 |'
- en: '| `if` | Conditional statement |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `if` | 条件语句 |'
- en: '| `import` | Loads modules |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `import` | 加载模块 |'
- en: '| `in` | Checks whether a value is present |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 检查某个值是否存在 |'
- en: '| `is` | Tests whether two variables are equal |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `is` | 测试两个变量是否相等 |'
- en: '| `lambda` | Creates an anonymous function on-the-fly |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `lambda` | 动态创建匿名函数 |'
- en: '| `None` | A null value |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `None` | 空值 |'
- en: '| `nonlocal` | Declares a non-local variable |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `nonlocal` | 声明一个非本地变量 |'
- en: '| `not` | Logical operator |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `not` | 逻辑运算符 |'
- en: '| `or` | Logical operator |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `or` | 逻辑运算符 |'
- en: '| `pass` | Statement that will do nothing |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `pass` | 什么都不做的语句 |'
- en: '| `raise` | Raises an exception |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `raise` | 抛出一个异常 |'
- en: '| `return` | Exits a function and returns a value or values |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 退出函数并返回一个或多个值 |'
- en: '| `True` | Boolean value |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `True` | 布尔值 |'
- en: '| `try` | Makes a try/except statement |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `try` | 创建 try/except 语句 |'
- en: '| `while` | Creates a while loop |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `while` | 创建一个 while 循环 |'
- en: '| `with` | Simplifies exception handling; auto-closes files after loading |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `with` | 简化异常处理；加载文件后自动关闭 |'
- en: '| `yield` | Suspends a generator function and returns a value |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `yield` | 挂起一个生成器函数并返回一个值 |'
- en: 'You don’t need to memorize all of these keywords; Python will raise a `SyntaxError`
    if you try to use one as a variable name. Here’s what happens if you try to assign
    the value `5` to the `pass` keyword:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住所有的关键字；如果你尝试将其中一个作为变量名，Python 会抛出 `SyntaxError` 错误。如果你试图将值 `5` 赋给 `pass`
    关键字，结果会发生如下情况：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also view the list of keywords through Python. Just run `import keyword`
    followed by `keyword.kwlist`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 Python 查看关键字列表。只需运行 `import keyword` 然后执行 `keyword.kwlist`。
- en: 'Besides keywords, you should avoid using the name of one of Python’s built-in
    functions, like `print()` or `id()`, as a variable name. There’s nothing to prevent
    this from happening, however. For example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关键字外，你还应该避免使用 Python 内置函数的名称作为变量名，比如 `print()` 或 `id()`。然而，这并不会阻止你这么做。例如：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You’ll regret doing this, as `print` now refers to the integer `5`. If you
    try to use the `print()` function, Python will raise an error:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会后悔这么做，因为 `print` 现在指向整数 `5`。如果你尝试使用 `print()` 函数，Python 会抛出错误：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To fix this, you’ll need to delete the `print` variable using `del(print)`.
    This will restore the `print()` function and allow it to work again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要使用 `del(print)` 删除 `print` 变量。这样会恢复 `print()` 函数并使其重新生效。
- en: 'Many of these function names are ones that you’ll be tempted to use, such as
    `min`, `max`, `sorted`, `list`, `set`, `slice`, and `sum`. We’ll look at a list
    of these built-in functions and their purpose in [Chapter 11](ch11.xhtml). In
    the meantime, you just need to be observant when naming variables. The console
    and text editor in Spyder will highlight these special names with a unique color.
    I can’t show this in a black-and-white book, but you can see for yourself by entering
    the following code in the console:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些函数名称是你可能会想使用的，比如 `min`、`max`、`sorted`、`list`、`set`、`slice` 和 `sum`。我们将在[第
    11 章](ch11.xhtml)中查看这些内置函数及其用途。与此同时，你只需要在命名变量时保持警觉。Spyder 中的控制台和文本编辑器会用独特的颜色高亮这些特殊名称。我无法在黑白书籍中展示这一点，但你可以通过在控制台中输入以下代码来亲自查看：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `spam` variable should be colored differently than the `list` variable because
    `list` is a built-in function name. If `list` is colored purple in your console,
    avoid using purple names for variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam` 变量应该与 `list` 变量不同颜色，因为 `list` 是一个内置函数的名称。如果在你的控制台中，`list` 是紫色的，避免为变量使用紫色名称。'
- en: '**NOTE**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you insist on using a reserved keyword or built-in function name, you can
    avoid conflicts by adding an underscore to the variable name, such as sum_, max_,
    or class_. Even better, add a descriptor after the underscore, such as max_pressure.
    Everybody wins!*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你坚持使用保留关键字或内置函数名称，你可以通过在变量名后加下划线来避免冲突，例如 sum_、max_ 或 class_。更好的做法是，在下划线后添加描述符，例如
    max_pressure。大家都能受益！*'
- en: '***Variables Are Case Sensitive***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变量区分大小写***'
- en: 'Python is a case-sensitive programming language. Not only must you spell variable
    names correctly to access them, but you must also use the same arrangement of
    uppercase and lowercase characters. For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种区分大小写的编程语言。你不仅需要正确拼写变量名以访问它们，还必须保持大写和小写字母的正确排列。例如：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Python doesn’t recognize the `Declination` variable due to the capitalized first
    letter, and it raises a `NameError` as a result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不识别 `Declination` 变量，因为第一个字母大写，结果抛出了 `NameError` 错误。
- en: '***Best Practices for Naming Variables***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命名变量的最佳实践***'
- en: Here are some suggestions for ensuring that your variable names are Pythonic.
    You can also find a section on naming conventions in Python’s PEP8 style guide
    at *[https://pep8.org/#naming-conventions/](https://pep8.org/#naming-conventions/)*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些确保你的变量名符合 Python 风格的建议。你还可以在 Python 的 PEP8 风格指南中找到关于命名约定的章节，地址是 *[https://pep8.org/#naming-conventions/](https://pep8.org/#naming-conventions/)*。
- en: 'You should use the underbar (`_`) to separate words within a variable name.
    For example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用下划线 (`_`) 来分隔变量名中的单词。例如：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should also use *lowercase* characters in most cases and reserve the use
    of capitals for special objects, such as *constants*. Constants are values that
    should not change during the program’s execution, and you can let others know
    that a variable represents a constant by naming it with all caps. For example,
    to assign the speed of light to a constant, you could use the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你应该使用*小写*字母，并将大写字母保留给特殊对象，例如*常量*。常量是指在程序执行过程中不应该改变的值，你可以通过使用全大写来告知其他人某个变量表示的是常量。例如，赋值光速常量时，你可以使用如下命名：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Constants in Python have a *contextual* meaning that’s not enforced by the Python
    interpreter. Using all caps for the name only alerts other programmers of your
    intent. Otherwise, constants can be overwritten like any other variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的常量有一个*上下文*意义，但这一点并不会被 Python 解释器强制执行。使用全大写字母来命名常量只是为了提醒其他程序员你的意图。否则，常量仍然可以像其他变量一样被覆盖。
- en: Variable names should be logical and descriptive but try to achieve this goal
    using as few characters as possible. Long variable names are not only difficult
    to type, but they can also cause lines to wrap, making the code challenging to
    read.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名应该是合乎逻辑的并且具描述性，但尽量使用尽可能少的字符来实现这一目标。长变量名不仅难以输入，还可能导致代码行换行，从而使代码变得难以阅读。
- en: 'Here’s an example of a name that’s clear to a fault:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个过于清晰的命名示例：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are several ways in which you can shorten this name, such as:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式缩短这个名字，例如：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'or:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can include important information, such as units, in *nonexecutable
    comments*. These will help you to keep your variable names under control. We examine
    comments in [Chapter 14](ch14.xhtml), but here’s an example of an inline comment:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在*不可执行的注释*中包含重要信息，如单位。这些注释有助于你保持变量名的控制。我们将在[第14章](ch14.xhtml)讨论注释，但这里有一个内联注释的例子：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Python will ignore all the text after the `#` mark, but humans reading your
    code will be able to glean more than what is conveyed in the variable name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会忽略 `#` 符号之后的所有文本，但阅读你代码的程序员可以从注释中获取比变量名所传达的信息更多的内容。
- en: Naming variables is an exercise in optimization. You’ll be surprised how often
    you can return to a program and improve your names. You should avoid taking this
    to extremes, however, as it’s easy to over-optimize. If you’re used to working
    in Imperial units, it might be obvious to you that `mps` means miles-per-second,
    but to most of the world, it’s meters-per-second.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 命名变量是一个优化练习。你会惊讶于自己能够多频繁地回到程序中并改进变量名。然而，你应该避免过度优化，因为很容易走向极端。如果你习惯使用英制单位，`mps`
    可能对你来说意味着“每秒英里数”，但对大多数人来说，它意味着“每秒米数”。
- en: Likewise, eschew variables that end with a numerical suffix, like `step1` or
    `step2`. These names aren’t meaningful, and if you add or delete a step, you’ll
    need to refactor the whole program. It’s better to use descriptive names that
    reference the step, such as `denoised_image`, or `kalman_filtered`. Additionally,
    never use `final` in a name. This will anger the gods, and you’ll surely need
    another variable after the “final” one.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，避免使用以数字后缀结尾的变量名，如 `step1` 或 `step2`。这些名字没有意义，而且如果你增加或删除一个步骤，你需要重构整个程序。最好使用描述性更强的名字，像是
    `denoised_image` 或 `kalman_filtered`。此外，永远不要在变量名中使用 `final`。这会惹怒神灵，你肯定在“final”之后还需要一个新的变量。
- en: You should also avoid the characters “l” (lowercase letter L), “O” (uppercase
    letter o), or “I” (uppercase letter i) as single character variable names. These
    characters can be confused for the numerals one and zero. In fact, you should
    avoid single character names altogether, except when the single letter is commonly
    understood, such as using `x` and `y` for Cartesian coordinate values. It’s also
    acceptable to use short names when performing simple tutorial exercises, like
    the ones we’ve been using here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该避免使用字符“l”（小写字母 L）、“O”（大写字母 O）或“I”（大写字母 I）作为单字符变量名。这些字符容易与数字 1 和 0 混淆。事实上，你应该完全避免使用单字符变量名，除非该字母是常见且广为人知的，例如使用
    `x` 和 `y` 作为笛卡尔坐标值。在进行简单的教程练习时，像我们这里使用的那样使用简短的名字也是可以接受的。
- en: '***Managing Dynamic Typing Issues***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理动态类型问题***'
- en: In the last chapter, we talked about how Python is a dynamically typed language,
    which means that Python can use context to assign a data type, and variables do
    not have a fixed type. This can lead to complex and difficult-to-debug code, as
    a variable named `x` might represent an integer, a string, or even a function
    at different places in a program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，我们讨论了 Python 是一种动态类型语言，这意味着 Python 可以根据上下文分配数据类型，并且变量没有固定类型。这可能导致代码复杂且难以调试，因为一个名为
    `x` 的变量在程序中的不同位置可能代表整数、字符串甚至函数。
- en: 'One way to manage this issue is to change the name of the variable when it
    changes data types. Compare this code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 管理这个问题的一种方法是在变量更改数据类型时更改变量名。对比以下代码：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'with this code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In both examples, the `x` variable starts out as a string and ends up as a float.
    Careful and considerate naming practices in the second example, however, help
    you to track what’s going on even if a program has many branches and loops and
    the assignment statements are many lines apart.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，`x` 变量最开始是字符串类型，最终变成了浮点数。然而，第二个例子中的小心且周到的命名实践帮助你跟踪程序的运行，即使程序有很多分支和循环，赋值语句之间相隔很远。
- en: '**NOTE**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Linters that you can get through Spyder, like Pylint ([https://pylint.pycqa.org/](https://pylint.pycqa.org/)),
    will alert you if you reassign a variable to a different type.*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过 Spyder 可以使用的 Linters，比如 Pylint ([https://pylint.pycqa.org/](https://pylint.pycqa.org/))，会在你将变量重新赋值为不同类型时提醒你。*'
- en: There’s no reason to reuse variable names, because each assignment will create
    a new object. And you don’t need to be as explicit as the previous example and
    include the data type in the name. The important thing is that you change names
    when you change data types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要重新使用变量名，因为每次赋值都会创建一个新对象。你不需要像前面的例子那样明确包含数据类型在变量名中。重要的是，当你更改数据类型时，应该更改变量名。
- en: '***Handling Insignificant Variables***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理无关紧要的变量***'
- en: 'Variables that serve as placeholders are often named using a single lowercase
    letter, typically “i”. Here’s an example using a `for` loop (which we cover in
    [Chapter 10](ch10.xhtml)):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为占位符的变量通常使用单个小写字母命名，通常是“i”。这里是一个使用 `for` 循环的例子（我们在[第10章](ch10.xhtml)中讨论过）：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember to use SHIFT-ENTER after `print(i)` to execute the code in the Qt console.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在执行 `print(i)` 代码后按 SHIFT-ENTER 以在 Qt 控制台中执行代码。
- en: Although there’s technically nothing wrong with this strategy, linters that
    check your code’s conformance to the PEP8 guidelines (like we discussed in [Chapter
    4](ch04.xhtml)) will flag the `i` as an “unused variable.” Although you can ignore
    this, it gets annoying.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲，这个策略没有错，但检查你代码是否符合 PEP8 标准的 linters（比如我们在[第4章](ch04.xhtml)中讨论过）会把 `i`
    标记为“未使用的变量”。虽然你可以忽略这个，但它会让人感到烦躁。
- en: 'To keep from violating a coding standard, you can use an underscore as a throwaway
    variable name, such as in this example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免违反编码标准，你可以使用下划线作为占位符变量名，例如以下示例：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will keep the linters quiet and happy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让 linters 安静并保持愉快。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 1.  Which variable names are valid?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  哪些变量名是有效的？
- en: a.  _steve
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: a.  _steve
- en: b.  br549
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: b.  br549
- en: c.  light-speed
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: c.  light-speed
- en: d.  O579
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: d.  O579
- en: 2.  Which naming style is recommended for a constant?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  推荐使用哪种命名风格来命名常量？
- en: a.  GravConstant
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: a.  GravConstant
- en: b.  GRAV_CONSTANT
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: b.  GRAV_CONSTANT
- en: c.  GRAV_constant
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: c.  GRAV_constant
- en: d.  grav_constant
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: d.  grav_constant
- en: 3.  When should you use a single underscore as a variable name?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  什么时候应该使用单个下划线作为变量名？
- en: a.  When you want to use a reserved keyword
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: a.  当你想使用保留关键字时
- en: b.  When you want to keep the variable private
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: b.  当你想保持变量的私密性时
- en: c.  When you need a placeholder for iteration
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: c.  当你需要一个占位符用于迭代时
- en: d.  When you can’t think of a good name
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: d.  当你想不出一个好名字时
- en: 4.  When you change a variable’s data type, you should ___________ .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 当你改变一个变量的数据类型时，你应该 ___________ 。
- en: 5.  Create a new variable and then delete it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 创建一个新变量并删除它。
- en: '**Getting User Input**'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取用户输入**'
- en: So far, *we’ve* been assigning values to variables. In many cases, you’ll want
    to get input directly from a user; for example, for a unit conversion program.
    Because this is such a common practice, Python provides the built-in
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，*我们*一直在将值赋给变量。在很多情况下，你可能希望直接从用户那里获取输入；例如，用于单位转换程序。由于这种做法非常常见，Python 提供了内建的
- en: '`input()` function. Here’s how it works:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()` 函数。它的工作原理如下：'
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `input()` function takes a question, known as a *prompt*, and presents it
    to the user. This prompt should be as unambiguous as possible so that the user
    knows what to enter (and in what format). The function then pauses the program
    until the user enters a value. Because the function expects strings, you don’t
    need to use quotation marks with the input.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()` 函数接收一个问题，称为 *提示*，并将其呈现给用户。这个提示应该尽可能清晰，以便用户知道该输入什么（以及什么格式）。然后，函数会暂停程序，直到用户输入一个值。由于函数期望输入的是字符串，所以你不需要为输入加上引号。'
- en: 'The `input()` function returns a *string*, which means that numbers might need
    to be converted to integers or floats depending on what your program will do with
    the input. To make the conversion, call either the `int()` or `float()` function
    in the assignment statement. For example, to ensure that the `age` variable is
    an integer, enter the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()` 函数返回一个 *字符串*，这意味着数字可能需要根据程序对输入的处理方式转换为整数或浮动数。为了进行转换，可以在赋值语句中调用 `int()`
    或 `float()` 函数。例如，为了确保 `age` 变量是一个整数，可以输入以下内容：'
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You might also want the input to be consistent. Because Python is case sensitive,
    it’s common to convert input to lowercase to avoid running into any problems later.
    Enter the following in the console:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望输入保持一致性。由于 Python 区分大小写，通常会将输入转换为小写字母，以避免后续出现问题。在控制台中输入以下内容：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, we called the `lower()` string method to automatically convert
    the input to lowercase.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们调用了 `lower()` 字符串方法来自动将输入转换为小写。
- en: '**NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When your program interacts with actual human users, if anything can go wrong,
    it will. There’s nothing to stop a user from entering their age as “forty-two”
    rather than “42.” Fortunately, Python provides things like while loops, try statements,
    and conditional statements, that let you check input for errors and either fix
    the problem directly or request that the user reenter the value in the format
    that it expects. We explore these in later chapters.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你的程序与实际用户互动时，如果有什么可能出错，它就会出错。没有任何东西能阻止用户将年龄输入为“forty-two”而不是“42”。幸运的是，Python
    提供了像 while 循环、try 语句和条件语句等功能，允许你检查输入错误，并可以直接修复问题或要求用户重新输入符合期望格式的值。我们将在后续章节中探讨这些内容。*'
- en: The `input()` function is a fairly primitive way to get user input. Later, in
    the book, we’ll look at more sophisticated methods, such as using a GUI with menus,
    radio buttons, text boxes, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()` 函数是一种比较原始的获取用户输入的方式。在本书的后面，我们将探讨一些更复杂的方法，例如使用带菜单、单选按钮、文本框等的图形用户界面（GUI）。'
- en: '**Using Comparison Operators**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用比较运算符**'
- en: Python provides *comparison* operators, also called *relational* operators (see
    [Table 8-2](ch08.xhtml#ch08tab2)), that let you compare variables and determine
    the relationship between them. Each operator returns either `True` or `False`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 *比较* 运算符，也叫做 *关系* 运算符（参见 [表 8-2](ch08.xhtml#ch08tab2)），它允许你比较变量并确定它们之间的关系。每个运算符都会返回
    `True` 或 `False`。
- en: '**Table 8-2:** Python Relational Operators'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2:** Python 关系运算符'
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `==` | If values are equal, condition is True | `(a == a) is True` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 如果值相等，则条件为 True | `(a == a) 为 True` |'
- en: '| `!=` | If values not equal, condition is True | `(a != b) is True` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 如果值不相等，则条件为 True | `(a != b) 为 True` |'
- en: '| `<>` | If values not equal, condition is True | `(a <> b) is True` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `<>` | 如果值不相等，则条件为 True | `(a <> b) 为 True` |'
- en: '| `>` | If left value is greater than right, then True | `(2 > 6) is False`
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 如果左侧大于右侧，则为 True | `(2 > 6) 为 False` |'
- en: '| `<` | If left value is less than right, then True | `(2 < 6) is True` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 如果左侧小于右侧，则为 True | `(2 < 6) 为 True` |'
- en: '| `>=` | If left is greater than or equal to right, then True | `(2 >= 6) is
    False` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 如果左侧大于或等于右侧，则为 True | `(2 >= 6) 为 False` |'
- en: '| `<=` | If left is less than or equal to right, then True | `(2 <= 6) is True`
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 如果左侧小于或等于右侧，则为 True | `(2 <= 6) 为 True` |'
- en: '| `is` | Object identity | `(a is a) is True` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `is` | 对象身份 | `(a is a) 为 True` |'
- en: '| `is not` | Negated object identity | `(a is not b) is True` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `is not` | 否定对象身份 | `(a is not b) 为 True` |'
- en: 'The operators evaluate from left to right. For example, to check that 10 is
    larger than 2:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符从左到右进行评估。例如，要检查 10 是否大于 2：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Comparison operators evaluate to a *Boolean* data type that has two values:
    `True` and `False`. These values are always capitalized and unlike strings, they
    don’t require quotes. You can check their type like any other value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符评估为 *布尔* 数据类型，具有两个值：`True` 和 `False`。这两个值总是大写的，与字符串不同，它们不需要引号。你可以像检查任何其他值一样检查它们的类型：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because computers work in binary, `True` represents `1` (or `1.0`), and `False`
    represents `0` (or `0.0`). You can test this for yourself in the console, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因为计算机以二进制方式工作，`True` 代表 `1`（或 `1.0`），而 `False` 代表 `0`（或 `0.0`）。你可以在控制台中测试这一点，如下所示：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see from this example, you can store Booleans in variables, use them
    in expressions, and convert them into integers and floats without raising an exception.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这个例子中看到的，你可以将布尔值存储在变量中，使用它们进行表达式运算，并将它们转换为整数和浮点数而不会引发异常。
- en: 'The first two operators, both of which evaluate equality, work with any data
    type:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个运算符都用于评估相等性，适用于任何数据类型：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The other operators, such as `>` and `<=`, work only with floating-point values
    and integers. For convenience, you can chain these together in a single line,
    such as `2 < x < 5`, which states that `x` is greater than `2` but less than `5`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其他运算符，如 `>` 和 `<=`，仅与浮点数值和整数一起使用。为了方便，你可以将这些运算符链式连接在一行中，例如 `2 < x < 5`，这表示 `x`
    大于 `2` 且小于 `5`。
- en: 'You can use these relationships to control what your program does. Here’s an
    example using conditional statements, which we investigate in [Chapter 10](ch10.xhtml).
    This example compares the pH values of three samples to determine which is the
    most acidic:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些关系来控制程序的行为。这里有一个使用条件语句的示例，我们将在[第10章](ch10.xhtml)中研究。此示例比较了三种样本的 pH 值，以确定哪个是最酸的：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, the relational operators determine which statement
    is printed. You can also chain together comparisons for multiple variables, as
    demonstrated here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，关系运算符决定了打印哪个语句。你还可以将多个变量的比较链式连接在一起，如下所示：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `is` and `is not` operators check whether two objects share the same identity
    (in other words, point to the same object in memory). This is not the same as
    the equal to (`==`) and not equal to (`!=`) operators, that check *equality*.
    Let’s look at an example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 和 `is not` 运算符检查两个对象是否具有相同的身份（换句话说，是否指向内存中的同一个对象）。这与等于运算符（`==`）和不等于运算符（`!=`）不同，后者检查的是*相等性*。我们来看一个例子：'
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because we assigned a large number to `x` and `y`, they are equal in value
    but are not the same object. If we use small values, however, they will be the
    same object, due to Python’s use of a startup memory cache, as discussed in “Chained
    Assignment and Internment” on [page 205](ch08.xhtml#ch00lev2sec116). For example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们为 `x` 和 `y` 分配了一个大数字，它们的值相等，但不是同一个对象。然而，如果我们使用较小的值，它们将是同一个对象，这是由于 Python
    使用了启动内存缓存，正如在《链式赋值与驻留机制》一节中[第205页](ch08.xhtml#ch00lev2sec116)讨论的那样。例如：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 6.  If `x = 257` and `y = 257`, what does the code `x is y` evaluate to?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  如果 `x = 257` 且 `y = 257`，`x is y` 代码的结果是什么？
- en: a.  True
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: a.  True
- en: b.  False
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: b.  False
- en: 7.  Write a code snippet that prompts a user for their name and then prints
    the name in reverse.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  编写一个代码片段，提示用户输入他们的名字，然后打印出反向的名字。
- en: 8.  Write an assignment statement that generates a `NameError`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  编写一个赋值语句，生成 `NameError`。
- en: 9.  Write an assignment statement that generates a `TypeError`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  编写一个赋值语句，生成 `TypeError`。
- en: 10.  In the console, what is the output of `'hydrogen sulfide'.title()`?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  在控制台中，`'hydrogen sulfide'.title()` 的输出是什么？
- en: a.  `'Hydrogen Sulfide'`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `'Hydrogen Sulfide'`
- en: b.  `'HYDROGEN SULFIDE'`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `'HYDROGEN SULFIDE'`
- en: 'c.  `AttributeError: ''str'' object has no attribute ''title''`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'c.  `AttributeError: ''str'' 对象没有 ''title'' 属性`'
- en: 'd.  `NameError: name ''title'' is not defined`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'd.  `NameError: name ''title'' is not defined`'
- en: '**Summary**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you got a closer look at how variables work and how to use
    them. You learned more about assigning variables as well as some rules and suggestions
    on how to name them, compare them, and solicit user input.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你更深入地了解了变量的工作原理以及如何使用它们。你学习了更多关于变量赋值的知识，以及一些命名规则和建议，如何比较变量并获取用户输入。
- en: Because variables are just labels for objects in memory, they can sometimes
    behave unexpectedly, especially when working with mutable objects. This will become
    apparent in the next chapter, in which we explore the container data types such
    as lists, sets, and dictionaries.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量只是内存中对象的标签，它们有时会表现得出乎意料，尤其是在处理可变对象时。在下一章中，我们将探讨容器数据类型，如列表、集合和字典，这一点会变得更加明显。
