- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VARIABLES**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Variables are one of the most important concepts for beginning programmers to
    understand, so this chapter explores these features in detail. Technically speaking,
    a variable is a reserved memory location used to store values. It’s a reference,
    or *pointer*, to an object in memory, but it’s not the object itself. Variables
    let you access and manipulate each object’s associated metadata (*attributes*)
    and functionality (*methods*).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to assign variables. In this chapter,
    you’ll learn more about assignment statements, discover how to name variables
    clearly, use a built-in function to get a user’s input, and practice comparing
    one variable to another.
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables Have Identities**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python encapsulates data and the functions that operate on that data into named
    entities known as *objects*. As the fundamental building block for the language,
    everything in Python is an object, and every object has an *identity* (memory
    address), a *type*, and a *value*. The number 42 is an object as well as the sentence
    “Hello, world!” An object’s identity and type never change, but its values can
    sometimes be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Variables can be thought of as labels for objects. Just as you can be referred
    to by multiple names and nicknames ([Figure 8-1](ch08.xhtml#ch08fig1)), an object
    in Python can be referenced by many variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: We can go by multiple names; so can objects in Python.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you use an assignment statement, such as `x = 5`, the variable `x` is initialized
    as a reference to the object on the right-hand side of the equal sign. It’s also
    given an integer number as an identity. This number is unique for all existing
    objects. You can view this number with the built-in `id()` function that ships
    with Python. Note that the ID numbers you see on your computer might be different
    from mine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can overwrite a variable by assigning it a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The reassigned `x` now has a new identity. In the first example, the variable
    `x` is a reference to an integer object with a value of `5`. When you overwrite
    `x` with the new value of `15`, the old object continues to exist, but if no variable
    is referencing it, its *reference count* goes to zero. At this point, it’s subject
    to *garbage collection*, the process by which Python periodically reclaims blocks
    of memory that are no longer in use. In some other languages, you must manually
    designate and free memory allocations in your code. Python’s ability to automatically
    manage memory and “clean up its own mess” makes it a very friendly language!
  prefs: []
  type: TYPE_NORMAL
- en: 'Because variables are just references, multiple variables can point to the
    same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By assigning `x` to `y` in line `In [7]`, both variables now reference the same
    object, as evidenced by their having the same identity. This type of memory-efficient
    behavior is called *aliasing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you overwrite `x`, its identity will change, but `y` will still point to
    the “old” object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the old object has a reference count greater than one, so it will
    not be deleted during garbage collection and will hang around for you to use in
    expressions, functions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assigning Variables**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assigning a value to a variable is known as *binding* in Python. In addition
    to the straightforward “x = y” method for assigning variables, you can also do
    so using expressions, operator overloading, functions, and more. Basically, both
    values and things that return values can be assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The result of expressions can be assigned to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '***Operator Overloading***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Likewise, you can use operator overloading when assigning variables. As discussed
    in the previous chapter, operator overloading refers to the ability of an operator
    to work in a different manner with different data types. The classic example is
    using the `+` sign to add numbers *and* concatenate strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operator overloading works directly with strings or with other variables. Here,
    we use it with strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, with variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In line `In [20]`, notice how I added a space between names. Without it, the
    printout would be `HariSeldon`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example of operator overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice how you can use precedence with the operators. To see the impact, run
    line `In [22]` again *without* the parentheses and print the result.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although we haven’t covered them yet, you can use functions in assignment statements.
    Here, we’ll use the built-in `count()` string method with an assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `count()` method returned the value `1`, which was then stored
    in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '***Chained Assignment and Internment***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can simultaneously assign the same value to multiple variables using a
    *chained assignment*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, Python doesn’t create a new object for each of these variables;
    they all have the same identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve processing speed, Python creates a small cache of memory addresses
    at startup. It uses some of these for a list of small integer values (`-5` to
    `256`). The programming practice of using references in place of copies of equal
    objects is called *interning*. Larger values not in the cache will get new addresses.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Some strings are also interned by Python as an optimization. As Python code
    is compiled, identifiers such as variable names, function names, and class names
    are interned. Other strings may be interned, as well. Python automatically makes
    this determination on a code-by-code basis.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of string interning is that when you’re comparing two variables
    Python can compare *memory addresses*. This is faster than comparing each string
    character by character.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, Python’s default interning is more than sufficient, but you should
    never rely on it. If you ever need to *ensure* that a string is interned, import
    the system module (`import sys`) and use the `sys.intern()` method, with your
    string in the parentheses (see *[https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Using f-Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use f-strings (see the section “String Formatting” on [page 192](ch07.xhtml#ch00lev3sec19))
    with variables. Just prefix the assignment with `f`, followed by a starting single
    or double quotation mark. Place the variables that you want to use within curly
    brackets and then add the ending quotation mark. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even format the strings within the assignment statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we called the `title()` string method on each variable in the
    curly brackets. This method capitalizes the first letter in a word and converts
    the remaining letters to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Naming Variables**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programs are read far more often than they’re written. Your code should be as
    readable as possible, and not just for other users, but for yourself. It’s all
    too common to return to a program you wrote months ago and have no idea how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: A common saying is that “code should be self-documenting.” This means that readers
    should be able to understand your code without relying on explanatory comments.
    To make your code “self-documenting,” you’ll want to pay a lot of attention to
    how you name variables. This involves ensuring that your names are legal and making
    them as logical and compact as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main rules for naming variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can contain only letters, numbers, or underscores (`_`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first character cannot be a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name cannot be a *reserved keyword*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Reserved Keywords***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python reserves a set of keywords for its own use ([Table 8-1](ch08.xhtml#ch08tab1)).
    You cannot use these as variable names, function names, or as any other identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Python’s Reserved Keywords'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Keyword** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | Logical operator |'
  prefs: []
  type: TYPE_TB
- en: '| `as` | Used to alias an imported module or tool |'
  prefs: []
  type: TYPE_TB
- en: '| `assert` | Used in debugging |'
  prefs: []
  type: TYPE_TB
- en: '| `async` | Used to define an asynchronous function |'
  prefs: []
  type: TYPE_TB
- en: '| `await` | Specifies the point in an asynchronous function at which control
    is given back to an event loop |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | Breaks out of a loop |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | For defining a class in object-oriented programming |'
  prefs: []
  type: TYPE_TB
- en: '| `continue` | Continue to the next iteration of a loop |'
  prefs: []
  type: TYPE_TB
- en: '| `def` | Define a function |'
  prefs: []
  type: TYPE_TB
- en: '| `del` | Delete an object |'
  prefs: []
  type: TYPE_TB
- en: '| `elif` | Else-if conditional statement |'
  prefs: []
  type: TYPE_TB
- en: '| `else` | Conditional statement |'
  prefs: []
  type: TYPE_TB
- en: '| `except` | Instructions on how to handle an exception |'
  prefs: []
  type: TYPE_TB
- en: '| `False` | Boolean value |'
  prefs: []
  type: TYPE_TB
- en: '| `finally` | Used for a block of code that executes in spite of exceptions
    |'
  prefs: []
  type: TYPE_TB
- en: '| `for` | Creates a for loop |'
  prefs: []
  type: TYPE_TB
- en: '| `from` | Imports specific parts of a module |'
  prefs: []
  type: TYPE_TB
- en: '| `global` | Declares a global variable |'
  prefs: []
  type: TYPE_TB
- en: '| `if` | Conditional statement |'
  prefs: []
  type: TYPE_TB
- en: '| `import` | Loads modules |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Checks whether a value is present |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | Tests whether two variables are equal |'
  prefs: []
  type: TYPE_TB
- en: '| `lambda` | Creates an anonymous function on-the-fly |'
  prefs: []
  type: TYPE_TB
- en: '| `None` | A null value |'
  prefs: []
  type: TYPE_TB
- en: '| `nonlocal` | Declares a non-local variable |'
  prefs: []
  type: TYPE_TB
- en: '| `not` | Logical operator |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | Logical operator |'
  prefs: []
  type: TYPE_TB
- en: '| `pass` | Statement that will do nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `raise` | Raises an exception |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | Exits a function and returns a value or values |'
  prefs: []
  type: TYPE_TB
- en: '| `True` | Boolean value |'
  prefs: []
  type: TYPE_TB
- en: '| `try` | Makes a try/except statement |'
  prefs: []
  type: TYPE_TB
- en: '| `while` | Creates a while loop |'
  prefs: []
  type: TYPE_TB
- en: '| `with` | Simplifies exception handling; auto-closes files after loading |'
  prefs: []
  type: TYPE_TB
- en: '| `yield` | Suspends a generator function and returns a value |'
  prefs: []
  type: TYPE_TB
- en: 'You don’t need to memorize all of these keywords; Python will raise a `SyntaxError`
    if you try to use one as a variable name. Here’s what happens if you try to assign
    the value `5` to the `pass` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can also view the list of keywords through Python. Just run `import keyword`
    followed by `keyword.kwlist`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides keywords, you should avoid using the name of one of Python’s built-in
    functions, like `print()` or `id()`, as a variable name. There’s nothing to prevent
    this from happening, however. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll regret doing this, as `print` now refers to the integer `5`. If you
    try to use the `print()` function, Python will raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To fix this, you’ll need to delete the `print` variable using `del(print)`.
    This will restore the `print()` function and allow it to work again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these function names are ones that you’ll be tempted to use, such as
    `min`, `max`, `sorted`, `list`, `set`, `slice`, and `sum`. We’ll look at a list
    of these built-in functions and their purpose in [Chapter 11](ch11.xhtml). In
    the meantime, you just need to be observant when naming variables. The console
    and text editor in Spyder will highlight these special names with a unique color.
    I can’t show this in a black-and-white book, but you can see for yourself by entering
    the following code in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `spam` variable should be colored differently than the `list` variable because
    `list` is a built-in function name. If `list` is colored purple in your console,
    avoid using purple names for variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you insist on using a reserved keyword or built-in function name, you can
    avoid conflicts by adding an underscore to the variable name, such as sum_, max_,
    or class_. Even better, add a descriptor after the underscore, such as max_pressure.
    Everybody wins!*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Variables Are Case Sensitive***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python is a case-sensitive programming language. Not only must you spell variable
    names correctly to access them, but you must also use the same arrangement of
    uppercase and lowercase characters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Python doesn’t recognize the `Declination` variable due to the capitalized first
    letter, and it raises a `NameError` as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '***Best Practices for Naming Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here are some suggestions for ensuring that your variable names are Pythonic.
    You can also find a section on naming conventions in Python’s PEP8 style guide
    at *[https://pep8.org/#naming-conventions/](https://pep8.org/#naming-conventions/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use the underbar (`_`) to separate words within a variable name.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also use *lowercase* characters in most cases and reserve the use
    of capitals for special objects, such as *constants*. Constants are values that
    should not change during the program’s execution, and you can let others know
    that a variable represents a constant by naming it with all caps. For example,
    to assign the speed of light to a constant, you could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Constants in Python have a *contextual* meaning that’s not enforced by the Python
    interpreter. Using all caps for the name only alerts other programmers of your
    intent. Otherwise, constants can be overwritten like any other variable.
  prefs: []
  type: TYPE_NORMAL
- en: Variable names should be logical and descriptive but try to achieve this goal
    using as few characters as possible. Long variable names are not only difficult
    to type, but they can also cause lines to wrap, making the code challenging to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a name that’s clear to a fault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways in which you can shorten this name, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can include important information, such as units, in *nonexecutable
    comments*. These will help you to keep your variable names under control. We examine
    comments in [Chapter 14](ch14.xhtml), but here’s an example of an inline comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Python will ignore all the text after the `#` mark, but humans reading your
    code will be able to glean more than what is conveyed in the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Naming variables is an exercise in optimization. You’ll be surprised how often
    you can return to a program and improve your names. You should avoid taking this
    to extremes, however, as it’s easy to over-optimize. If you’re used to working
    in Imperial units, it might be obvious to you that `mps` means miles-per-second,
    but to most of the world, it’s meters-per-second.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, eschew variables that end with a numerical suffix, like `step1` or
    `step2`. These names aren’t meaningful, and if you add or delete a step, you’ll
    need to refactor the whole program. It’s better to use descriptive names that
    reference the step, such as `denoised_image`, or `kalman_filtered`. Additionally,
    never use `final` in a name. This will anger the gods, and you’ll surely need
    another variable after the “final” one.
  prefs: []
  type: TYPE_NORMAL
- en: You should also avoid the characters “l” (lowercase letter L), “O” (uppercase
    letter o), or “I” (uppercase letter i) as single character variable names. These
    characters can be confused for the numerals one and zero. In fact, you should
    avoid single character names altogether, except when the single letter is commonly
    understood, such as using `x` and `y` for Cartesian coordinate values. It’s also
    acceptable to use short names when performing simple tutorial exercises, like
    the ones we’ve been using here.
  prefs: []
  type: TYPE_NORMAL
- en: '***Managing Dynamic Typing Issues***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the last chapter, we talked about how Python is a dynamically typed language,
    which means that Python can use context to assign a data type, and variables do
    not have a fixed type. This can lead to complex and difficult-to-debug code, as
    a variable named `x` might represent an integer, a string, or even a function
    at different places in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to manage this issue is to change the name of the variable when it
    changes data types. Compare this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, the `x` variable starts out as a string and ends up as a float.
    Careful and considerate naming practices in the second example, however, help
    you to track what’s going on even if a program has many branches and loops and
    the assignment statements are many lines apart.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Linters that you can get through Spyder, like Pylint ([https://pylint.pycqa.org/](https://pylint.pycqa.org/)),
    will alert you if you reassign a variable to a different type.*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no reason to reuse variable names, because each assignment will create
    a new object. And you don’t need to be as explicit as the previous example and
    include the data type in the name. The important thing is that you change names
    when you change data types.
  prefs: []
  type: TYPE_NORMAL
- en: '***Handling Insignificant Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Variables that serve as placeholders are often named using a single lowercase
    letter, typically “i”. Here’s an example using a `for` loop (which we cover in
    [Chapter 10](ch10.xhtml)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember to use SHIFT-ENTER after `print(i)` to execute the code in the Qt console.
  prefs: []
  type: TYPE_NORMAL
- en: Although there’s technically nothing wrong with this strategy, linters that
    check your code’s conformance to the PEP8 guidelines (like we discussed in [Chapter
    4](ch04.xhtml)) will flag the `i` as an “unused variable.” Although you can ignore
    this, it gets annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep from violating a coding standard, you can use an underscore as a throwaway
    variable name, such as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will keep the linters quiet and happy.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Which variable names are valid?
  prefs: []
  type: TYPE_NORMAL
- en: a.  _steve
  prefs: []
  type: TYPE_NORMAL
- en: b.  br549
  prefs: []
  type: TYPE_NORMAL
- en: c.  light-speed
  prefs: []
  type: TYPE_NORMAL
- en: d.  O579
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Which naming style is recommended for a constant?
  prefs: []
  type: TYPE_NORMAL
- en: a.  GravConstant
  prefs: []
  type: TYPE_NORMAL
- en: b.  GRAV_CONSTANT
  prefs: []
  type: TYPE_NORMAL
- en: c.  GRAV_constant
  prefs: []
  type: TYPE_NORMAL
- en: d.  grav_constant
  prefs: []
  type: TYPE_NORMAL
- en: 3.  When should you use a single underscore as a variable name?
  prefs: []
  type: TYPE_NORMAL
- en: a.  When you want to use a reserved keyword
  prefs: []
  type: TYPE_NORMAL
- en: b.  When you want to keep the variable private
  prefs: []
  type: TYPE_NORMAL
- en: c.  When you need a placeholder for iteration
  prefs: []
  type: TYPE_NORMAL
- en: d.  When you can’t think of a good name
  prefs: []
  type: TYPE_NORMAL
- en: 4.  When you change a variable’s data type, you should ___________ .
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Create a new variable and then delete it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting User Input**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, *we’ve* been assigning values to variables. In many cases, you’ll want
    to get input directly from a user; for example, for a unit conversion program.
    Because this is such a common practice, Python provides the built-in
  prefs: []
  type: TYPE_NORMAL
- en: '`input()` function. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `input()` function takes a question, known as a *prompt*, and presents it
    to the user. This prompt should be as unambiguous as possible so that the user
    knows what to enter (and in what format). The function then pauses the program
    until the user enters a value. Because the function expects strings, you don’t
    need to use quotation marks with the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `input()` function returns a *string*, which means that numbers might need
    to be converted to integers or floats depending on what your program will do with
    the input. To make the conversion, call either the `int()` or `float()` function
    in the assignment statement. For example, to ensure that the `age` variable is
    an integer, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also want the input to be consistent. Because Python is case sensitive,
    it’s common to convert input to lowercase to avoid running into any problems later.
    Enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we called the `lower()` string method to automatically convert
    the input to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When your program interacts with actual human users, if anything can go wrong,
    it will. There’s nothing to stop a user from entering their age as “forty-two”
    rather than “42.” Fortunately, Python provides things like while loops, try statements,
    and conditional statements, that let you check input for errors and either fix
    the problem directly or request that the user reenter the value in the format
    that it expects. We explore these in later chapters.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `input()` function is a fairly primitive way to get user input. Later, in
    the book, we’ll look at more sophisticated methods, such as using a GUI with menus,
    radio buttons, text boxes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Comparison Operators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python provides *comparison* operators, also called *relational* operators (see
    [Table 8-2](ch08.xhtml#ch08tab2)), that let you compare variables and determine
    the relationship between them. Each operator returns either `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-2:** Python Relational Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | If values are equal, condition is True | `(a == a) is True` |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | If values not equal, condition is True | `(a != b) is True` |'
  prefs: []
  type: TYPE_TB
- en: '| `<>` | If values not equal, condition is True | `(a <> b) is True` |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | If left value is greater than right, then True | `(2 > 6) is False`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | If left value is less than right, then True | `(2 < 6) is True` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | If left is greater than or equal to right, then True | `(2 >= 6) is
    False` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | If left is less than or equal to right, then True | `(2 <= 6) is True`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | Object identity | `(a is a) is True` |'
  prefs: []
  type: TYPE_TB
- en: '| `is not` | Negated object identity | `(a is not b) is True` |'
  prefs: []
  type: TYPE_TB
- en: 'The operators evaluate from left to right. For example, to check that 10 is
    larger than 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparison operators evaluate to a *Boolean* data type that has two values:
    `True` and `False`. These values are always capitalized and unlike strings, they
    don’t require quotes. You can check their type like any other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Because computers work in binary, `True` represents `1` (or `1.0`), and `False`
    represents `0` (or `0.0`). You can test this for yourself in the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this example, you can store Booleans in variables, use them
    in expressions, and convert them into integers and floats without raising an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two operators, both of which evaluate equality, work with any data
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The other operators, such as `>` and `<=`, work only with floating-point values
    and integers. For convenience, you can chain these together in a single line,
    such as `2 < x < 5`, which states that `x` is greater than `2` but less than `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these relationships to control what your program does. Here’s an
    example using conditional statements, which we investigate in [Chapter 10](ch10.xhtml).
    This example compares the pH values of three samples to determine which is the
    most acidic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the relational operators determine which statement
    is printed. You can also chain together comparisons for multiple variables, as
    demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `is` and `is not` operators check whether two objects share the same identity
    (in other words, point to the same object in memory). This is not the same as
    the equal to (`==`) and not equal to (`!=`) operators, that check *equality*.
    Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we assigned a large number to `x` and `y`, they are equal in value
    but are not the same object. If we use small values, however, they will be the
    same object, due to Python’s use of a startup memory cache, as discussed in “Chained
    Assignment and Internment” on [page 205](ch08.xhtml#ch00lev2sec116). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  If `x = 257` and `y = 257`, what does the code `x is y` evaluate to?
  prefs: []
  type: TYPE_NORMAL
- en: a.  True
  prefs: []
  type: TYPE_NORMAL
- en: b.  False
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Write a code snippet that prompts a user for their name and then prints
    the name in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Write an assignment statement that generates a `NameError`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Write an assignment statement that generates a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 10.  In the console, what is the output of `'hydrogen sulfide'.title()`?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `'Hydrogen Sulfide'`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `'HYDROGEN SULFIDE'`
  prefs: []
  type: TYPE_NORMAL
- en: 'c.  `AttributeError: ''str'' object has no attribute ''title''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'd.  `NameError: name ''title'' is not defined`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you got a closer look at how variables work and how to use
    them. You learned more about assigning variables as well as some rules and suggestions
    on how to name them, compare them, and solicit user input.
  prefs: []
  type: TYPE_NORMAL
- en: Because variables are just labels for objects in memory, they can sometimes
    behave unexpectedly, especially when working with mutable objects. This will become
    apparent in the next chapter, in which we explore the container data types such
    as lists, sets, and dictionaries.
  prefs: []
  type: TYPE_NORMAL
