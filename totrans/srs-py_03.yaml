- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**DOCUMENTATION AND GOOD API PRACTICE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档与良好的 API 实践**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: In this chapter, we’ll discuss documentation; specifically, how to automate
    the trickier and more tedious aspects of documenting your project with *Sphinx*.
    While you will still have to write the documentation yourself, Sphinx will simplify
    your task. As it is common to provide features using a Python library, we’ll also
    look at how to manage and document your public API changes. Because your API will
    have to evolve as you make changes to its features, it’s rare to get everything
    built perfectly from the outset, but I’ll show you a few things you can do to
    ensure your API is as user-friendly as possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论文档编写；特别是如何使用 *Sphinx* 自动化处理文档编写过程中较为繁琐和棘手的部分。虽然你仍然需要自己编写文档，但 Sphinx
    会简化你的任务。由于使用 Python 库提供功能很常见，我们还将探讨如何管理和记录公共 API 的变更。由于 API 必须随着功能的变化而发展，从一开始就把一切都构建得完美是罕见的，但我会展示一些方法，帮助你确保你的
    API 尽可能用户友好。
- en: We’ll end this chapter with an interview with Christophe de Vienne, author of
    the Web Services Made Easy framework, in which he discusses best practices for
    developing and maintaining APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以对 Web Services Made Easy 框架作者 Christophe de Vienne 的访谈结束，他在访谈中讨论了开发和维护 API
    的最佳实践。
- en: '**Documenting with Sphinx**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Sphinx 进行文档编写**'
- en: 'Documentation is one of the most important parts of writing software. Unfortunately,
    a lot of projects don’t provide proper documentation. Writing documentation is
    seen as complicated and daunting, but it doesn’t have to be: with the tools available
    to Python programmers, documenting your code can be just as easy as writing it.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是编写软件时最重要的部分之一。不幸的是，很多项目没有提供合适的文档。编写文档被认为是复杂且令人生畏的，但其实不必如此：借助 Python 程序员可用的工具，文档编写可以像编写代码一样简单。
- en: One of the biggest reasons for sparse or nonexistent documentation is that many
    people assume the only way to document code is by hand. Even with multiple people
    on a project, this means one or more of your team will end up having to juggle
    contributing code with maintaining documentation—and if you ask any developer
    which job they’d prefer, you can be sure they’ll say they’d rather write software
    than write *about* software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文档稀缺或根本没有的一个最大原因是许多人认为文档代码的唯一方式是手动编写。即使一个项目有多个成员，这也意味着你团队中的一人或多人最终不得不在贡献代码和维护文档之间进行权衡——如果你问任何开发人员他们更愿意做哪个工作，你可以肯定他们会说，他们更愿意编写软件，而不是*编写*关于软件的文档。
- en: 'Sometimes the documentation process is completely separate from the development
    process, meaning that the documentation is written by people who did not write
    the actual code. Furthermore, any documentation produced this way is likely to
    be out-of-date: it’s almost impossible for manual documentation to keep up with
    the pace of development, regardless of who handles it.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，文档编写过程与开发过程完全分开，意味着文档是由那些没有编写实际代码的人来写的。此外，以这种方式生成的任何文档都很可能是过时的：无论谁来处理，手动编写文档几乎不可能跟得上开发的步伐。
- en: 'Here’s the bottom line: the more degrees of separation between your code and
    your documentation, the harder it will be to keep the latter properly maintained.
    So why keep them separate at all? It’s not only possible to put your documentation
    directly in the code itself, but it’s also simple to convert that documentation
    into easy-to-read HTML and PDF files.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，代码和文档之间的隔阂越大，后者保持更新的难度就越大。那么，为什么要将它们分开呢？不仅可以将文档直接放在代码中，而且将文档转换为易于阅读的HTML和PDF文件也很简单。
- en: The most common format for Python documentation is *reStructuredText*, or *reST*
    for short. It’s a lightweight markup language (like Markdown) that’s as easy to
    read and write for humans as it is for computers. Sphinx is the most commonly
    used tool for working with this format; Sphinx can read reST-formatted content
    and output documentation in a variety of other formats.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文档的最常见格式是 *reStructuredText*，简称 *reST*。它是一种轻量级标记语言（类似于 Markdown），对于人类和计算机来说，都同样易于阅读和编写。Sphinx
    是最常用的处理这种格式的工具；Sphinx 可以读取 reST 格式的内容，并以多种其他格式输出文档。
- en: 'I recommend that your project documentation always include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你的项目文档始终包括以下内容：
- en: The problem your project is intended to solve, in one or two sentences.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目旨在解决的问题，简要概述，一两句话即可。
- en: The license your project is distributed under. If your software is open source,
    you should also include this information in a header in each code file; just because
    you’ve uploaded your code to the Internet doesn’t mean that people will know what
    they’re allowed to do with it.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目分发所使用的许可证。如果你的软件是开源的，你还应该在每个代码文件的头部包含这类信息；仅仅将代码上传到互联网上并不意味着人们会知道他们可以对其做什么。
- en: A small example of how your code works.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个小示例，展示你的代码如何工作。
- en: Installation instructions.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装说明。
- en: Links to community support, mailing list, IRC, forums, and so on.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向社区支持、邮件列表、IRC、论坛等的链接。
- en: A link to your bug tracker system.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向你的问题追踪系统的链接。
- en: A link to your source code so that developers can download and start delving
    into it right away.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向你源代码的链接，供开发者下载并立即开始深入研究。
- en: You should also include a *README.rst* file that explains what your project
    does. This README should be displayed on your GitHub or PyPI project page; both
    sites know how to handle reST formatting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该包括一个 *README.rst* 文件，解释你的项目的功能。这个 README 应该显示在你的 GitHub 或 PyPI 项目页面上；这两个网站都支持处理
    reST 格式。
- en: '**NOTE**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using GitHub, you can also add a CONTRIBUTING.rst file that will
    be displayed when someone submits a pull request. It should provide a checklist
    for users to follow before they submit the request, including things like whether
    your code follows PEP 8 and reminders to run the unit tests. Read the Docs ([http://readthedocs.org/](http://readthedocs.org/))
    allows you to build and publish your documentation online automatically. Signing
    up and configuring a project is straightforward. Then Read the Docs searches for
    your Sphinx configuration file, builds your documentation, and makes it available
    for your users to access. It’s a great companion to code-hosting sites.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你使用 GitHub，你还可以添加一个 CONTRIBUTING.rst 文件，当有人提交拉取请求时，它会显示出来。该文件应提供一个检查清单，供用户在提交请求之前遵循，包括诸如代码是否遵循
    PEP 8 规范、是否运行单元测试等提醒。Read the Docs ([http://readthedocs.org/](http://readthedocs.org/))
    允许你自动构建并发布在线文档。注册和配置项目非常简单。然后 Read the Docs 会搜索你的 Sphinx 配置文件，构建文档并让用户访问。它是代码托管网站的一个绝佳伴侣。*'
- en: '***Getting Started with Sphinx and reST***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开始使用 Sphinx 和 reST***'
- en: You can get Sphinx from *[http://www.sphinx-doc.org/](http://www.sphinx-doc.org/)*.
    There are installation instructions on the site, but the easiest method is to
    install with pip install sphinx.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *[http://www.sphinx-doc.org/](http://www.sphinx-doc.org/)* 获取 Sphinx。网站上有安装说明，但最简单的方法是使用
    `pip install sphinx` 安装。
- en: 'Once Sphinx is installed, run sphinx-quickstart in your project’s top-level
    directory. This will create the directory structure that Sphinx expects to find,
    along with two files in the *doc/source* folder: *conf.py*, which contains Sphinx’s
    configuration settings (and is absolutely required for Sphinx to work), and *index.rst*,
    which serves as the front page of your documentation. Once you run the quick-start
    command, you’ll be taken through a series of steps to designate naming conventions,
    version conventions, and options for other useful tools and standards.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Sphinx，在你项目的顶层目录下运行 sphinx-quickstart。这将创建 Sphinx 期望找到的目录结构，并在 *doc/source*
    文件夹中创建两个文件：*conf.py*，它包含 Sphinx 的配置设置（这是 Sphinx 工作所必需的），以及 *index.rst*，它作为文档的首页。运行快速启动命令后，系统会引导你完成一系列步骤，用以指定命名约定、版本约定以及其他有用工具和标准的选项。
- en: The *conf.py* file contains a few documented variables, such as the project
    name, the author, and the theme to use for HTML output. Feel free to edit this
    file at your convenience.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*conf.py* 文件包含了一些已文档化的变量，如项目名称、作者以及用于 HTML 输出的主题。你可以根据需要随时编辑此文件。'
- en: Once you’ve built your structure and set your defaults, you can build your documentation
    in HTML by calling sphinx-build with your source directory and output directory
    as arguments, as shown in [Listing 3-1](ch03.xhtml#ch3list1). The command sphinx-build
    reads the *conf.py* file from the source directory and parses all the *.rst* files
    from this directory. It renders them in HTML in the output directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了结构并设置了默认值，就可以通过调用 sphinx-build 并将源目录和输出目录作为参数，来构建 HTML 格式的文档，如 [示例 3-1](ch03.xhtml#ch3list1)
    所示。命令 sphinx-build 会读取源目录中的 *conf.py* 文件，并解析该目录下的所有 *.rst* 文件。然后它会在输出目录中以 HTML
    格式渲染这些文件。
- en: $ sphinx-build doc/source doc/build
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: $ sphinx-build doc/source doc/build
- en: import pkg_resources
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: import pkg_resources
- en: Running Sphinx v1.2b1
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行 Sphinx v1.2b1
- en: loading pickled environment... done
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正在加载 pickle 环境... 完成
- en: 'No builder selected, using default: html'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 未选择构建器，使用默认值：html
- en: 'building [html]: targets for 1 source files that are out of date'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正在构建 [html]：目标为 1 个过期的源文件
- en: 'updating environment: 0 added, 0 changed, 0 removed'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正在更新环境：0 添加，0 更改，0 删除
- en: looking for now-outdated files... none found
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正在查找过时的文件... 未找到
- en: preparing documents... done
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正在准备文档... 完成
- en: writing output... [100%] index
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正在写入输出... [100%] index
- en: writing additional files... genindex search copying static files... done
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正在写入附加文件... 生成索引、搜索、复制静态文件... 完成
- en: dumping search index... done
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正在转储搜索索引... 完成
- en: dumping object inventory... done
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正在转储对象清单... 完成
- en: build succeeded.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功。
- en: '*Listing 3-1: Building a basic Sphinx HTML document*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：构建基本的 Sphinx HTML 文档*'
- en: Now you can open *[doc/build/index.html](http://doc/build/index.html)* in your
    favorite browser and read your documentation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在你喜欢的浏览器中打开 *[doc/build/index.html](http://doc/build/index.html)* 并阅读你的文档。
- en: '**NOTE**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using setuptools or pbr (see [Chapter 5](ch05.xhtml#ch05)) for packaging,
    Sphinx extends them to support the command setup.py build_sphinx, which will run
    sphinx-build automatically. The pbr integration of Sphinx has some saner defaults,
    such as outputting the documentation in the /doc subdirectory.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你使用 setuptools 或 pbr（见 [第 5 章](ch05.xhtml#ch05)）进行打包，Sphinx 扩展了它们以支持命令 setup.py
    build_sphinx，这将自动运行 sphinx-build。Sphinx 的 pbr 集成提供了一些更合理的默认设置，例如将文档输出到 /doc 子目录中。*'
- en: 'Your documentation begins with the *index.rst* file, but it doesn’t have to
    end there: reST supports include directives to include reST files from other reST
    files, so there’s nothing stopping you from dividing your documentation into multiple
    files. Don’t worry too much about syntax and semantics to start; reST offers a
    lot of formatting possibilities, but you’ll have plenty of time to dive into the
    reference later. The complete reference (*[http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html](http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html)*)
    explains how to create titles, bulleted lists, tables, and more.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文档从 *index.rst* 文件开始，但不一定就此结束：reST 支持包含指令，可以从其他 reST 文件中包含 reST 文件，所以你可以将文档分成多个文件，没有任何障碍。刚开始时不用过于担心语法和语义；reST
    提供了许多格式化的可能性，但你以后有足够的时间深入了解参考资料。完整的参考资料 (*[http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html](http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html)*)
    解释了如何创建标题、项目符号列表、表格等。
- en: '***Sphinx Modules***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Sphinx 模块***'
- en: 'Sphinx is highly extensible: its basic functionality supports only manual documentation,
    but it comes with a number of useful modules that enable automatic documentation
    and other features. For example, sphinx.ext.autodoc extracts reST-formatted docstrings
    from your modules and generates *.rst* files for inclusion. This is one of the
    options sphinx-quickstart will ask if you want to activate. If you didn’t select
    that option, however, you can still edit your *conf.py* file and add it as an
    extension like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是高度可扩展的：其基本功能仅支持手动文档化，但它配备了多个有用的模块，使自动文档化和其他功能成为可能。例如，sphinx.ext.autodoc
    从你的模块中提取 reST 格式的文档字符串，并生成 *.rst* 文件以供包含。这是 sphinx-quickstart 在启动时会询问是否激活的选项。如果你没有选择该选项，依然可以编辑你的
    *conf.py* 文件，并像这样将其作为扩展添加：
- en: extensions = ['sphinx.ext.autodoc']
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 = ['sphinx.ext.autodoc']
- en: Note that autodoc will *not* automatically recognize and include your modules.
    You need to explicitly indicate which modules you want documented by adding something
    like [Listing 3-2](ch03.xhtml#ch3list2) to one of your *.rst* files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，autodoc *不会* 自动识别并包含你的模块。你需要显式指明希望文档化的模块，方法是将类似 [列表 3-2](ch03.xhtml#ch3list2)
    的内容添加到你的 *.rst* 文件中。
- en: '.. automodule:: foobar'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '.. automodule:: foobar'
- en: '➊     :members:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     :members:'
- en: '➋     :undoc-members:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '➋     :undoc-members:'
- en: '➌     :show-inheritance:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '➌     :show-inheritance:'
- en: '*Listing 3-2: Indicating the modules for autodoc to document*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：指定模块供 autodoc 文档化*'
- en: 'In [Listing 3-2](ch03.xhtml#ch3list2), we make three requests, all of which
    are optional: that all documented members be printed ➊, that all undocumented
    members be printed ➋, and that inheritance be shown ➌. Also note the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 3-2](ch03.xhtml#ch3list2) 中，我们发出了三个请求，所有这些请求都是可选的：打印所有已记录的成员 ➊，打印所有未记录的成员
    ➋，以及显示继承关系 ➌。还请注意以下几点：
- en: If you don’t include any directives, Sphinx won’t generate any output.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不包含任何指令，Sphinx 将不会生成任何输出。
- en: 'If you only specify :members:, undocumented nodes on your module, class, or
    method tree will be skipped, even if all their members are documented. For example,
    if you document the methods of a class but not the class itself, :members: will
    exclude both the class and its methods. To keep this from happening, you’d have
    to write a docstring for the class or specify :undoc-members: as well.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果你只指定 :members:，则模块、类或方法树中未文档化的节点将被跳过，即使它们的所有成员都已文档化。例如，如果你只文档化了一个类的方法，但没有文档化该类本身，:members:
    将排除该类及其方法。为了避免这种情况，你需要为类写一个文档字符串，或者同时指定 :undoc-members:。'
- en: Your module needs to be where Python can import it. Adding ., .., and/or ../..
    to sys.path can help.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的模块需要放在 Python 可以导入的位置。将 .、.. 和/或 ../.. 添加到 sys.path 中可以帮助解决问题。
- en: The autodoc extension gives you the power to include most of your documentation
    in your source code. You can even pick and choose which modules and methods to
    document—it’s not an “all-or-nothing” solution. By maintaining your documentation
    directly alongside your source code, you can easily ensure it stays up to date.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: autodoc 扩展使你能够将大部分文档直接包含在源代码中。你甚至可以选择要文档化的模块和方法——这不是“全有或全无”的解决方案。通过直接在源代码旁边维护文档，你可以轻松确保文档保持最新。
- en: '**Automating the Table of Contents with autosummary**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 autosummary 自动化目录生成**'
- en: If you’re writing a Python library, you’ll usually want to format your API documentation
    with a table of contents containing links to individual pages for each module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写 Python 库，通常会希望将 API 文档格式化为一个包含每个模块单独页面链接的目录。
- en: 'The sphinx.ext.autosummary module was created specifically to handle this common
    use case. First, you need to enable it in your *conf.py* by adding the following
    line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: sphinx.ext.autosummary 模块专门为处理这种常见的用例而创建。首先，你需要在 *conf.py* 中启用它，方法是添加以下行：
- en: extensions = ['sphinx.ext.autosummary']
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: extensions = ['sphinx.ext.autosummary']
- en: 'Then, you can add something like the following to an *.rst* file to automatically
    generate a table of contents for the specified modules:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像以下方式将其添加到 *.rst* 文件中，以便为指定的模块自动生成目录：
- en: '.. autosummary::'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '.. autosummary::'
- en: mymodule
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: mymodule
- en: mymodule.submodule
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: mymodule.submodule
- en: This will create files called *generated/mymodule.rst* and *generated/mymodule.submodule.rst*
    containing the autodoc directives described earlier. Using this same format, you
    can specify which parts of your module API you want included in your documentation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建名为 *generated/mymodule.rst* 和 *generated/mymodule.submodule.rst* 的文件，其中包含前面描述的
    autodoc 指令。使用这种格式，你可以指定希望包含在文档中的模块 API 部分。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The sphinx-apidoc command can automatically create these files for you; check
    out the Sphinx documentation to find out more.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*sphinx-apidoc 命令可以自动为你创建这些文件；请查看 Sphinx 文档了解更多信息。*'
- en: '**Automating Testing with doctest**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 doctest 自动化测试**'
- en: 'Another useful feature of Sphinx is the ability to run doctest on your examples
    automatically when you build your documentation. The standard Python doctest module
    searches your documentation for code snippets and tests whether they accurately
    reflect what your code does. Every paragraph starting with the primary prompt
    >>> is treated as a code snippet to test. For example, if you wanted to document
    the standard print function from Python, you could write this documentation snippet
    and doctest would check the result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 另一个有用的功能是能够在构建文档时自动运行 doctest 来检查你的示例。标准的 Python doctest 模块会在文档中搜索代码片段，并测试它们是否准确地反映了你的代码行为。每个以主提示符
    >>> 开头的段落都会被视为需要测试的代码片段。例如，如果你想文档化 Python 的标准 print 函数，你可以写下如下文档片段，然后 doctest
    会检查结果：
- en: To print something to the standard output, use the :py:func:`print`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要将内容打印到标准输出，使用 :py:func:`print`
- en: 'function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数：
- en: '>>> print("foobar")'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("foobar")'
- en: foobar
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: foobar
- en: Having such examples in your documentation lets users understand your API. However,
    it’s easy to put off and eventually forget to update your examples as your API
    evolves. Fortunately, doctest helps make sure this doesn’t happen. If your documentation
    includes a step-by-step tutorial, doctest will help you keep it up to date throughout
    development by testing every line it can.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中包含此类示例可以帮助用户理解你的 API。然而，随着 API 的发展，很容易拖延并最终忘记更新示例。幸运的是，doctest 可以确保这种情况不会发生。如果你的文档包括逐步教程，doctest
    会通过测试它能检查的每一行来帮助你在开发过程中保持文档的最新。
- en: 'You can also use doctest for *documentation-driven development (DDD)*: write
    your documentation and examples first and then write code to match your documentation.
    Taking advantage of this feature is as simple as running sphinx-build with the
    special doctest builder, like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用doctest进行*文档驱动开发（DDD）*：先编写文档和示例，然后编写代码以匹配文档。利用此功能非常简单，只需使用特殊的doctest构建器运行sphinx-build，例如：
- en: $ sphinx-build -b doctest doc/source doc/build
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: $ sphinx-build -b doctest doc/source doc/build
- en: Running Sphinx v1.2b1
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Sphinx v1.2b1
- en: loading pickled environment... done
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正在加载腌制的环境... 完成
- en: 'building [doctest]: targets for 1 source files that are out of date'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正在构建[doctest]：1个过期源文件的目标
- en: 'updating environment: 0 added, 0 changed, 0 removed'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 更新环境：0新增，0更改，0移除
- en: looking for now-outdated files... none found
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正在寻找过时的文件... 未找到
- en: running tests...
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行测试...
- en: 'Document: index'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文档：index
- en: '---------------'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------'
- en: '1 items passed all tests:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 1个项目通过了所有测试：
- en: 1 tests in default
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下的1个测试
- en: 1 tests in 1 items.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 1个测试在1个项目中通过。
- en: 1 passed and 0 failed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1个通过，0个失败。
- en: Test passed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过。
- en: Doctest summary
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest总结
- en: ===============
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ===============
- en: 1 test
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 1个测试
- en: 0 failures in tests
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中没有失败
- en: 0 failures in setup code
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设置代码中没有失败
- en: 0 failures in cleanup code
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 清理代码中没有失败
- en: build succeeded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功。
- en: When using the doctest builder, Sphinx reads the usual *.rst* files and executes
    code examples that are contained in those files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用doctest构建器时，Sphinx会读取常规的*.rst*文件，并执行其中包含的代码示例。
- en: 'Sphinx also provides a bevy of other features, either out of the box or through
    extension modules, including these:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx还提供了许多其他功能，既有开箱即用的，也有通过扩展模块提供的，包括这些：
- en: Linking between projects
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目间链接
- en: HTML themes
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML主题
- en: Diagrams and formulas
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表和公式
- en: Output to Texinfo and EPUB format
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出到Texinfo和EPUB格式
- en: Linking to external documentation
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到外部文档
- en: You might not need all this functionality right away, but if you ever need it
    in the future, it’s good to know about in advance. Again, check out the full Sphinx
    documentation to find out more.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不需要立即使用所有这些功能，但如果将来需要的话，提前了解这些功能是很有帮助的。再次查看完整的Sphinx文档以了解更多。
- en: '***Writing a Sphinx Extension***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写Sphinx扩展***'
- en: Sometimes off-the-shelf solutions just aren’t enough and you need to create
    custom tools to deal with a situation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候现成的解决方案不足以应对某些情况，你需要创建自定义工具来解决问题。
- en: 'Say you’re writing an HTTP REST API. Sphinx will only document the Python side
    of your API, forcing you to write your REST API documentation by hand, with all
    the problems that entails. The creators of Web Services Made Easy (WSME) (interviewed
    at the end of this chapter) have come up with a solution: a Sphinx extension called
    sphinxcontrib-pecanwsme that analyzes docstrings and actual Python code to generate
    REST API documentation automatically.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个HTTP REST API。Sphinx只会记录你的API的Python部分，这迫使你手动编写REST API文档，并且会遇到所有相关的问题。Web
    Services Made Easy (WSME)的创建者（本章末尾的访谈中提到）提出了一个解决方案：一个名为sphinxcontrib-pecanwsme的Sphinx扩展，它分析文档字符串和实际Python代码，自动生成REST
    API文档。
- en: '**NOTE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For other HTTP frameworks, such as Flask, Bottle, and Tornado, you can use
    sphinxcontrib.httpdomain.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于其他HTTP框架，如Flask、Bottle和Tornado，你可以使用sphinxcontrib.httpdomain。*'
- en: My point is that whenever you know you could extract information from your code
    to build documentation, you should, and you should also automate the process.
    This is better than trying to maintain manually written documentation, especially
    when you can leverage auto-publication tools such as Read the Docs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我的观点是，每当你知道可以从代码中提取信息来生成文档时，就应该这样做，并且应当自动化这个过程。这比尝试维护手写的文档要好，特别是当你可以利用像Read
    the Docs这样的自动发布工具时。
- en: We’ll examine the sphinxcontrib-pecanwsme extension as an example of writing
    your own Sphinx extension. The first step is to write a module—preferably as a
    submodule of sphinxcontrib, as long as your module is generic enough—and pick
    a name for it. Sphinx requires this module to have one predefined function called
    setup(app), which contains the methods you’ll use to connect your code to Sphinx
    events and directives. The full list of methods is available in the Sphinx extension
    API at *[http://www.sphinx-doc.org/en/master/extdev/appapi.html](http://www.sphinx-doc.org/en/master/extdev/appapi.html)*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以 sphinxcontrib-pecanwsme 扩展为例，介绍如何编写自己的 Sphinx 扩展。第一步是编写一个模块——最好作为 sphinxcontrib
    的子模块，只要你的模块足够通用——并为其选择一个名称。Sphinx 要求此模块必须有一个名为 setup(app) 的预定义函数，该函数包含你用来将代码连接到
    Sphinx 事件和指令的方法。完整的方法列表可以在 Sphinx 扩展 API 中找到，地址是 *[http://www.sphinx-doc.org/en/master/extdev/appapi.html](http://www.sphinx-doc.org/en/master/extdev/appapi.html)*。
- en: For example, the sphinxcontrib-pecanwsme extension includes a single directive
    called rest-controller, added using the setup(app) function. This added directive
    needs a fully qualified controller class name to generate documentation for, as
    shown in [Listing 3-3](ch03.xhtml#ch3list3).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，sphinxcontrib-pecanwsme 扩展包含一个名为 rest-controller 的指令，通过使用 setup(app) 函数添加。此添加的指令需要一个完全限定的控制器类名来生成文档，如
    [列表 3-3](ch03.xhtml#ch3list3) 所示。
- en: 'def setup(app):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup(app):'
- en: app.add_directive('rest-controller', RESTControllerDirective)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: app.add_directive('rest-controller', RESTControllerDirective)
- en: '*Listing 3-3: Code from sphinxcontrib.pecanwsme.rest.setup that adds the rest-controller
    directive*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-3：来自 sphinxcontrib.pecanwsme.rest.setup 的代码，添加了 rest-controller 指令*'
- en: The add_directive method in [Listing 3-3](ch03.xhtml#ch3list3) registers the
    rest-controller directive and delegates its handling to the RESTControllerDirective
    class. This RESTControllerDirective class exposes certain attributes that indicate
    how the directive treats content, whether it has arguments, and so on. The class
    also implements a run() method that actually extracts the documentation from your
    code and returns parsed data to Sphinx.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-3](ch03.xhtml#ch3list3) 中的 add_directive 方法注册了 rest-controller 指令，并将其处理委托给
    RESTControllerDirective 类。此 RESTControllerDirective 类公开了某些属性，用于指示指令如何处理内容，是否有参数等。该类还实现了一个
    run() 方法，实际上从代码中提取文档并将解析后的数据返回给 Sphinx。'
- en: The repository at *[https://bitbucket.org/birkenfeld/sphinx-contrib/src/](https://bitbucket.org/birkenfeld/sphinx-contrib/src/)*
    has many small modules that can help you develop your own extensions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *[https://bitbucket.org/birkenfeld/sphinx-contrib/src/](https://bitbucket.org/birkenfeld/sphinx-contrib/src/)*
    上的代码库中，有许多小模块可以帮助你开发自己的扩展。
- en: '**NOTE**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even though Sphinx is written in Python and targets it by default, extensions
    are available that allow it to support other languages as well. You can use Sphinx
    to document your project in full, even if it uses multiple languages at once.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 Sphinx 是用 Python 编写的，并且默认支持 Python，但也有扩展可以让它支持其他语言。即使你的项目同时使用多种语言，你也可以使用
    Sphinx 来全面记录你的项目。*'
- en: As another example, in one of my projects named Gnocchi—a database for storing
    and indexing time series data at a large scale—I’ve used a custom Sphinx extension
    to autogenerate documentation. Gnocchi provides a REST API, and usually to document
    such an API, projects will manually write examples of what an API request and
    its response should look like. Unfortunately, this approach is error prone and
    out of sync with reality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，在我名为 Gnocchi 的项目中——这是一个用于存储和索引大规模时间序列数据的数据库——我使用了一个自定义的 Sphinx 扩展来自动生成文档。Gnocchi
    提供了一个 REST API，通常为了文档化这样的 API，项目会手动编写 API 请求及其响应的示例。不幸的是，这种方法容易出错，并且与实际情况不同步。
- en: 'Using the unit-testing code available to test the Gnocchi API, we built a Sphinx
    extension to run Gnocchi and generate an *.rst* file containing HTTP requests
    and responses run against a real Gnocchi server. In this way, we ensure the documentation
    is up to date: the server responses are not manually crafted, and if a manually
    written request fails, then the documentation process fails, and we know that
    we must fix the documentation.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可用的单元测试代码来测试 Gnocchi API，我们构建了一个 Sphinx 扩展来运行 Gnocchi，并生成一个 *.rst* 文件，其中包含针对真实
    Gnocchi 服务器运行的 HTTP 请求和响应。通过这种方式，我们确保文档是最新的：服务器响应不是手工编写的，如果手动编写的请求失败，则文档生成过程失败，我们知道必须修复文档。
- en: Including that code in the book would be too verbose, but you can check the
    sources of Gnocchi online and look at the gnocchi.gendoc module to get an idea
    of how it works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码包含在书中会显得过于冗长，但你可以在线查看 Gnocchi 的源码，并查看 gnocchi.gendoc 模块以了解它的工作原理。
- en: '***Managing Changes to Your APIs***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理你的 API 变更***'
- en: Well-documented code is a sign to other developers that the code is suitable
    to be imported and used to build something else. When building a library and exporting
    an API for other developers to use, for example, you want to provide the reassurance
    of solid documentation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的文档化代码是其他开发者看到该代码适合被导入并用于构建其他东西的标志。例如，当构建一个库并导出 API 供其他开发者使用时，你应该提供稳固的文档以增加可信度。
- en: This section will cover best practices for public APIs. These will be exposed
    to users of your library or application, and while you can do whatever you like
    with internal APIs, public APIs should be handled with care.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖公共 API 的最佳实践。这些 API 将暴露给你的库或应用程序的用户，虽然你可以随意处理内部 API，但公共 API 应该谨慎处理。
- en: 'To distinguish between public and private APIs, the Python convention is to
    prefix the symbol for a private API with an underscore: foo is public, but _bar
    is private. You should use this convention both to recognize whether another API
    is public or private and to name your own APIs. In contrast to other languages,
    such as Java, Python does not enforce any restriction on accessing code marked
    as private or public. The naming conventions are just to facilitate understanding
    among programmers.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分公共和私有 API，Python 的约定是将私有 API 的符号前缀加上一个下划线：foo 是公共的，但 _bar 是私有的。你应该遵循这一约定来识别其他
    API 是否为公共或私有，并为你自己的 API 命名。与其他语言（如 Java）不同，Python 不会强制限制对标记为私有或公共的代码的访问。命名约定仅仅是为了方便程序员之间的理解。
- en: '***Numbering API Versions***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***API 版本号管理***'
- en: When properly constructed, the version number of an API can give users a great
    deal of information. Python has no particular system or convention in place for
    numbering API versions, but we can take inspiration from Unix platforms, which
    use a complex management system for libraries with fine-grained version identifiers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确构建时，API 的版本号可以为用户提供大量信息。Python 没有特别的系统或约定来标识 API 版本，但我们可以从 Unix 平台中获取灵感，Unix
    平台使用复杂的管理系统为库提供精细的版本标识符。
- en: Generally, your version numbering should reflect changes in the API that will
    impact users. For example, when the API has a major change, the major version
    number might change from 1 to 2\. When only a few new API calls are added, the
    lesser number might go from 2.2 to 2.3\. If a change only involves bug fixes,
    the version might bump from 2.2.0 to 2.2.1\. A good example of how to use version
    numbering is the Python requests library (*[https://pypi.python.org/pypi/requests/](https://pypi.python.org/pypi/requests/)*).
    This library increments its API numbers based on the number of changes in each
    new version and the impact the changes might have on consuming programs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，版本号应反映出会影响用户的 API 变化。例如，当 API 进行重大更改时，主版本号可能会从 1 更改为 2。如果只添加了少量新的 API 调用，次版本号可能会从
    2.2 更改为 2.3。如果更改仅涉及修复漏洞，版本号可能会从 2.2.0 升级到 2.2.1。Python 的 requests 库是如何使用版本号的一个很好的例子
    (*[https://pypi.python.org/pypi/requests/](https://pypi.python.org/pypi/requests/)*)，该库基于每个新版本中的更改数量以及这些更改对消费程序的影响来递增其
    API 版本号。
- en: 'Version numbers hint to developers that they should look at changes between
    two releases of a library, but alone they are not enough to fully guide a developer:
    you must provide detailed documentation to describe those changes.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号提示开发者应该查看库的两个版本之间的变化，但仅凭版本号并不足以完全指导开发者：你必须提供详细的文档来描述这些变化。
- en: '***Documenting Your API Changes***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***记录你的 API 变更***'
- en: 'Whenever you make changes to an API, the first and most important thing to
    do is to heavily document them so that a consumer of your code can get a quick
    overview of what’s changing. Your document should cover the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你对 API 进行更改时，最重要的事情是要详细记录这些变更，以便代码的使用者可以快速了解发生了什么变化。你的文档应该涵盖以下内容：
- en: New elements of the new interface
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新接口的新增元素
- en: Elements of the old interface that are deprecated
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已废弃的旧接口元素
- en: Instructions on how to migrate to the new interface
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何迁移到新接口的说明
- en: You should also make sure that you don’t remove the old interface right away.
    I recommend keeping the old interface until it becomes too much trouble to do
    so. If you have marked it as deprecated, users will know not to use it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该确保不要立刻删除旧的接口。我建议在遇到麻烦之前继续保留旧接口。如果你已经标记为废弃，用户就会知道不要使用它。
- en: '[Listing 3-4](ch03.xhtml#ch3list4) is an example of good API change documentation
    for code that provides a representation of a car object that can turn in any direction.
    For whatever reason, the developers decided to retract the turn_left method and
    instead provide a generic turn method that can take the direction as an argument.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 3-4](ch03.xhtml#ch3list4) 是一个很好的 API 变更文档示例，展示了一个可以转向任意方向的汽车对象的代码。由于某种原因，开发者决定撤回
    `turn_left` 方法，而是提供一个通用的 `turn` 方法，能够接受方向作为参数。'
- en: 'class Car(object):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Car(object):'
- en: 'def turn_left(self):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turn_left(self):'
- en: '"""Turn the car left.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将车转向左。'
- en: '.. deprecated:: 1.1'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '.. deprecated:: 1.1'
- en: Use :func:`turn` instead with the direction argument set to left
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 :func:`turn`，并将方向参数设置为左
- en: '"""'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self.turn(direction='left')
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: self.turn(direction='left')
- en: 'def turn(self, direction):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turn(self, direction):'
- en: '"""Turn the car in some direction.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将车转向某个方向。'
- en: ':param direction: The direction to turn to.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ':param direction: 转向的方向。'
- en: ':type direction: str'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ':type direction: str'
- en: '"""'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# Write actual code for the turn function here instead'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在这里编写实际的 turn 函数代码'
- en: pass
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '*Listing 3-4: An example of API change documentation for a car object*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-4：汽车对象的 API 变更文档示例*'
- en: The triple quotes here, """, indicate the start and end of the docstrings, which
    will be pulled into the documentation when the user enters help(Car.turn_left)
    into the terminal or extracts the documentation with an external tool such as
    Sphinx. The deprecation of the car.turn_left method is indicated by .. deprecated
    1.1, where 1.1 refers to the first version released that ships this code as deprecated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的三重引号 `"""` 表示文档字符串的开始和结束，当用户在终端输入 help(Car.turn_left) 或使用像 Sphinx 这样的外部工具提取文档时，这部分内容将被引入到文档中。`car.turn_left`
    方法的废弃通过 `.. deprecated 1.1` 来标识，其中 1.1 表示包含该废弃代码的第一个版本。
- en: Using this deprecation method and making it visible via Sphinx clearly tells
    users that the function should not be used and gives them direct access to the
    new function along with an explanation of how to migrate old code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种废弃方法并通过 Sphinx 使其可见，可以清晰地告诉用户该函数不应使用，并直接提供新的函数，同时解释如何迁移旧代码。
- en: '[Figure 3-1](ch03.xhtml#ch3fig1) shows Sphinx documentation that explains some
    deprecated functions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.xhtml#ch3fig1) 显示了 Sphinx 文档，解释了一些废弃函数。'
- en: '![image](../images/f03-01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-01.jpg)'
- en: '*Figure 3-1: Explanation of some deprecated functions*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：某些废弃函数的说明*'
- en: 'The downside of this approach is that it relies on developers reading your
    changelog or documentation when they upgrade to a newer version of your Python
    package. However, there is a solution for that: mark your deprecated functions
    with the warnings module.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是它依赖于开发者在升级到新版本 Python 包时阅读你的变更日志或文档。然而，有一个解决方案：使用 `warnings` 模块标记废弃函数。
- en: '***Marking Deprecated Functions with the warnings Module***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 warnings 模块标记废弃函数***'
- en: Though deprecated modules should be marked well enough in documentation that
    users will not attempt to call them, Python also provides the warnings module,
    which allows your code to issue various kinds of warnings when a deprecated function
    is called. These warnings, DeprecationWarning and PendingDeprecationWarning, can
    be used to tell the developer that a function they’re calling is deprecated or
    going to be deprecated, respectively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管废弃的模块应在文档中标明，以避免用户尝试调用它们，但 Python 还提供了 `warnings` 模块，允许你的代码在调用废弃函数时发出各种警告。这些警告
    `DeprecationWarning` 和 `PendingDeprecationWarning` 可用于告知开发者，他们调用的函数已经废弃或即将废弃。
- en: '**NOTE**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For those who work with C, this is a handy counterpart to the __attribute__
    ((deprecated)) GCC extension.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于从事 C 开发的人来说，这是 GCC 扩展 __attribute__ ((deprecated)) 的一个便捷对应物。*'
- en: To go back to the car object example in [Listing 3-4](ch03.xhtml#ch3list4),
    we can use this to warn users when they are attempting to call deprecated functions,
    as shown in [Listing 3-5](ch03.xhtml#ch3list5).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [Listing 3-4](ch03.xhtml#ch3list4) 中的汽车对象示例，我们可以用这个方法在用户尝试调用废弃函数时发出警告，如 [Listing
    3-5](ch03.xhtml#ch3list5) 所示。
- en: import warnings
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: import warnings
- en: 'class Car(object):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Car(object):'
- en: 'def turn_left(self):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turn_left(self):'
- en: '"""Turn the car left.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将车转向左。'
- en: '➊ .. deprecated:: 1.1'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ .. deprecated:: 1.1'
- en: Use :func:`turn` instead with the direction argument set to "left".
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请改用 :func:`turn`，并将方向参数设置为 "left"。
- en: '"""'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ➋ warnings.warn("turn_left is deprecated; use turn instead",
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ warnings.warn("turn_left 已弃用；请改用 turn",
- en: DeprecationWarning)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 弃用警告)
- en: self.turn(direction='left')
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: self.turn(direction='left')
- en: 'def turn(self, direction):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turn(self, direction):'
- en: '"""Turn the car in some direction.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将车向某个方向转。'
- en: ':param direction: The direction to turn to.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ':param direction: 要转向的方向。'
- en: ':type direction: str'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ':type direction: str'
- en: '"""'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# Write actual code here instead'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这里写实际的代码'
- en: pass
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '*Listing 3-5: A documented change to the car object API using the warnings
    module*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-5：使用 warnings 模块记录的车对象 API 更改*'
- en: 'Here, the turn_left function has been deprecated ➊. By adding the warnings.warn
    line, we can write our own error message ➋. Now, if any code should call the turn_left
    function, a warning will appear that looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，turn_left 函数已经被弃用 ➊。通过添加 warnings.warn 语句，我们可以写下自己的错误消息 ➋。现在，如果任何代码调用 turn_left
    函数，警告将如下所示：
- en: '>>> Car().turn_left()'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Car().turn_left()'
- en: '__main__:8: DeprecationWarning: turn_left is deprecated; use turn instead'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '__main__:8: 弃用警告：turn_left 已弃用；请改用 turn'
- en: Python 2.7 and later versions, by default, do not print any warnings emitted
    by the warnings module because the warnings are filtered. To see those warnings
    printed, you need to pass the -W option to the Python executable. The option -W
    all will print all warnings to stderr. See the Python man page for more information
    on the possible values for -W.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7 及以后的版本默认不会打印 warnings 模块发出的任何警告，因为警告被过滤了。要查看这些警告，您需要将 -W 选项传递给 Python
    可执行文件。选项 -W all 会将所有警告打印到标准错误输出。有关 -W 可能的值，请参阅 Python 手册页。
- en: When running test suites, developers can run Python with the -W error option,
    which will raise an error every time an obsolete function is called. Developers
    using your library can readily find exactly where their code needs to be fixed.
    [Listing 3-6](ch03.xhtml#ch3list6) shows how Python transforms warnings into fatal
    exceptions when Python is called with the -W error option.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试套件时，开发者可以使用 -W 错误选项运行 Python，这将在每次调用过时的函数时抛出错误。使用您的库的开发者可以轻松找到代码需要修复的地方。[示例
    3-6](ch03.xhtml#ch3list6) 展示了在使用 -W 错误选项调用 Python 时，Python 如何将警告转化为致命异常。
- en: '>>> import warnings'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import warnings'
- en: '>>> warnings.warn("This is deprecated", DeprecationWarning)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> warnings.warn("此功能已弃用", DeprecationWarning)'
- en: 'Traceback (most recent call last):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module>
- en: 'DeprecationWarning: This is deprecated'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 弃用警告：此功能已弃用
- en: '*Listing 3-6: Running Python with the -W error option and getting a deprecation
    error*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-6：使用 -W 错误选项运行 Python 并获取弃用错误*'
- en: Warnings are usually missed at runtime, and running a production system with
    the -W error option is rarely a good idea. Running the test suite of a Python
    application with the -W error option, on the other hand, can be a good way to
    catch warnings and fix them early on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 警告通常在运行时被忽略，且使用 -W 错误选项运行生产系统通常不是一个好主意。另一方面，使用 -W 错误选项运行 Python 应用程序的测试套件，反而可以是一个捕获警告并及早修复它们的好方法。
- en: However, manually writing all those warnings, docstring updates, and so on can
    become tedious, so the debtcollector library has been created to help automate
    some of that. The debtcollector library provides a few decorators that you can
    use with your functions to make sure the correct warnings are emitted and the
    docstring is updated correctly. [Listing 3-7](ch03.xhtml#ch3list7) shows how you
    can, with a simple decorator, indicate that a function has been moved to some
    other place.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动编写所有这些警告、文档字符串更新等会变得繁琐，因此创建了 debtcollector 库来帮助自动化其中的一些工作。debtcollector
    库提供了一些装饰器，您可以将其与函数一起使用，确保正确的警告被发出，并且文档字符串得到正确更新。[示例 3-7](ch03.xhtml#ch3list7)
    展示了如何通过一个简单的装饰器，指示一个函数已经被移动到其他地方。
- en: from debtcollector import moves
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: from debtcollector import moves
- en: 'class Car(object):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Car(object):'
- en: '@moves.moved_method(''turn'', version=''1.1'')'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '@moves.moved_method(''turn'', version=''1.1'')'
- en: 'def turn_left(self):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turn_left(self):'
- en: '"""Turn the car left."""'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将车向左转。”'
- en: return self.turn(direction='left')
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: return self.turn(direction='left')
- en: 'def turn(self, direction):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'def turn(self, direction):'
- en: '"""Turn the car in some direction.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将车向某个方向转。'
- en: ':param direction: The direction to turn to.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ':param direction: 要转向的方向。'
- en: ':type direction: str'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ':type direction: str'
- en: '"""'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# Write actual code here instead'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这里写实际的代码'
- en: pass
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '*Listing 3-7: An API change automated with debtcollector*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-7：通过 debtcollector 自动化的 API 更改*'
- en: Here we’re using the moves() method from debtcollector, whose moved_method decorator
    makes turn_left emit a DeprecationWarning whenever it’s called.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了来自 debtcollector 的 moves() 方法，它的 moved_method 装饰器会在每次调用 turn_left 时发出一个
    DeprecationWarning。
- en: '**Summary**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Sphinx is the de facto standard for documenting Python projects. It supports
    a wide variety of syntax, and it is easy to add new syntax or features if your
    project has particular needs. Sphinx can also automate tasks such as generating
    indexes or extracting documentation from your code, making it easy to maintain
    documentation in the long run.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是记录 Python 项目的事实标准。它支持多种语法，如果你的项目有特殊需求，也可以轻松添加新的语法或功能。Sphinx 还可以自动化生成索引或从代码中提取文档等任务，使得长时间维护文档变得更加容易。
- en: Documenting changes to your API is critical, especially when you deprecate functionality,
    so that users are not caught unawares. Ways to document deprecations include the
    Sphinx deprecated keyword and the warnings module, and the debtcollector library
    can automate maintaining this documentation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对 API 变更进行文档记录至关重要，特别是当你弃用某些功能时，以避免用户措手不及。记录弃用内容的方式包括 Sphinx 的 deprecated 关键字和
    warnings 模块，而 debtcollector 库可以自动化维护这些文档。
- en: '**Christophe de Vienne on Developing APIs**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Christophe de Vienne 关于开发 API 的观点**'
- en: Christophe is a Python developer and the author of the WSME (Web Services Made
    Easy) framework, which allows developers to define web services in a Pythonic
    way and supports a wide variety of APIs, allowing it to be plugged into many other
    web frameworks.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Christophe 是一名 Python 开发者，也是 WSME（Web Services Made Easy）框架的作者，该框架允许开发者以 Pythonic
    的方式定义 Web 服务，并支持多种 API，能够与其他 Web 框架进行集成。
- en: '**What mistakes do developers tend to make when designing a Python API?**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者在设计 Python API 时容易犯哪些错误？**'
- en: 'There are a few common mistakes I avoid when designing a Python API by following
    these rules:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 Python API 时，我遵循这些规则来避免一些常见的错误：
- en: '**Don’t make it too complicated.** Keep it simple. Complicated APIs are hard
    to understand and hard to document. While the actual library functionality doesn’t
    *have* to be simple as well, it’s smart to make it simple so users can’t easily
    make mistakes. For example, the library is very simple and intuitive, but it does
    complex things behind the scenes. The urllib API, by contrast, is almost as complicated
    as the things it does, making it hard to use.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要把它做得太复杂。** 保持简单。复杂的 API 很难理解，也很难文档化。虽然实际的库功能不一定要简单，但聪明的做法是将其设计得简单，这样用户就不容易出错。例如，该库本身非常简单直观，但在幕后做了复杂的事情。相比之下，urllib
    的 API 几乎与它所做的事情一样复杂，导致它难以使用。'
- en: '**Make the magic visible.** When your API does things that your documentation
    doesn’t explain, your end users will want to crack open your code and see what’s
    going on under the hood. It’s okay if you’ve got some magic happening behind the
    scenes, but your end users should never see anything unexpected happening up front,
    or they could become confused or rely on a behavior that may change.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让魔法显现出来。** 当你的 API 做了一些文档中没有解释的事情时，最终用户可能会想打开你的代码，看看背后发生了什么。如果你在幕后有一些魔法是没问题的，但你的最终用户不应该看到任何意外的行为发生，否则他们可能会感到困惑，或者依赖某种可能会改变的行为。'
- en: '**Don’t forget use cases.** When you’re so focused on writing code, it’s easy
    to forget to think about how your library will actually be used. Thinking up good
    use cases makes it easier to design an API.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忽视使用场景。** 当你专注于编写代码时，很容易忘记思考你的库将如何被实际使用。思考出好的使用场景有助于更容易地设计一个 API。'
- en: '**Write unit tests.** *TDD (test-driven development)* is a very efficient way
    to write libraries, especially in Python, because it forces the developer to assume
    the role of the end user from the very beginning, which leads the developer to
    design for usability. It’s the only approach I know of that allows a programmer
    to completely rewrite a library, as a last resort.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写单元测试。** *TDD（测试驱动开发）* 是一种非常高效的编写库的方式，尤其是在 Python 中，因为它迫使开发者从一开始就站在最终用户的角度进行思考，这使得开发者更注重可用性设计。这是我所知道的唯一一种方法，能够让程序员在必要时完全重写一个库。'
- en: '**What aspects of Python may affect how easy it is to design a library API?**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 的哪些方面可能会影响设计库 API 的难易程度？**'
- en: Python has no built-in way to define which sections of the API are public and
    which are private, which can be both a problem and an advantage.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有内建的方式来定义哪些部分是公开的，哪些是私有的，这既是一个问题，也可能是一个优势。
- en: It’s a problem because it can lead the developer to not fully consider which
    parts of their API are public and which parts should remain private. But with
    a little discipline, documentation, and (if needed) tools like zope.interface,
    it doesn’t stay a problem for long.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: It’s an advantage when it makes it quicker and easier to refactor APIs while
    keeping compatibility with previous versions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**What do you consider when thinking about your API’s evolution, deprecation,
    and removal?**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several criteria I weigh when making any decision regarding API development:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**How difficult will it be for users of the library to adapt their code?**
    Considering that there are people relying on your API, any change you make has
    to be worth the effort needed to adopt it. This rule is intended to prevent incompatible
    changes to the parts of the API that are in common use. That said, one of the
    advantages of Python is that it’s relatively easy to refactor code to adopt an
    API change.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How easy will it be to maintain my API?** Simplifying the implementation,
    cleaning up the codebase, making the API easier to use, having more complete unit
    tests, making the API easier to understand at first glance . . . all of these
    things will make your life as a maintainer easier.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How can I keep my API consistent when applying a change?** If all the functions
    in your API follow a similar pattern (such as requiring the same parameter in
    the first position), make sure new functions follow that pattern as well. Also,
    doing too many things at once is a great way to end up doing none of them right:
    keep your API focused on what it’s meant to do.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How will users benefit from the change?** Last but not least, always consider
    the users’ point of view.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What advice do you have regarding API documentation in Python?**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Good documentation makes it easy for newcomers to adopt your library. Neglecting
    it will drive away a lot of potential users—not just beginners, either. The problem
    is, documenting is difficult, so it gets neglected all the time!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Document early and include your documentation build in continuous integration.**
    With the Read the Docs tool for creating and hosting documentation, there’s no
    excuse for not having documentation built and published (at least for open source
    software).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use docstrings to document classes and functions in your API.** If you follow
    the PEP 257 (*[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*)
    guidelines, developers won’t have to read your source to understand what your
    API does. Generate HTML documentation from your docstrings—and don’t limit it
    to the API reference.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Give practical examples throughout.** Have at least one “startup guide” that
    will show newcomers how to build a working example. The first page of the documentation
    should give a quick overview of your API’s basic and representative use case.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document the evolution of your API in detail, version by version.** Version
    control system (VCS) logs are not enough!'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细记录你 API 的演变过程，逐个版本地记录。** 版本控制系统（VCS）日志是不够的！'
- en: '**Make your documentation accessible and, if possible, comfortable to read.**
    Your users need to be able to find it easily and get the information they need
    without feeling like they’re being tortured. Publishing your documentation through
    PyPI is one way to achieve this; publishing on Read the Docs is also a good idea,
    since users will expect to find your documentation there.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使你的文档易于访问，并且如果可能的话，让它更舒适易读。** 你的用户需要能够轻松找到文档，并获取所需的信息，而不会觉得自己像在受折磨。通过 PyPI
    发布文档是一种实现这个目标的方法；在 Read the Docs 上发布文档也是个不错的主意，因为用户通常会期望在那找到你的文档。'
- en: '**Finally, choose a theme that is both efficient and attractive.** I chose
    the “Cloud” Sphinx theme for WSME, but there are plenty of other themes out there
    to choose from. You don’t have to be a web expert to produce nice-looking documentation.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后，选择一个既高效又吸引人的主题。** 我为 WSME 选择了“Cloud” Sphinx 主题，但还有很多其他主题可以选择。你不需要是网页专家就能制作出美观的文档。'
