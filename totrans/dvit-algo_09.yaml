- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Artificial Intelligence
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能
- en: '![](Images/circleart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/circleart.png)'
- en: Throughout this book, we’ve noted the capacity of the human mind to do remarkable
    things, whether it be catching baseballs, proofreading texts, or deciding whether
    someone is having a heart attack. We explored the ways we can translate these
    abilities into algorithms, and the challenges therein. In this chapter, we face
    these challenges once more and build an algorithm for artificial intelligence
    (AI). The AI algorithm we’ll discuss will be applicable not only to one narrow
    task, like catching a baseball, but to a wide range of competitive scenarios.
    This broad applicability is what excites people about artificial intelligence—just
    as a human can learn new skills throughout life, the best AI can apply itself
    to domains it’s never seen before with only minimal reconfiguration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经注意到人类大脑执行惊人任务的能力，无论是接球、校对文本，还是判断某人是否发生心脏病发作。我们探讨了如何将这些能力转化为算法及其中的挑战。在本章中，我们将再次面对这些挑战，并构建一个人工智能（AI）算法。我们将讨论的AI算法不仅适用于某个特定任务，比如接球，还能应用于广泛的竞争场景。这种广泛的适应性是人工智能让人兴奋的地方——就像人类可以在一生中学习新技能一样，最好的AI也可以在只需最少的重新配置的情况下，应用到它从未见过的领域。
- en: The term *artificial intelligence* has an aura about it that can make people
    think that it’s mysterious and highly advanced. Some believe that AI enables computers
    to think, feel, and experience conscious thought in the same way that humans do;
    whether computers will ever be able to do so is an open, difficult question that
    is far beyond the scope of this chapter. The AI that we’ll build is much simpler
    and will be capable of playing a game well, but not of writing sincerely felt
    love poems or feeling despondency or desire (as far as I can tell!).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*人工智能*这一术语常常让人感觉神秘且高度先进。有人认为人工智能让计算机能够像人类一样思考、感受并体验意识的思维；是否计算机最终能够做到这一点是一个开放的、困难的问题，远远超出了本章的讨论范围。我们将要构建的人工智能要简单得多，能够玩好一款游戏，但并不能写出真挚的爱情诗，也无法体验沮丧或欲望（就我所知！）。'
- en: Our AI will be able to play *dots and boxes*, a simple but nontrivial game played
    worldwide. We’ll start by drawing the game board. Then we’ll build functions to
    keep score as games are in progress. Next, we’ll generate game trees that represent
    all possible combinations of moves that can be played in a given game. Finally,
    we’ll introduce the minimax algorithm, an elegant way to implement AI in just
    a few lines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的AI将能够玩*点与框*，这是一款简单但不平凡的全球性游戏。我们将从绘制游戏棋盘开始。接着，我们会构建一些函数来在游戏进行中记录分数。然后，我们将生成游戏树，表示在特定游戏中可以进行的所有可能的动作组合。最后，我们将引入极小极大算法，这是一种优雅的方法，可以在几行代码中实现AI。
- en: La Pipopipette
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: La Pipopipette
- en: Dots and boxes was invented by the French mathematician Édouard Lucas, who named
    it *la pipopipette*. It starts with a *lattice*, or grid of points, like the one
    shown in [Figure 10-1](#figure10-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 点与框由法国数学家埃杜阿尔·卢卡斯发明，他将其命名为*la pipopipette*。游戏开始时使用的是*格子*，也就是点的网格，如[图10-1](#figure10-1)所示。
- en: '![figure_10_1](Images/figure_10_1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![figure_10_1](Images/figure_10_1.png)'
- en: '[Figure 10-1:](#figureanchor10-1) A lattice, which we can use as a game board
    for dots and boxes'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-1：](#figureanchor10-1) 一个格子，我们可以用它作为点与框的游戏棋盘'
- en: The lattice is usually a rectangle but can be any shape. Two players play against
    each other, taking turns. On each turn, a player is allowed to draw a line segment
    that connects two adjacent points in the lattice. If they use different colors
    to draw their line segments, we can see who has drawn what, though that’s not
    required. As they proceed through the game, line segments fill the lattice until
    every possible segment connecting adjacent points is drawn. You can see an example
    game in progress in [Figure 10-2](#figure10-2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格子通常是矩形的，但也可以是任何形状。两名玩家轮流对战。在每一轮中，玩家可以画出一条连接格子中两个相邻点的线段。如果他们用不同的颜色画线段，我们可以看到谁画了哪条线，尽管这并不是必须的。随着游戏的进行，线段将填满格子，直到每条连接相邻点的线段都被画出。你可以在[图10-2](#figure10-2)中看到一个正在进行的示例游戏。
- en: 'A player’s goal in dots and boxes is to draw line segments that complete squares.
    In [Figure 10-2](#figure10-2), you can see that in the bottom left of the game
    board, one square has been completed. Whichever player drew the line segment that
    completed that square will have earned one point from doing so. In the top-right
    section, you can see that three sides of another square have been drawn. It’s
    player one’s turn, and if they use their turn to draw a line segment between (4,4)
    and (4,3), they’ll earn one point for that. If instead they draw another line
    segment, like a line segment from (4,1) to (5,1), then they’ll give they’ll give
    player two a chance to finish the square and earn a point. Players only earn points
    for completing the smallest possible squares on the board: those with a side length
    of 1\. The player who’s earned the most points when the lattice is completely
    filled in with line segments wins the game. There are some variations on the game,
    including different board shapes and more advanced rules, but the simple AI we’ll
    build in this chapter will work with the rules we’ve described here.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 点与方框游戏中的玩家目标是绘制完成方格的线段。在 [图 10-2](#figure10-2) 中，你可以看到在游戏棋盘的左下角，已经完成了一个方格。绘制了完成这个方格的线段的玩家将因此得一分。在右上角，你可以看到另一个方格的三条边已经绘制出来。现在是玩家一的回合，如果他们利用这一回合绘制从
    (4,4) 到 (4,3) 的线段，他们将获得一分。如果他们选择绘制另一条线段，例如从 (4,1) 到 (5,1)，那么玩家二就有机会完成这个方格并获得一分。玩家仅在完成棋盘上最小的方格时才能得分：即边长为
    1 的方格。当所有线段填满网格时，得分最多的玩家获胜。游戏还有一些变种，包括不同的棋盘形状和更高级的规则，但我们将在本章中构建的简单 AI 将适用于我们这里描述的规则。
- en: '![figure_10_2](Images/figure_10_2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![figure_10_2](Images/figure_10_2.png)'
- en: '[Figure 10-2:](#figureanchor10-2) A dots and boxes game in progress'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-2:](#figureanchor10-2) 一个正在进行的点与方框游戏'
- en: Drawing the Board
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制棋盘
- en: 'Though not strictly necessary for our algorithmic purposes, drawing the board
    can make it easier to visualize the ideas we’re discussing. A very simple plotting
    function can make an *n*×*n* lattice by looping over x and y coordinates and using
    the `plot()` function in Python’s `matplotlib` module:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对我们的算法目的来说并非严格必要，但绘制棋盘可以使我们更容易可视化我们正在讨论的思想。一个非常简单的绘图函数可以通过遍历 x 和 y 坐标，并使用
    Python 中 `matplotlib` 模块的 `plot()` 函数，绘制一个 *n*×*n* 的网格：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code, `n` represents the size of each side of our lattice, and we use
    the `name` argument for the filepath where we want to save the output. The `c
    = ''black''` argument specifies the color of the points in our lattice. We can
    create a 5×5 black lattice and save it with the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`n` 表示我们网格每一边的大小，我们使用 `name` 参数指定我们想要保存输出的文件路径。`c = 'black'` 参数指定网格中点的颜色。我们可以用以下命令创建一个
    5×5 的黑色网格并保存它：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is exactly the command that was used to create [Figure 10-1](#figure10-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是用来创建 [图 10-1](#figure10-1) 的命令。
- en: Representing Games
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示游戏
- en: 'Since a game of dots and boxes consists of successively drawn line segments,
    we can record a game as a list of ordered lines. Just as we did in previous chapters,
    we can represent a line (one move) as a list consisting of two ordered pairs (the
    ends of the line segment). For example, we can represent the line between (1,2)
    and (1,1) as this list:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于点与方框游戏由一系列按顺序绘制的线段组成，我们可以将游戏记录为一个按顺序排列的线条列表。就像我们在前几章中所做的那样，我们可以将一条线（一个回合）表示为一个包含两个有序对（线段的两端）的列表。例如，我们可以用以下列表表示从
    (1,2) 到 (1,1) 的线段：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A game will be an ordered list of such lines, like the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个游戏将是这样一组按顺序排列的线条，例如以下示例：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This game is the one illustrated in [Figure 10-2](#figure10-2). We can tell
    it must still be in progress, since not all of the possible line segments have
    been drawn to fill in the lattice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏是 [图 10-2](#figure10-2) 中展示的游戏。我们可以看出它仍在进行中，因为并非所有可能的线段都已绘制出来以填充网格。
- en: We can add to our `drawlattice()` function to create a `drawgame()` function.
    This function should draw the points of the game board as well as all line segments
    that have been drawn between them in the game so far. The function in [Listing
    10-1](#listing10-1) will do the trick.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `drawlattice()` 函数中添加内容，创建一个 `drawgame()` 函数。这个函数应当绘制游戏棋盘上的点以及至今为止在游戏中绘制的所有线段。
    [清单 10-1](#listing10-1) 中的函数将完成这一任务。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Listing 10-1:](#listinganchor10-1) A function that draws a game board for
    dots and boxes'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1:](#listinganchor10-1) 一个绘制点与方框游戏棋盘的函数'
- en: This function takes `n` and `name` as arguments, just as `drawlattice()` did.
    It also includes exactly the same nested loops we used to draw lattice points
    in `drawlattice()`. The first addition you can see is the `colors2` list, which
    starts out empty, and we fill it up with the colors we assign to the line segments
    that we’ll draw. In dots and boxes, turns alternate between the two players, so
    we’ll alternate the colors of the line segments that we assign to the players—in
    this case, red for the first player and blue for the second player. The `for`
    loop after the definition of the `colors2` list fills it up with alternating instances
    of `'red'` and `'blue'` until there are as many color assignments as there are
    moves in the game. The other lines of code we’ve added create a collection of
    lines out of our game moves and draw them, in the same way we’ve drawn collections
    of lines in previous chapters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受`n`和`name`作为参数，和`drawlattice()`一样。它还包括我们在`drawlattice()`中用来绘制格点的完全相同的嵌套循环。你可以看到的第一个新增内容是`colors2`列表，它最初为空，我们用它来填充我们将要绘制的线段的颜色。在“点和框”游戏中，玩家轮流进行，因此我们会交替为线段分配颜色——在这种情况下，第一位玩家的线段为红色，第二位玩家的线段为蓝色。`colors2`列表定义后的`for`循环将其填充为交替的`'red'`和`'blue'`实例，直到颜色分配的数量与游戏中的步数一样多。我们添加的其他代码行创建了一组游戏步数的线段，并像我们在前几章中一样绘制它们。
- en: 'We can call our `drawgame()` function in one line as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样用一行代码调用我们的`drawgame()`函数：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is exactly how we created [Figure 10-2](#figure10-2).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们创建[图 10-2](#figure10-2)的方式。
- en: Scoring Games
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计分游戏
- en: 'Next, we’ll create a function that can keep score for a dots and boxes game.
    We start with a function that can take any given game and find the completed squares
    that have been drawn, and then we create a function that will calculate the score.
    Our function will count completed squares by iterating over every line segment
    in the game. If a line is a horizontal line, we determine whether it is the top
    of a completely drawn square by checking whether the parallel line below it has
    also been drawn in the game, and also whether the left and right sides of the
    square have been drawn. The function in [Listing 10-2](#listing10-2) accomplishes
    this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个可以记录“点和框”游戏得分的函数。我们从一个函数开始，该函数可以接受任何给定的游戏并找到已经完成的方块，然后我们创建一个计算得分的函数。我们的函数通过遍历游戏中的每一条线段来统计完成的方块。如果某条线是水平线，我们通过检查其下方平行的线是否也在游戏中绘制，以及该方块的左右两条边是否也已绘制来判断它是否是一个完全绘制的方块。[列表
    10-2](#listing10-2)中的函数实现了这一点：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Listing 10-2:](#listinganchor10-2) A function that counts the number of squares
    that appear in a dots and boxes game board'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-2:](#listinganchor10-2) 一个计算“点和框”游戏棋盘上方块数量的函数'
- en: You can see that the function returns the value of `countofsquares`, which we
    initialized with a `0` value at the beginning of the function. The function’s
    `for` loop iterates over every line segment in a game. We start out assuming that
    neither the parallel line below this line nor the left and right lines that would
    connect these parallel lines have been played in the game so far. If a given line
    is a horizontal line, we check for the existence of those parallel, left, and
    right lines. If all four lines of the square we’ve checked are listed in the game,
    then we increment the `countofsquares` variable by 1\. In this way, `countofsquares`
    records the total number of squares that have been completely drawn in the game
    so far.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，该函数返回`countofsquares`的值，我们在函数开始时将其初始化为`0`。该函数的`for`循环遍历游戏中的每一条线段。我们一开始假设该线下方的平行线以及连接这些平行线的左右线都还没有在游戏中绘制。如果某条线是水平线，我们检查这些平行线、左右线是否存在。如果我们检查的方块的四条线都出现在游戏中，那么我们将`countofsquares`变量加1。通过这种方式，`countofsquares`记录了迄今为止游戏中完全绘制的方块总数。
- en: Now we can write a short function to calculate the score of a game. The score
    will be recorded as a list with two elements, like `[2,1]`. The first element
    of the score list represents the score of the first player, and the second element
    represents the score of the second player. [Listing 10-3](#listing10-3) has our
    scoring function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个简短的函数来计算游戏的得分。得分将以一个包含两个元素的列表记录，如`[2,1]`。得分列表的第一个元素代表第一位玩家的得分，第二个元素代表第二位玩家的得分。[列表
    10-3](#listing10-3)展示了我们的得分函数。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Listing 10-3:](#listinganchor10-3) A function that finds the score of an in-progress
    dots and boxes game'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10-3:](#listinganchor10-3) 一个计算正在进行的点线方块游戏得分的函数'
- en: Our scoring function proceeds through every line segment in a game in order,
    and considers the partial game consisting of every line drawn up to that turn.
    If the total number of squares drawn in a partial game is higher than the number
    of squares that had been drawn one turn previously, then we know that the player
    whose turn it was scored that turn, and we increment their score by 1\. You can
    run `print(score(game))` to see the score of the game illustrated in [Figure 10-2](#figure10-2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的得分函数会按顺序遍历游戏中的每个线段，考虑每个回合所画的线段组成的部分游戏。如果在某个部分游戏中，绘制的方块数比上一个回合绘制的方块数多，那么我们就知道，当前回合的玩家得分了，我们将他们的得分加1。你可以运行`print(score(game))`来查看[图10-2](#figure10-2)中展示的游戏得分。
- en: Game Trees and How to Win a Game
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏树与如何赢得游戏
- en: Now that you’ve seen how to draw and score dots and boxes, let’s consider how
    to win it. You may not be particularly interested in dots and boxes as a game,
    but the way to win at it is the same as the way to win at chess or checkers or
    tic-tac-toe, and an algorithm for winning all those games can give you a new way
    to think about every competitive situation you encounter in life. The essence
    of a winning strategy is simply to systematically analyze the future consequences
    of our current actions, and to choose the action that will lead to the best possible
    future. This may sound tautological, but the way we accomplish it will rely on
    careful, systematic analysis; this can take the form of a tree, similar to the
    trees we constructed in Chapter 9.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何绘制和评分点线方块游戏，我们来考虑如何赢得这场游戏。你可能并不特别关心点线方块作为一款游戏，但赢得这场游戏的方式与赢得国际象棋、跳棋或井字游戏的方法是相同的，一个可以帮助你赢得所有这些游戏的算法，也可以为你提供一种全新的方式来思考你在生活中遇到的每一种竞争情境。制胜策略的本质，实际上就是系统地分析我们当前行动的未来后果，并选择能够带来最佳未来的行动。这听起来可能有些套话，但我们实现这一点的方式将依赖于小心、系统的分析；这可以呈现为一棵树，类似于我们在第9章中构建的树。
- en: Consider the possible future outcomes illustrated in [Figure 10-3](#figure10-3).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图10-3](#figure10-3)中展示的可能的未来结果。
- en: '![Figure_10-3](Images/figure_10-3.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_10-3](Images/figure_10-3.png)'
- en: '[Figure 10-3:](#figureanchor10-3) A tree of some possible continuations of
    our game'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-3:](#figureanchor10-3) 我们游戏的一些可能延续的树形图'
- en: 'We start at the top of the tree, considering the current situation: we’re behind
    0–1 and it’s our turn to move. One move we consider is the move in the left branch:
    drawing a line from (4,4) to (4,3). This move will complete a square and give
    us one point. No matter what move our opponent makes (see the possibilities listed
    in the two branches in the bottom left of [Figure 10-3](#figure10-3)), the game
    will be tied after our opponent’s next move. By contrast, if we use our current
    turn to draw a line from (1,3) to (2,3), as described in Figure 10-3’s right branch,
    our opponent then has a choice between drawing a line from (4,4) to (4,3) and
    completing a square and earning a point, or drawing another line like one connecting
    (3,1) and (4,1), and leaving the score at 0–1.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从树的顶部开始，考虑当前的情况：我们落后0-1，现在轮到我们走棋。我们考虑的一步是左支路中的一步：从(4,4)到(4,3)画一条线。这一步将完成一个方块，并为我们获得1分。不论对手走什么棋（见[图10-3](#figure10-3)中左下角两个分支列出的可能性），在对手下一步后，比赛将会平局。相反，如果我们在当前回合选择从(1,3)到(2,3)画一条线，如[图10-3](#figure10-3)右支路所示，对手接下来将有两个选择：从(4,4)到(4,3)画线并完成一个方块得1分，或者画另一条线，如连接(3,1)和(4,1)，并保持比分为0-1。
- en: 'Considering these possibilities, within two moves the game could be at any
    of three different scores: 1–1, 0–2, or 0–1\. In this tree, it’s clear that we
    should choose the left branch, because every possibility that grows from that
    branch leads to a better score for us than do the possibilities growing from the
    right branch. This style of reasoning is the essence of how our AI will decide
    on the best move. It will build a game tree, check the outcomes at all terminal
    nodes of the game tree, and then use simple recursive reasoning to decide what
    move to make, in light of the possible futures that decision will open up.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些可能性，在两步内，游戏的得分可能是三种不同的结果：1-1，0-2，或者0-1。在这棵树中，很明显我们应该选择左支路，因为从左支路发展出来的每一个可能性都会比右支路发展出来的可能性为我们带来更好的得分。这种推理方式正是我们的AI决策最佳走法的精髓。它将构建一个游戏树，检查游戏树中所有终端节点的结果，然后通过简单的递归推理，决定采取什么行动，依据这一决策将开启的可能未来。
- en: 'You probably noticed that the game tree in [Figure 10-3](#figure10-3) is woefully
    incomplete. It appears that there are only two possible moves (the left branch
    and the right branch), and that after each of those possible moves, our opponent
    has only two possible moves. Of course, this is incorrect; there are many choices
    available to both players. Remember that they can connect any two adjacent points
    in the lattice. The true game tree representing this moment in our game would
    have many branches, one for each possible move for each player. This is true at
    every level of the tree: not only do I have many moves to choose from, but so
    does my opponent, and each of those moves will have its own branch at every point
    in the tree where it’s playable. Only near the end of the game, when nearly all
    the line segments have already been drawn, will the number of possible moves shrink
    to two and one. We didn’t draw every branch of the game tree in [Figure 10-3](#figure10-3),
    because there’s not enough space on the page—we only had space to include a couple
    of moves, just to illustrate the idea of the game tree and our thought process.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，图[10-3](#figure10-3)中的游戏树显得非常不完整。看起来似乎只有两种可能的移动（左分支和右分支），而在每一次这些可能的移动之后，对方也只有两种可能的移动。当然，这是不正确的；两位玩家都有许多选择。请记住，他们可以连接格子中任何两个相邻的点。真正表示我们游戏中这个时刻的游戏树应该有许多分支，每个玩家每个可能的移动都会对应一个分支。这在树的每一层都是如此：不仅我有很多可以选择的移动，我的对手也有，而每一个这些移动都会在游戏树中的每一个可操作的点上有一个分支。只有在游戏接近尾声时，当几乎所有线段已经绘制完成，可能的移动数才会减少到两个和一个。我们没有在图[10-3](#figure10-3)中画出所有分支，是因为页面空间不够——我们只有空间展示了几种移动，仅仅是为了说明游戏树的概念和我们的思考过程。
- en: You can imagine a game tree extending to any possible depth—we should consider
    not only our move and the opponent’s response, but also our response to that response,
    and our opponent’s response to that response, and so on as far as we care to continue
    the tree-building.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象一个游戏树，它可以扩展到任何可能的深度——我们不仅要考虑我们的移动和对方的反应，还要考虑我们对该反应的回应，以及对方对这个回应的反应，以此类推，直到我们想要继续构建游戏树为止。
- en: Building Our Tree
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建我们的树
- en: 'The game trees we’re building here are different in important ways from the
    decision trees of Chapter 9\. The most important difference is the goal: decision
    trees enable classifications and predictions based on characteristics, while game
    trees simply describe every possible future. Since the goal is different, so will
    be the way we build it. Remember that in Chapter 9 we had to select a variable
    and a split point to decide every branch in the tree. Here, knowing what branches
    will come next is easy, since there will be exactly one branch for every possible
    move. All we need to do is generate a list of every possible move in our game.
    We can do this with a couple of nested loops that consider every possible connection
    between points in our lattice:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里构建的游戏树在几个重要方面与第9章中的决策树不同。最重要的区别是目标：决策树通过特征进行分类和预测，而游戏树则简单地描述了所有可能的未来。由于目标不同，因此我们的构建方法也会有所不同。请记得在第9章中，我们需要选择一个变量和一个分裂点来决定树中的每一条分支。而在这里，知道接下来会有哪些分支很容易，因为对于每一个可能的移动，都会有恰好一条分支。我们所需要做的，就是生成一个游戏中所有可能移动的列表。我们可以通过几个嵌套循环来实现这一点，循环会考虑格子中每一对点之间的所有可能连接：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This snippet starts by defining an empty list, called `allpossible`, and a `gamesize`
    variable, which is the length of each side of our lattice. Then, we have two loops.
    The first is meant to add vertical moves to our list of possible moves. Notice
    that for every possible value of `i` and `j`, this first loop appends the move
    represented by `[(i,j),(i,j - 1)]` to our list of possible moves. This will always
    be a vertical line. Our second loop is similar, but for every possible combination
    of `i` and `j`, it appends the horizontal move `[(i,j),(i + 1,j)]` to our list
    of possible moves. At the end, our `allpossible` list will be populated with every
    possible move.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先定义了一个空的列表，名为`allpossible`，以及一个`gamesize`变量，表示我们格子中每一边的长度。接着，我们有两个循环。第一个循环是为了将垂直移动添加到我们的可能移动列表中。注意，对于每一个可能的`i`和`j`值，这个循环将`[(i,j),(i,j
    - 1)]`表示的移动添加到可能的移动列表中。这将始终是一个垂直线段。我们的第二个循环类似，不过对于每一组可能的`i`和`j`值，它会将水平移动`[(i,j),(i
    + 1,j)]`添加到可能的移动列表中。最终，我们的`allpossible`列表将包含所有可能的移动。
- en: 'If you think about a game that’s in progress, like the game illustrated in
    [Figure 10-2](#figure10-2), you’ll realize that not every move is always possible.
    If a player has already played a particular move during a game, no player can
    play that same move again for the rest of the game. We’ll need a way to remove
    all moves that have already been played from the list of all possible moves, resulting
    in a list of all possible moves remaining for any particular in-progress game.
    This is easy enough:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑到一场正在进行的游戏，例如[图10-2](#figure10-2)中展示的游戏，你会意识到并非每个移动总是可行的。如果某个玩家在游戏中已经执行了某个特定的移动，那么接下来的任何玩家都不能再执行这个相同的移动。我们需要一种方法来从所有可能的移动列表中移除那些已经执行过的移动，从而得到一个仅包含某个特定进行中的游戏中仍然可能的所有移动的列表。这很容易实现：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we iterate over every move in our list of possible moves, and
    if it’s already been played, we remove it from our list. In the end, we have a
    list of only moves that are possible in this particular game. You can run `print(allpossible)`
    to see all of these moves and check that they’re correct.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们遍历了所有可能的移动列表中的每一个移动，如果某个移动已经被执行过，我们就将它从列表中移除。最终，我们得到的列表只包含当前游戏中可能的移动。你可以运行`print(allpossible)`来查看所有这些移动，并检查它们是否正确。
- en: 'Now that we have a list of every possible move, we can construct the game tree.
    We’ll record a game tree as a nested list of moves. Remember that each move can
    be recorded as a list of ordered pairs, like `[(4,4),(4,3)]`, the first move in
    the left branch of [Figure 10-3](#figure10-3). If we wanted to express a tree
    that consisted of only the top two moves in [Figure 10-3](#figure10-3), we could
    write it as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了每一个可能移动的列表，我们可以构建游戏树。我们将记录游戏树作为一个嵌套的移动列表。记住，每个移动可以记录为有序对的列表，例如`[(4,4),(4,3)]`，这是[图10-3](#figure10-3)中左分支的第一个移动。如果我们想表示一个只包含[图10-3](#figure10-3)中前两个移动的树，我们可以这样写：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This tree contains only two moves: the ones we’re considering playing in the
    current state of the game in [Figure 10-3](#figure10-3). If we want to include
    the opponent’s potential responses, we’ll have to add another layer of nesting.
    We do this by putting each move in a list together with its *children*, the moves
    that branch out from the original move. Let’s start by adding empty lists representing
    a move’s children:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树只包含两个移动：我们在[图10-3](#figure10-3)中考虑执行的当前状态下的移动。如果我们想包括对手的潜在回应，我们将需要添加另一层嵌套。我们通过将每个移动和它的*子节点*（从原始移动分支出的移动）放在一个列表中来实现这一点。让我们从添加表示移动子节点的空列表开始：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Take a moment to make sure you see all the nesting we’ve done. Each move is
    a list itself, as well as the first element of a list that will also contain the
    list’s children. Then, all of those lists together are stored in a master list
    that is our full tree.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微停下来，确保你能看到我们所做的所有嵌套。每个移动本身就是一个列表，并且是一个列表的第一个元素，这个列表还将包含该列表的子节点。然后，所有这些列表一起存储在一个主列表中，这就是我们的完整树。
- en: 'We can express the entire game tree from [Figure 10-3](#figure10-3), including
    the opponent’s responses, with this nested list structure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个嵌套的列表结构来表示[图10-3](#figure10-3)中整个游戏树，包括对手的回应：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The square brackets quickly get unwieldy, but we need the nested structure so
    we can correctly keep track of which moves are which moves’ children.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号很快就会变得不易管理，但我们需要这种嵌套结构，这样我们才能正确地追踪哪些移动是哪个移动的子节点。
- en: Instead of writing out game trees manually, we can build a function that will
    create them for us. It will take our list of possible moves as an input and then
    append each move to the tree ([Listing 10-4](#listing10-4)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写一个函数来代替手动编写游戏树，它会为我们创建游戏树。该函数将接受我们的可能移动列表作为输入，然后将每个移动附加到树中（见[列表10-4](#listing10-4)）。
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Listing 10-4:](#listinganchor10-4) A function that creates a game tree of
    a specified depth'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10-4:](#listinganchor10-4) 一个创建指定深度游戏树的函数'
- en: 'This function, `generate_tree()`, starts out by defining an empty list called
    `tree`. Then, it iterates over every possible move. For each move, it creates
    a `move_profile`. At first, the `move_profile` consists only of the move itself.
    But for branches that are not yet at the lowest depth of the tree, we need to
    add those moves’ children. We add children recursively: we call the `generate_tree()`
    function again, but now we have removed one move from the `possible_moves` list.
    Finally, we append the `move_profile` list to the tree.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this function simply, with a couple of lines:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run this, we see the following tree:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we’ll make two additions to make our tree more useful: the first records
    the game score along with the moves, and the second appends a blank list to keep
    a place for children ([Listing 10-5](#listing10-5)).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Listing 10-5:](#listinganchor10-5) A function that generates a game tree,
    including child moves and game scores'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this again as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We see the following results:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see that each entry in this tree is a full move profile, consisting
    of a move (like `[(4,4),(4,3)]`), a score (like `[0,0]`), and a (sometimes empty)
    list of children.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Winning a Game
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re finally ready to create a function that can play dots and boxes well.
    Before we write the code, let’s consider the principles behind it. Specifically,
    how is it that we, as humans, play dots and boxes well? More generally, how is
    it that we go about winning any strategic game (like chess or tic-tac-toe)? Every
    game has unique rules and features, but there’s a general way to choose a winning
    strategy based on an analysis of the game tree.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm we’ll use for choosing a winning strategy is called *minimax*
    (a combination of the words *minimum* and *maximum*), so called because while
    we’re trying to maximize our score in the game, our opponent is trying to minimize
    our score. The constant fight between our maximization and our opponent’s minimization
    is what we have to strategically consider as we’re choosing the right move.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look closely at the simple game tree in [Figure 10-3](#figure10-3). In
    theory, a game tree can grow to be enormous, with a huge depth and many branches
    at each depth. But any game tree, big or small, consists of the same components:
    a lot of little nested branches.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: At the point we’re considering in [Figure 10-3](#figure10-3), we have two choices.
    [Figure 10-4](#figure10-4) shows them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_10-4](Images/figure_10-4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-4:](#figureanchor10-4) Considering which of two moves to choose'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to maximize our score. To decide between these two moves, we need
    to know what they will lead to, what future each move brings to pass. To know
    that, we need to travel farther down the game tree and look at all the possible
    consequences. Let’s start with the move on the right ([Figure 10-5](#figure10-5)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_10-5](Images/figure_10-5.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '[Figure 10-5:](#figureanchor10-5) Assuming that an opponent will try to minimize
    your score, you can find what future you expect a move to lead to.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-5:](#figureanchor10-5) 假设对手将试图最小化你的得分，你可以找到每一步预计将导致的未来局面。'
- en: 'This move could bring about either of two possible futures: we could be behind
    0–1 at the end of our tree, or we could be behind 0–2\. If our opponent is playing
    well, they will want to maximize their own score, which is the same as minimizing
    our score. If our opponent wants to minimize our score, they’ll choose the move
    that will put us behind 0–2\. By contrast, consider our other option, the left
    branch of [Figure 10-5](#figure10-5), whose possible futures we consider in [Figure
    10-6](#figure10-6).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步可能会导致两种未来局面中的任何一种：在树的末端我们可能落后于 0-1，或者我们可能落后于 0-2。如果我们的对手玩得很好，他们会想要最大化自己的得分，这等同于最小化我们的得分。如果对手想要最小化我们的得分，他们会选择把我们置于
    0-2 落后的局面。相反，考虑我们的另一个选择，即[图 10-5](#figure10-5)的左分支，其可能的未来局面在[图 10-6](#figure10-6)中进行了考虑。
- en: '![Figure_10-6](Images/figure_10-6.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_10-6](Images/figure_10-6.png)'
- en: '[Figure 10-6:](#figureanchor10-6) No matter what the opponent’s choice, we
    expect the same outcome.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-6:](#figureanchor10-6) 无论对手选择什么，我们都预期得到相同的结果。'
- en: In this case, both of our opponent’s choices lead to a score of 1–1\. Again
    assuming that our opponent will be acting to minimize our score, we say that this
    move leads to a future of the game being tied 1–1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们对手的两个选择都将导致 1-1 的得分。同样假设我们的对手会采取最小化我们得分的行动，我们可以说这一步将导致比赛以 1-1 平局结束。
- en: Now we know what future will be brought about by the two moves. [Figure 10-7](#figure10-7)
    notes these futures in an updated version of [Figure 10-4](#figure10-4).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这两步将带来的未来局面。[图 10-7](#figure10-7)在[图 10-4](#figure10-4)的更新版本中记录了这些未来局面。
- en: 'Because we know exactly what future to expect from each of our two moves, we
    can do a maximization: the move that leads to the maximum, the best score, is
    the move on the left, so we choose that one.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们准确知道每一步可能带来的未来局面，我们可以进行最大化：导致最大得分的最佳步骤是左侧的那一步，所以我们选择了那一步。
- en: '![Figure_10-7](Images/figure_10-7.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_10-7](Images/figure_10-7.png)'
- en: '[Figure 10-7:](#figureanchor10-7) Using Figures 10-5 and 10-6, we can reason
    about the futures that each move will lead to and then compare them.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-7:](#figureanchor10-7) 利用图 10-5 和 10-6，我们可以推理出每一步将导致的未来局面，并进行比较。'
- en: The reasoning process we just went through is known as the minimax algorithm.
    Our decision in the present is about maximizing our score. But in order to maximize
    our score, we have to consider all the ways that our opponent will try to minimize
    our score. So the best choice is a maximum of minima.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才经历的推理过程被称为最小最大算法（minimax algorithm）。我们现在的决策是为了最大化我们的得分。但是为了最大化得分，我们必须考虑对手所有试图最小化我们得分的方式。因此，最佳选择是最大化的最小值。
- en: Note that minimax goes through time in reverse. The game proceeds forward in
    time, from the present to the future. But in a way, the minimax algorithm proceeds
    backward in time, because we consider the scores of possible far futures first
    and then work our way back to the present to find the current choice that will
    lead to the best future. In the context of our game tree, the minimax code starts
    at the top of the tree. It calls itself recursively on each of its child branches.
    The child branches, in turn, call minimax recursively on their own child branches.
    This recursive calling continues all the way to the terminal nodes, where, instead
    of calling minimax again, we calculate the game score for each node. So we’re
    calculating the game score for the terminal nodes first; we’re starting our game
    score calculations in the far future. These scores are then passed back to their
    parent nodes so that the parent nodes can calculate the best moves and corresponding
    score for their part of the game. These scores and moves are passed back up through
    the game tree until arriving back at the very top, the parent node, which represents
    the present.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，极小极大算法是通过逆向时间进行的。游戏的进程是向前的，从现在到未来。但是在某种意义上，极小极大算法是向后进行的，因为我们首先考虑可能的遥远未来的得分，然后再回到当前，找到能够通向最佳未来的选择。在我们的游戏树中，极小极大算法从树的顶部开始。它递归地调用每一个子分支。子分支又递归地调用极小极大算法，继续递归到终端节点。在终端节点处，我们不再继续调用极小极大算法，而是为每个节点计算游戏得分。因此，我们首先计算终端节点的游戏得分；我们从遥远的未来开始计算游戏得分。这些得分随后被传回父节点，以便父节点可以计算出最佳的走法及其对应的得分。这些得分和走法将被传回游戏树的上方，直到到达最顶层的父节点，这个父节点代表着现在。
- en: '[Listing 10-6](#listing10-6) has a function that accomplishes minimax.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-6](#listing10-6) 中包含了一个实现极小极大算法的函数。'
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Listing 10-6:](#listinganchor10-6) A function that uses minimax to find the
    best move in a game tree'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-6:](#listinganchor10-6) 一个使用极小极大算法来寻找游戏树中最佳走法的函数'
- en: Our `minimax()` function is relatively short. Most of it is a `for` loop that
    iterates over every move profile in our tree. If the move profile has no child
    moves, then we calculate the score associated with that move as the difference
    between our squares and our opponent’s squares. If the move profile does have
    child moves, then we call `minimax()` on each child to get the score associated
    with each move. Then all we need to do is find the move associated with the maximum
    score.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`minimax()`函数相对较短。大部分代码是一个`for`循环，用于遍历树中的每个走法。如果该走法没有子走法，那么我们根据该走法与对手的得分差计算该走法的得分。如果该走法有子走法，我们就对每个子走法调用`minimax()`来获取每个走法的得分。然后，我们只需要找到与最大得分相关的走法。
- en: 'We can call our `minimax()` function to find the best move to play in any turn
    in any in-progress game. Let’s make sure everything is defined correctly before
    we call `minimax()`. First, let’s define the game, and get all possible moves,
    using exactly the same code we used before:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用我们的`minimax()`函数，在任何进行中的游戏中的任意回合找到最佳走法。在调用`minimax()`之前，让我们先确保一切都已正确定义。首先，让我们定义游戏，并使用之前的代码获取所有可能的走法：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we’ll generate a complete game tree that extends to a depth of three
    levels:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将生成一个完整的游戏树，扩展到三层深度：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have our game tree, we can call our `minimax()` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的游戏树，我们可以调用我们的`minimax()`函数：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And finally, we can check the best move as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以按如下方式检查最佳的走法：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We see that the best move is `[(4, 4), (4, 3)]`, the move that completes a square
    and earns us a point. Our AI can play dots and boxes, and choose the best moves!
    You can try other game board sizes, or different game scenarios, or different
    tree depths, and check whether our implementation of the minimax algorithm is
    able to perform well. In a sequel to this book, we’ll discuss how to ensure that
    your AI doesn’t become simultaneously self-aware and evil and decide to overthrow
    humanity.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到最佳的走法是`[(4, 4), (4, 3)]`，这一步完成了一个方块并为我们赢得了一个积分。我们的AI可以玩点阵和方格游戏，并选择最佳的走法！你可以尝试其他游戏板大小，或者不同的游戏场景，或者不同的树深度，检查我们的极小极大算法实现是否表现良好。在本书的续集中，我们将讨论如何确保你的AI既不会突然自我觉醒，也不会变得邪恶，决定推翻人类。
- en: Adding Enhancements
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加增强功能
- en: Now that you can perform minimax, you can use it for any game you happen to
    be playing. Or you can apply it to life decisions, thinking through the future
    and maximizing every minimum possibility. (The structure of the minimax algorithm
    will be the same for any competitive scenario, but in order to use our minimax
    code for a different game, we would have to write new code for the generation
    of the game tree, the enumeration of every possible move, and the calculation
    of game scores.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经能执行最小最大算法了，你就可以把它应用到任何你正在玩的游戏中。或者，你也可以将它应用到生活决策中，考虑未来并最大化每个最小可能性。（最小最大算法的结构对于任何竞争情境都是一样的，但为了将我们的最小最大代码用于其他游戏，我们需要编写新的代码来生成游戏树、枚举每个可能的动作，以及计算游戏分数。）
- en: The AI we’ve built here has very modest capabilities. It’s only able to play
    one game, with one simple version of the rules. Depending on what processor you
    use to run this code, it can probably look only a few moves forward without taking
    an unreasonable amount of time (a few minutes or more) for each decision. It’s
    natural to want to enhance our AI to make it better.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的AI能力非常有限。它只能玩一个游戏，且仅适用于一种简单的规则版本。根据你使用的处理器，AI可能只能提前看几个步骤，而不会在每次决策时花费过多的时间（几分钟或更长）。我们自然希望能增强我们的AI，使其变得更强大。
- en: 'One thing we’ll definitely want to improve is our AI’s speed. It’s slow because
    of the large size of the game trees it has to work through. One of the main ways
    to improve the performance of minimax is by pruning the game tree. Pruning, as
    you might remember from Chapter 9, is exactly what it sounds like: we remove branches
    from the tree if we consider them exceptionally poor or if they represent a duplicate
    of another branch. Pruning is not trivial to implement and requires learning yet
    more algorithms to do it well. One example is the *alpha–beta pruning algorithm*,
    which will stop checking particular sub-branches if they are certainly worse than
    sub-branches elsewhere in the tree.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定需要改善的一个方面是AI的速度。它之所以很慢，是因为它需要处理庞大的游戏树。提高最小最大算法性能的主要方法之一是修剪游戏树。正如你在第九章中学到的那样，修剪就是字面意思：我们会去除那些特别糟糕的分支，或者是与其他分支重复的分支。修剪并非易事，它需要学习更多的算法来做好这件事。一个例子就是*alpha–beta修剪算法*，它会在某些子分支肯定比其他分支差的情况下，停止检查这些子分支。
- en: Another natural improvement to our AI would be to enable it to work with different
    rules or different games. For example, a commonly used rule in dots and boxes
    is that after earning a point, a player gets to draw another line. Sometimes this
    results in a cascade, in which one player completes many boxes in a row in a single
    turn. This simple change, which was called “make it, take it” on my elementary
    school playground, changes the game’s strategic considerations and will require
    some changes to our code. You can also try to implement an AI that plays dots
    and boxes on a lattice that has a cross shape or some other exotic shape that
    could influence strategy. The beauty of minimax is that it doesn’t require subtle
    strategic understanding; it requires only an ability to look ahead, and that’s
    why a coder who isn’t good at chess can write an implementation of minimax that
    can beat them at chess.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个自然的改进方向是让我们的AI能适应不同的规则或不同的游戏。例如，在“点与盒”游戏中，一个常见的规则是，玩家在得分后可以再画一条线。有时，这会导致一个连锁反应，其中一名玩家在一轮内连续完成多个盒子。这一简单的变化，叫做“得分即得继续”规则，在我小学的操场上就是这么叫的，它改变了游戏的战略考虑，并需要对我们的代码做出一些调整。你也可以尝试实现一个能在交叉形状或其他可能影响策略的特殊形状的网格上玩的“点与盒”AI。最小最大算法的美妙之处在于它不需要微妙的战略理解；它只需要具备提前预测的能力，这也是为什么一个不擅长象棋的程序员能够编写出一个最小最大算法，并在象棋中战胜他自己的原因。
- en: There are some powerful methods that go beyond the scope of this chapter that
    can improve the performance of computer AI. These methods include reinforcement
    learning (where a chess program, for example, plays against itself to get better),
    Monte Carlo methods (where a shogi program generates random future shogi games
    to help understand possibilities), and neural networks (where a tic-tac-toe program
    predicts what its opponent will do using a machine learning method similar to
    what we discussed in Chapter 9). These methods are powerful and remarkable, but
    they mostly just make our tree search and minimax algorithms more efficient; tree
    search and minimax remain the humble workhorse core of strategic AI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些强大的方法超出了本章的范围，它们可以提高计算机AI的表现。这些方法包括强化学习（例如，棋类程序通过自我对弈来提高水平）、蒙特卡罗方法（例如，将随机生成未来的将棋游戏来帮助理解可能性），以及神经网络（例如，井字棋程序使用类似于我们在第9章讨论的机器学习方法来预测对手的动作）。这些方法既强大又引人注目，但它们大多数只是让我们的树搜索和minimax算法更高效；树搜索和minimax仍然是战略性AI中那种谦逊的核心工具。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed artificial intelligence. It’s a term surrounded
    by hype, but when you see that it takes only about a dozen lines to write a `minimax()`
    function, AI suddenly doesn’t seem so mysterious and intimidating. But of course,
    to prepare to write those lines, we had to learn the game rules, draw the game
    board, construct game trees, and configure our `minimax()` function to calculate
    game outcomes correctly. Not to mention the rest of the journey of this book,
    in which we carefully constructed algorithms that prepared us to think algorithmically
    and to write this function when we needed it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了人工智能。它是一个充满炒作的术语，但当你看到只需约十几行代码就能编写一个`minimax()`函数时，人工智能突然看起来不那么神秘和令人畏惧。当然，为了准备编写这些代码，我们首先需要学习游戏规则，绘制游戏棋盘，构建游戏树，并配置我们的`minimax()`函数以正确计算游戏结果。更不用说本书的其余部分，我们在其中精心构建了算法，帮助我们以算法化的方式思考，并在需要时编写这个函数。
- en: The next chapter suggests next steps for ambitious algorithmicists who want
    to continue their journey to the edges of the world of algorithms and push out
    to further frontiers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章为有志于深入算法世界的算法学者们提出了下一步的建议，帮助他们不断推动算法的前沿。
