["```py\n>>> import math\n>>> math.sin(math.pi/2)\n1.0\n```", "```py\n>>> import sympy\n>>> sympy.sin(math.pi/2)\n1.00000000000000\n```", "```py\n   >>> from sympy import Symbol\n   >>> theta = Symbol('theta')\n➊ >>> math.sin(theta) + math.sin(theta)\n   Traceback (most recent call last):\n     File \"<pyshell#53>\", line 1, in <module>\n       math.sin(theta) + math.sin(theta)\n     File \"/usr/lib/python3.4/site-packages/sympy/core/expr.py\", line 225, in\n   __float__\n       raise TypeError(\"can't convert expression to float\")\n   TypeError: can't convert expression to float\n\n➋ >>> sympy.sin(theta) + sympy.sin(theta)\n   2*sin(theta)\n```", "```py\n>>> from sympy import sin, solve, Symbol\n>>> u = Symbol('u')\n>>> t = Symbol('t')\n>>> g = Symbol('g')\n>>> theta = Symbol('theta')\n>>> solve(u*sin(theta)-g*t, t)\n[u*sin(theta)/g]\n```", "```py\n>>> from sympy import Symbol\n>>> x = Symbol('x')\n>>> if (x+5) > 0:\n    print('Do Something')\nelse:\n    print('Do Something else')\n\nTraceback (most recent call last):\n  File \"<pyshell#45>\", line 1, in <module>\n    if (x + 5) > 0:\n  File \"/usr/lib/python3.4/site-packages/sympy/core/relational.py\", line 103,\nin __nonzero__\n    raise TypeError(\"cannot determine truth value of\\n%s\" % self)\nTypeError: cannot determine truth value of\nx + 5 > 0\n```", "```py\n>>> x = Symbol('x', positive=True)\n>>> if (x+5) > 0:\n    print('Do Something')\nelse:\n    print('Do Something else')\n\nDo Something\n```", "```py\n➊ >>> from sympy import Limit, Symbol, S\n➋ >>> x = Symbol('x')\n➌ >>> Limit(1/x, x, S.Infinity)\n   Limit(1/x, x, oo, dir='-')\n```", "```py\n>>> l = Limit(1/x, x, S.Infinity)\n>>> l.doit()\n0\n```", "```py\n>>> Limit(1/x, x, 0, dir='-').doit()\n-oo\n```", "```py\n>>> Limit(1/x, x, 0, dir='+').doit()\noo\n```", "```py\n>>> from sympy import Symbol, sin\n>>> Limit(sin(x)/x, x, 0).doit()\n1\n```", "```py\n>>> from sympy import Limit, Symbol, S\n>>> n = Symbol('n')\n>>> Limit((1+1/n)**n, n, S.Infinity).doit()\nE\n```", "```py\n>>> from sympy import Symbol, Limit, S\n>>> p = Symbol('p', positive=True)\n>>> r = Symbol('r', positive=True)\n>>> t = Symbol('t', positive=True)\n>>> Limit(p*(1+r/n)**(n*t), n, S.Infinity).doit()\np*exp(r*t)\n```", "```py\n   >>> from sympy import Symbol, Limit\n   >>> t = Symbol('t')\n➊ >>> St = 5*t**2 + 2*t + 8\n\n   >>> t1 = Symbol('t1')\n   >>> delta_t = Symbol('delta_t')\n\n➋ >>> St1 = St.subs({t: t1})\n➌ >>> St1_delta = St.subs({t: t1 + delta_t})\n```", "```py\n>>> Limit((St1_delta-St1)/delta_t, delta_t, 0).doit()\n10*t1 + 2\n```", "```py\n➊ >>> from sympy import Symbol, Derivative\n\n   >>> t = Symbol('t')\n   >>> St = 5*t**2 + 2*t + 8\n\n➋ >>> Derivative(St, t)\n   Derivative(5*t**2 + 2*t + 8, t)\n```", "```py\n>>> d = Derivative(St, t)\n>>> d.doit()\n10*t + 2\n```", "```py\n>>> d.doit().subs({t:t1})\n10*t1 + 2\n>>> d.doit().subs({t:1})\n12\n```", "```py\n>>> from sympy import Derivative, Symbol\n>>> x = Symbol('x')\n>>> f = (x**3 + x**2 + x)*(x**2+x)\n>>> Derivative(f, x).doit()\n(2*x + 1)*(x**3 + x**2 + x) + (x**2 + x)*(3*x**2 + 2*x + 1)\n```", "```py\n   '''\n   Derivative calculator\n   '''\n\n   from sympy import Symbol, Derivative, sympify, pprint\n   from sympy.core.sympify import SympifyError\n\n   def derivative(f, var):\n       var = Symbol(var)\n       d = Derivative(f, var).doit()\n       pprint(d)\n\n   if __name__=='__main__':\n\n➊     f = input('Enter a function: ')\n       var = input('Enter the variable to differentiate with respect to: ')\n       try:\n➋         f = sympify(f)\n       except SympifyError:\n           print('Invalid input')\n       else:\n➌         derivative(f, var)\n```", "```py\nEnter a function: 2*x**2 + 3*x + 1\nEnter the variable to differentiate with respect to: x\n4·x + 3\n```", "```py\nEnter a function: 2*x**2 + y**2\nEnter the variable to differentiate with respect to: x\n4·x\n```", "```py\nEnter a function: 2*x*y + x*y**2\nEnter the variable to differentiate with respect to: x\ny2 + 2·y\n```", "```py\n>>> from sympy import Symbol, solve, Derivative\n>>> x = Symbol('x')\n>>> f = x**5 - 30*x**3 + 50*x\n>>> d1 = Derivative(f, x).doit()\n```", "```py\n>>> critical_points = solve(d1)\n>>> critical_points\n[-sqrt(-sqrt(71) + 9), sqrt(-sqrt(71) + 9), -sqrt(sqrt(71) + 9),\nsqrt(sqrt(71) + 9)]\n```", "```py\n>>> A = critical_points[2]\n>>> B = critical_points[0]\n>>> C = critical_points[1]\n>>> D = critical_points[3]\n```", "```py\n>>> d2 = Derivative(f, x, 2).doit()\n```", "```py\n>>> d2.subs({x:B}).evalf()\n127.661060789073\n>>> d2.subs({x:C}).evalf()\n-127.661060789073\n>>> d2.subs({x:A}).evalf()\n-703.493179468151\n>>> d2.subs({x:D}).evalf()\n703.493179468151\n```", "```py\n>>> x_min = -5\n>>> x_max = 5\n\n>>> f.subs({x:A}).evalf()\n705.959460380365\n>>> f.subs({x:C}).evalf()\n25.0846626340294\n>>> f.subs({x:x_min}).evalf()\n375.000000000000\n>>> f.subs({x:x_max}).evalf()\n-375.000000000000\n```", "```py\n>>> f.subs({x:B}).evalf()\n-25.0846626340294\n>>> f.subs({x:D}).evalf()\n-705.959460380365\n>>> f.subs({x:x_min}).evalf()\n375.000000000000\n>>> f.subs({x:x_max}).evalf()\n-375.000000000000\n```", "```py\n   '''\n   Use gradient ascent to find the angle at which the projectile\n   has maximum range for a fixed velocity, 25 m/s\n   '''\n\n   import math\n   from sympy import Derivative, Symbol, sin\n\n   def grad_ascent(x0, f1x, x):\n➊     epsilon = 1e-6\n➋     step_size = 1e-4\n➌     x_old = x0\n➍     x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()\n➎     while abs(x_old - x_new) > epsilon:\n           x_old = x_new\n           x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()\n\n       return x_new\n\n➏ def find_max_theta(R, theta):\n       # Calculate the first derivative\n       R1theta = Derivative(R, theta).doit()\n       theta0 = 1e-3\n       theta_max = grad_ascent(theta0, R1theta, theta)\n➐     return theta_max\n\n   if __name__ == '__main__':\n\n       g = 9.8\n       # Assume initial velocity\n       u = 25\n       # Expression for range\n       theta = Symbol('theta')\n➑     R = u**2*sin(2*theta)/g\n\n➒     theta_max = find_max_theta(R, theta)\n       print('Theta: {0}'.format(math.degrees(theta_max)))\n       print('Maximum Range: {0}'.format(R.subs({theta:theta_max})))\n```", "```py\nTheta: 44.99999978475661\nMaximum Range: 63.7755102040816\n```", "```py\n   '''\n   Use gradient ascent to find the maximum value of a\n   single-variable function\n   '''\n\n   from sympy import Derivative, Symbol, sympify\n\n   def grad_ascent(x0, f1x, x):\n       epsilon = 1e-6\n       step_size = 1e-4\n       x_old = x0\n       x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()\n       while abs(x_old - x_new) > epsilon:\n           x_old = x_new\n           x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()\n\n       return x_new\n\n   if __name__ == '__main__':\n\n       f = input('Enter a function in one variable: ')\n       var = input('Enter the variable to differentiate with respect to: ')\n       var0 = float(input('Enter the initial value of the variable: '))\n       try:\n           f = sympify(f)\n       except SympifyError:\n           print('Invalid function entered')\n       else:\n➊         var = Symbol(var)\n➋         d = Derivative(f, var).doit()\n➌         var_max = grad_ascent(var0, d, var)\n           print('{0}: {1}'.format(var.name, var_max))\n           print('Maximum value: {0}'.format(f.subs({var:var_max})))\n```", "```py\nEnter a function in one variable: 25*25*sin(2*theta)/9.8\nEnter the variable to differentiate with respect to: theta\nEnter the initial value of the variable: 0.001\ntheta: 0.785360029379083\nMaximum value: 63.7755100185965\n```", "```py\nEnter a function in one variable: cos(y)\nEnter the variable to differentiate with respect to: y\nEnter the initial value of the variable: 0.01\ny: 0.00999900001666658\nMaximum value: 0.999950010415832\n```", "```py\nEnter a function in one variable: cos(y) + k\nEnter the variable to differentiate with respect to: y\nEnter the initial value of the variable: 0.01\ny: 0.00999900001666658\nMaximum value: k + 0.999950010415832\n```", "```py\nEnter a function in one variable: x**5 - 30*x**3 + 50*x\nEnter the variable to differentiate with respect to: x\nEnter the initial value of the variable: -2\nx: -4.17445116397103\nMaximum value: 705.959460322318\n```", "```py\nEnter a function in one variable: x**5 - 30*x**3 + 50*x\nEnter the variable to differentiate with respect to: x\nEnter the initial value of the variable: 0.5\nx: 0.757452532565767\nMaximum value: 25.0846622605419\n```", "```py\n   '''\n   Use gradient ascent to find the maximum value of a\n   single-variable function. This also checks for the existence\n   of a solution for the equation f'(x)=0.\n   '''\n\n   from sympy import Derivative, Symbol, sympify, solve\n\n   def grad_ascent(x0, f1x, x):\n       # Check if f1x=0 has a solution\n➊     if not solve(f1x):\n           print('Cannot continue, solution for {0}=0 does not exist'.format(f1x))\n           return\n       epsilon = 1e-6\n       step_size = 1e-4\n       x_old = x0\n       x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()\n       while abs(x_old - x_new) > epsilon:\n           x_old = x_new\n           x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()\n\n       return x_new\n\n   if __name__ == '__main__':\n\n       f = input('Enter a function in one variable: ')\n       var = input('Enter the variable to differentiate with respect to: ')\n       var0 = float(input('Enter the initial value of the variable: '))\n       try:\n           f = sympify(f)\n       except SympifyError:\n           print('Invalid function entered')\n       else:\n           var = Symbol(var)\n           d = Derivative(f, var).doit()\n           var_max = grad_ascent(var0, d, var)\n➋         if var_max:\n              print('{0}: {1}'.format(var.name, var_max))\n              print('Maximum value: {0}'.format(f.subs({var:var_max})))\n```", "```py\nEnter a function in one variable: log(x)\nEnter the variable to differentiate with respect to: x\nEnter the initial value of the variable: 0.1\nCannot continue, solution for 1/x=0 does not exist\n```", "```py\n>>> from sympy import Integral, Symbol\n>>> x = Symbol('x')\n>>> k = Symbol('k')\n>>> Integral(k*x, x)\nIntegral(k*x, x)\n```", "```py\n>>> Integral(k*x, x).doit()\nk*x**2/2\n```", "```py\n>>> Integral(k*x, (x, 0, 2)).doit()\n2*k\n```", "```py\n>>> from sympy import Integral, Symbol\n>>> x = Symbol('x')\n>>> Integral(x, (x, 2, 4)).doit()\n6\n```", "```py\n>>> from sympy import Symbol, exp, sqrt, pi, Integral\n>>> x = Symbol('x')\n>>> p = exp(-(x - 10)**2/2)/sqrt(2*pi)\n>>> Integral(p, (x, 11, 12)).doit().evalf()\n0.135905121983278\n```", "```py\n>>> from sympy import Symbol, exp, sqrt, pi, Integral, S\n>>> x = Symbol('x')\n>>> p = exp(-(x – 10)**2/2)/sqrt(2*pi)\n>>> Integral(p, (x, S.NegativeInfinity, S.Infinity)).doit().evalf()\n1.00000000000000\n```", "```py\nEnter a function in one variable: 1/x\nEnter the variable: x\nEnter the point to check the continuity at: 1\n1/x is continuous at 1.0\n```", "```py\nEnter a function in one variable: 1/x\nEnter the variable: x\nEnter the point to check the continuity at: 0\n1/x is not continuous at 0.0\n```"]