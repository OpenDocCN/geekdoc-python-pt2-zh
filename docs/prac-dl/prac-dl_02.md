## **2

使用 Python**

![image](Images/common.jpg)

如果你已经熟悉 Python，可以跳过本章。本总结是为那些对编程有一定了解但不熟悉 Python 的人准备的。我们只会介绍足够的语言知识，以便能读懂和理解本书中的代码示例。如果你几乎没有计算机编程经验，建议先阅读更完整的书籍，例如 Eric Matthes 编写的《*Python 编程快速上手*》第二版（No Starch Press，2019）。

Python 的基本构成是：通过缩进将顺序语句组织成块；包括数字、字符串、元组、列表和字典在内的数据结构；包括 if-elif-else、for 循环、while 循环、with 语句和 try-except 块在内的控制结构；带有可选嵌套函数的函数；以及大量可导入的模块库。我们将逐一介绍这些特性。

### Python 解释器

在 Linux 系统中，Python 通常以两种方式之一使用。你可以从命令行运行 Python 解释器并交互式地输入命令，或者你可以运行一个 Python 命令脚本。只需在控制台中输入 python3 来交互式地使用 Python：

$ python3

Python 3.6.7（默认，2018年10月22日，11:32:17）

[GCC 8.2.0] 在 Linux 上

输入“help”、“copyright”、“credits”或“license”以获取更多信息。

>>>

如你所见，Python 会为你打开一个提示符，你可以在其中输入命令，提示符以 >>> 开头。输入像 1+2 这样的表达式并按回车键。Python 会立即通过求值该方程并返回结果。当你想退出控制台时，使用 CTRL-D。

### 语句与空白

和几乎所有其他编程语言一样，除非被控制流结构修改，否则 Python 中的语句按照它们在代码中出现的顺序依次执行。例如，考虑以下代码：

statement1

statement2

statement3

这里，statement1 会首先执行，接着是 statement2，最后是 statement3。

多个语句可以组合成称为 *块* 的单元。例如，if 语句的条件为 True 时，可能触发一个块的执行。在语法上，和 if 语句一起使用的语句需要以某种方式标记，以便计算机知道哪些语句需要执行。经典的语言如 Pascal 使用冗长的 BEGIN 和 END 关键字。C 语言及其衍生语言（包括当前广泛使用的大多数语言）使用大括号：“{” 和 “}”。

在 Python 中，我们使用缩进。这使得 Python 代码在阅读时显得优雅，因为它遵循传统大纲的格式。它还使得不同作者的代码在视觉上保持一致，减少了混淆的空间。在 Python 中，当我们使用 if else 语句时，即使我们还未完全理解 if 语句的格式，也能很容易地看到哪些语句应当在条件的哪一部分下运行。例如：

if condition1:

statement1

statement2

else:

statement3

缩进清晰地表明，当 condition1（无论是什么）为真时，statement1 和 statement2 会被执行。同样，我们看到当 condition1 为假时，statement3 会被执行。

注意前面 if 语句中的冒号。Python 使用冒号来标记代码块。你必须在任何控制语句后加上冒号，然后下一行应该总是缩进一个级别。如果你尝试使用控制结构，但在控制结构的主体中没有提供任何语句，Python 会抛出一个错误。

例如，else: 子句在块中至少需要有一个语句。如果不需要 else，就不要包括它。（如果你真的想包括它，可以使用 pass 关键字告诉 Python 你知道这里需要一个语句，但你不希望这个条件做任何事。）

缩进对于新接触 Python 的人来说可能会让人感到害怕，但你可以通过正确配置文本编辑器来让自己更轻松。Python 的约定是，你应该告诉文本编辑器执行以下操作：

1.  用空格代替制表符。像避开瘟疫一样避开制表符。

1.  每次按下 TAB 键时插入四个空格。

1.  按下回车键时会自动缩进。

通过这些设置，当你输入控制语句的 “:” 后，直接按回车，Python 会自动缩进代码块。

配置这些设置的方式当然取决于所使用的文本编辑器，但任何值得信赖的文本编辑器都能做到这些，许多编辑器将自动缩进设置为标准。如果你使用集成开发环境（IDE），那么一旦 IDE 识别出你在编写 Python 代码，这些约定大多数会自动生效。

### 变量与基本数据结构

Python 的原生数据结构简单而优雅。在本节中，我们将介绍数字表示、变量、字符串、列表和字典。

#### 表示数字

Python 中的数字有两种类型：整数或浮点数。*整数*是像 42 和 66 这样的整数。*浮点数*是带小数点的数字，如 3.1415 和 2.718。本书将忽略复数，尽管 Python 支持复数。

如果不包含小数点，Python 会认为你指的是整数；否则，它会使用浮点数。浮点数也可以使用科学计数法表示，其中 6.022e23 表示 6.023 × 10^(23)。

大多数编程语言只能表示一定范围内的数字，但 Python 对整数没有这个限制，整数的大小可以大到计算机内存能够容纳的程度。为了好玩，输入 **2**2001** 看看会发生什么。计算机存储和操作数字的多种方式相当令人着迷。那些好奇的人可能会想进一步了解。[^(1)](ch02.xhtml#ch02fn1)

#### 变量

*变量* 提供了一个有用的地方来存储数据以便重用。幸运的是，使用 Python 变量非常简单。Python 是 *动态类型* 的，这意味着我们不需要提前声明一个变量将存储的数据类型。我们只需要将数据赋值给一个变量，Python 会自动推断出数据的类型。

我们甚至可以通过赋予新值来改变变量中存储的数据类型，无论新值的数据类型是什么。例如，以下所有赋值在 Python 中都是有效的：

❶ >>> v = 123

❷ >>> n = 3.141592

❸ >>> v = 6.022e23

该代码将整数 123 赋值给 v ❶，将浮点值 3.141592 赋值给 n ❷，然后将一个浮点值赋值给 v：6.022 × 10^(23) ❸。

Python 变量名区分大小写，必须以字母开头，并且可以包含字母、数字和“_”（下划线）字符。许多 Python 程序员遵循 Java 的驼峰命名法，如此例所示，但这不是严格要求的：

>>> myVariableName=123

#### 字符串

Python 支持使用字符串来处理文本数据。你可以用引号（单引号（’）、双引号（’’）或三引号（’’’））来标记 *字符串* 的开始和结束，只要开头和结尾使用的引号一致。三引号字符串是特殊的：它可以跨越多行文本，通常在定义一个函数后，你会立刻使用它来实现简单的文档字符串。以下所有的都是有效的 Python 字符串：

>>> thing1 = 'how now brown cow?'

>>> thing2 = "I don't think; therefore I am not."

>>> thing3 = """

one

two

three

"""

在这里，thing1 是一个简单的字符串；thing2 也是一个简单的字符串，但注意它内部嵌入了一个单引号，用作撇号。我们之所以能够这样做，是因为我们用双引号字符开始了字符串；如果我们想在字符串内部使用双引号，那么我们就需要用单引号将其括起来。

最后一个字符串 thing3 跨越了多行。为了从一行到二行而输入的换行符也属于字符串的一部分，当打印时，它们会被显示出来。请注意，如果你在 Python 解释器中实际输入对 thing3 的赋值，你会看到解释器插入了省略号（...）。我们在示例中忽略了这些符号，因为它们会让人困惑，且并不真正是字符串的一部分。

#### 列表

字符串和数字是 *原始数据类型*，意味着它们不是由一组数据集合组成的。可以把它们想象为原子。它们可以通过使用元组和列表，组合成更复杂的数据结构。*列表* 是其他数据的有序集合，这些数据可以是原始数据，也可以是任何其他数据集合。例如，一个列表可以包含另一个列表。

##### 基本的列表操作

与其他某些数据类型不同，向列表中添加项目的顺序是很重要的。我们先来看看一些列表的例子，再讨论发生了什么：

❶ >>> t = ["Quednoe","Biggles",39]

>>> t

['Quednoe', 'Biggles', 39]

❷ >>> t[0]

'Quednoe'

>>> t[1]

'Biggles'

>>> t[2]

39

首先，我们定义一个列表❶。我们使用“[”字符来开始列表，输入元素，最后用“]”字符结束。列表中的元素由逗号（,）分隔。这个列表有三个元素，当我们要求Python评估表达式t时，我们会看到它的内容。

我们可以通过使用数字和方括号来索引列表，就像操作数组一样。在这里，我们使用括号表示法❷来请求列表中的第一个元素。对于第二个和第三个元素，我们也是一样做的。

我们可以使用append方法向列表中添加元素：

>>> t.append(3.14)

>>> t

['Quednoe', 'Biggles', 39, 3.14]

这里我们看到列表t现在有了第四个成员3.14。请注意，将元素附加到列表中会将其添加到列表的*末尾*。

让我们看几个关于列表的例子。

❶ >>> t[-1]

3.14

❷ >>> t[0:2]

['Quednoe', 'Biggles']

❸ >>> t[1] = 'Melvin'

>>> t

['Quednoe', 'Melvin', 39, 3.14]

❹ >>> t.index("Melvin")

1

这些例子展示了如何使用负索引❶，它从列表的*末尾*开始计数，并向后数，因此-1将始终返回列表中的最后一个元素。我们还展示了如何使用范围来选择列表的一个子集❷。

使用Python的范围时，遵循格式[a:b]来返回从索引a到*比b小1*的所有元素。在数学上，这是[*a*,*b*)，其中*b*索引的元素不包括在内。因此，要求t[0:2]将只返回索引0和1的元素。请注意，如果你跳过了范围的开始部分或结束部分，它会默认到第一个元素（如果跳过开始部分）或最后一个元素（如果跳过结束部分）。

如果在赋值语句的左侧使用索引，则该列表的元素会被修改❸。现在我们看到列表的第二个元素已经改变。

最后，我们使用索引方法来搜索列表中的某个元素❹。如果找到了该元素，index方法会返回元素的索引。如果该元素不在列表中，Python会抛出一个错误。

如果你想知道某个元素是否在列表中，但不关心它*在哪里*，可以使用in，像这样：

>>> b = [1,2,3,4]

>>> 2 in b

True

>>> 5 in b

False

这里返回的值是布尔值，True和False。注意True和False的首字母大写。布尔值也可以赋给变量。我们还应该提到None，它是Python中类似于其他语言中的NULL的版本（至少在初步理解上是如此）。当我们在讲解Python函数时，"Functions– on [page 39](ch03.xhtml#page_39)"会看到None的一个好用例子。

##### 复制列表

关于列表的最后一点需要注意的是，Python在将列表赋值给新变量时并不会复制列表；而是将新变量指向列表已经存在的内存位置。例如：

>>> a = [0,1,2,3,4]

>>> a

[0, 1, 2, 3, 4]

>>> b = a

>>> b

[0, 1, 2, 3, 4]

这里我们将a定义为一个包含五个数字的列表。然后我们将这个列表赋给一个新变量b，发现b确实和a相同。

到目前为止，一切顺利。然而，如果我们决定像这样更改列表中的某个元素呢：

>>> a[2] = 3

>>> a

[0, 1, 3, 3, 4]

>>> b

[0, 1, 3, 3, 4]

我们看到a如预期已更新，但或许出乎意料的是，b也更新了。这是因为将a赋值给b时，b指向了与a相同的内存位置。它并没有真正复制a的内容。

如果我们想在将a赋值给b时复制a，我们需要像这样显式选择a的所有元素：

❶ >>> b = a[:]

>>> a

[0, 1, 3, 3, 4]

>>> b

[0, 1, 3, 3, 4]

>>> a[2] = 2

>>> a

[0, 1, 2, 3, 4]

>>> b

[0, 1, 3, 3, 4]

在这里，我们定义了一个列表a，然后通过选择a的所有元素将a赋值给b❶。我们看到b现在看起来像a。接下来，我们更新a中的*第三*项，看到a现在看起来如我们所预期，第三项从3变成了2。然而，b并没有被改变，因为最初的赋值通过选择a的所有元素在内存中创建了一个新的列表。

Python不自动复制列表的原因是列表可能很大，因此不必要的复制会浪费大量内存。完全复制由其他嵌套列表组成的列表可能并不简单。选择一切的方法❶只会进行浅拷贝——嵌套元素仍然是别名。使用copy模块的deepcopy函数可以递归地复制具有嵌套元素的列表的所有级别。

Python还有一种与列表类似的数据类型，叫做*元组*。元组用圆括号定义，而不是方括号，它们与列表非常相似，只是一旦定义后，元组不能被修改。通常情况下，我们会使用列表，但NumPy偶尔也会使用元组（参见[第3章](ch03.xhtml#ch03)）。

#### 字典

我们要看的最后一种数据类型是*字典*。字典由一组键组成，每个键都与一个值关联。你可以用“{”和“}”字符定义字典。与列表类似，字典的值可以是任何类型，包括另一个字典。键通常是字符串，但也可以是数字或其他对象。你可以这样定义字典：

>>> d = {"a":1, "b":2, "c":3}

>>> d.keys()

dict_keys(['a', 'b', 'c'])

这个例子展示了如何通过直接列出字典的内容来定义字典。字典的元素是键:值对。在这里，所有键都是字符串，与每个键关联的值是整数。keys方法返回字典中的所有键。

上述语法在字典内容已知的情况下非常有用。但通常并非如此。大多数情况下，字典已经定义，我们会逐个添加元素：

>>> d = {}

>>> d["a"] = 1

>>> d["b"] = 2

>>> d["c"] = 3

这里我们定义了一个空字典d，并为一组新键逐个赋值。如果键在字典d中已存在，它的值会被更新。

要获取与特定键关联的值，只需用该键索引字典：

>>> d["b"]

2

如果字典中没有该键，Python会抛出一个错误。要测试一个键是否在字典中，可以使用in，像这样：

>>> "c" in d

True

在列表和字典之间，你几乎可以方便地存储任何数据。这是像Python这样的语言的一个优点：程序员可以将精力集中在完成手头的任务上，而不是实现复杂的数据结构。列表和字典使用起来非常迅速，通常情况下它们是你所需要的，除非你在做科学编程，在这种情况下，我们有NumPy，正如在[第3章](ch03.xhtml#ch03)中讨论的那样。

### 控制结构

Python实现了几种*控制结构*，允许你通过语法改变程序的执行流程。我们将介绍这些结构：

+   if-elif-else语句

+   for循环

+   while循环

+   with语句

+   try-except块

#### if-elif-else语句

if语句用于做决策。你给它一个必须返回布尔值True或False的条件。如果条件为真，if语句的第一个代码块就会执行。如果条件为假，则什么都不会发生，代码会跳过if语句，除非你包含了else语句，在这种情况下，else语句的代码块会被执行。你可以通过使用elif关键字在一个语句中测试多个条件，它会添加额外的条件及其自己的代码块。举个例子：

❶ >>> disc = b**2 - 4*a*c

❷ >>> if (disc < 0):

print("虚数")

❸ elif (disc == 0):

print("实数")

else:

❹ print("两个实数")

这段代码检查二次多项式*ax*² + *bx* + *c*的判别式，以确定解的数量和类型：实数解、一对实数解或虚数解。解是使多项式等于零的*x*值。

首先，代码计算判别式值（disc）❶。然后它检查该值是否小于零❷。如果是，说明有两个虚数解。如果判别式恰好为零❸，则只有一个解，即一个实数。最后，如果两个条件都不成立，else语句就会执行；在这种情况下，意味着有两个实数解❹。条件周围的括号并不是必须的，但有助于提高可读性。还要注意，Python使用“**”进行幂运算，因此b**2-4*a*c等于*b*² *–* 4*ac*。你可以根据需要使用任意数量的elif语句（可以没有），后面跟一个可选的else语句。Python没有其他常见编程语言中的case或switch语句。

#### for 循环

几乎所有结构化编程语言都有循环，可以反复执行某个特定的代码块。在这一节中，我们将介绍Python中的几种循环。

Python的主要循环结构是for循环。在其他语言中，for循环通常是从某个起始值到结束值的计数循环，按固定的增量递增。在Python中，循环遍历可以迭代的对象，即具有next方法的事物。这包括字符串的字符、列表或元组的元素，或字典的元素。

Python 有两个内建函数，和循环一起使用时非常方便。第一个是 `range`，它创建一个生成器对象，按顺序生成整数，默认从 0 开始，除非另有指定：

❶ >>> for i in range(6):

print(i)

0

1

2

3

4

5

`range` 函数 ❶ 返回 0...5 的值，`for` 语句将这些值逐一赋给 i，直到循环结束。这里我们简单地使用内建的 `print` 函数打印当前的 i 值。

另一个在 `for` 循环中非常有用的函数是 `enumerate`。这个函数返回两个值，第一个是当前元素的索引，第二个是该元素本身。一个例子会更清楚地说明：

>>> x = ["how","now","brown","cow"]

>>> for i in x: ❶

print(i)

how

now

brown

cow

>>> for i,v in enumerate(x): ❷

print(i,v)

0 how

1 now

2 brown

3 cow

在第一个只遍历列表 x 的循环 ❶ 中，我们将列表 x 的每个元素按顺序赋值给 i。第二个循环使用 `enumerate`，每次迭代时返回 *两个* 值：当前的索引存储在 i 中，当前列表元素存储在 v 中 ❷。Python 能够同时将多个部分赋值给多个变量。在这个例子中，循环体打印的是索引后跟着该索引对应的元素。

当我们对字典使用 `for` 循环时会发生什么？让我们来看看：

❶ >>> d = {"a":1, "b":2, "c":2.718}

❷ >>> for i in d:

print(i)

a

b

c

❸ >>> for i in d:

print(i, d[i])

a 1

b 2

c 2.718

在这里，我们首先定义了一个字典 d，包含三个键 ❶。如果我们简单地遍历字典变量，我们会得到这些键 ❷。但是，如果我们使用键来返回相关的值，如第二个循环 ❸ 所示，我们就能遍历整个字典，每次只访问一个值。

Python 的一个特别吸引人的特性是我们可以将 `for` 循环与列表结合使用，形成 *列表推导式*。列表推导式开始时是一个以“[”为开头的列表，但它的主体实际上是生成该列表的代码，而不是列出单个元素。这种简写法需要一些时间来适应，但一旦熟悉后，你会发现它是许多 `for` 循环的高效替代方法。例如：

❶ >>> import random

>>> a = []

>>> for i in range(10000):

❷         a.append(random.random())

❸ >>> b = [random.random() for i in range(10000)]

❹ >>> m3 = [i for i in range(10000) if (i % 3) == 0]

我们首先导入标准的随机数库 ❶，然后用范围 [0,1) 内的 10,000 个随机数填充列表 a（表示包括 0，但不包括 1） ❷。接着，我们也用列表推导式填充 b，生成 10,000 个随机数 ❸。注意，语法与定义值的列表相同，但这里列表的主体是一个 *返回* 值的代码块。在这个例子中，它是对 `random.random()` 的调用，并对 10,000 个元素执行 `for` 循环。

最后一个示例创建了一个列表 m3，包含所有小于 10,000 且是 3 的倍数的数值❹。if 子句是用于测试某个 i 值是否会包含在列表中的条件。百分号操作符是 *取模运算*，它返回除法后的余数。在这种情况下，它是在判断 i 除以 3（使用整数除法）的余数是否为零。如果是零，表示没有余数，也就是说 i 是 3 的倍数（或者是 0）。

#### while 循环

许多编程语言包括顶测循环和底测循环。*顶测循环* 在执行循环体之前先测试循环条件，如果测试不为真，循环体将永远不会执行。*底测循环* 至少执行一次循环体，然后才测试是否应该再次执行循环。在 C 中，while 循环是顶测循环，而 do...while 循环是底测循环。Python 只有顶测的 while 循环，其语法如下：

❶ >>> i = 0

❷ >>> while (i < 4):

print(i)

❸ i += 1

0

1

2

3

我们必须在开始循环❶之前初始化循环控制变量 (i)，以确保条件 i < 4 一开始就为真❷。还要注意，我们显式地在循环体的末尾递增 i❸。表达式 i += 1 是 i = i + 1 的简写，并将 i 增加 1。Python 不支持 C 风格的递增和递减运算符，例如 i ++。如果你尝试这么做，Python 会亲切地告诉你一个语法错误（SyntaxError）。

while 循环会一直重复执行，只要条件评估为 True。程序员需要在循环体内做些事情，使得条件最终变为 False，从而结束循环。你也可以手动退出循环，如下文所示。

#### break 和 continue 语句

for 和 while 循环与另外两条 Python 语句一起使用：要立即退出循环，使用 break 语句；要立即跳到下一次迭代，使用 continue。break 的一个常见用法是跳出一个无限循环：

>>> i = 0

>>> while True:

print(i)

i += 1

if (i == 4):

❶ break

0

1

2

3

这会产生与之前的 while 循环示例相同的输出，但当满足终止条件时，通过 break 显式退出循环❶；在这里，当 i 增加到 4 时终止。使用 break 对这个示例来说并不完全合适，因为有其他更清晰的方式来实现这个功能，但通常循环可能需要一直执行，直到程序结束，或者直到某些其他罕见的情况或错误发生。例如，命令行解释器会不断检查键盘输入。每次输入字符时，它都会添加到缓冲区。然而，如果字符是“换行符”，它会跳出循环并解释缓冲区的内容。

continue 语句会跳过循环体中它后面的所有语句，继续执行下一次循环。例如：

>>> for i in range(4):

print(i)

❶ continue

print("xyzzy")

0

1

2

3

在这里，continue 语句❶ 确保了第二个 print 语句永远不会被执行。

#### with 语句

Python的`with`语句在处理文件时非常有用。例如，以下代码使用`with`语句打开磁盘上的一个文件，并将其内容读取到一个字符串中：

>>> with open("sesame") as f:

s = f.read()

>>> s

'this is a file\n'

`with`语句打开了一个名为*sesame*的文件，并将文件对象赋值给f。然后我们使用`read`方法读取整个文件并将其作为字符串赋值给s。评估s时，我们看到文件包含字符串“this is a file”，并且末尾有一个换行符。

请注意，上面的示例使用了`open`和`read`，但在完成后并没有显式关闭文件。这是因为当`with`语句退出时，`close`方法会自动调用，因为f超出了作用域（意味着f仅在`with`语句的代码块内定义）。

#### 使用`try-except`块处理错误

最后，让我们快速看一下Python如何捕获和处理错误，而不是让错误停止我们的程序。同样，我们只会看一下Python错误控制能力的简要框架，作为调试的辅助工具。

为了捕获错误而不是让它停止程序执行，我们可以将可能导致错误的语句封装在`try...except`块中。如果在`try`和`except`之间的任何语句引发了错误，它将被捕获，执行会跳到`except`语句块中的内容。这里的示例展示了如何捕获`try`块内任何可能发生的*错误*；虽然值得注意的是，Python有丰富的错误类型，并且用户可以定义自己的错误类型：

>>> x = 1.0/0.0

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

ZeroDivisionError: 浮点数除以零

>>> try:

x = 1.0/0.0

except:

x = 0

>>> x

0

这里我们首先尝试将除以零的结果赋值给x。这个操作会失败，并返回Python给出的错误信息。然而，如果我们将赋值操作包裹在一个`try`块内，Python会跳转到`except`块中的x = 0语句，并将x赋值为0，如下所示。

如果你没有使用支持在执行代码时跳出执行的高级Python编程环境，那么下面的结构很有用，因为它会在遇到时停止执行。在这里，它会在发生除零错误后立即停止执行：

>>> try:

x = 1.0/0.0

except:

import pdb; pdb.set_trace()

当发生错误时，`pdb`模块会被导入（如果尚未导入），并调用`set_trace`函数进入调试环境。当然，`pdb.set_trace()`可以在代码的任何位置调用——它不一定要在`try...except`块内部。

### 函数

在 Python 中，你使用 `def` 关键字定义一个函数，后跟函数名以及函数将接受的参数列表，参数放在括号中。即使你不包括任何参数，也必须包含一对括号。由于 Python 是动态类型的，你列出函数的参数，但不包含类型信息。如果有必要，你也可以提供默认值。同样，我们忽略 Python 的面向对象能力，只关注我们可以用函数做的一小部分。让我们定义一个简单的函数：

>>> def product(a,b):

return a*b

>>> product(4,5)

20

这个函数叫做 `product`，它接受两个参数，我们将在函数内部将其称为 `a` 和 `b`。这个函数的主体由一个语句组成——一个 `return` 语句，它将返回到调用 `product` 时的代码位置，并返回给定的值，这里是两个参数的乘积。如果我们测试这个函数，我们会看到它确实会将两个参数相乘。

接下来，让我们重新定义 `product` 函数，并为第二个参数提供一个默认值，使用以下代码：

>>> def product(a,b=3):

return a*b

>>> product(4,5)

20

>>> product(3)

9

我们在函数的参数列表中提供默认值。如果我们使用两个参数，Python 会像以前一样在函数内部分配第二个参数的值。然而，如果我们不提供第二个参数，Python 会使用给定的默认值 `3`，从而给我们返回一个有意义的结果 `3 × 3 = 9`。为函数参数提供默认值使其成为关键字参数，正如我们上面看到的那样，在调用函数时我们不需要为该参数提供值。这种技巧非常方便，我们将在我们的代码示例中不时看到它。

我们下面的最终示例展示了如何定义一个不接受任何参数的函数：

>>> def pp():

print("plugh")

>>> pp()

plugh

`pp` 函数有一个空的参数列表。函数主体中的唯一语句是打印单词 *plugh*。没有返回值。

Python 允许你嵌套函数定义，这样一个函数本身可以在内部定义其他函数。内部函数仅对外部函数可访问。通常情况下，不需要这样做，如果你发现自己经常这么做，可能需要考虑重构为面向对象设计；但偶尔这种做法是有意义的，所以我们在这里提到它。

最后，一个有用的做法是将默认值设为 `None`，使得我们可以在函数内部检查是否提供了值，通过测试参数是否为 `None`。任何持有任何类型数据的变量都可以与 `None` 进行测试。

### 模块

我们通过回顾Python的模块系统来结束这次快速复习。这类似于C标准库，它为Python提供了一整套现成的工具，所有这些工具都定义为模块。用户自然也可以创建自己的模块。那么，*模块*就是一组可以导入到程序中的函数。你也可以只从特定模块导入某些函数，而不是导入整个模块，只要你注意到导入的函数可能与其他命名空间中的函数同名。

通过*命名空间*，我们指的是一组函数，就像一个家庭，其中的函数是家庭成员的名字。程序知道的所有函数都在我们的命名空间中。如果我们从一个模块导入一个函数，那么这个函数也会出现在我们的命名空间中。如果我们导入整个模块，并通过加上模块名来引用函数，那么我们可以使用这个函数，但它不在我们的命名空间中。我们很快就会看到为什么这种区分很重要。

让我们来看一些使用Python库模块的例子：

>>> import time

>>> time.time()

1524693601.402852

我们首先导入`time`模块。这意味着只要我们在函数名前加上`time.`，就可以访问`time`模块中的所有函数。`time`模块的`time`函数返回当前时间，自1970年1月1日以来的秒数。这个时间被称为*纪元时间*，它对于衡量代码执行所需的时间非常有用。由于返回的值只会增加，代码开始时和结束时的纪元时间差值表示代码执行的时长。

我们来看另一个例子：

>>> from time import ctime, localtime

>>> ctime()

'Wed Apr 25 16:00:21 2020'

>>> localtime().tm_year

2018

在这里，我们没有导入整个`time`模块，而是仅导入了其中的两个函数。这样做将这些函数放入我们的命名空间中，我们可以直接调用它们。`ctime`函数返回一个显示当前日期和时间的字符串，而`localtime`函数返回按日期和时间部分拆分的当前时间。在这里，我们展示了写作时的年份。

我们最后一个例子告诉我们，通常最好直接导入整个模块，而不是只导入其中的函数：

>>> def sqrt(x):

return 4

>>> sqrt(2)

4

>>> from math import *

>>> sqrt(2)

1.4142135623730951

首先，我们定义了一个名为`sqrt`的函数。这个函数无论参数是什么，都会始终返回4。虽然这当然不是特别有用，但它仍然是一个有效的Python函数。

接下来，我们导入整个数学库函数。这个语法将模块中的所有函数都放入我们的命名空间中，这样我们就可以在不使用模块名的情况下引用它们。完成此操作后，我们看到`sqrt`现在返回实际的平方根。

我们的sqrt实现出了什么问题？当我们导入整个数学库时，它被覆盖了，因为数学库中也包含一个叫做sqrt的函数，而由于数学库是在我们定义sqrt之后导入的，因此数学库中的sqrt版本优先使用。

Python的模块库是该语言在实用性方面的一个关键优势。标准库有着丰富的文档。想要快速查看Python 3.*X*模块的列表，请访问 *[https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)*。Python的官方网站是：[http://www.python.org/](http://www.python.org/)。我强烈建议你花些时间浏览这些链接，真正了解Python能提供的所有功能。

### 总结

在本章中，我们回顾了Python的基础知识，为理解本书其余部分的代码示例打下了基础。我们学习了Python的语法和语句，接着研究了Python的变量和数据结构，并探索了Python的控制结构和函数，最后了解了Python的模块库。

在下一章中，我们将深入探讨NumPy，看看如何使Python对我们更有用。NumPy是几乎所有机器学习库中都使用的核心工具，也是我们在本书中将要使用的库之一。

[1.](ch02.xhtml#Rch02fn1) 请参阅**罗纳德·T·克努瑟尔**的《*数字与计算机*》（Springer-Verlag，2017）。
