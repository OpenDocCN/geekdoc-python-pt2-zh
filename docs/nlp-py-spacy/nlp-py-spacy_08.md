## **8

**意图识别**

![Image](../Images/comm1.jpg)

聊天机器人应该足够智能，能够理解用户的需求。例如，一个对话型聊天机器人必须识别用户的意图，才能与用户保持良好的对话，而一个点餐聊天机器人则需要理解顾客的意图，以便接受订单。虽然在之前的章节中曾简要提到过意图识别，但本章将更深入地讨论这一话题。

你将通过提取话语中的及物动词和直接宾语来开始识别用户的意图。然后，你将探索如何从一系列句子中推导出用户的意图，识别不同意图的同义词，并使用语义相似度确定用户的意图。

### **提取及物动词和直接宾语以识别意图**

你通常可以通过三个步骤来识别用户的意图：将句子解析成词元（tokens），用表示句法关系的标记弧连接词元，并通过导航这些弧提取相关词元。在许多情况下，提取句子的及物动词和直接宾语可以识别用户的意图，如[图8-1](../Text/ch08.xhtml#ch08fig01)中的句法依存分析所示。

![image](../Images/fig8-1.jpg)

*图8-1：句子句法结构的图形表示示例*

连接及物动词和直接宾语的弧表明用户的意图是寻找一家酒店，或者如果将及物动词和直接宾语合并为一个词，则为 findHotel。你可以将这个结构作为后续程序中的*意图标识符*，如以下代码片段所示：

intent = extract_intent(doc)

if intent == 'orderPizza':

print('我们需要你回答一些问题才能下单。')

...

elif intent == 'showPizza':

print('你想看看我们的菜单吗？')

...

**注意**

*在[第11章](../Text/ch11.xhtml#ch11)中，你将看到更多关于如何在聊天机器人应用代码中使用意图标识符的详细示例。*

但有时仅通过及物动词/直接宾语对来找到意义并不容易。你可能需要探索及物动词和直接宾语的句法关系，以找到最能描述意图的动词和名词。

在其他情况下，用户的意图并没有明确表达，因此你必须推测出隐含的意图。在本节中，你将学习如何利用句法依存结构提取意图的策略。

#### ***获取及物动词/直接宾语对***

让我们首先通过检查每个词元的依存标签，寻找 dobj，来从句子中提取及物动词/直接宾语对。一旦找到直接宾语，我们可以通过获取直接宾语的句法中心来轻松获得相应的及物动词，如下面的脚本所示：

import spacy

nlp = spacy.load('en')

➊ doc = nlp(u'给我展示柏林最好的酒店')

➋ 对于 doc 中的每个词元：

if token.dep_ == 'dobj':

print(➌token.head.text + token.text.capitalize())

在这个脚本中，我们将管道应用于示例句子 ➊，然后遍历每个 token，寻找其依赖标签为 dobj ➋ 的 token。当找到时，我们通过获取直接对象的 head ➌ 来确定相应的及物动词。在这个例子中，我们还将及物动词和直接对象连接起来，以单个词的形式表达意图。

脚本生成的字符串如下：

showHotel

请记住，并非所有包含及物动词/直接对象对的句子都表达意图。例如，“他给了我一本书”只是一个陈述事实的句子。我们可以通过检查动词的特征来过滤出这样的句子，只挑选那些动词是现在时且不是第三人称的句子。不过，从客户与接受订单的聊天机器人交谈时，听到这样的句子还是不太常见的。

#### ***使用 token.conjuncts 提取多个意图***

有时，你可能会遇到一个看似表达多个意图的句子。例如，考虑以下句子：

我想要一份比萨和可乐。

在这种情况下，用户想要点一份比萨和一瓶可乐。但在大多数情况下，你可以将这些意图视为一个复杂的单一意图。尽管用户请求了不同类型的物品，你通常会将此句子视为包含多个项目的单个订单。在这个例子中，你可能会将意图识别为 orderPizza，它是通过结合及物动词和直接对象对形成的，但会提取比萨和可乐作为订单中的物品。

[图 8-2](../Text/ch08.xhtml#ch08fig02) 显示了示例句子的依赖树。

![image](../Images/fig8-2.jpg)

*图 8-2：包含直接对象及其连接词的句子的依赖树*

在图示中，你可以看到两条箭头指向直接对象“比萨”和与之相关的连接词“可乐”的弧线。名词的 *conjunct* 是通过连词（例如“和”、“或”等）与之连接的另一个名词。为了提取直接对象及其相关连接词，我们可以使用以下代码：

doc = nlp(u'I want a pizza and cola.')

#提取直接对象及其相关连接词

for token in doc:

if token.dep_ == 'dobj':

dobj = [token.text]

conj = [t.text for t in ➊token.conjuncts]

#合并提取的元素列表

➋ dobj_conj = dobj + conj

print(dobj_conj)

我们通过使用直接对象 ➊ 的 Token 对象的 conjuncts 属性来提取与直接对象相关的连接词。一旦我们获得了直接对象及其连接词，就将它们合并成一个单一的列表 ➋。

脚本输出应该如下所示：

['比萨', '可乐']

为了构建意图，我们也应该提取动词。我们已经有了直接宾语，获得它最简单的方法是获取直接宾语的句法头（你在“[获取及物动词/直接宾语对](../Text/ch08.xhtml#lev105)”中看到过这个示例，见[第113页](../Text/ch08.xhtml#page_113)）：

verb = dobj.head

然后，使用动词和直接宾语的 text 属性，我们可以构建意图。

#### ***尝试这个***

在[第114页](../Text/ch08.xhtml#page_114)提供的脚本中，你通过 Token 对象的 conjuncts 属性访问了与直接宾语相关联的连接词。在新的脚本中，将那一行代码替换为提取连接词的代码，通过查找从直接宾语向外延伸的标记为 conj 的弧线。你可以在获取直接宾语的同一个循环中完成这项操作，方法是查找标记为 dobj 的弧线。务必检查 conj 弧线的头部是否与直接宾语匹配。

#### ***使用词汇列表提取意图***

在某些情况下，除及物动词和直接宾语之外的其他词汇更能准确描述用户的意图。这些词汇通常与及物动词或直接宾语相关。因此，你需要进一步探索及物动词和直接宾语的句法关系，以发现最能表达意图的词汇。

例如，考虑以下话语：

我想要订购一个披萨。

在这个句子中，“want”和“pizza”这两个词最能表达意图，但这两个词都不是直接宾语或及物动词。然而，通过查看话语的依赖关系树，你会发现，“want”和“pizza”分别与及物动词“place”和直接宾语“order”相关联。[图8-3](../Text/ch08.xhtml#ch08fig03)展示了这里讨论的依赖关系树。

![image](../Images/fig8-3.jpg)

*图8-3：一个话语的依赖关系树，其中的及物动词和直接宾语并没有传达用户的意图*

为了从话语中提取这些词汇，我们将使用一个预定义的词汇列表，然后在用户的输入中查找这些词汇。

一位经验丰富的程序员可能会质疑硬编码如此列表的有效性，因为这个列表可能相当长，特别是在许多不同的上下文中使用时。但如果这个列表是针对特定上下文的，比如说订购披萨，它可能非常简短，这使得这种方法非常高效。以下代码实现了这种方法：

# 将管道应用于示例句子

doc = nlp(u'我想要订购一个披萨。')

# 提取直接宾语及其及物动词

dobj = ''

tverb = ''

for token in doc:

➊ 如果 token.dep_ == 'dobj'：

dobj = token

tverb = token.head

# 提取动词以定义意图

intentVerb = ''

verbList = ['want', 'like', 'need', 'order']

➋ 如果 tverb.text 在 verbList 中：

intentVerb = tverb

➌ 否则：

if tverb.head.dep_ == 'ROOT':

intentVerb = tverb.head

# 提取对象以定义意图

intentObj = ''

objList = ['披萨', '可乐']

➍ if dobj.text in objList:

intentObj = dobj

else:

for child in dobj.children:

if child.dep_ == 'prep':

➎ intentObj = list(child.children)[0]

break

➏ elif child.dep_ == 'compound':

intentObj = child

break

# 打印样本句子中表达的意图

print(intentVerb.text + intentObj.text.capitalize())

一如既往，我们首先找到并提取直接宾语和它的及物动词 ➊。一旦我们得到它们，我们检查它们是否可以在预定义的词汇列表中找到。这里我们使用了简化的列表：verbList 列表包含客户可能用来下订单的动词，而 objList 列表包含可能的菜单项的直接宾语。我们首先检查及物动词 ➋。如果它不在允许的动词列表 ➌ 中，我们检查句子的主要动词（ROOT），它是及物动词的核心。如果及物动词是句子的主要动词，这个实现方法仍然有效，因为主要动词的核心（ROOT）会指向它自己。

接下来，我们检查直接宾语 ➍。如果它不在允许的词汇列表中，我们检查它的句法子节点。我们首先检查直接宾语的介词。如果存在介词，我们取介词的子节点（它只能有一个子节点） ➎，它总是介词的宾语。

为了使这种方法适用于更多的情况，仅仅检查直接宾语子节点中的介词是不够的。例如，这个逻辑无法适用于以下句子：“我想下一个披萨订单”，其中没有介词子分支。相反，直接宾语有一个左子节点，“披萨”，spaCy将其标记为复合词。因此，我们检查直接宾语的子节点中是否有复合词 ➏。

最后，我们打印表示意图标识符的字符串。我们应该得到以下字符串：

wantPizza

注意，我们使用wantPizza作为意图标识符，而不是placeOrder（如果我们直接使用及物动词/直接宾语组合，应该会得到placeOrder）。这种方法可以减少应用中使用的意图标识符的数量。

### **使用同义词和语义相似性寻找单词的意义**

英语，像许多其他自然语言一样，让你可以用不同的方式表达相同的思想和意图，因为它包含了*同义词*——意义几乎相同的词或短语。

作为一个聊天机器人应用的开发者，你需要考虑到用户可能会为每个应用应该支持的意图使用相当广泛的短语。这意味着你的应用必须识别用户输入中的同义短语。事实上，如果你在一个流行的聊天机器人平台上构建你的聊天机器人，比如谷歌的Dialogflow，你就需要为每个可能的意图提交一组短语。然后，你会在后台使用这些语句来训练机器人的模型。

识别同义词有多种方法。一种方法是使用一组预定义的同义词列表。您将感兴趣的单词与这些列表进行比对，基于找到该单词的列表来识别其含义。另一种方法是根据语义相似性识别同义词，这一任务在[第5章](../Text/ch05.xhtml#ch05)中有详细描述。我将在接下来的章节中讨论这两种方法。

#### ***使用预定义列表识别同义词***

您已经知道，在大多数情况下，及物动词及其直接宾语最好描述了短语的意图。识别两个短语是否表达相同意图的一个简单方法是，确保两个短语中的及物动词是同义词，并且它们的直接宾语也是同义词。

例如，以下三个句子表达了相同的意图，您可以将其定义为orderPizza：

我想要一道菜。我想点一个披萨。给我一份派。

要处理这些话语，您可以使用以下步骤：

1.  执行依赖句法分析，从句子中提取及物动词及其直接宾语。

1.  检查预定义的同义词列表，将及物动词和直接宾语替换为应用程序能识别的单词。

1.  组成表示意图的字符串。

[图 8-4](../Text/ch08.xhtml#ch08fig04)中的图示总结了这些步骤，展示了如何处理比如“我想要一道菜”这样的句子。

![image](../Images/fig8-4.jpg)

*图 8-4：使用同义词列表处理意图识别*

在进行依赖句法分析后（当您将管道应用于话语时，依赖句法分析是隐式完成的），您提取直接宾语和及物动词，然后检查它们是否与相应的同义词列表匹配。如果找到匹配项，您将用列表中的首位单词替换该单词，该单词应是应用程序可以识别的。

让我们来看看这个场景的Python实现可能是什么样的：

# 将管道应用于样本句子

doc = nlp(u'我想要一道菜。')

# 从依赖树中提取及物动词及其直接宾语

➊ for token in doc:

if token.dep_ == 'dobj':

verb = token.head.text

dobj = token.text

# 创建一个可能的动词同义词元组列表

➋ verbList = [('order','want','give','make'),('show','find')]

# 查找包含从样本中提取的及物动词的元组

➌ verbSyns = [item for item in verbList if verb in item]

# 创建一个可能的直接宾语同义词元组列表

➍ dobjList = [('pizza','pie','dish'),('cola','soda')]

# 查找包含从样本中提取的直接宾语的元组

dobjSyns = [item for item in dobjList if dobj in item]

# 用同义词替换及物动词和直接宾语

应用程序

# 并组成表示意图的字符串

➎ intent = verbSyns[0][0] + dobjSyns[0][0].capitalize()

print(intent)

我们首先为示例句子创建一个Doc对象实例。然后，我们遍历通过Doc对象提供的依赖树，提取及物动词及其直接宾语 ➊。接着，我们创建一个包含所有允许的及物动词及其同义词的元组列表 ➋。每个元组的第一个元素是应用程序可以识别的及物动词，而元组中的其他元素是其同义词。

现在我们已经定义了允许的及物动词及其同义词，并将它们放入元组列表中，我们可以遍历整个列表，找到一个包含从示例句子提取的及物动词的元组 ➌。

同样，我们创建一个包含已识别的直接宾语及其同义词的元组列表，然后找到包含从示例中提取的直接宾语的元组 ➍。

最后，我们将选中的元组的第一个元素拼接起来，组成意图名称 ➎。结果，打印命令应该输出以下字符串：

orderPizza

请记住，选择给定动词的同义词集合在很大程度上取决于我们正在创建的应用类型。例如，在一个接收披萨订单的机器人应用中，动词“make”和“give”可以认为是同义的。原因是用户在订披萨时，可能会互换使用“Make me a pizza”和“Give me a pizza”这样的短语。

#### ***试试看***

使用[第118页](../Text/ch08.xhtml#page_118)提供的示例代码作为创建新脚本的基础。让脚本保留原有功能，但当找不到及物动词、其直接宾语或两者时，将“unrecognized”作为意图名称。为了测试你的代码，尝试使用示例句子，修改它以便能看到新功能的实际效果。例如，你可以使用以下句子：

我想要一个苹果。

用包含一个不在列表中的动词的句子来测试一下。

此外，你还可以尝试使用同义词列表来处理前面部分讨论的连词问题。

#### ***通过语义相似性识别隐含意图***

现实世界中的实现通常会比本章提供的示例更加复杂。即便使用一大套预定义的同义词列表，也不一定能总是奏效。原因是用户表达意图的方式多种多样，并且他们并不总是显式地表达出来。

识别隐含意图在很大程度上依赖于上下文。例如，如果你的机器人是为某个特定类型的任务设计的，比如订餐，它应该能识别出像“我想吃个派”这样的表达，作为下单披萨的意图。

一种广为人知的技术是通过提问来帮助用户更清楚地表达其意图。为了确定要问什么问题，你可以计算之前用户话语的语义相似性。

[图 8-5](../Text/ch08.xhtml#ch08fig05)展示了如何实现这个任务。

![image](../Images/fig8-5.jpg)

*图 8-5：通过计算语义相似度和提问澄清问题来识别隐含意图*

你从分析输入语句的依赖树开始，提取直接宾语及其及物动词。例如，如果在预定义的同义词列表中找不到直接宾语，如在《[使用预定义列表识别同义词](../Text/ch08.xhtml#lev110)》一节中的[第117页](../Text/ch08.xhtml#page_117)所讨论的，你可以尝试确定直接宾语与列表中单词的相似度。根据计算的语义相似度结果，你可以生成一个澄清性用户问题。

让我们在代码中实现这个技术，我会将其分成几个部分。像往常一样，我们从对示例句子应用文本处理管道开始：

doc = nlp(u'I feel like eating a pie.')

然后，我们提取直接宾语标记：

对于 doc 中的每个标记：

if token.dep_ == 'dobj':

dobj = token

我们为单词“food”创建一个标记。接下来，我们将计算这个标记与直接宾语标记之间的语义相似度：

tokens = nlp(u'food')

如果相似度大于预定义的阈值，应用程序会猜测用户最有可能是想要下订单。然后，它会提出一个澄清问题来确认这一点：

if dobj.similarity(tokens[0]) > 0.6:

question = 'Would you like to look at our menu?'

回顾一下[第五章](../Text/ch05.xhtml#ch05)，spaCy 使用词向量来计算标记之间的语义相似度。两个词向量在向量空间中越接近，它们之间的相似度就越高。在这个例子中，我们使用 0.6 作为假设直接宾语与食物产品相似的最小相似度。

#### ***尝试这个***

当然，你不能提前知道用户会使用哪些短语以及多容易识别用户的意图。你的应用程序也无法预知。这就是为什么现实中的应用通常会结合多种方法来识别意图。将基于识别同义词的方法与上一节讨论的基于处理隐含意图的方法结合使用，这样你就可以应对更多可能的情况。首先，尝试通过同义词方法从语句中提取意图。如果失败了，再尝试使用基于语义相似度的方法。如果两种方法都失败了，你可以将语句标记为表达了无法识别的意图。

### **从一系列句子中提取意图**

在对话中，反映用户意图的词语可能出现在不同的句子中，如以下示例所示：

我已经吃完了我的比萨，我想要另一个。

你的机器人应该准备好通过提取整个对话中的用户意图来处理这种场景。在这一节中，我将向你展示一种实现这一目标的技术。

#### ***遍历话语的依存结构***

我们先来看看话语的依存句法分析，这将揭示每个句子中的及物动词/直接宾语对，如[图 8-6](../Text/ch08.xhtml#ch08fig06)所示。

![image](../Images/fig8-6.jpg)

*图 8-6：整个话语的依存句法分析的可视化展示*

图中的淡色箭头表示我们关注的依存关系。换句话说，您希望将替代词“one”替换为它所代表的名词“pizza”。但是，spaCy的依存句法分析器不会显示此链接，因为它无法连接来自不同句子的标记。因此，确定这些依存关系的任务留给了您。

#### ***用前后文替换代词***

*前后文*是一个表达（如词语或从句），它为*代词*（如代词或代动词）赋予其含义。在这种意图提取中，您需要确定前后文并用它们替换相应的代词。您可以通过以下步骤来实现：

1.  解析整个话语的依存关系。

1.  将话语分解成句子。

1.  找到代词的前后文，代词是将要在意图定义中使用的及物动词的直接宾语。

[图 8-7](../Text/ch08.xhtml#ch08fig07)以图示方式展示了这些步骤。

![image](../Images/fig8-7.jpg)

*图 8-7：从一系列句子中提取意图的图形展示*

在spaCy中，我们可以用几行代码实现前两个步骤：

doc = nlp(u'I have finished my pizza. I want another one.')

我们将doc.sents属性返回的对象转换成列表，以便通过索引引用文本中的每个句子。（我们也可以直接使用for循环遍历doc.sents中的句子序列。）

接下来，我们定义两个列表，分别包含允许的及物动词和允许的直接宾语：

verbList = [('order','want','give','make'),('show','find')]

dobjList = [('pizza','pie','pizzaz'),('cola','soda')]

这些列表包含同义词的元组（有关详细信息，请参阅[《使用预定义列表识别同义词》](../Text/ch08.xhtml#lev110)，在[第 117 页](../Text/ch08.xhtml#page_117)）。

我们还需要定义一个可接受的替代词列表。为此，我们必须确定直接宾语可能是什么代词。我们先来想想可以替换最后一个句子的其他短语，然后突出显示每个短语中的直接宾语。可能的替代选项包括：

我想要另一个。我再要一次。我想要相同的。我想要更多。

所以，我们可以按如下方式定义替代词列表：

substitutes = ('one','it','same','more')

与及物动词和直接宾语列表不同，替代词列表具有简单的结构，因为我们不需要对替代词进行分组。同一个替代词可以指代任何直接宾语。

除了这些列表之外，我们可能还想定义一个字典来存储正在提取的意图定义部分：

intent = {'verb': '', 'dobj': ''}

现在我们准备开始意图识别过程：

for sent in doc.sents:

for token in sent:

if token.dep_ == 'dobj':

verbSyns = [item for item in verbList if token.head.text in item]

➊ dobjSyns = [item for item in dobjList if token.text in item]

substitute = [item for item in substitutes if token.text in item]

if ➋(dobjSyns != [] or substitute != []) and ➌verbSyns != []:

intent['verb'] = verbSyns[0][0]

➍ if dobjSyns != []:

intent['dobj'] = dobjSyns[0][0]

外部循环遍历Doc对象中保存的句子序列。内部循环则遍历句子中的标记。我们检查每个标记，看看它是否是直接宾语。如果是，我们确定该直接宾语是否是直接宾语同义词列表或替代词列表的一部分➊。我们还会检查相应的及物动词是否在及物动词同义词列表中。

只有当直接宾语在直接宾语同义词列表或替代词列表中时，我们才提取它 ➋。例如，我们不会对以下短语中的及物动词感兴趣（除非我们卖苹果，当然）：

我想要一个苹果。

如果及物动词不在允许的列表中 ➌，我们也不感兴趣，即使它的直接宾语满足这个条件，如下短语所示：

我喜欢它。

这就是为什么，在获取及物动词之前，我们不仅要检查直接宾语是否在直接宾语同义词列表或替代词列表中，还要检查及物动词是否在及物动词同义词列表中的原因。

最后，为了获取定义意图的直接宾语，我们确保可以在直接宾语同义词列表中找到它 ➍。现在我们可以构建意图定义：

intentStr = intent['verb'] + intent['dobj'].capitalize()

可选择地，我们可能想要打印出来，以确保一切按预期工作：

print(intentStr)

我们应该得到以下输出：

orderPizza

这个结果表明用户打算点一个披萨。

#### ***试试这个***

在某些话语中，多个句子可能会将先行词与其代词分开。例如，考虑以下句子的序列：

我吃完了我的披萨。它很好吃。我想再要一个。

编辑[第124页](../Text/ch08.xhtml#page_124)中提供的脚本，以便它可以处理此类或类似的句子序列。

### **总结**

意图识别是一个复杂的任务，可能需要你结合多种方法。在本章中，你学习了如何提取话语依存树中最重要的部分用于意图识别。然后你使用预定义的列表、语义相似性或两者结合来分析它们。你还通过将代词替换为其先行词，提取了从句子序列中获得的意图。
