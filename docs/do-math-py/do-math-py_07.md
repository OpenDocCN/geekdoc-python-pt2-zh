## **7**

**求解微积分问题**

![image](images/common-01.jpg)

在本章最后，我们将学习如何求解微积分问题。我们将首先了解数学函数，然后快速回顾 Python 标准库和 SymPy 中常见的数学函数。接着，我们将学习如何找到函数的极限，并计算导数和积分——也就是你在任何微积分课上都会做的事情。让我们开始吧！

### **什么是函数？**

让我们从一些基本定义开始。函数是输入集合和输出集合之间的*映射*。函数的特殊条件是输入集合中的一个元素与*恰好一个*输出集合中的元素相关联。例如，[图 7-1](ch07.html#ch7fig1) 显示了两个集合，其中输出集合的一个元素是输入集合中某个元素的平方。

![image](images/f07-01.jpg)

*图 7-1：一个函数描述了输入集合与输出集合之间的映射。这里，输出集合中的一个元素是输入集合中某个元素的平方。*

使用常见的函数表示法，我们将这个函数写作 *f*(*x*) = *x*²，其中 *x* 是独立变量。比如 *f*(2) = 4，*f*(100) = 10000，等等。我们称 *x* 为独立变量，因为我们可以自由地为它假设一个值，只要该值在它的定义域内（参见下一节）。

函数也可以用多个变量来定义。例如，*f*(*x*, *y*) = *x*² + *y*² 定义了一个包含两个变量 *x* 和 *y* 的函数。

#### ***函数的定义域和值域***

函数的*定义域*是独立变量可以有效取值的输入值集合。函数的输出集合称为*值域*。

例如，函数 *f*(*x*) = 1/*x* 的定义域是所有非零的实数和复数，因为 1/0 是未定义的。值域是通过将定义域中的每个数代入 1/*x* 计算得到的值集，因此在这种情况下，值域也是所有非零的实数和复数。

**注意**

*函数的定义域和值域当然可以不同。例如，对于函数* x*²，定义域是所有正数和负数，但值域仅包括正数。*

#### ***常见数学函数概述***

我们已经使用了 Python 标准库的 math 模块中的一些常见数学函数。几个熟悉的例子是 sin() 和 cos() 函数，它们分别对应三角函数中的正弦和余弦。其他三角函数——tan() 以及这些函数的反函数，asin()、acos() 和 atan()——也已定义。

math 模块还包括一些用来计算数值对数的函数——自然对数函数 log()、以 2 为底的对数 log2() 和以 10 为底的对数 log10()——以及函数 exp()，该函数计算 *e^x* 的值，其中 *e* 是欧拉常数（大约等于 2.71828）。

所有这些函数的一个缺点是，它们不适合处理符号表达式。如果我们想要处理包含符号的数学表达式，就必须开始使用SymPy定义的等效函数。

让我们看一个简短的例子：

>>> import math

>>> math.sin(math.pi/2)

1.0

在这里，我们使用标准库的math模块定义的sin()函数来求解角度*π*/2的正弦值。然后，我们可以使用SymPy做同样的事情。

>>> import sympy

>>> sympy.sin(math.pi/2)

1.00000000000000

类似于标准库的sin()函数，SymPy的sin()函数也期望角度以弧度表示。两个函数都返回1。

现在，让我们尝试使用符号来调用每个函数，看看会发生什么：

>>> from sympy import Symbol

>>> theta = Symbol('theta')

➊ >>> math.sin(theta) + math.sin(theta)

回溯（最近的调用最后）：

文件 "<pyshell#53>"，第1行，位于 <module>

math.sin(theta) + math.sin(theta)

文件 "/usr/lib/python3.4/site-packages/sympy/core/expr.py"，第225行，位于

__float__

引发 TypeError("无法将表达式转换为浮动类型")

TypeError: 无法将表达式转换为浮动类型

➋ >>> sympy.sin(theta) + sympy.sin(theta)

2*sin(theta)

标准库的sin()函数在我们以➊的形式调用它时，不知道该怎么办，因此它引发一个异常，表示它期望sin()函数的参数是一个数值。另一方面，SymPy能够在➋执行相同的操作，并返回表达式2*sin(theta)作为结果。现在这对我们来说不算什么令人惊讶的事，但它说明了标准库的数学函数在某些任务中的不足之处。

让我们考虑另一个例子。假设我们想要推导出一个物体在抛射运动中到达最高点所需的时间表达式，如果它以初速度u在角度theta下被抛出（见[《抛体运动》](ch02.html#ch02lev2sec08)，第48页）。

在最高点，u*sin(theta)-g*t = 0，因此为了求解t，我们将使用在[第4章](ch04.html#ch04)中学到的solve()函数：

>>> from sympy import sin, solve, Symbol

>>> u = Symbol('u')

>>> t = Symbol('t')

>>> g = Symbol('g')

>>> theta = Symbol('theta')

>>> solve(u*sin(theta)-g*t, t)

[u*sin(theta)/g]

如我们之前所学，t的表达式是u*sin(theta)/g，它展示了如何使用solve()函数来求解包含数学函数的方程。

### **SymPy中的假设**

在我们所有的程序中，我们都创建了一个Symbol对象来定义变量，像这样：x = Symbol('x')。假设由于你要求SymPy执行的操作，SymPy需要检查表达式*x* + 5是否大于0。我们来看看会发生什么：

>>> from sympy import Symbol

>>> x = Symbol('x')

>>> 如果 (x+5) > 0：

print('做一些事情')

否则：

print('做一些别的事情')

回溯（最近的调用最后）：

文件 "<pyshell#45>"，第1行，位于 <module>

如果 (x + 5) > 0：

文件 "/usr/lib/python3.4/site-packages/sympy/core/relational.py"，第 103 行，

在 __nonzero__

raise TypeError("无法确定真假值\n%s" % self)

TypeError: 无法确定的真假值

x + 5 > 0

因为 SymPy 无法知道 *x* 的符号，它无法推断 *x* + 5 是否大于 0，所以显示了一个错误。但基础数学告诉我们，如果 *x* 为正，*x* + 5 永远大于 0；如果 *x* 为负，它只有在某些情况下才大于 0。

所以，如果我们创建一个指定 positive=True 的 Symbol 对象，我们告诉 SymPy 只假设正值。现在它可以确定 *x* + 5 肯定大于 0：

>>> x = Symbol('x', positive=True)

>>> if (x+5) > 0:

print('做某事')

else:

print('做其他事情')

做某事

请注意，如果我们改为指定 negative=True，我们可能会遇到与第一个例子相同的错误。正如我们可以声明一个符号为正或负一样，也可以将其指定为实数、整数、复数、虚数等。这些声明在 SymPy 中被称为*假设*。

### **寻找函数的极限**

微积分中的一个常见任务是找到当变量的值趋近于某个特定值时，函数的*极限值*（或简称*极限*）。考虑一个函数 *f*(*x*) = 1/*x*，其图像如[图 7-2](ch07.html#ch7fig2)所示。

随着 *x* 的值增大，*f*(*x*) 的值接近 0。使用极限符号，我们可以写作：

![image](images/e0181-01.jpg)![image](images/f07-02.jpg)

*图 7-2：显示函数 1/*x* 随着 *x* 增大而变化的图形*

我们可以通过创建 Limit 类的对象来在 SymPy 中找到函数的极限，方法如下：

➊ >>> from sympy import Limit, Symbol, S

➋ >>> x = Symbol('x')

➌ >>> Limit(1/x, x, S.Infinity)

Limit(1/x, x, oo, dir='-')

在 ➊ 处，我们导入 Limit 和 Symbol 类，以及 S，这是一个特殊的 SymPy 类，包含无穷大（正负）及其他特殊值的定义。然后在 ➋ 处，我们创建一个符号对象 x 来表示 *x*。在 ➌ 处，我们创建 Limit 对象，传入三个参数：1/x、变量 x 和我们想要计算函数极限的值（无穷大，由 S.Infinity 给出）。

结果以*未求值*的对象形式返回，oo 符号表示正无穷大，dir='-' 符号指定我们是从负方向接近极限。

为了找到极限值，我们使用 doit() 方法：

>>> l = Limit(1/x, x, S.Infinity)

>>> l.doit()

0

默认情况下，极限是从正方向求得，除非计算极限的值是正无穷大或负无穷大。在正无穷大的情况下，方向是负的，反之亦然。你可以通过以下方式更改默认方向：

>>> Limit(1/x, x, 0, dir='-').doit()

-oo

这里，我们计算

![image](images/e0182-01.jpg)

当我们从负侧逼近 0 时，*x* 的极限值趋向负无穷。另一方面，如果我们从正侧逼近 0，极限值则趋向正无穷：

>>> Limit(1/x, x, 0, dir='+').doit()

oo

Limit 类也处理具有不定型极限的函数，

![image](images/e0182-02.jpg)

自动计算：

>>> 从 sympy 导入 Symbol, sin

>>> Limit(sin(x)/x, x, 0).doit()

1

你很可能已经使用了 l'Hôpital 法则来求解这样的极限，但正如我们在这里看到的，Limit 类会为我们处理这一问题。

#### ***连续复利***

假设你在银行存入了 1 美元。这笔存款就是 *本金*，它会支付给你 *利息*——在这种情况下，利率为 100%，并且每年复利计算 n 次，持续 1 年。你在 1 年结束时得到的金额由下式给出：

![image](images/e0183-01.jpg)

著名数学家詹姆斯·伯努利发现，当 *n* 的值增加时，(1 + 1/*n*)*^n* 这一项趋近于常数 *e*——我们可以通过计算该函数的极限来验证这一点：

>>> 从 sympy 导入 Limit, Symbol, S

>>> n = Symbol('n')

>>> Limit((1+1/n)**n, n, S.Infinity).doit()

E

对于任何本金 *p*、任何利率 *r* 和任何年数 *t*，复利可以通过以下公式计算：

![image](images/e0183-02.jpg)

假设是连续复利，我们可以按照以下方式找到 *A* 的表达式：

>>> 从 sympy 导入 Symbol, Limit, S

>>> p = Symbol('p', positive=True)

>>> r = Symbol('r', positive=True)

>>> t = Symbol('t', positive=True)

>>> Limit(p*(1+r/n)**(n*t), n, S.Infinity).doit()

p*exp(r*t)

我们创建三个符号对象，分别表示本金 *p*，利率 *r* 和年数 *t*。我们还通过传递 `positive=True` 关键字参数告诉 SymPy 这些符号将假定为正值。如果不指定，SymPy 将不知道这些符号可以假定的数值，因此可能无法正确计算极限。然后，我们将复利的表达式传入，创建 Limit 对象，并使用 `doit()` 方法进行求值。结果极限为 *p*exp(*r*t*)，这告诉我们，在固定利率下，复利随时间呈指数增长。

#### ***瞬时变化率***

考虑一辆沿道路行驶的汽车。它匀加速运动，使得所行驶的距离 *S* 可以通过以下函数表示：

*S*(*t*) = 5*t*² + 2*t* + 8。

在此函数中，自变量是 *t*，表示汽车开始运动后经过的时间。

如果我们在时间 *t*[1] 和时间 *t*[2]（其中 *t*[2] > *t*[1]）之间测量汽车行驶的距离，那么我们可以使用以下表达式计算汽车在 1 单位时间内行驶的距离：

![image](images/e0184-01.jpg)

这也称为函数 *S*(*t*) 相对于变量 *t* 的平均变化率，或者换句话说，平均速度。如果我们将 *t*[2] 写成 *t*[1] + *δ[t]*——其中 *δ[t]* 是 *t*[2] 和 *t*[1] 之间的时间差——我们可以将平均速度的表达式改写为：

![image](images/e0184-02.jpg)

这个表达式也是一个以 *t*[1] 为变量的函数。现在，如果我们进一步假设 *δ[t]* 很小，趋近于 0，我们可以使用极限符号将其写作：

![image](images/e0184-03.jpg)

我们现在将计算上述的极限。首先，我们来创建各种表达式对象：

>>> from sympy import Symbol, Limit

>>> t = Symbol('t')

➊ >>> St = 5*t**2 + 2*t + 8

>>> t1 = Symbol('t1')

>>> delta_t = Symbol('delta_t')

➋ >>> St1 = St.subs({t: t1})

➌ >>> St1_delta = St.subs({t: t1 + delta_t})

我们首先在 ➊ 定义了函数 *S*(*t*)。然后，我们定义了两个符号，t1 和 delta_t，它们分别对应于 *t*[1] 和 *δ[t]*。使用 subs() 方法后，我们通过在 ➋ 和 ➌ 处将 t 替换为 t1 和 t1_delta_t 来找到 *S*(*t*[1]) 和 *S*(*t*[1] + *δ[t]*)。

现在，我们来计算这个极限：

>>> Limit((St1_delta-St1)/delta_t, delta_t, 0).doit()

10*t1 + 2

极限结果为 10*t1 + 2，它是 *S*(*t*) 在时刻 t1 处的变化率，或者说是瞬时变化率。这个变化通常称为汽车在时刻 t1 的 *瞬时速度*。

我们在这里计算的极限称为函数的 *导数*，我们可以直接使用 SymPy 的 Derivative 类来计算它。

### **求函数的导数**

函数 *y* = *f*(*x*) 的导数表示因变量 *y* 相对于自变量 *x* 的变化率。它通常表示为 *f*′(*x*) 或 *dy*/*dx*。我们可以通过创建 Derivative 类的对象来求函数的导数。我们以之前表示汽车运动的函数为例：

➊ >>> from sympy import Symbol, Derivative

>>> t = Symbol('t')

>>> St = 5*t**2 + 2*t + 8

➋ >>> Derivative(St, t)

Derivative(5*t**2 + 2*t + 8, t)

我们在 ➊ 导入了 Derivative 类。在 ➋，我们创建了 Derivative 类的一个对象。创建该对象时传入的两个参数是函数 St 和符号 t，t 对应于变量 *t*。与 Limit 类一样，Derivatives 类的对象会被返回，导数并没有实际计算。我们调用未求值的 Derivative 对象的 doit() 方法来计算导数：

>>> d = Derivative(St, t)

>>> d.doit()

10*t + 2

导数的表达式为 10*t + 2。如果我们想计算某个特定值 *t*（比如 *t* = *t*[1] 或 *t* = 1）处的导数值，可以使用 subs() 方法：

>>> d.doit().subs({t:t1})

10*t1 + 2

>>> d.doit().subs({t:1})

12

让我们尝试一个复杂的任意函数，以*x*为唯一变量：(*x*³ + *x*² + *x*) × (*x*² + *x*)。

>>> from sympy import Derivative, Symbol

>>> x = Symbol('x')

>>> f = (x**3 + x**2 + x)*(x**2+x)

>>> Derivative(f, x).doit()

(2*x + 1)*(x**3 + x**2 + x) + (x**2 + x)*(3*x**2 + 2*x + 1)

你可以将此函数视为两个独立函数的乘积，这意味着，我们手动计算时需要使用求导的*乘积法则*。但在这里，我们不需要担心这些，因为我们可以直接创建一个Derivative类的对象来为我们完成这项工作。

尝试一些其他复杂的表达式，例如涉及三角函数的表达式。

#### ***一个求导计算器***

现在，让我们编写一个求导计算器程序，该程序接受一个函数作为输入，然后打印出对指定变量求导后的结果：

'''

求导计算器

'''

from sympy import Symbol, Derivative, sympify, pprint

from sympy.core.sympify import SympifyError

def derivative(f, var):

var = Symbol(var)

d = Derivative(f, var).doit()

pprint(d)

if __name__=='__main__':

➊     f = input('输入一个函数: ')

var = input('输入要进行求导的变量: ')

try:

➋         f = sympify(f)

except SympifyError:

print('无效的输入')

else:

➌         derivative(f, var)

在➊处，我们让用户输入一个需要求导的函数，然后让用户输入希望对其求导的变量。在➋处，我们使用sympify()函数将输入的函数转换为SymPy对象。我们在try...except块中调用该函数，以便在用户输入无效内容时显示错误信息。如果输入的表达式是有效的，我们会在➌处调用derivative函数，传入转换后的表达式和需要对其求导的变量作为参数。

在derivative()函数中，我们首先创建一个Symbol对象，表示需要对其进行求导的变量。我们使用标签var来引用这个变量。接下来，我们创建一个Derivative对象，并传入需要求导的函数和symbol对象var。然后，我们立即调用doit()方法来计算导数，最后使用pprint()函数打印结果，使其尽量与数学表达式相似。以下是程序的示例执行：

输入一个函数: 2*x**2 + 3*x + 1

输入要进行求导的变量: x

4·x + 3

这是一个针对双变量函数的示例运行：

输入一个函数: 2*x**2 + y**2

输入要进行求导的变量: x

4·x

#### ***计算偏导数***

在之前的程序中，我们看到通过导数类可以计算多变量函数对任意变量的导数。这种计算通常被称为*偏微分*，其中*偏*表示我们假设只有一个变量发生变化，而其他变量保持不变。

让我们考虑函数*f*（*x*，*y*）= 2*xy* + *xy*²。函数*f*（*x*，*y*）对*x*的偏微分为：

![image](images/e0187-01.jpg)

上面的程序能够找到偏导数，因为它只需要指定正确的变量：

输入函数：2*x*y + x*y**2

输入要计算导数的变量：x

y² + 2·y

**注意**

*我在本章中做出的一个关键假设是，我们正在计算导数的所有函数在各自的定义域内都是可微的。*

### **高阶导数和寻找极大值与极小值**

默认情况下，使用导数类创建导数对象会找到一阶导数。要找到高阶导数，只需在创建导数对象时将计算导数的阶数作为第三个参数传递即可。在这一节中，我将向你展示如何使用一阶和二阶导数来找到函数在区间上的最大值和最小值。

考虑函数*x*⁵ – 30*x*³ + 50*x*，定义在区间[–5, 5]上。注意，我使用方括号表示闭区间，这表示变量*x*可以取任意实数值，且该值大于或等于–5，小于或等于5（见[图 7-3](ch07.html#ch7fig3)）。

![image](images/f07-03.jpg)

*图 7-3: 函数*x*⁵ – 30*x*³* + *50*x*的图形，定义域为–5* ≤ x ≤ *5*

从图形中我们可以看到，函数在区间–2 ≤ *x* ≤ 0上取得最小值，在点*B*处。同样，在区间0 ≤ *x* ≤ 2上，函数在点*C*处取得最大值。另一方面，函数在我们所考虑的整个*x*定义域内分别在点*A*和*D*处取得最大值和最小值。因此，当我们考虑函数在整个区间[–5, 5]上的表现时，点*B*和*C*分别称为*局部最小值*和*局部最大值*，而点*A*和*D*分别是*全局最大值*和*全局最小值*。

*极值*（复数形式*极值点*）是指函数取得局部或全局最大值或最小值的点。如果* x *是函数*f*（*x*）的极值点，那么函数在* x *处的一阶导数*f*′（*x*）必须为零。这个性质表明，寻找可能的极值点的一个有效方法是尝试解方程*f*′（*x*） = 0\. 这些解称为函数的*临界点*。我们来尝试一下：

>>> from sympy import Symbol, solve, Derivative

>>> x = Symbol('x')

>>> f = x**5 - 30*x**3 + 50*x

>>> d1 = Derivative(f, x).doit()

现在，我们已经计算了函数的第一阶导数*f*′(*x*)，接下来我们将解*f*′(*x*) = 0来找到临界点：  

>>> critical_points = solve(d1)  

>>> critical_points  

[-sqrt(-sqrt(71) + 9), sqrt(-sqrt(71) + 9), -sqrt(sqrt(71) + 9),  

sqrt(sqrt(71) + 9)]  

列表critical_points中的数字对应于点*B*、*C*、*A*和*D*。我们将为这些点创建标签，然后可以在命令中使用这些标签：  

>>> A = critical_points[2]  

>>> B = critical_points[0]  

>>> C = critical_points[1]  

>>> D = critical_points[3]  

因为该函数的所有临界点都位于考虑的区间内，所以它们都与我们寻找*f*(*x*)的全局最大值和最小值相关。现在我们可以应用所谓的*二阶导数检验*来缩小哪些临界点可能是全局最大值或最小值。  

首先，我们计算函数*f*(*x*)的二阶导数。请注意，为此，我们需要将2作为第三个参数输入：  

>>> d2 = Derivative(f, x, 2).doit()  

现在，我们通过将每个临界点的值逐一代入二阶导数中来找到二阶导数的值。如果结果小于0，则该点为局部最大值；如果结果大于0，则为局部最小值。如果结果为0，则检验不确定，我们无法推断该临界点*x*是局部最小值、最大值，还是既不是。  

>>> d2.subs({x:B}).evalf()  

127.661060789073  

>>> d2.subs({x:C}).evalf()  

-127.661060789073  

>>> d2.subs({x:A}).evalf()  

-703.493179468151  

>>> d2.subs({x:D}).evalf()  

703.493179468151  

对临界点进行二阶导数检验的结果告诉我们，点*A*和*C*是局部最大值，点*B*和*D*是局部最小值。  

函数*f*(*x*)在区间[–5, 5]上的全局最大值和最小值要么出现在临界点*x*处，要么出现在区间端点（*x* = –5和*x* = 5）。我们已经找到了所有的临界点，即点*A*、*B*、*C*和*D*。由于点*A*和*C*是局部最大值，因此函数不能在这两个临界点处取得全局最小值。通过类似的逻辑，函数也不能在点*B*和*D*处取得全局最大值。  

因此，为了找到全局最大值，我们必须计算函数*f*(*x*)在点*A*、*C*、–5和5处的值。在这些点中，*f*(*x*)取得最大值的地方一定是全局最大值。  

我们将创建两个标签，x_min和x_max，用来表示区间的边界，并在点A、C、x_min和x_max处评估函数：

>>> x_min = -5  

>>> x_max = 5  

>>> f.subs({x:A}).evalf()  

705.959460380365  

>>> f.subs({x:C}).evalf()  

25.0846626340294  

>>> f.subs({x:x_min}).evalf()  

375.000000000000  

>>> f.subs({x:x_max}).evalf()  

-375.000000000000  

通过这些计算，以及检查所有临界点和定义域边界的函数值（[图7-3](ch07.html#ch7fig3)），我们可以看到，*A* 点是全局最大值。

同样，为了确定全局最小值，我们必须计算 *f*(*x*) 在点 *B*、*D*、–5 和 5 处的值：

>>> f.subs({x:B}).evalf()

-25.0846626340294

>>> f.subs({x:D}).evalf()

-705.959460380365

>>> f.subs({x:x_min}).evalf()

375.000000000000

>>> f.subs({x:x_max}).evalf()

-375.000000000000

函数 *f*(*x*) 的最小值点一定是该函数的全局最小值；这就是点 *D*。

这种通过考虑函数在所有临界点（可能通过二阶导数测试舍弃某些临界点）和边界值处的函数值来寻找极值的方法——只要函数是二阶可微的——总是有效的。也就是说，函数的一阶和二阶导数必须在定义域的每个点上都存在。

对于像 *e^x* 这样的函数，可能在定义域内没有任何临界点，但在这种情况下，方法仍然有效：它只是告诉我们，极值发生在定义域的边界处。

### **使用梯度上升法找到全局最大值**

有时候，我们只关心找到函数的全局最大值，而不是所有的局部和全局最大值与最小值。例如，我们可能想知道一个球的投射角度，使得它能覆盖最大水平距离。我们将学习一种新的、更实用的方法来解决这样的问题。这种方法仅使用一阶导数，因此只适用于可以计算一阶导数的函数。

这种方法叫做 *梯度上升法*，它是一种迭代求解全局最大值的方法。由于梯度上升法涉及大量计算，因此它是通过编程来解决的理想方法，而不是手工计算。让我们尝试使用找出投射角度的例子问题。在[第2章](ch02.html#ch02)中，我们推导了这个表达式：

![image](images/e0191-01.jpg)

用于计算在投射运动中，物体以速度 *u* 和角度 *θ* 被抛出的飞行时间。一个抛体的*射程*，*R*，是抛体所走的总水平距离，由 *u[x] × t*[flight] 的乘积给出。这里，*u[x]* 是初速度的水平分量，等于 *u* cos*θ*。将 *u[x]* 和 *t*[flight] 的公式代入，我们得到以下表达式：

![image](images/e0191-02.jpg)

[图7-4](ch07.html#ch7fig4)中的图像显示了*θ*在0到90度之间的值及对应的范围（行进距离）。从图中可以看出，最大范围出现在投射角度约为45度时。接下来，我们将学习使用梯度上升法来数值求解这个*θ*值。

![image](images/f07-04.jpg)

*图 7-4：以25 m/s的初速度投射的抛射物，在不同投射角度下的射程*

梯度上升法是一种迭代方法：我们从*θ*的初始值开始——例如，0.001，或者*θ*[old] = 0.001——并逐渐接近对应于最大范围的*θ*值（[图 7-5](ch07.html#ch7fig5)）。使我们逐步接近的步骤是：

![image](images/e0192-01.jpg)

其中*λ*是*步长*，并且

![image](images/e0192-02.jpg)

是*R*对*θ*的导数。一旦我们设定*θ*[old] = 0.001，我们执行以下步骤：

1\. 使用上述方程计算*θ*[new]。

2\. 如果*θ*[new] – *θ*[old]的绝对差值大于某个值*ε*，我们设定*θ*[old] = *θ*[new]，然后返回第1步。否则，进入第3步。

3\. *θ*[new]是*θ*的一个近似值，使得*R*达到最大值。

*epsilon*（*ε*）的值决定了我们何时停止算法的迭代。在“[步长和epsilon的作用](ch07.html#ch07lev2sec09)”中会有更详细的讨论，见[第197页](ch07.html#page_197)。

![image](images/f07-05.jpg)

*图 7-5：梯度上升法逐步逼近函数的最大点。*

以下grad_ascent()函数实现了梯度上升算法。参数x0是开始迭代的变量初始值，f1x是我们要寻找最大值的函数的导数，x是与该函数变量对应的Symbol对象。

'''

使用梯度上升法找到使抛射物

对于固定速度，25 m/s下，*R*具有最大射程

'''

import math

from sympy import Derivative, Symbol, sin

def grad_ascent(x0, f1x, x):

➊     epsilon = 1e-6

➋     step_size = 1e-4

➌     x_old = x0

➍     x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()

➎     while abs(x_old - x_new) > epsilon:

x_old = x_new

x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()

return x_new

➏ def find_max_theta(R, theta):

# 计算一阶导数

R1theta = Derivative(R, theta).doit()

theta0 = 1e-3

theta_max = grad_ascent(theta0, R1theta, theta)

➐     return theta_max

if __name__ == '__main__':

g = 9.8

# 假设初速度

u = 25

# 范围公式

theta = Symbol('theta')

➑     R = u**2*sin(2*theta)/g

➒     theta_max = find_max_theta(R, theta)

print('Theta: {0}'.format(math.degrees(theta_max)))

print('最大射程: {0}'.format(R.subs({theta:theta_max})))

我们在➊和➋分别设定了epsilon值为1e-6，步长为1e-4。epsilon值必须始终是非常小的正数，接近0，步长应选择为使变量在每次迭代时增量较小。epsilon值和步长的选择将在“[步长和epsilon的作用](ch07.html#ch07lev2sec09)”中更详细讨论，见[第197页](ch07.html#page_197)。

我们在➌将x_old设为x0，并在➍第一次计算x_new。我们使用subs()方法将x_old的值代入变量中，然后使用evalf()计算数值。如果绝对差值abs(x_old – x_new)大于epsilon，while循环会在➎继续执行，我们会根据梯度上升算法的第1步和第2步更新x_old和x_new的值。一旦我们跳出循环——也就是abs(x_old – x_new)小于epsilon——我们返回x_new，即对应最大函数值的变量值。  

我们在➏定义了find_max_theta()函数。在这个函数中，我们计算R的一阶导数；创建一个标签theta0，并将其设为1e-3；然后调用grad_ascent()函数，并将这两个值作为参数，同时传入第三个参数，即符号对象theta。一旦我们得到对应最大函数值的*θ*（theta_max），我们会在➐返回它。  

最后，我们在➑创建了表示水平范围的表达式，初始速度u = 25，并设定了对应角度*θ*的符号对象theta。然后我们用R和theta调用find_max_theta()函数，在➒处。  

当你运行这个程序时，你应该会看到以下输出：  

Theta: 44.99999978475661  

最大范围: 63.7755102040816  

*θ*的值以度为单位打印，结果接近45度，符合预期。如果你改变初速度的值，你会发现达到最大范围的投射角始终接近45度。

#### ***梯度上升的通用程序***  

我们可以稍微修改前面的程序，制作一个通用的梯度上升程序：  

'''  

使用梯度上升法找到a的最大值  

单变量函数  

'''  

from sympy import Derivative, Symbol, sympify  

def grad_ascent(x0, f1x, x):  

epsilon = 1e-6  

step_size = 1e-4  

x_old = x0  

x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()  

while abs(x_old - x_new) > epsilon:  

x_old = x_new  

x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()  

return x_new  

if __name__ == '__main__':  

f = input('请输入一个单变量函数：')  

var = input('请输入要进行微分的变量：')  

var0 = float(input('请输入变量的初始值：'))  

try:  

f = sympify(f)  

except SympifyError:  

print('无效的函数输入')  

else:  

➊         var = Symbol(var)  

➋         d = Derivative(f, var).doit()  

➌         var_max = grad_ascent(var0, d, var)  

print('{0}: {1}'.format(var.name, var_max))  

print('最大值: {0}'.format(f.subs({var:var_max})))  

函数grad_ascent()在这里保持不变。然而，现在程序要求用户输入函数、函数中的变量以及变量的初始值，梯度上升将从这个初始值开始。一旦我们确认SymPy能够识别用户的输入，我们创建一个与变量对应的Symbol对象（➊），求出关于该变量的一阶导数（➋），并使用这三个参数调用grad_ascent()函数。最大值在➌处返回。

这是一个示例运行：

输入一个单变量函数：25*25*sin(2*theta)/9.8

输入要进行求导的变量：theta

输入变量的初始值：0.001

theta：0.785360029379083

最大值：63.7755100185965

这里输入的函数与我们第一次实现梯度上升时相同，*θ*的值以弧度形式打印。

这是程序的另一次运行，它将找到cos*y*的最大值：

输入一个单变量函数：cos(y)

输入要进行求导的变量：y

输入变量的初始值：0.01

y：0.00999900001666658

最大值：0.999950010415832

该程序对像cos(y) + k这样的函数也能正常工作，其中k是一个常数：

输入一个单变量函数：cos(y) + k

输入要进行求导的变量：y

输入变量的初始值：0.01

y：0.00999900001666658

最大值：k + 0.999950010415832

然而，像cos(ky)这样的函数不起作用，因为它的一阶导数kcos(ky)仍然包含k，而SymPy并不知道k的值。因此，SymPy无法执行梯度上升算法中的关键步骤——即比较abs(x_old - x_new) > epsilon。

#### ***关于初始值的警告***

我们开始梯度上升法迭代的变量初始值在算法中起着非常重要的作用。考虑函数*x*⁵ – 30*x*³ + 50*x*，我们在[图7-3](ch07.html#ch7fig3)中使用了这个例子。让我们使用通用的梯度上升程序来找到最大值：

输入一个单变量函数：x**5 - 30*x**3 + 50*x

输入要进行求导的变量：x

输入变量的初始值：-2

x：-4.17445116397103

最大值：705.959460322318

梯度上升算法在找到*最接近的峰值*时停止，这并不总是全局最大值。在这个例子中，当你从初始值-2开始时，它停在了对应于全局最大值（约706）的峰值上。为了进一步验证这一点，我们尝试使用不同的初始值：

输入一个单变量函数：x**5 - 30*x**3 + 50*x

输入要进行求导的变量：x

输入变量的初始值：0.5

x：0.757452532565767

最大值：25.0846622605419

在这种情况下，梯度上升算法停止的最近峰值并不是函数的真正全局最大值。[图 7-6](ch07.html#ch7fig6) 描述了这两种情况的梯度上升算法结果。

![image](images/f07-06.jpg)

*图 7-6：使用不同初始值的梯度上升算法结果。梯度上升总是将我们带到最近的峰值。*

因此，在使用此方法时，初始值必须谨慎选择。算法的一些变体试图解决这个限制。

#### ***步长和 Epsilon 的作用***

在梯度上升算法中，下一步的变量值是通过以下方程计算的

![image](images/e0197-01.jpg)

其中 *λ* 是 *步长*。步长决定了下一步的距离。它应该足够小，以避免“越过”一个峰值。也就是说，如果当前的 *x* 值接近于对应于函数最大值的 *x* 值，那么下一步不应超过这个峰值，否则算法将失败。另一方面，过小的步长会导致计算时间更长。我们使用了固定的步长 10^(–3)，但这可能*不是*所有函数的最合适值。

决定何时停止算法迭代的 epsilon (*ε*) 值应该是一个足够小的值，以便我们可以确信 *x* 的值不再变化。我们期望在最大值点，*f*′(*x*) 的导数为 0，理想情况下，绝对差值 |*θ*[new] – *θ*[old]| 应为 0（请参见 [第192页](ch07.html#page_192)的梯度上升算法的第二步）。然而，由于数值不准确，我们可能无法精确得到 0 的差值；因此，选择一个接近 0 的 epsilon 值，这个值在实际应用中能够告诉我们 *x* 的值已经不再变化。我使用了 10^(–6) 作为所有函数的 epsilon 值。这个值虽然足够小，并且适用于那些在 *f*′(*x*) = 0 下有解的函数，比如 sin(x)，但对于其他函数，这个值可能不是最合适的。因此，验证最终的最大值以确保其正确性是个好主意，并且如果需要，可以相应调整 epsilon 的值。

梯度上升算法的第二步还意味着，为了使算法终止，方程 *f*′(*x*) = 0 必须有解，而像 *e^x* 或 log(*x*) 这样的函数则没有解。因此，如果你将这些函数之一作为输入提供给前面的程序，程序将无法给出解，并将继续运行。我们可以通过加入检查 *f*′(*x*) = 0 是否有解来使梯度上升程序在这种情况下更加实用。以下是修改后的程序：

'''

使用梯度上升法寻找 a 的最大值

单变量函数。这个过程也检查是否存在

对于方程 f'(x)=0 的解

'''

from sympy import Derivative, Symbol, sympify, solve

def grad_ascent(x0, f1x, x):

# 检查 f1x=0 是否有解

➊     如果 not solve(f1x):

print('无法继续，{0}=0 的解不存在'.format(f1x))

return

epsilon = 1e-6

step_size = 1e-4

x_old = x0

x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()

while abs(x_old - x_new) > epsilon:

x_old = x_new

x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()

return x_new

if __name__ == '__main__':

f = input('请输入一个单变量函数：')

var = input('请输入需要对其求导的变量：')

var0 = float(input('请输入变量的初始值：'))

try:

f = sympify(f)

except SympifyError:

print('输入的函数无效')

else:

var = Symbol(var)

d = 导数(f, var).doit()

var_max = grad_ascent(var0, d, var)

➋         如果 var_max:

print('{0}: {1}'.format(var.name, var_max))

print('最大值：{0}'.format(f.subs({var:var_max})))

在 grad_ascent() 函数的这个修改中，我们在 ➊ 调用 SymPy 的 solve() 函数来判断方程 *f*′(*x*) = 0（这里是 f1x）是否有解。如果没有解，我们打印一条信息并返回。另一个修改出现在 __main__ 块的 ➋。我们检查 grad_ascent() 函数是否成功返回结果；如果成功，则继续打印函数的最大值和相应的变量值。

这些改动使得程序能够处理诸如 log(*x*) 和 *e^x* 这样的函数：

输入一个单变量函数：log(x)

输入需要对其求导的变量：x

输入变量的初始值：0.1

无法继续，1/x=0 的解不存在

你将看到相同的结果，*e^x*。

**梯度下降算法**

梯度上升算法的逆算法是梯度*下降*算法，它是一种找到函数最小值的方法。它与梯度上升算法类似，不同之处在于，我们不是沿着函数“向上爬”，而是“向下爬”。[第205页](ch07.html#page_205)的挑战#2讨论了这两种算法的区别，并给你提供了实现逆算法的机会。

### **寻找函数的积分**

函数 *f*(*x*) 的*不定积分*，或称为*反导数*，是另一个函数 *F*(*x*)，使得 *F*′(*x*) = *f*(*x*)。也就是说，函数的积分是另一个函数，它的导数就是原函数。数学上表示为 *F*(*x*) = ∫ *f*(*x*)*dx*。而*定积分*则是函数的积分，

![image](images/e0200-01.jpg)

这实际上是 *F*(*b*) – *F*(*a*)，其中 *F*(*b*) 和 *F*(*a*) 是该函数在 *x* = *b* 和 *x* = *a* 时的反导数值。我们可以通过创建一个积分对象来求解这两个积分。

这是我们如何找到积分 ∫ *kxdx*，其中 *k* 是常数项：

>>> from sympy import Integral, Symbol

>>> x = Symbol('x')

>>> k = Symbol('k')

>>> 积分(k*x, x)

积分(k*x, x)

我们导入Integral和Symbol类，并创建两个Symbol对象，分别对应于k和x。然后，我们使用函数kx创建一个积分对象，指定按x进行积分。类似于Limit和Derivative类，我们现在可以使用doit()方法计算积分：

>>> Integral(k*x, x).doit()

k*x**2/2

积分的结果是*kx*²/2。如果你计算*kx*²/2的导数，你将得到原始函数*kx*。

要计算*定积分*，我们只需在创建积分对象时指定变量、下限和上限作为一个元组：

>>> Integral(k*x, (x, 0, 2)).doit()

2*k

返回的结果是定积分

![image](images/e0200-02.jpg)

通过在几何上下文中讨论定积分，直观地理解它们是很有帮助的。考虑[图7-7](ch07.html#ch7fig7)，它展示了函数*f*(*x*) = *x*在*x* = 0和*x* = 5之间的图形。

现在考虑图形*ABDE*下的区域，该区域被*x*-轴以及点*x* = 2和*x* = 4——分别是点*A*和*B*——所界定。该区域的面积可以通过将平方区域*ABCE*的面积与直角三角形*ECD*的面积相加来计算，面积为2 × 2 + (1/2) × 2 × 2 = 6。

![image](images/f07-07.jpg)

*图7-7：在两个点之间的定积分是由该函数的图形与*x*-轴围成的面积。*

现在我们来计算积分！[image](images/e0201-01.jpg)：

>>> from sympy import Integral, Symbol

>>> x = Symbol('x')

>>> Integral(x, (x, 2, 4)).doit()

6

积分的值恰好等于区域*ABDE*的面积。这并非偶然；你会发现对于任何可以确定积分的函数*f*(*x*)，这一点都是成立的。

理解定积分是由指定点之间的函数图形与*x*-轴围成的区域所组成的面积，这对于理解涉及连续随机变量的随机事件中的概率计算至关重要。

### **概率密度函数**

让我们考虑一个虚拟的学生班级及其数学测验成绩。每个学生可以获得0到20之间的成绩，包括分数。如果我们将成绩视为一个随机事件，则成绩本身是一个*连续随机变量*，因为它可以在0到20之间取*任何*值。如果我们想要计算一个学生获得11到12之间成绩的概率，我们不能应用在[第5章](ch05.html#ch05)中学到的策略。为了理解为什么，我们来看看公式，假设均匀概率，

![image](images/e0202-01.jpg)

其中，*E*是11到12之间所有可能分数的集合，*S*是所有可能分数的集合——即1到20之间的所有实数。根据我们对前述问题的定义，*n*(*E*)是无限的，因为不可能数出11到12之间所有可能的实数；*n*(*S*)也同样如此。因此，我们需要采用不同的方法来计算概率。

一个 *概率密度函数*，*P*(*x*)，表示随机变量的值接近 *x* 的概率，即某个任意值。[¹](footnote.html#fn05) 它还可以告诉我们 *x* 落在某个区间内的概率。也就是说，如果我们知道表示我们虚构班级成绩概率的概率密度函数，计算 *P*(11 < *x* < 12) 就能给出我们所寻找的概率。那么，我们该如何计算呢？事实证明，这个概率就是概率密度函数图形与 *x* 轴之间，在 *x* = 11 和 *x* = 12 之间的面积。假设一个任意的概率密度函数，[图 7-8](ch07.html#ch7fig8) 展示了这一点。

![image](images/f07-08.jpg)

*图 7-8：数学小测验成绩的概率密度函数*

我们已经知道，这个面积等于积分的值，

![image](images/e0203-01.jpg)

因此，我们有了一种简单的方法来计算成绩位于 11 和 12 之间的概率。计算完成后，我们可以得出所需的概率。我们之前假设的概率密度函数是

![image](images/e0203-02.jpg)

其中 *x* 是获得的成绩。这个函数的选择是为了使得成绩接近 10（无论是大于还是小于）的概率较高，但随后迅速下降。

现在，让我们计算积分

![image](images/e0203-03.jpg)

其中 *p*(*x*) 是前面提到的函数：

>>> from sympy import Symbol, exp, sqrt, pi, Integral

>>> x = Symbol('x')

>>> p = exp(-(x - 10)**2/2)/sqrt(2*pi)

>>> Integral(p, (x, 11, 12)).doit().evalf()

0.135905121983278

我们为该函数创建了积分对象，其中 p 表示概率密度函数，指定我们要计算 *x* 轴上 11 到 12 之间的定积分。我们使用 doit() 评估该函数，并使用 evalf() 找到数值结果。因此，成绩位于 11 和 12 之间的概率接近 0.14。

**概率密度函数：一个警告**

严格来说，这个密度函数会对小于 0 或大于 20 的成绩分配一个非零的概率。然而，正如你可以通过本节的概念所验证的那样，这样的事件概率非常小，可以忽略不计。

一个概率密度函数有两个特殊性质：（1）对于任何 *x*，函数值总是大于 0，因为概率不能小于 0；（2）定积分的值

![image](images/e0204-01.jpg)

等于 1。第二个性质值得讨论。因为 *p*(*x*) 是一个概率密度函数，它所围成的面积也是积分的值。

![image](images/e0204-02.jpg)

在任何两个点之间，*x* = *a* 和 *x* = *b*，给出了 *x* 在 *x* = *a* 和 *x* = *b* 之间的概率。这也意味着，无论 *a* 和 *b* 的值是多少，积分的值都不能超过1，因为根据定义，概率不能大于1。因此，即使 *a* 和 *b* 是非常大的值，趋向于 –∞ 和 ∞，积分的值仍然是1，正如我们自己可以验证的那样：

>>> from sympy import Symbol, exp, sqrt, pi, Integral, S

>>> x = Symbol('x')

>>> p = exp(-(x – 10)**2/2)/sqrt(2*pi)

>>> Integral(p, (x, S.NegativeInfinity, S.Infinity)).doit().evalf()

1.00000000000000

S.NegativeInfinity和S.Infinity分别表示我们在创建积分对象时指定的负无穷和正无穷的下限和上限。

当我们处理连续随机变量时，可能会遇到一些棘手的情况。在离散概率中，像掷一个公平的六面骰子得到7这样的事件概率是0。我们称概率为0的事件为*不可能*事件。在连续随机变量的情况下，尽管某个特定值可能是*可能*的事件，但变量取得该值的概率是0。例如，学生成绩恰好为11.5是可能的，但由于连续随机变量的性质，概率为0。要理解为什么，考虑概率是积分的值

![image](images/e0204-03.jpg)

因为这个积分的上下限相同，所以它的值是0。这是相当不直观和自相矛盾的，因此让我们试着理解它。

考虑我们之前讨论的成绩范围——0到20。学生可以获得的成绩是这个区间内的任意数字，这意味着有无限多个数字。如果每个数字的选择概率相等，那么这个概率是多少呢？根据离散概率公式，这应该是1/∞，也就是说，这是一个非常小的数字。事实上，这个数字小到在实际应用中可以视为0。因此，成绩为11.5的概率是0。

### **你学到了什么**

在本章中，你学会了如何找到函数的极限、导数和积分。你了解了用于寻找函数最大值的梯度上升法，并看到如何应用积分原理来计算连续随机变量的概率。接下来，你有几个任务可以尝试。

### **编程挑战**

以下挑战基于你在本章中学到的内容。你可以在*[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*找到示例解答。

#### ***#1：验证函数在某点的连续性***

一个函数在某点可微的必要条件是它必须在该点连续。也就是说，函数必须在该点定义，并且其左极限和右极限必须存在且等于该点的函数值。如果 *f*(*x*) 是函数，且 *x* = *a* 是我们感兴趣的评价点，那么可以数学地表示为

![image](images/e0205-01.jpg)

你的挑战是编写一个程序，该程序将（1）接受一个单变量函数和该变量的值作为输入，并（2）检查输入的函数在变量取值时是否连续。

这是完成解法的一个示例：

输入一个单变量函数：1/x

输入变量：x

输入要检查连续性的点：1

1/x 在 1.0 处是连续的

函数 1/*x* 在 0 处是间断的，所以我们来检查一下：

输入一个单变量函数：1/x

输入变量：x

输入要检查连续性的点：0

1/x 在 0.0 处不是连续的

#### ***#2：实现梯度下降***

梯度下降法用于寻找函数的最小值。与梯度上升法类似，梯度下降法是一种迭代方法：我们从变量的初始值开始，逐渐接近对应于函数最小值的变量值。让我们更接近的步骤是方程

![image](images/e0206-01.jpg)

其中 *λ* 是步长，且

![image](images/e0206-02.jpg)

是函数的导数结果。因此，与梯度上升法的唯一区别是如何通过 x_new 从 x_old 获取值。

你的挑战是使用梯度下降算法实现一个通用程序，找到用户输入的单变量函数的最小值。程序还应该创建该函数的图形，并显示在找到最小值之前它找到的所有中间值。（你可能需要参考[图 7-5](ch07.html#ch7fig5)，在[第 193 页](ch07.html#page_193)。）

#### ***#3：两曲线之间的面积***

我们学到，积分

![image](images/e0206-03.jpg)

表示由函数 *f*(*x*) 和 *x* 轴围成的区域，在 *x* = *a* 和 *x* = *b* 之间。因此，两个曲线之间的面积表示为积分

![image](images/e0206-04.jpg)

其中 *a* 和 *b* 是两条曲线的交点，且 *a* < *b*。函数 *f*(*x*) 称为 *上函数*，*g*(*x*) 称为 *下函数*。[图 7-9](ch07.html#ch7fig9) 说明了这一点，假设 *f*(*x*) = *x* 且 *g*(*x*) = *x*²，且 *a* = 0 和 *b* = 1。

你的挑战是编写一个程序，允许用户输入任何两个单变量的 *x* 函数，并打印出它们之间的包围面积。程序应该明确指出，首先输入的函数应该是上函数，并且还应询问 *x* 的取值范围，来计算该区域的面积。

![image](images/f07-09.jpg)

*图 7-9：函数* f*(*x*) =* x 和* g*(*x*) =* x*² 在* x = *0 和* x = *1.0* 之间包围了一个区域。*

#### ***#4：求曲线长度***

假设你刚刚完成了沿着一条大致如[图 7-10](ch07.html#ch7fig10)所示的道路骑行。由于你没有里程表，你希望知道是否有一种数学方法来确定你骑行的距离。首先，我们需要找到一个方程——即使是一个近似的方程——来描述这条路径。

![image](images/f07-10.jpg)

*图 7-10：骑行路径的近似图*

注意它看起来和我们在前面章节讨论的二次函数非常相似吗？实际上，对于这个挑战，我们假设方程是 *y* = *f*(*x*) = 2*x*² + 3*x* + 1，且你从点 *A* (–5, 36) 骑行到点 *B* (10, 231)。为了找到这个弧线的长度——也就是你骑行的距离——我们需要计算积分。

![image](images/e0208-01.jpg)

其中 *y* 描述了前面的函数。你的挑战是编写一个程序来计算弧长 *AB*。

你也许还希望将你的解决方案推广，使其可以用来计算任意两个点之间任意函数 *f*(*x*) 的弧长。
