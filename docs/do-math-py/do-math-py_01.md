## **1**

**与数字的操作**

![image](images/common-01.jpg)

让我们迈出第一步，利用 Python 探索数学和科学的世界。现在我们保持简单，帮助你掌握如何使用 Python。本节我们将从执行基本的数学运算开始，然后编写简单的程序来处理和理解数字。让我们开始吧！

### **基本数学运算**

*Python 交互式 shell* 将是我们在本书中的好伙伴。启动 Python 3 IDLE shell，并通过输入 print('Hello IDLE') 然后按下 ENTER 来打个“招呼”（见 [图 1-1](ch01.html#ch1fig1)）。(有关如何安装 Python 和启动 IDLE 的说明，请参见 [附录 A](app01.html#app01)。) IDLE 会按照你的命令操作，并将文字输出到屏幕上。恭喜你——你刚刚写了一个程序！

当你再次看到 >>> 提示符时，IDLE 已准备好接收更多指令。

![image](images/f01-01.jpg)

*图 1-1：Python 3 IDLE shell*

Python 可以像一个增强版的计算器一样进行简单的计算。只需输入表达式，Python 会对其进行求值。按下 ENTER 后，结果会立即显示出来。

试试看。你可以使用加法（+）和减法（–）运算符来加减数字。例如：

>>> 1 + 2

3

>>> 1 + 3.5

4.5

>>> -1 + 2.5

1.5

>>> 100 – 45

55

>>> -1.1 + 5

3.9

要进行乘法运算，请使用乘法（*）运算符：

>>> 3 * 2

6

>>> 3.5 * 1.5

5.25

要进行除法运算，请使用除法（/）运算符：

>>> 3 / 2

1.5

>>> 4 / 2

2.0

如你所见，当你让 Python 执行除法运算时，它会返回数字的分数部分。如果你希望结果是整数形式，去除任何小数值，你应该使用地板除法（//）运算符：

>>> 3 // 2

1

地板除法运算符将第一个数字除以第二个数字，然后将结果向下舍入到最接近的整数。当其中一个数字是负数时，这个操作就变得有趣。例如：

>>> -3 // 2

-2

最终结果是小于除法运算结果的整数（-3/2 = -1.5，因此最终结果为 -2）。

另一方面，如果你只想要余数，你应该使用取模（%）运算符：

>>> 9 % 2

1

你可以使用指数（**）运算符来计算数字的幂。下面的例子说明了这一点：

>>> 2 ** 2

4

>>> 2 ** 10

1024

>>> 1 ** 10

1

我们也可以使用指数符号来计算小于 1 的幂。例如，一个数字 *n* 的平方根可以表示为 *n*^(1/2)，立方根可以表示为 *n*^(1/3)：

>>> 8 ** (1/3)

2.0

如这个例子所示，你可以使用括号将多个数学运算结合成更复杂的表达式。Python 会按照标准的 *PEMDAS* 规则评估表达式中的计算顺序——括号、指数、乘法、除法、加法和减法。请看以下两个表达式——一个没有括号，另一个有括号：

>>> 5 + 5 * 5

30

>>> (5 + 5) * 5

50

在第一个例子中，Python 首先计算乘法：5 乘以 5 得到 25；25 加上 5 得到 30。在第二个例子中，括号内的表达式首先被计算，正如我们预期的那样：5 加上 5 得到 10；10 乘以 5 得到 50。

这些是 Python 中操作数字的基本知识。接下来我们来学习如何为数字赋予名称。

### **标签：为数字附加名称**

当我们开始设计更复杂的 Python 程序时，我们会为数字赋予名称——有时是为了方便，但更多的是出于必要。这里有一个简单的例子：

➊ >>> a = 3

>>> a + 1

4

➋ >>> a = 5

>>> a + 1

6

在 ➊ 处，我们将数字 3 赋予名称 a。当我们要求 Python 计算表达式 a + 1 的结果时，它看到 a 所指向的数字是 3，然后它加上 1 并显示输出（4）。在 ➋ 处，我们将 a 的值改为 5，这个变化反映在第二次加法操作中。使用名称 a 很方便，因为你可以简单地改变 a 所指向的数字，之后在任何地方引用 a 时，Python 会使用这个新值。

这种名称叫做*标签*。你可能在其他地方接触过术语*变量*来描述这个概念。然而，考虑到*变量*也是一个数学术语（用来指代像方程式 *x* + 2 = 3 中的 *x* 这样的东西），在本书中我只在数学方程和表达式的上下文中使用“变量”一词。

### **不同种类的数字**

你可能注意到，我使用了两种不同的数字来演示数学运算——没有小数点的数字，你已经知道它们是*整数*，以及带有小数点的数字，程序员称之为*浮动点数*。我们人类在识别和操作数字时没有任何问题，无论它们是以整数、浮动小数、分数还是罗马数字的形式出现。但在我们编写的某些程序中，只有对特定类型的数字执行任务才有意义，因此我们经常需要写一些代码，检查输入的数字是否属于正确的类型。

Python 将整数和浮动点数视为不同的*类型*。如果你使用 type() 函数，Python 会告诉你你刚刚输入的是什么类型的数字。例如：

>>> type(3)

<class 'int'>

>>> type(3.5)

<class 'float'>

>>> type(3.0)

<class 'float'>

在这里，你可以看到 Python 将数字 3 分类为整数（类型为 'int'），但将 3.0 分类为浮动点数（类型为 'float'）。我们都知道 3 和 3.0 在数学上是等价的，但在许多情况下，Python 会将这两个数字视为不同的类型，因此它们会被不同对待。

本章中我们编写的一些程序只有在输入为整数时才能正常工作。正如我们刚才看到的，Python 不会将像 1.0 或 4.0 这样的数字识别为整数，因此如果我们希望在这些程序中接受这样的数字作为有效输入，我们就需要将它们从浮点数转换为整数。幸运的是，Python 内置了一个函数可以做到这一点：

>>> int(3.8)

3

>>> int(3.0)

3

int() 函数将输入的浮点数去除小数点后的部分，并返回结果整数。float() 函数类似，执行反向转换：

>>> float(3)

3.0

float() 函数接收输入的整数并加上小数点，将其转换为浮点数。

#### ***处理分数***

Python 也能处理分数，但为此我们需要使用 Python 的 fractions 模块。你可以把 *模块* 想象成一个由其他人编写的程序，能够在你自己的程序中使用。模块可以包含类、函数，甚至标签定义。它可以是 Python 标准库的一部分，也可以是从第三方位置分发的。在后一种情况下，你需要在使用之前先安装这个模块。

fractions 模块是 Python 标准库的一部分，这意味着它已经安装好。它定义了一个 Fraction 类，我们将用它来将分数输入到我们的程序中。在使用之前，我们需要 *导入* 它，这是告诉 Python 我们想使用这个模块中的类。我们来看一个快速示例——我们将创建一个新的标签 f，它代表分数 3/4：

➊ >>> from fractions import Fraction

➋ >>> f = Fraction(3, 4)

➌ >>> f

Fraction(3, 4)

我们首先从 fractions 模块导入 Fraction 类 ➊。接下来，我们通过传入分子和分母作为参数 ➋ 来创建该类的对象。这将创建一个表示分数 3/4 的 Fraction 对象。当我们打印该对象 ➌ 时，Python 以 Fraction(分子, 分母) 的形式显示该分数。

基本的数学运算，包括比较运算，都适用于分数。你也可以在一个表达式中结合分数、整数和浮点数：

>>> Fraction(3, 4) + 1 + 1.5

3.25

当表达式中有浮点数时，表达式的结果将以浮点数形式返回。

另一方面，当表达式中只有分数和整数时，结果将是分数，即使结果的分母为 1。

>>> Fraction(3, 4) + 1 + Fraction(1/4)

Fraction(2, 1)

现在你已经了解了在 Python 中处理分数的基本知识。接下来，我们将转向另一种类型的数字。

#### ***复数***

到目前为止，我们看到的数字是所谓的*实数*。Python 还支持*复数*，其中虚部由字母*j*或*J*表示（与数学符号中使用的字母*i*不同）。例如，复数 2 + 3*i* 在 Python 中写作 2 + 3*j*：

>>> a = 2 + 3j

>>> type(a)

<class 'complex'>

如你所见，当我们对一个复数使用 type() 函数时，Python 告诉我们这是一个 complex 类型的对象。

你还可以使用 complex() 函数定义复数：

>>> a = complex(2, 3)

>>> a

(2 + 3j)

在这里，我们将复数的实部和虚部作为两个参数传递给 complex() 函数，函数返回一个复数。

你可以像对待实数一样加减复数：

>>> b = 3 + 3j

>>> a + b

(5 + 6j)

>>> a - b

(-1 + 0j)

复数的乘法和除法也是类似进行的：

>>> a * b

(-3 + 15j)

>>> a / b

(0.8333333333333334 + 0.16666666666666666j)

对复数而言，取余（%）和整除（//）操作无效。

可以通过复数的 real 和 imag 属性获取复数的实部和虚部，如下所示：

>>> z = 2 + 3j

>>> z.real

2.0

>>> z.imag

3.0

复数的*共轭*具有相同的实部，但虚部的大小相同且符号相反。可以使用 conjugate() 方法获得共轭复数：

>>> z.conjugate()

(2 - 3j)

实部和虚部都是浮动小数。使用实部和虚部，你可以使用以下公式计算复数的*模*，其中*x*和*y*分别是复数的实部和虚部：![image](images/e0007-01.jpg)。在 Python 中，写法如下：

>>> (z.real ** 2 + z.imag ** 2) ** 0.5

3.605551275463989

计算复数的大小更简单的一种方法是使用 abs() 函数。调用 abs() 函数时，如果参数是实数，它返回绝对值。例如，abs(5) 和 abs(-5) 都返回 5。对于复数，它返回的是模长：

>>> abs(z)

3.605551275463989

标准库中的 cmath 模块（cmath 为*复数数学*的缩写）提供了访问许多其他专门用于处理复数的函数。

### **获取用户输入**

当我们开始编写程序时，使用 input() 函数接收用户输入会非常有帮助。通过这种方式，我们可以编写让用户输入数字、对其执行特定操作并显示结果的程序。让我们看看实际应用：

➊ >>> a = input()

➋ 1

在 ➊ 处，我们调用了 input() 函数，它等待你输入内容，如 ➋ 所示，然后按 ENTER 键。输入的内容会存储在 a 变量中：

>>> a

➌ '1'

注意➌处1周围的单引号。input()函数将输入作为*字符串*返回。在Python中，字符串是任何位于两个引号之间的字符集。当你想创建一个字符串时，可以使用单引号或双引号：

>>> s1 = 'a string'

>>> s2 = "a string"

在这里，s1和s2都指向相同的字符串。

即使字符串中的唯一字符是数字，Python也不会将该字符串当作数字，除非我们去掉那些引号。因此，在我们执行任何数学运算之前，必须将其转换为正确的数字类型。可以使用int()或float()函数分别将字符串转换为整数或浮动点数：

>>> a = '1'

>>> int(a) + 1

2

>>> float(a) + 1

2.0

这些就是我们之前看到的相同的int()和float()函数，但这次它们不是将一种类型的数字转换为另一种类型，而是将字符串作为输入（'1'），并返回一个数字（2或2.0）。然而，需要注意的是，int()函数无法将包含浮动点数的字符串转换为整数。如果你输入一个包含浮动点数的字符串（如'2.5'甚至'2.0'）并将该字符串传递给int()函数，你会得到一条错误消息：

>>> int('2.0')

Traceback (最近的调用最后):

文件 "<pyshell#26>"，第1行，在<module>中

int('2.0')

ValueError: int()的无效文字：'2.0'

这就是一个*异常*的示例——Python告诉你，它由于错误无法继续执行程序。在这种情况下，异常类型是ValueError。（关于异常的快速复习，请参见[附录B](app02.html#app02)。）

类似地，当你输入一个分数数字（例如3/4）时，Python无法将其转换为等效的浮动点数或整数。再次，抛出一个ValueError异常：

>>> a = float(input())

3/4

Traceback (最近的调用最后):

文件 "<pyshell#25>"，第1行，在<module>中

a=float(input())

ValueError: 无法将字符串转换为浮动数：'3/4'

你可能会觉得在try...except块中执行转换很有用，这样你就可以*处理*这个异常，并提醒用户程序遇到了无效的输入。接下来，我们将看看try...except块。

#### ***处理异常和无效输入***

如果你不熟悉try...except，基本的思路是这样的：如果你在try...except块中执行一个或多个语句，并且在执行过程中出现错误，你的程序不会崩溃并打印Traceback。相反，执行会转移到except块，你可以在其中执行适当的操作，例如打印一条有用的错误消息或尝试其他操作。

这是你在try...except块中执行上述转换，并在遇到无效输入时打印有用错误消息的方式：

>>> try:

a = float(input('请输入一个数字：'))

except ValueError:

print('你输入了无效的数字')

请注意，我们需要指定我们希望处理的异常类型。在这里，我们希望处理ValueError异常，因此我们将其指定为except ValueError。

现在，当你输入一个无效的内容，比如3/4时，它会显示一条有帮助的错误信息，如➊所示：

输入一个数字：3/4

➊ 你输入了一个无效的数字

你还可以使用input()函数指定一个提示，告诉用户期望输入什么类型的内容。例如：

>>> a = input('输入一个整数: ')

用户现在会看到提示信息，提示输入一个整数：

输入一个整数：1

在本书的许多程序中，我们会要求用户输入一个数字作为输入，因此我们必须确保在对这些数字进行任何操作之前先进行转换。你可以将输入和转换结合在一个语句中，如下所示：

>>> a = int(input())

1

>>> a + 1

2

如果用户输入一个整数，这个方法效果很好。但正如我们之前所看到的，如果输入是浮点数（即使它等同于整数，如1.0），也会产生错误：

>>> a = int(input())

1.0

回溯（最近的调用最后）：

文件 "<pyshell#42>"，第1行，在<module>中

a = int(input())

ValueError: int()的无效字面量，基数为10：'1.0'

为了避免这个错误，我们可以设置一个类似我们之前看到的ValueError捕获机制。这样程序就能捕获浮点数，这些数字在专为整数设计的程序中无法使用。然而，这也会标记像1.0和2.0这样的数字，尽管Python*看作*浮点数，但它们实际上等同于整数，如果它们作为正确的Python类型输入，应该没有问题。

为了避免这一切，我们将使用is_integer()方法来过滤掉任何小数点后有有效数字的数字。（这个方法仅对Python中的float类型数字有效；它无法用于已经输入的整数形式的数字。）

这里有一个例子：

>>> 1.1.is_integer()

False

在这里，我们调用is_integer()方法来检查1.1是否是一个整数，结果是False，因为1.1确实是一个浮点数。另一方面，当调用该方法时，如果浮点数是1.0，结果是True：

>>> 1.0.is_integer()

True

我们可以使用is_integer()来过滤掉非整数输入，同时保留像1.0这样的输入，尽管它是以浮点数形式表示，但等同于整数。稍后我们会看到该方法如何适应更大的程序。

#### ***分数和复数作为输入***

我们之前学习过的Fraction类也能够将字符串如'3/4'转换为一个Fraction对象。事实上，这就是我们如何接受一个分数作为输入的方法：

>>> a = Fraction(input('请输入一个分数: '))

输入一个分数：3/4

>>> a

Fraction(3, 4)

尝试输入一个像3/0这样的分数作为输入：

>>> a = Fraction(input('请输入一个分数: '))

输入一个分数：3/0

回溯（最近的调用最后）：

文件 "<pyshell#2>"，第1行，在<module>中

a = Fraction(input('输入一个分数: '))

文件 "/usr/lib64/python3.3/fractions.py"，第 167 行，在 __new__ 中

raise ZeroDivisionError('Fraction(%s, 0)' % numerator)

ZeroDivisionError: Fraction(3, 0)

ZeroDivisionError 异常信息告诉你（正如你已经知道的那样），分母为 0 的分数是无效的。如果你计划让程序用户输入分数，最好总是捕获这些异常。以下是如何处理的示例：

>>> try:

a = Fraction(input('输入一个分数: '))

except ZeroDivisionError:

print('无效的分数')

输入一个分数: 3/0

无效的分数

现在，每当程序用户输入一个分母为 0 的分数时，它会打印出“无效的分数”信息。

同样，complex() 函数可以将字符串 '2+3j' 转换为复数：

>>> z = complex(input('输入一个复数: '))

输入一个复数: 2+3j

>>> z

(2+3j)

如果你输入字符串 '2 + 3j'（带有空格），会导致 ValueError 错误信息：

>>> z = complex(input('输入一个复数: '))

输入一个复数: 2 + 3j

回溯 (最近的调用最后):

文件 "<pyshell#43>"，第 1 行，在 <module> 中

z = complex(input('输入一个复数: '))

ValueError: complex() 参数是一个格式错误的字符串

在将字符串转换为复数时，捕获 ValueError 异常是个好主意，正如我们在处理其他数字类型时所做的那样。

### **编写为你做数学运算的程序**

现在，我们已经学习了一些基本概念，可以将它们与 Python 的条件语句和循环语句结合起来，编写一些更先进且有用的程序。

#### ***计算整数的因子***

当一个非零整数 a 除以另一个整数 b，且余数为 0 时，称 a 为 b 的 *因子*。例如，2 是所有偶数的因子。我们可以编写一个如下的函数，来判断一个非零整数 a 是否是另一个整数 b 的因子：

>>> def is_factor(a, b):

if b % a == 0:

return True

else:

return False

我们使用本章前面介绍的 % 运算符来计算余数。如果你曾经问过类似“4 是 1024 的因子吗？”这样的问题，你可以使用 is_factor() 函数：

>>> is_factor(4, 1024)

True

对于任何正整数 *n*，我们如何找到它的所有正因子？对于从 1 到 *n* 之间的每个整数，我们检查将 *n* 除以该整数后的余数。如果余数为 0，那么它就是一个因子。我们将使用 range() 函数编写一个程序，遍历 1 到 *n* 之间的每个数字。

在编写完整程序之前，我们先来看看 range() 是如何工作的。range() 函数的典型用法如下：

>>> for i in range(1, 4):

print(i)

1

2

3

在这里，我们设置了一个 for 循环，并给 range 函数传递了两个参数。range() 函数从第一个参数指定的整数（*起始值*）开始，一直到第二个参数指定的整数之前（*停止值*）。在本例中，我们告诉 Python 打印出这个范围内的数字，从 1 开始，到 4 停止。注意，这意味着 Python 不会打印 4，所以它打印的最后一个数字是停止值之前的数字（3）。还需要注意的是，range() 函数只接受整数作为参数。

你也可以在不指定起始值的情况下使用 range() 函数，此时默认起始值为 0。例如：

>>> for i in range(5):

print(i)

0

1

2

3

4

range() 函数生成的两个连续整数之间的差值称为 *步长*。默认情况下，步长为 1。要指定不同的步长值，可以将其作为第三个参数来指定（当指定步长时，起始值 *不是* 可选的）。例如，下面的程序会打印出 *小于* 10 的奇数：

>>> for i in range(1,10,2):

print(i)

1

3

5

7

9

好的，现在我们了解了 range() 函数的工作原理，接下来我们可以来看一个因子计算程序。因为我要编写一个相对较长的程序，所以我不在交互式 IDLE 提示符中编写这个程序，而是使用 IDLE 编辑器。你可以通过在 IDLE 中选择 **文件** ▸ **新建窗口** 来启动编辑器。注意，我们首先通过三个单引号 (') 来注释代码。引号之间的文字不会被 Python 执行，它只是给我们人类看的注释。

'''

查找整数的因子

'''

def factors(b):

➊     对于 i 在 range(1, b+1) 中：

如果 b % i == 0:

print(i)

如果 __name__ == '__main__':

b = input('请输入您的数字：')

b = float(b)

➋     如果 b > 0 且 b 是整数：

factors(int(b))

else:

print('请输入一个正整数')

factors() 函数定义了一个 for 循环，对于从 1 到输入整数之间的每个整数，使用 range() 函数进行迭代。在这里，我们希望迭代到用户输入的整数 b，所以停止值设置为 b+1。对于这些整数 i，程序检查它是否能整除输入的数字且没有余数，如果能就打印出来。

当你运行这个程序（通过选择 **运行** ▸ **运行模块**），它会要求你输入一个数字。如果你的数字是正整数，它的因子将被打印出来。例如：

请输入您的数字：25

1

5

25

如果你输入一个非整数或负整数，程序会打印出错误信息，提示你输入一个正整数：

请输入您的数字：15.5

请输入一个正整数

这是一个示例，展示了我们如何通过始终检查程序中的无效输入，使程序更具用户友好性。因为我们的程序仅适用于查找正整数的因子，我们通过 is_integer() 方法 ➋ 检查输入的数字是否大于 0 且是整数，以确保输入有效。如果输入不是正整数，程序会打印出用户友好的提示，而不是简单地显示一个错误信息。

#### ***生成乘法表***

考虑三个数字，*a*、*b* 和 *n*，其中 *n* 是一个整数，满足以下条件：

*a* × *n* = *b*。

我们可以在这里说 *b* 是 *a* 的第 *n* 个 *倍数*。例如，4 是 2 的第 2 个倍数，1024 是 2 的第 512 个倍数。

一个数字的乘法表列出了该数字的所有倍数。例如，2 的乘法表如下所示（这里展示的是前几个倍数）：

2 × 1 = 2

2 × 2 = 4

2 × 3 = 6

我们的下一个程序会生成用户输入的任意数字的乘法表，最多到 10。在这个程序中，我们将结合 format() 方法和 print() 函数，以帮助程序输出看起来更漂亮和易读。如果你之前没有见过，我将简要解释它是如何工作的。

format() 方法允许你插入标签并进行设置，以便它们可以以漂亮且易读的字符串格式输出，周围还带有额外的格式化。例如，如果我有所有我在杂货店购买的水果的名称，并为每个名称创建了单独的标签，想要把它们打印出来形成一个连贯的句子，我可以使用 format() 方法，代码如下：

>>> item1 = '苹果'

>>> item2 = '香蕉'

>>> item3 = '葡萄'

>>> print('在杂货店，我买了些{0}、{1}和{2}'.format(item1, item2, item3))

在杂货店，我买了些苹果、香蕉和葡萄

首先，我们创建了三个标签（item1、item2 和 item3），每个标签分别对应一个不同的字符串（苹果、香蕉和葡萄）。然后，在 print() 函数中，我们输入了一个带有三个占位符的大括号字符串：{0}、{1} 和 {2}。接着我们调用 .format()，并传入我们创建的这三个标签。这告诉 Python 按照指定的顺序将这些标签的值填充到占位符中，因此 Python 会打印出文本，其中 {0} 被第一个标签的值替换，{1} 被第二个标签的值替换，依此类推。

并不一定需要标签来指向我们想要打印的值。我们也可以直接将值输入到 .format() 中，如以下示例所示：

>>> print('数字 1: {0} 数字 2: {1} '.format(1, 3.578))

数字 1: 1 数字 2: 3.578

请注意，占位符的数量和标签或值的数量必须相等。

现在我们已经了解了 format() 的工作原理，我们可以查看用于打印乘法表的程序：

'''

乘法表打印机

'''

def multi_table(a):

➊ for i in range(1, 11):

print('{0} x {1} = {2}'.format(a, i, a*i))

如果 __name__ == '__main__':

a = input('输入一个数字: ')

multi_table(float(a))

函数`multi_table()`实现了程序的主要功能。它以需要打印乘法表的数字a为参数。因为我们希望打印从1到10的乘法表，所以在➊处有一个for循环，遍历这些数字，打印每个数字与a的乘积。

当你执行程序时，它会要求你输入一个数字，然后程序会打印出该数字的乘法表：

输入一个数字：5

5.0 x 1 = 5.0

5.0 x 2 = 10.0

5.0 x 3 = 15.0

5.0 x 4 = 20.0

5.0 x 5 = 25.0

5.0 x 6 = 30.0

5.0 x 7 = 35.0

5.0 x 8 = 40.0

5.0 x 9 = 45.0

5.0 x 10 = 50.0

看看那张表格多么整齐有序？那是因为我们使用了`.format()`方法按可读的统一模板打印输出。

你可以使用`format()`方法进一步控制数字的打印方式。例如，如果你只想要保留两位小数，可以使用`format()`方法进行指定。以下是一个例子：

>>> '{0}'.format(1.25456)

'1.25456'

>>> '{0:.2f}'.format(1.25456)

'1.25'

上面的第一个格式化语句仅仅是按我们输入的方式打印数字。第二个语句中，我们修改了占位符为{0:.2f}，意味着我们只希望小数点后保留两位数字，f表示浮动小数点数字。如你所见，下一次输出中，小数点后只有两位数字。注意，如果小数点后的数字超过了你指定的位数，数字会被四舍五入。例如：

>>> '{0:.2f}'.format(1.25556)

'1.26'

这里，1.25556四舍五入到最接近的百分位，并打印为1.26。如果你使用`.2f`格式，且打印的数字是整数，末尾会添加零：

>>> '{0:.2f}'.format(1)

'1.00'

添加两个零是因为我们指定了要打印小数点后恰好两位数字。

#### ***单位转换***

国际单位制定义了七个*基本量*。这些基本量可以用来推导其他量，称为*导出量*。长度（包括宽度、高度和深度）、时间、质量和温度是这七个基本量中的四个。每个基本量都有一个标准的计量单位：米、秒、千克和开尔文，分别对应。

但是每个标准测量单位也都有多个非标准测量单位。你可能更习惯于看到温度以30摄氏度或86华氏度来表示，而不是303.15开尔文。这是否意味着303.15开尔文比86华氏度热三倍？当然不！我们不能仅通过数值大小将86华氏度与303.15开尔文进行比较，因为它们是用不同的测量单位表示的，尽管它们衡量的是相同的物理量——温度。只有当两种物理量的测量使用相同的计量单位时，我们才能进行比较。

不同单位之间的转换可能比较棘手，这也是为什么你经常在高中被要求解决涉及不同单位转换的问题。这是一个测试你基本数学技能的好方法。但Python也有很多数学技能，而且不同于某些高中生，Python不会在循环中反复计算时感到疲倦！接下来，我们将探索编写程序来为你执行这些单位转换。

我们从长度开始。在美国和英国，通常使用英寸和英里来测量长度，而大多数其他国家使用厘米和公里。

一英寸等于2.54厘米，你可以使用乘法操作将英寸转换为厘米。然后，你可以将厘米数除以100得到以米为单位的长度。例如，以下是如何将25.5英寸转换为米：

>>> (25.5 * 2.54) / 100

0.6476999999999999

另一方面，一英里大约等于1.609公里。因此，如果你看到目的地距离是650英里，那么你距离目的地的公里数是：650 × 1.609公里。

>>> 650 * 1.609

1045.85

现在让我们来看一下*温度*转换——将温度从华氏度转换为摄氏度，反之亦然。以华氏度表示的温度，通过以下公式转换为相应的摄氏度：

![image](images/e0018-01.jpg)

*F* 是华氏温度，*C* 是相应的摄氏温度。你知道98.6华氏度被认为是正常人体体温。要找到相应的摄氏温度，我们在Python中评估上述公式：

>>> F = 98.6

>>> (F - 32) * (5 / 9)

37.0

首先，我们创建一个标签F，值为华氏温度98.6。接下来，我们计算将这个温度转换为其对应摄氏度的公式，结果是37.0摄氏度。

要将温度从摄氏度转换为华氏度，可以使用以下公式：

![image](images/e0018-02.jpg)

你可以以类似的方式评估这个公式：

>>> C = 37

>>> C * (9 / 5) + 32

98.60000000000001

我们创建了一个标签C，值为37（正常人体体温，单位摄氏度）。然后，我们使用公式将其转换为华氏温度，结果是98.6度。

一遍又一遍地编写这些转换公式是件麻烦事。让我们编写一个单位转换程序，来为我们完成这些转换。这个程序会显示一个菜单，允许用户选择他们想执行的转换，要求输入相关的数值，然后打印计算结果。以下是程序的展示：

'''

单位转换器：英里和公里

'''

def print_menu():

print('1. 公里转换为英里')

print('2. 英里转换为公里')

def km_miles():

km = float(input('输入距离（公里）：'))

miles = km / 1.609

print('距离（英里）: {0}'.format(miles))

def miles_km():

miles = float(input('输入距离（英里）：'))

km = miles * 1.609

print('公里数: {0}'.format(km))

if __name__ == '__main__':

➊     print_menu()

➋     choice = input('你想进行哪种转换？: ')

if choice == '1':

km_miles()

if choice == '2':

miles_km()

这是一个比其他程序稍长的程序，但别担心。它其实很简单。我们从 ➊ 开始。调用了 print_menu() 函数，该函数打印出包含两种单位转换选择的菜单。在 ➋，程序要求用户选择其中一种转换。如果输入选择为 1（公里转英里），则调用 km_miles() 函数。如果选择输入为 2（英里转公里），则调用 miles_km() 函数。在这两个函数中，用户首先被要求输入转换所选单位的距离（对于 km_miles() 为公里， 对于 miles_km() 为英里）。然后程序使用相应的公式进行转换并显示结果。

下面是该程序的一个示例运行：

1. 公里转英里

2. 英里转公里

➊ 你想进行哪种转换？: 2

输入英里数: 100

公里数: 160.900000

用户在 ➊ 处被要求输入选择。选择被输入为 2（英里转公里）。程序随后要求用户输入需要转换为公里的英里数，并输出转换结果。

这个程序只是进行英里和公里之间的转换，但在后续的编程挑战中，你将扩展该程序，使其可以执行其他单位的转换。

#### ***求解二次方程的根***

当你有一个方程式，如 *x* + 500 – 79 = 10，而你需要求解未知数 *x* 的值时，该怎么办？你需要将方程式重新排列，使常数（500，–79 和 10）都在方程的一侧，而变量 (*x*) 在另一侧。这就得到以下方程式：*x* = 10 – 500 + 79。

求解右侧表达式的值，就能得到 *x* 的值，这就是你的解，也叫做方程的 *根*。在 Python 中，你可以这样做：

>>> x = 10 - 500 + 79

>>> x

-411

这是一个 *线性方程* 的例子。一旦你将两边的项重新排列，表达式就足够简单，可以进行求解。另一方面，对于像 *x*² + 2*x* + 1 = 0 这样的方程，求解 *x* 的根通常需要计算一个复杂的表达式，称为 *二次公式*。这种方程被称为 *二次方程*，通常表示为 *ax*² + *bx* + *c* = 0，其中 *a*、*b* 和 *c* 是常数。计算根的二次公式如下所示：

![image](images/e0020-01.jpg)

一元二次方程有两个根——两个使二次方程两边相等的 *x* 值（虽然有时这两个值可能是相同的）。这在二次公式中由 *x*[1] 和 *x*[2] 表示。

比较方程 *x*² + 2*x* + 1 = 0 与通用的二次方程，我们看到 *a* = 1，*b* = 2，*c* = 1。我们可以将这些值直接代入二次公式中计算 *x*[1] 和 *x*[2] 的值。在 Python 中，我们首先将 *a*、*b* 和 *c* 的值存储为标签 a、b 和 c，并赋予相应的值：

>>> a = 1

>>> b = 2

>>> c = 1

然后，考虑到两个公式都有项 *b*² – 4*ac*，我们定义一个新的标签 *D*，如下图所示：![image](images/e0021-01.jpg):

>>> D = (b ** 2 – 4 * a * c) ** 0.5

如你所见，我们通过将 *b*² – 4*ac* 提升到 0.5 次方来计算平方根。现在，我们可以写出计算 *x*[1] 和 *x*[2] 的表达式：

>>> x_1 = (-b + D) / (2 * a)

>>> x_1

-1.0

>>> x_2 = (-b - D) / (2 * a)

>>> x_2

-1.0

在这种情况下，两个根的值相同，如果将该值代入方程 *x*² + 2*x* + 1，方程将计算出 0。

我们的下一个程序将这些步骤结合到一个名为 roots() 的函数中，该函数将 *a*、*b* 和 *c* 作为参数，计算并打印根：

'''

二次方程根计算器

'''

def roots(a, b, c):

D = (b * b - 4 * a * c) ** 0.5

x_1 = (-b + D) / (2 * a)

x_2 = (-b - D) / (2 * a)

print('x1: {0}'.format(x_1))

print('x2: {0}'.format(x_2))

if __name__ == '__main__':

a = input('输入 a: ')

b = input('输入 b: ')

c = input('输入 c: ')

roots(float(a), float(b), float(c))

起初，我们使用标签 a、b 和 c 来引用二次方程三个常数的值。然后，我们调用 roots() 函数，并将这三个值作为参数传入（在传入之前将它们转换为浮动点数）。这个函数将 *a*、*b* 和 *c* 代入二次公式，计算方程的根，并打印出来。

当你执行程序时，它会要求用户输入对应于他们想要寻找根的二次方程的 *a*、*b* 和 *c* 的值。

输入 a: 1

输入 b: 2

输入 c: 1

x1: -1.000000

x2: -1.000000

尝试使用不同常数值解决更多的二次方程，程序会正确地找到根。

你可能知道，二次方程的根也可以是复数。例如，方程 *x*² + *x* + 1 = 0 的根都是复数。上述程序也可以为你找到这些根。让我们通过再次执行程序来试试（常数为 *a* = 1，*b* = 1，*c* = 1）：

输入 a: 1

输入 b: 1

输入 c: 1

x1: (-0.49999999999999994+0.8660254037844386j)

x2: (-0.5 - 0.8660254037844386j)

上面打印出的根是复数（由 j 表示），程序可以正确计算并显示它们。

### **你学到了什么**

很棒，完成了第一章！你学会了编写能够识别整数、浮点数、分数（以分数或浮点数形式表示）和复数的程序。你编写了生成乘法表、执行单位转换和求解二次方程根的程序。我相信你已经很兴奋，迈出了编写能为你进行数学计算的程序的第一步。在我们继续之前，这里有一些编程挑战，可以让你进一步应用你所学的知识。

### **编程挑战**

这里有一些挑战题，能够让你有机会练习本章的概念。每个问题可以用多种方法解决，但你可以在*[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*找到示例解答。

#### ***#1: 奇偶自动售货机***

尝试编写一个“奇偶自动售货机”，它将接受一个数字作为输入，并执行两件事：

1\. 打印数字是偶数还是奇数。

2\. 显示数字后跟随接下来的9个偶数或奇数。

如果输入是2，程序应该打印“偶数”，然后打印 2, 4, 6, 8, 10, 12, 14, 16, 18, 20。类似地，如果输入是1，程序应该打印“奇数”，然后打印 1, 3, 5, 7, 9, 11, 13, 15, 17, 19。

如果输入是一个小数，程序应该使用is_integer()方法显示错误信息，表示输入是一个有有效数字的小数。

#### ***#2: 强化版乘法表生成器***

我们的乘法表生成器很酷，但它只打印前10个倍数。加强这个生成器，让用户可以指定数字和要显示的倍数个数。例如，我应该能够输入我想查看9的前15个倍数的表格。

#### ***#3: 强化版单位转换器***

我们在本章中编写的单位转换程序只限于千米和英里的转换。尝试扩展该程序，实现质量单位（如千克和磅）以及温度单位（如摄氏度和华氏度）之间的转换。

#### ***#4: 分数计算器***

编写一个可以对两个分数执行基本数学运算的计算器。它应该询问用户两个分数和用户希望执行的运算。作为起步，这里有一个只执行加法运算的程序示例：

'''

分数运算

'''

from fractions import Fraction

def add(a, b):

print('加法结果：{0}'.format(a+b))

if __name__ == '__main__':

➊     a = Fraction(input('请输入第一个分数：'))

➋     b = Fraction(input('请输入第二个分数：'))

op = input('请选择要执行的操作 - 加法、减法、除法、乘法：')

if op == '加法':

add(a,b)

你已经看过这个程序中的大部分元素。在➊和➋的位置，我们要求用户输入两个分数。然后，我们询问用户要对这两个分数执行哪个操作。如果用户输入 'Add'，则调用我们定义的 add() 函数，该函数用于计算传入的两个分数的和。add() 函数执行该操作并打印结果。例如：

输入第一个分数：3/4

输入第二个分数：1/4

执行的操作 - 加法、减法、除法、乘法：加法

加法结果：1

尝试添加对其他操作的支持，如减法、除法和乘法。例如，下面是如何让你的程序计算两个分数的差：

输入第一个分数：3/4

输入第二个分数：1/4

执行的操作 - 加法、减法、除法、乘法：减法

减法结果：2/4

在除法的情况下，你应该让用户知道是第一个分数除以第二个分数，还是反过来。

#### ***#5: 给用户退出的权力***

到目前为止，我们编写的所有程序都仅适用于一次输入输出。例如，考虑一个打印乘法表的程序：用户执行程序并输入一个数字，然后程序打印乘法表并退出。如果用户想打印另一个数字的乘法表，则必须重新运行程序。

如果用户能够选择是否退出或继续使用程序，那会更加方便。编写此类程序的关键是设置一个 *无限循环*，或者一个只有在明确要求退出时才会停止的循环。下面，你可以看到一个此类程序布局的示例：

'''

直到退出布局

'''

def fun():

print('我在一个无限循环中')

if __name__ == '__main__':

➊     while True:

fun()

➋         answer = input('你想退出吗？（y）是，其他键为否')

if answer == 'y':

break

我们在➊处使用 `while True` 定义了一个无限循环。`while` 循环会一直执行，除非条件评估为 False。由于我们将循环条件设置为常量值 True，因此它将一直运行，除非我们以某种方式中断它。在循环内部，我们调用 `fun()` 函数，打印出字符串“我在一个无限循环中”。在➋处，询问用户“你想退出吗？” 如果用户输入 y 作为输入，程序会通过 `break` 语句退出循环（`break` 语句会退出最内层的循环，而不执行该循环中的其他任何语句）。如果用户输入其他内容（或者什么都不输入，仅按回车键），则 `while` 循环会继续执行——也就是说，它会再次打印该字符串，并继续这样做，直到用户希望退出。以下是该程序的一次示例运行：

我在一个无限循环中

你想退出吗？（y）是，其他键为否 n

我在一个无限循环中

你想退出吗？（y）是，其他键为否 n

我在一个无限循环中

你想退出吗？（y）是，其他键为否 n

我在一个无限循环中

你想退出吗？（y）是，其他键为否 y

基于这个例子，让我们重写乘法表生成器，使其继续运行，直到用户想要退出。新版本的程序如下所示：

'''

带有乘法表打印器的

退出权限授予用户

'''

def multi_table(a):

for i in range(1, 11):

print('{0} x {1} = {2}'.format(a, i, a*i))

if __name__ == '__main__':

while True:

a = input('请输入一个数字: ')

multi_table(float(a))

answer = input('你想退出吗？(y) 代表是 ')

if answer == 'y':

break

如果你将这个程序与我们之前写的程序进行比较，你会发现唯一的变化就是添加了 while 循环，其中包括提示用户输入数字的部分和调用 multi_table() 函数的部分。

当你运行程序时，程序会要求输入一个数字并打印该数字的乘法表，如之前所示。然而，程序还会随后询问用户是否希望退出程序。如果用户不想退出，程序将准备好打印另一个数字的乘法表。以下是一个示例运行：

请输入一个数字: 2

2.000000 x 1.000000 = 2.000000

2.000000 x 2.000000 = 4.000000

2.000000 x 3.000000 = 6.000000

2.000000 x 4.000000 = 8.000000

2.000000 x 5.000000 = 10.000000

2.000000 x 6.000000 = 12.000000

2.000000 x 7.000000 = 14.000000

2.000000 x 8.000000 = 16.000000

2.000000 x 9.000000 = 18.000000

2.000000 x 10.000000 = 20.000000

你想退出吗？(y) 代表是，n 代表否

请输入一个数字：

尝试重写本章中的其他一些程序，使它们在用户要求退出之前持续执行。
