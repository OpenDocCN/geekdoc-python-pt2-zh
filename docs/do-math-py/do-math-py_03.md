## **3**

**使用统计学描述数据**

![image](img/common-01.jpg)

在本章中，我们将使用 Python 来探索统计学，以便研究、描述并更好地理解数据集。在介绍一些基本的统计度量——平均数、中位数、众数和极差——之后，我们将学习一些更高级的度量，例如方差和标准差。然后，我们将看到如何计算相关系数，它允许你量化两个数据集之间的关系。我们将通过学习散点图来结束本章。在这个过程中，我们将进一步了解 Python 语言和标准库模块。让我们从最常用的统计度量之一——平均数开始。

**注意**

*在统计学中，一些统计度量的计算方法略有不同，具体取决于你是拥有整个群体的数据还是仅有样本数据。为了简化起见，本章我们将使用群体数据的计算方法。*

### **寻找平均数**

*平均数*是一个常见且直观的统计量。我们在日常生活中可能称它为“平均值”，尽管正如我们将看到的，还有其他类型的平均值。让我们以一组示例数字为例，来计算平均数。

假设有一个学校的慈善活动，在过去的 12 天里收到了捐款（我们将这段时间称为 A 期）。在这段时间里，以下 12 个数字代表每天收到的捐款总额：100、60、70、900、100、200、500、500、503、600、1000 和 1200。我们可以通过将这些总额相加，再除以天数来计算平均数。在这种情况下，数字的总和是 5733。如果我们将这个数字除以 12（天数），我们得到 477.75，这就是每天的*平均*捐款额。这个数字为我们提供了一个大致的捐款金额。

接下来，我们将编写一个程序来计算并打印一组数字的平均数。正如我们刚刚看到的，计算平均数时，我们需要将数字列表的总和除以列表中的项数。让我们来看一下两个 Python 函数，它们可以非常方便地完成这两个操作：sum()和 len()。

当你在数字列表上使用 sum()函数时，它会将列表中的所有数字相加并返回结果：

>>> shortlist = [1, 2, 3]

>>> sum(shortlist)

6

我们可以使用 len()函数来获得列表的长度：

>>> len(shortlist)

3

当我们对列表使用 len()函数时，它会返回 3，因为 shortlist 中有三个项。现在我们准备编写一个程序，计算捐款列表的平均数。

'''

计算平均数

'''

def calculate_mean(numbers):

➊     s = sum(numbers)

➋     N = len(numbers)

# 计算平均数

➌     mean = s/N

return mean

if __name__ == '__main__':

➍     donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]

➎     mean = calculate_mean(donations)

N = len(donations)

➏     print('过去{0}天的平均捐款额是{1}'.format(N, mean))

首先，我们定义一个函数`calculate_mean()`，它接受一个参数`numbers`，这是一个数字列表。在➊处，我们使用`sum()`函数将列表中的数字相加，并创建一个标签`s`来表示总和。同样地，在➋处，我们使用`len()`函数来获取列表的长度，并创建一个标签`N`来表示它。然后，正如你在➌处看到的，我们通过将总和（s）除以元素数量（N）来计算平均值。在➍处，我们创建一个列表`donations`，其中包含之前列出的捐款数额。然后，我们调用`calculate_mean()`函数，在➎处传入该列表作为参数。最后，我们在➏处打印计算出的平均值。

当你运行程序时，应该会看到以下内容：

过去 12 天的平均捐款额是 477.75

`calculate_mean()`函数将计算*任何*列表的总和和长度，因此我们也可以重复使用它来计算其他数字集合的平均值。

我们计算出每一天的平均捐款额为 477.75。值得注意的是，最初几天的捐款远低于我们计算的平均捐款额，而最后几天的捐款则远高于平均值。平均数给我们提供了一种总结数据的方式，但它并不能提供完整的画面。然而，还有其他统计量可以在与平均数进行比较时，提供更多关于数据的信息。

### **寻找中位数**

数字集合的*中位数*是另一种类型的平均值。为了找到中位数，我们将数字按升序排列。如果列表中的数字个数是奇数，中间的数字就是中位数。如果列表中的数字个数是偶数，我们通过取中间两个数字的平均值来获得中位数。让我们来找一下之前捐款列表的中位数：100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000 和 1200。

将数字从小到大排序后，数字列表变为 60, 70, 100, 100, 200, 500, 500, 503, 600, 900, 1000 和 1200。我们列表中有一个偶数个元素（12 个），所以为了得到中位数，我们需要取中间两个数字的平均值。在这种情况下，中间的两个数字是第六个和第七个数字——500 和 500——这两个数字的平均值是(500 + 500)/2，结果为 500。这意味着中位数是 500。

现在假设—仅为了这个例子—我们在第 13 天有了另一笔捐款总额，因此列表现在看起来是这样的：100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200 和 800。

再一次，我们需要对列表进行排序，排序后列表变为 60, 70, 100, 100, 200, 500, 500, 503, 600, 800, 900, 1000 和 1200。这个列表中有 13 个数字（奇数个），所以这个列表的中位数就是中间的数字。在这种情况下，它是第七个数字，即 500。

在我们编写一个程序来找到一组数字的中位数之前，让我们先考虑一下如何自动计算列表中的中间元素。在两种情况下，如果列表的长度 (*N*) 是奇数，中位数就是位置为 (*N* + 1)/2 的数字。如果 *N* 是偶数，中位数则是位置为 *N*/2 和 (*N*/2) + 1 的两个中间元素。对于本节的第一个示例，*N* = 12，因此两个中间元素是 12/2（第六个）和 12/2 + 1（第七个）元素。在第二个示例中，*N* = 13，因此第七个元素（(*N* + 1)/2）是中位数。

为了编写一个计算中位数的函数，我们还需要将列表按升序排序。幸运的是，sort() 方法正好可以实现这一点：

>>> samplelist = [4, 1, 3]

>>> samplelist.sort()

>>> samplelist

[1, 3, 4]

现在我们可以编写下一个程序，它会找到一组数字的中位数：

'''

计算中位数

'''

def calculate_median(numbers):

➊     N = len(numbers)

➋     numbers.sort()

# 找到中位数

如果 N % 2 == 0:

# 如果 N 是偶数

m1 = N / 2

m2 = (N / 2) + 1

# 转换为整数，匹配位置

➌         m1 = int(m1) - 1

➍         m2 = int(m2) - 1

➎         median = (numbers[m1] + numbers[m2]) / 2

else:

➏         m = (N + 1) / 2

# 转换为整数，匹配位置

m = int(m) - 1

median = numbers[m]

return median

if __name__ == '__main__':

donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]

median = calculate_median(donations)

N = len(donations)

print('过去 {0} 天的中位数捐赠额是 {1}'.format(N, median))

该程序的整体结构类似于前面计算平均值的程序。calculate_median() 函数接受一个数字列表并返回中位数。在 ➊ 处，我们计算列表的长度，并创建一个标签 N 来表示它。接下来，在 ➋ 处，我们使用 sort() 方法对列表进行排序。

然后，我们检查 N 是否为偶数。如果是，我们找到中间的元素 m1 和 m2，它们是排序列表中位置为 N / 2 和 (N / 2) + 1 的数字。接下来的两条语句（➌ 和 ➍）通过两种方式调整 m1 和 m2。首先，我们使用 int() 函数将 m1 和 m2 转换为整数形式。因为即使除法结果等于整数，除法运算符的结果总是返回浮点数。例如：

>>> 6 / 2

3.0

我们不能将浮点数作为列表的索引，因此我们使用 int() 将结果转换为整数。我们还从 m1 和 m2 中分别减去 1，因为在 Python 中列表的索引是从 0 开始的。这意味着为了从列表中获取第六个和第七个数字，我们必须请求索引为 5 和 6 的数字。在 ➎ 处，我们通过计算中间位置两个数字的平均值来得出中位数。

从➏开始，程序会查找中位数，如果列表中的项数是奇数，它会再次使用 int()并减去 1 来找到正确的索引。最后，程序会计算捐赠列表的中位数并返回。当你执行程序时，它会计算出中位数是 500：

过去 12 天的中位数捐赠为 500.0

正如你所看到的，在这个特定的列表中，平均数（477.75）和中位数（500）非常接近，但中位数稍微高一点。

### **寻找众数并创建频率表**

如果你不想找到一组数字的平均值或中位数，而是想找出出现频率最高的数字呢？这个数字叫做*众数*。例如，考虑一下 20 名学生在一次数学测试中的成绩（满分 10 分）：7, 8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1 和 10。这个列表的众数可以告诉你班上最常见的成绩是什么。从这个列表可以看出，9 出现的次数最多，因此 9 是这个数字列表的众数。没有一个固定的公式来计算众数——你只需要统计每个唯一数字出现的次数，并找出出现最多的那个。

要编写一个计算众数的程序，我们需要让 Python 计算每个数字在列表中出现的次数，并打印出出现最频繁的那个数字。collections 模块中的 Counter 类是标准库的一部分，它使这个任务变得非常简单。

#### ***寻找最常见的元素***

在数据集里找到最常见的数字可以看作是找出若干个最常见数字的子问题。例如，如果你不仅想找出最常见的成绩，而是想知道五个最常见的成绩呢？Counter 类的 most_common()方法使得我们能够轻松地回答这样的问题。让我们来看一个例子：

>>> simplelist = [4, 2, 1, 3, 4]

>>> from collections import Counter

>>> c = Counter(simplelist)

>>> c.most_common()

[(4, 2), (1, 1), (2, 1), (3, 1)]

这里，我们从一个包含五个数字的列表开始，并从 collections 模块导入 Counter。然后，我们创建一个 Counter 对象，使用 c 来引用这个对象。接着，我们调用 most_common()方法，它返回一个按最常见元素排序的列表。

列表中的每个元素都是一个元组。第一个元组的第一个元素是最常见的数字，第二个元素是它出现的次数。第二、第三和第四个元组包含其他数字以及它们出现的次数。这个结果告诉我们 4 出现的次数最多（两次），而其他数字只出现了一次。请注意，出现次数相同的数字会按照任意顺序返回。

当你调用`most_common()`方法时，你还可以提供一个参数，告诉它你想返回多少个最常见的元素。例如，如果我们只想找到最常见的元素，我们会传入参数 1：

>>> c.most_common(1)

[(4, 2)]

如果你再次调用这个方法，并传入 2 作为参数，你将看到如下结果：

>>> c.most_common(2)

[(4, 2), (1, 1)]

现在，`most_common`方法返回的结果是一个包含两个元组的列表。第一个是出现最频繁的元素，紧随其后的是第二个最频繁的元素。当然，在这种情况下，有几个元素的出现频率相同，因此函数返回 1（而不是 2 或 3）是任意的，正如之前所提到的。

`most_common()`方法返回的是数字及其出现次数。如果我们只想要数字，而不关心它们出现的次数，该怎么办呢？我们可以这样获取这些信息：

➊ >>> mode = c.most_common(1)

>>> mode

[(4, 2)]

➋ >>> mode[0]

(4, 2)

➌ >>> mode[0][0]

4

在➊，我们使用`mode`标签来表示`most_common()`方法返回的结果。我们通过`mode[0]` ➋来获取这个列表的第一个（也是唯一一个）元素，得到一个元组。因为我们只需要元组中的第一个元素，所以我们可以通过`mode[0][0]` ➌来提取这个元素。这个值是 4——即最常见的元素，或者说是众数。

现在我们知道了`most_common()`方法的工作原理，我们将应用它来解决接下来的两个问题。

#### ***寻找众数***

我们已经准备好编写一个程序来查找一组数字的众数了：

'''

计算众数

'''

from collections import Counter

def calculate_mode(numbers):

➊     c = Counter(numbers)

➋     mode = c.most_common(1)

➌     return mode[0][0]

if __name__=='__main__':

scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]

mode = calculate_mode(scores)

print('这个数字列表的众数是：{0}'.format(mode))

`calculate_mode()`函数找到并返回传入的数字的众数。为了计算众数，我们首先从`collections`模块导入`Counter`类，并用它在➊创建一个`Counter`对象。然后，在➋，我们使用`most_common()`方法，正如之前所见，它返回一个包含元组的列表，元组里包含最常见的数字及其出现次数。我们将这个列表命名为`mode`。最后，我们使用`mode[0][0]` ➌来获取我们想要的数字：列表中出现次数最多的数字，即众数。

程序的其余部分应用`calculate_mode`函数处理我们之前看到的测试分数列表。运行程序后，你应该会看到以下输出：

这个数字列表的众数是：9

如果你的数据集中有两个或多个数字出现次数相同，并且是最大出现次数呢？例如，在数字列表[5, 5, 5, 4, 4, 4, 9, 1, 3]中，4 和 5 都出现了三次。在这种情况下，数字列表被称为具有多个众数，我们的程序应该找出并打印所有众数。修改后的程序如下：

'''

当数字列表可能发生变化时，计算众数

有多个众数

'''

from collections import Counter

def calculate_mode(numbers):

c = Counter(numbers)

➊     numbers_freq = c.most_common()

➋     max_count = numbers_freq[0][1]

modes = []

for num in numbers_freq:

➌         if num[1] == max_count:

modes.append(num[0])

return modes

if __name__ == '__main__':

scores = [5, 5, 5, 4, 4, 4, 9, 1, 3]

modes = calculate_mode(scores)

print('该数字列表的众数是：')

➍     for mode in modes:

print(mode)

在 ➊ 处，我们不仅仅找出最常见的元素，而是获取所有数字及其出现次数。接下来，在 ➋ 处，我们找出最大出现次数的值——即任何数字出现的最大次数。然后，对于每个数字，我们检查它出现的次数是否等于最大出现次数 ➌。每个满足这个条件的数字就是众数，我们将其添加到众数列表中并返回该列表。

在 ➍ 处，我们遍历 calculate_mode() 函数返回的列表，并打印每个数字。

当你执行上述程序时，应该会看到以下输出：

该数字列表的众数是：

4

5

如果你想找出每个数字出现的次数，而不仅仅是众数怎么办？*频率表*，顾名思义，是一个展示每个数字在数字集合中出现次数的表格。

#### ***创建频率表***

让我们再次考虑测试分数列表：7、8、9、2、10、9、9、9、9、4、5、6、1、5、6、7、8、6、1 和 10。该列表的频率表显示在 表格 3-1 中。对于每个数字，我们列出它在第二列中的出现次数。

**表格 3-1：** 频率表

| **得分** | **频率** |
| --- | --- |
| 1 | 2 |
| 2 | 1 |
| 4 | 1 |
| 5 | 2 |
| 6 | 3 |
| 7 | 2 |
| 8 | 2 |
| 9 | 5 |
| 10 | 2 |

注意，第二列中各个频率的总和等于总的分数数量（在这个例子中是 20）。

我们将再次使用 most_common() 方法来打印给定数字集合的频率表。回顾一下，当我们不为 most_common() 方法提供参数时，它会返回一个包含所有数字及其出现次数的元组列表。我们可以直接从这个列表打印每个数字及其频率，从而展示频率表。

以下是程序：

'''

数字列表的频率表

'''

from collections import Counter

def frequency_table(numbers):

➊     table = Counter(numbers)

print('数字\t 频率')

➋     for number in table.most_common():

print('{0}\t{1}'.format(number[0], number[1]))

if __name__=='__main__':

scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]

frequency_table(scores)

frequency_table() 函数打印传递给它的数字列表的频率表。在 ➊，我们首先创建一个 Counter 对象并创建标签表来引用它。接下来，使用 `for` 循环 ➋，我们遍历每个元组，打印第一个成员（数字本身）和第二个成员（对应数字的频率）。我们使用 `\t` 在每个值之间打印一个制表符来间隔表格。当你运行程序时，你会看到以下输出：

数字    频率

9       5

6       3

1       2

5       2

7       2

8       2

10      2

2       1

4       1

在这里，你可以看到数字按频率降序排列，因为 `most_common()` 函数返回的是这种顺序。如果你希望程序按值从低到高排序打印频率表，如表格 3-1 所示，那么你需要重新排序元组列表。

`sort()` 方法是我们修改之前频率表程序所需的全部内容：

'''

数字列表的频率表

增强功能以按数字排序显示表格

'''

from collections import Counter

def frequency_table(numbers):

table = Counter(numbers)

➊     numbers_freq = table.most_common()

➋     numbers_freq.sort()

print('数字\t 频率')

➌     for number in numbers_freq:

print('{0}\t{1}'.format(number[0], number[1]))

if __name__ == '__main__':

scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]

frequency_table(scores)

在这里，我们将通过调用 `most_common()` 方法返回的列表存储在 `numbers_freq` 中，标记为 ➊，然后通过调用 `sort()` 方法对其进行排序 ➋。最后，我们使用 `for` 循环遍历已排序的元组，并打印每个数字及其频率 ➌。现在，当你运行程序时，你会看到以下表格，它与表格 3-1 完全相同：

数字    频率

1       2

2       1

4       1

5       2

6       3

7       2

8       2

9       5

10      2

在本节中，我们已经讨论了均值、中位数和众数，它们是描述数字列表的三种常见度量。每个度量都有其用处，但当单独考虑时，它们也可能掩盖数据的其他方面。接下来，我们将讨论其他更高级的统计度量，这些度量可以帮助我们对数字集合得出更多结论。

### **衡量离散程度**

接下来我们要讨论的统计计算是衡量*离散程度*，它告诉我们数据集中的数字与数据集均值的距离。我们将学习如何计算三种不同的离散度量：极差、方差和标准差。

#### ***找出数字集合的极差***

再次考虑 A 期间的捐赠列表：100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000 和 1200。我们发现每天的平均捐赠为 477.75。但仅仅看平均值，我们无法知道所有捐赠是否集中在一个较小的范围内——比如 400 到 500 之间——还是在更广泛的范围内变化——比如 60 到 1200，如本例所示。对于一组数字，*范围*是最大值与最小值之间的差异。你可能有两个平均值相同的数字组，但它们的范围却差异很大，因此知道范围能提供比仅仅看平均值、中位数和众数更多的信息。

下一个程序计算前面提到的捐赠列表的范围：

'''

计算范围

'''

def find_range(numbers):

➊     lowest = min(numbers)

➋     highest = max(numbers)

# 计算范围

r = highest - lowest

➌     return lowest, highest, r

if __name__ == '__main__':

donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]

➍     lowest, highest, r = find_range(donations)

print('最小值: {0} 最大值: {1} 范围: {2}'.format(lowest, highest, r))

函数 find_range()接受一个列表作为参数并计算范围。首先，它使用 min()和 max()函数分别在➊和➋计算出最小值和最大值。正如函数名所示，它们分别找到数字列表中的最小值和最大值。

然后我们通过计算最大值和最小值之间的差异来计算范围，并用标签 r 表示这个差异。在➌处，我们返回所有三个数字——最小值、最大值和范围。这是本书中第一次从一个函数返回多个值——而不是仅返回一个值，这个函数返回三个值。在➍处，我们使用三个标签来*接收*从 find_range()函数返回的三个值。最后，我们打印这些值。当你运行程序时，应该会看到以下输出：

最小值: 60 最大值: 1200 范围: 1140

这告诉我们，捐赠总额在几天内分布较为均匀，范围为 1140，因为我们每天的捐赠总额从 60 到 1200 不等。

#### ***计算方差和标准差***

极差告诉我们一组数字中两个极值之间的差异，但如果我们想了解所有单个数字与平均值的偏差呢？它们是否都相似，集中在平均值附近，还是它们都很不同，更接近极值？有两个相关的离散度度量可以帮助我们了解这些数字的分布：*方差* 和 *标准差*。要计算这两个度量中的任何一个，首先需要找到每个数字与平均值的差异。方差是这些差异平方的平均值。较高的方差意味着数值远离平均值；较低的方差意味着数值集中在平均值附近。我们使用以下公式来计算方差。

![image](img/e0073-01.jpg)

在公式中，*x[i]* 代表单个数字（在此情况下为每日总捐款），*x*[mean] 代表这些数字的平均值（每日平均捐款），*n* 是列表中的值的数量（即接受捐款的天数）。对于列表中的每个值，我们计算该数字与平均值的差异并将其平方。然后，我们将所有这些平方差加在一起，最后用 *n* 除以总和，得到方差。

如果我们还想计算标准差，所需要做的就是取方差的平方根。那些在平均值一个标准差以内的数值可以认为是相当典型的，而那些离平均值三个或更多标准差远的数值则可以被视为更不典型——我们称这样的数值为 *离群值*。

为什么我们需要这两种离散度度量——方差和标准差？简而言之，这两个度量在不同情况下各有用处。回到我们用于计算方差的公式，你可以看到方差以平方单位表示，因为它是与平均值差异的平方的平均值。对于某些数学公式，使用这些平方单位而不是取平方根来计算标准差会更加方便。另一方面，标准差以与总体数据相同的单位表示。例如，如果我们计算捐款列表的方差（就像我们接下来要做的那样），结果将以“美元平方”表示，这并不太有意义。而标准差则直接以“美元”表示，与每笔捐款的单位相同。

以下程序用于计算一组数字的方差和标准差：

'''

计算一组数字的方差和标准差

'''

def calculate_mean(numbers):

s = sum(numbers)

N = len(numbers)

# 计算平均值

mean = s / N

return mean

def find_differences(numbers):

# 计算平均值

mean = calculate_mean(numbers)

# 找出与平均值的差异

diff = []

for num in numbers:

diff.append(num - mean)

return diff

def calculate_variance(numbers):

# 找出差异列表

➊     diff = find_differences(numbers)

# 计算平方差

squared_diff = []

➋     for d in diff:

squared_diff.append(d**2)

# 计算方差

sum_squared_diff = sum(squared_diff)

➌     variance = sum_squared_diff/len(numbers)

return variance

if __name__ == '__main__':

donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]

variance = calculate_variance(donations)

print('这个数字列表的方差是{0}'.format(variance))

➍     std = variance**0.5

print('这个数字列表的标准差是{0}'.format(std))

函数 calculate_variance()计算传递给它的数字列表的方差。首先，它在➊调用 find_differences()函数来计算每个数字与平均值之间的差异。find_differences()函数返回每个捐款与平均值之间的差异，作为一个列表。在这个函数中，我们使用之前写的 calculate_mean()函数来计算平均捐款。接下来，从➋开始，计算这些差异的平方，并将结果保存到一个名为 squared_diff 的列表中。然后，我们使用 sum()函数计算这些平方差的总和，最后在➌处计算方差。在➍处，我们通过取方差的平方根来计算标准差。

当你运行前面的程序时，应该会看到以下输出：

这个数字列表的方差是 141047.35416666666

这个数字列表的标准差是 375.5627166887931

方差和标准差都非常大，这意味着单个每日捐赠总额与平均值的偏差很大。现在，让我们比较另一组具有相同平均值的捐款：382、389、377、397、396、368、369、392、398、367、393 和 396。在这种情况下，方差和标准差分别为 135.38888888888889 和 11.63567311713804。方差和标准差的较低值告诉我们，个别数字更接近平均值。图 3-1 通过图示直观展示了这一点。

![image](img/f03-01.jpg)

*图 3-1：捐款的变化与平均捐款的关系*

两组捐款的平均值相似，因此图中的两条线重叠，看起来像一条单一的线。然而，第一组捐款与平均值的差异较大，而第二组捐款则非常接近平均值，这验证了我们从较低方差值推断出的结论。

### **计算两个数据集之间的相关性**

在本节中，我们将学习如何计算一种统计度量，它告诉我们两组数字之间关系的性质和强度：*皮尔逊相关系数*，我将简称为 *相关系数*。请注意，这个系数衡量的是*线性*关系的强度。如果两组数据之间存在非线性关系，我们需要使用其他度量方法（我们这里不讨论）来找到相应的系数。该系数可以是正值也可以是负值，且其大小范围在 –1 到 1 之间（包括 –1 和 1）。

相关系数为 0 表示两者之间没有线性相关性。（注意，这并不意味着这两个变量彼此独立，它们之间可能仍然存在非线性关系）。系数为 1 或接近 1 表示存在强的正线性相关性；当系数为 1 时，称为完全正相关。类似地，相关系数为 –1 或接近 –1 表示存在强的负相关性，其中 –1 表示完全负相关。

**相关性与因果性**

在统计学中，你常常会遇到“相关性不意味着因果性”这一说法。这提醒我们，即使两组观察数据之间存在强相关，也不意味着一个变量*导致*了另一个变量。当两个变量之间存在强相关时，有时会有第三个因素影响这两个变量，从而解释相关性。一个经典例子是冰淇淋销售和犯罪率之间的相关性——如果你在一个典型城市中跟踪这两个变量，你可能会发现它们之间有相关性，但这并不意味着冰淇淋销售导致了犯罪（反之亦然）。冰淇淋销售和犯罪之间的相关性，实际上是因为夏天气温变热时，它们都会增加。当然，这并不意味着热天气直接导致犯罪率上升；这其中还有其他更复杂的原因。

#### ***计算相关系数***

相关系数是通过以下公式计算的：

![image](img/e0076-01.jpg)

在上述公式中，*n* 是每组数字中值的总数（这两组数据必须长度相等）。这两组数据分别用 *x* 和 *y* 表示（你可以任意选择哪个表示哪个）。其他项的含义如下：

| Σ*xy* | 两组数字 *x* 和 *y* 中各个元素乘积的总和 |
| --- | --- |
| Σ*x* | 集合 *x* 中数字的总和 |
| Σ*y* | 集合 *y* 中数字的总和 |
| (Σ*x*)² | 集合 *x* 中数字总和的平方 |
| (Σ*y*)² | 集合 *y* 中数字总和的平方 |
| Σ*x*² | 集合 *x* 中数字的平方和 |
| Σ*y*² | 集合 *y* 中数字的平方和 |

一旦我们计算出这些项，你就可以根据前面的公式将它们结合起来计算相关系数。对于小的列表，这个过程可以手动完成，而且不太麻烦，但随着每个数值集合的增大，计算会变得更加复杂。  

稍后，我们将编写一个程序来计算相关系数。在这个程序中，我们将使用 zip() 函数，它帮助我们计算两个数值集合的乘积和。下面是 zip() 函数如何工作的示例：  

>>> simple_list1 = [1, 2, 3]  

>>> simple_list2 = [4, 5, 6]  

>>> for x, y in zip(simple_list1, simple_list2):  

print(x, y)  

1 4  

2 5  

3 6  

zip() 函数返回 x 和 y 中对应元素的配对，你可以在循环中使用这些配对进行其他操作（例如打印，如前面的代码所示）。如果两个列表长度不一致，函数将在较小列表的所有元素被读取完后终止。  

现在我们准备编写一个程序，计算相关系数：  

def find_corr_x_y(x, y):  

n = len(x)  

# 计算乘积和  

prod = []  

➊       for xi, yi in zip(x, y):  

prod.append(xi*yi)  

➋       sum_prod_x_y = sum(prod)  

➌       sum_x = sum(x)  

➍       sum_y = sum(y)  

squared_sum_x = sum_x**2  

squared_sum_y = sum_y**2

x_square = []  

➎       for xi in x:  

x_square.append(xi**2)  

# 计算和  

x_square_sum = sum(x_square)  

y_square = []  

for yi in y:  

y_square.append(yi**2)  

# 计算和  

y_square_sum = sum(y_square)  

# 使用公式计算相关性  

➏       numerator = n*sum_prod_x_y - sum_x*sum_y  

denominator_term1 = n*x_square_sum - squared_sum_x  

denominator_term2 = n*y_square_sum - squared_sum_y  

➐       denominator = (denominator_term1*denominator_term2)**0.5  

➑       correlation = numerator / denominator  

return correlation  

find_corr_x_y() 函数接受两个参数，x 和 y，它们是我们希望计算相关性的两个数值集合。在该函数的开始，我们找到列表的长度，并创建一个标签 n 来表示它。接着，在 ➊ 中，我们使用 zip() 函数进行 for 循环，计算每对列表中对应元素的乘积（依次将每个列表中的第一个项、第二个项等相乘）。我们使用 append() 方法将这些乘积添加到名为 prod 的列表中。  

在 ➋，我们使用 sum() 函数计算 prod 中存储的乘积和。在 ➌ 和 ➍ 中，我们分别计算 x 和 y 中数值的和（再次使用 sum() 函数）。然后，我们计算 x 和 y 中元素和的平方，并分别用 squared_sum_x 和 squared_sum_y 来表示它们。  

在从➎开始的循环中，我们计算 x 中每个元素的平方，并求出这些平方的和。然后，我们对 y 中的元素进行相同的操作。现在我们已经拥有了计算相关性所需的所有项，并且我们将在➏、➐和➑的语句中完成这一计算。最后，我们返回相关性。相关性是统计研究中常引用的一个度量——无论是在大众媒体还是科学文章中。我们有时提前知道存在相关性，只是想了解这一相关性的强度。在第 86 页的“从 CSV 文件读取数据”一节中，我们将看到一个例子，演示如何计算从文件读取的数据之间的相关性。其他时候，我们可能只是怀疑数据之间存在相关性，需要进一步研究数据以验证是否确实存在这种关系（如以下例子所示）。

#### ***高中成绩与大学入学考试表现***

在这一部分，我们将考虑一个虚构的 10 人高中生小组，探讨他们的高中成绩与大学入学考试成绩之间是否存在关系。表 3-2 列出了我们为研究假定的数据，并将以此为基础进行实验。“高中成绩”一列列出了学生的高中成绩百分比，而“大学入学考试成绩”一列则展示了他们在大学入学考试中的百分比成绩。

**表 3-2：** 高中成绩与大学入学考试表现

| **高中成绩** | **大学入学考试成绩** |
| --- | --- |
| 90 | 85 |
| 92 | 87 |
| 95 | 86 |
| 96 | 97 |
| 87 | 96 |
| 87 | 88 |
| 90 | 89 |
| 95 | 98 |
| 98 | 98 |
| 96 | 87 |

为了分析这些数据，我们来看一下*散点图*。图 3-2 展示了前述数据集的散点图，*x*-轴表示高中成绩，*y*-轴表示相应的大学入学考试成绩。

![image](img/f03-02.jpg)

*图 3-2：高中成绩与大学入学考试成绩的散点图*

数据图表显示，高中成绩最好的学生在大学入学考试中的表现并不一定更好，反之亦然。一些高中成绩较差的学生在大学入学考试中表现非常好，而一些成绩优秀的学生则在大学考试中表现相对较差。如果我们计算这两个数据集的相关系数（使用我们之前的程序），会发现其大约为 0.32。这意味着两者之间有一定的相关性，但并不很强。如果相关性接近 1，我们将在散点图中看到这一点——数据点将更紧密地沿着一条直线分布。

假设表 3-2 中展示的高中成绩是数学、科学、英语和社会科学各科成绩的平均值。我们还假设大学考试对数学的重视程度较高——比其他科目更为重要。与其看学生的总体高中成绩，不如仅看他们的数学成绩，以此判断数学成绩是否能更好地预测他们的大学考试成绩。表 3-3 现在仅显示数学成绩（按百分位表示）和大学入学考试成绩。相应的散点图展示在图 3-3 中。

**表 3-3：** 高中数学成绩与大学入学考试成绩

| **高中数学成绩** | **大学入学考试成绩** |
| --- | --- |
| 83 | 85 |
| 85 | 87 |
| 84 | 86 |
| 96 | 97 |
| 94 | 96 |
| 86 | 88 |
| 87 | 89 |
| 97 | 98 |
| 97 | 98 |
| 85 | 87 |

现在，散点图（图 3-3）显示数据点几乎完全沿直线分布。这表明高中数学成绩与大学入学考试成绩之间有很高的相关性。在这种情况下，相关系数约为 1。借助散点图和相关系数，我们可以得出结论，确实存在高中数学成绩与大学入学考试成绩之间的强关系。

![image](img/f03-03.jpg)

*图 3-3：高中数学成绩与大学入学考试成绩的散点图*

### **散点图**

在前一节中，我们看到了散点图如何帮助我们初步判断两组数据之间是否存在相关性。在这一节中，我们将通过分析四组数据集来展示散点图分析的重要性。对于这些数据集，常规的统计量结果完全相同，但每个数据集的散点图揭示了重要的差异。

首先，让我们了解如何在 Python 中创建散点图：

>>> x = [1, 2, 3, 4]

>>> y = [2, 4, 6, 8]

>>> import matplotlib.pyplot as plt

➊ >>> plt.scatter(x, y)

<matplotlib.collections.PathCollection object at 0x7f351825d550>

>>> plt.show()

scatter() 函数用于在两个数字列表 x 和 y 之间创建散点图 ➊。与我们在第二章中创建的图表唯一的区别是，这里我们使用 scatter() 函数，而不是 plot() 函数。再次提醒，我们需要调用 show() 来显示图表。

要了解更多关于散点图的内容，我们来看一项重要的统计学研究：“统计分析中的图表”，作者是统计学家 Francis Anscombe。¹ 该研究考虑了四组不同的数据集——统称为*安斯科姆四重奏*——这些数据集具有相同的统计特性：均值、方差和相关系数。

数据集如表 3-4 所示（来自原始研究的复刻）。

**表 3-4：** 安斯科姆四重奏—四个几乎相同统计量的不同数据集

| **A** | **B** | **C** | **D** |
| --- | --- | --- | --- |
| **X1** | **Y1** | **X2** | **Y2** | **X3** | **Y3** | **X4** | **Y4** |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 10.0 | 8.04 | 10.0 | 9.14 | 10.0 | 7.46 | 8.0 | 6.58 |
| 8.0 | 6.95 | 8.0 | 8.14 | 8.0 | 6.77 | 8.0 | 5.76 |
| 13.0 | 7.58 | 13.0 | 8.74 | 13.0 | 12.74 | 8.0 | 7.71 |
| 9.0 | 8.81 | 9.0 | 8.77 | 9.0 | 7.11 | 8.0 | 8.84 |
| 11.0 | 8.33 | 11.0 | 9.26 | 11.0 | 7.81 | 8.0 | 8.47 |
| 14.0 | 9.96 | 14.0 | 8.10 | 14.0 | 8.84 | 8.0 | 7.04 |
| 6.0 | 7.24 | 6.0 | 6.13 | 6.0 | 6.08 | 8.0 | 5.25 |
| 4.0 | 4.26 | 4.0 | 3.10 | 4.0 | 5.39 | 19.0 | 12.50 |
| 12.0 | 10.84 | 12.0 | 9.13 | 12.0 | 8.15 | 8.0 | 5.56 |
| 7.0 | 4.82 | 7.0 | 7.26 | 7.0 | 6.42 | 8.0 | 7.91 |
| 5.0 | 5.68 | 5.0 | 4.74 | 5.0 | 5.73 | 8.0 | 6.89 |

我们将称（X1, Y1）、（X2, Y2）、（X3, Y3）和（X4, Y4）为数据集 A、B、C 和 D。表 3-5 展示了这些数据集的统计量，结果四舍五入至小数点后两位。

**表 3-5：** 安斯科姆四重奏—统计量

| **数据集** | **X** | **Y** |
| --- | --- | --- |
| **均值** | **标准差** | **均值** | **标准差** | **相关性** |
| --- | --- | --- | --- | --- |
| A | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |
| B | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |
| C | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |
| D | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |

每个数据集的散点图见于图 3-4。

![image](img/f03-04.jpg)

*图 3-4：安斯科姆四重奏的散点图*

如果我们仅仅看传统的统计量（参见表 3-5）——如均值、标准差和相关系数——这些数据集看起来几乎是一样的。但散点图显示，这些数据集实际上彼此差异很大。因此，散点图可以是一个重要工具，应该与其他统计量一起使用，在对数据集做出任何结论之前。

### **从文件中读取数据**

在本章的所有程序中，我们用来计算的数字列表都是直接写入程序中的，或者是*硬编码*的。如果你想要为不同的数据集找到这些统计量，你必须在程序中输入整个新的数据集。你也知道如何制作让用户输入数据的程序，但对于大数据集，每次让用户输入长长的数字列表并不方便。

一个更好的选择是从文件中读取用户数据。让我们来看一个简单的例子，展示如何从文件中读取数字并对其进行数学运算。首先，我将展示如何从一个简单的文本文件中读取数据，文件的每一行包含一个新的数据元素。然后，我将展示如何从一个数据以广为人知的 CSV 格式存储的文件中读取数据，这将开辟很多可能性，因为有大量有用的数据集可以从互联网上以 CSV 格式下载。（如果你不熟悉 Python 中的文件操作，可以参考附录 B 中的简要介绍。）

#### ***从文本文件中读取数据***

让我们来看一个文件*mydata.txt*，其中包含我们在本章开头考虑的 A 期捐赠列表（每行一个）：

100

60

70

900

100

200

500

500

503

600

1000

1200

以下程序将读取此文件并打印存储在文件中的数字的总和：

# 计算存储在文件中的数字的总和

def sum_data(filename):

s = 0

➊     with open(filename) as f:

for line in f:

➋           s = s + float(line)

print('数字的总和: {0}'.format(s))

if __name__ == '__main__':

sum_data('mydata.txt')

sum_data()函数在➊处打开由参数 filename 指定的文件，并逐行读取（f 被称为*文件对象*，你可以把它看作是指向已打开文件的指针）。在➋处，我们使用 float()函数将每个数字转换为浮点数，然后继续相加，直到读取完所有数字。最终的数字，标记为 s，保存了所有数字的总和，并在函数末尾打印出来。

在运行程序之前，你必须首先创建一个名为*mydata.txt*的文件，并将适当的数据保存到与程序相同的目录中。你可以通过 IDLE 本身创建此文件，方法是点击**文件**▸**新建窗口**，在新窗口中输入数字（每行一个），然后将文件保存为*mydata.txt*，并保存在与程序相同的目录中。现在，如果你运行程序，你将看到以下输出：

数字的总和: 5733.0

本章中所有的程序都假设输入数据是以列表的形式提供的。为了在文件数据上使用我们之前编写的程序，我们需要首先从这些数据中创建一个列表。一旦我们有了列表，就可以使用之前编写的函数来计算相应的统计量。以下程序计算存储在文件*mydata.txt*中的数字的平均值：

'''

计算存储在文件中的数字的平均值

'''

def read_data(filename):

numbers = []

with open(filename) as f:

for line in f:

➊           numbers.append(float(line))

return numbers

def calculate_mean(numbers):

s = sum(numbers)

N = len(numbers)

mean = s / N

return mean

if __name__ == '__main__':

➋     data = read_data('mydata.txt')

mean = calculate_mean(data)

print('平均值: {0}'.format(mean))

在我们调用 calculate_mean()函数之前，我们需要读取存储在文件中的数字并将其转换为列表。为此，使用 read_data()函数，它逐行读取文件。该函数不是求和数字，而是将它们转换为浮动点数并将它们添加到列表 numbers ➊中。列表返回后，我们通过标签 data ➋来引用它。然后我们调用 calculate_mean()函数，它返回数据的均值。最后，我们打印出来。

当你运行程序时，应该看到以下输出：

Mean: 477.75

当然，如果文件中的数字与你这个示例中的数字不同，你会看到一个不同的均值。

请参阅附录 B 了解如何提示用户输入文件名并相应地修改程序。这将允许你的程序用户指定任何数据文件。

#### ***从 CSV 文件读取数据***

一个逗号分隔值（CSV）文件由行和列组成，列之间由逗号分隔。你可以使用操作系统上的文本编辑器或专门的软件（如 Microsoft Excel、OpenOffice Calc 或 LibreOffice Calc）查看 CSV 文件。

这是一个包含一些数字及其平方值的 CSV 文件示例：

Number,Squared

10,100

9,81

22,484

第一行被称为*头部*。在这个例子中，它告诉我们文件中第一列的条目是数字，而第二列的条目是对应的平方值。接下来的三行或行包含一个数字及其平方值，两者之间用逗号分隔。使用与我之前展示的*.txt*文件类似的方法，可以读取此文件中的数据。但是，Python 的标准库有一个专门的模块(csv)，用于读取（和写入）CSV 文件，这使得事情变得稍微简单一些。

将数字及其平方保存到一个名为*numbers.csv*的文件中，并放在与你的程序相同的目录中。以下程序演示了如何读取此文件，然后创建一个散点图，显示数字与其平方之间的关系：

import csv

import matplotlib.pyplot as plt

def scatter_plot(x, y):

plt.scatter(x, y)

plt.xlabel('Number')

plt.ylabel('Square')

plt.show()

def read_csv(filename):

numbers = []

squared = []

with open(filename) as f:

➊          reader = csv.reader(f)

next(reader)

➋          for row in reader:

numbers.append(int(row[0]))

squared.append(int(row[1]))

return numbers, squared

if __name__ == '__main__':

numbers, squared = read_csv('numbers.csv')

scatter_plot(numbers, squared)

read_csv()函数使用 csv 模块中定义的 reader()函数读取 CSV 文件（该模块在程序开头已被导入）。此函数以文件对象 f 作为参数调用➊。该函数返回指向 CSV 文件第一行的*指针*。我们知道文件的第一行是表头，我们想要跳过它，因此我们使用 next()函数将指针移动到下一行。接着，我们读取文件的每一行，每行通过标签 row 表示➋，其中 row[0]表示数据的第一列，row[1]表示第二列。对于这个特定的文件，我们知道这两个数字都是整数，因此我们使用 int()函数将它们从字符串转换为整数，并将其存储在两个列表中。然后返回这两个列表——一个包含数字，另一个包含这些数字的平方。

然后，我们调用 scatter_plot()函数，传入这两个列表来创建散点图。我们之前写的 find_corr_x_y()函数也可以很容易地用来计算这两个数字集之间的相关系数。

现在让我们尝试处理一个更复杂的 CSV 文件。打开*[`www.google.com/trends/correlate/`](https://www.google.com/trends/correlate/)*，在浏览器中输入你想要的任何搜索查询（例如，*summer*），然后点击**搜索相关性**按钮。你会看到在“与夏天相关”的标题下返回了一些结果，第一个结果是相关性最高的（每个结果左侧的数字）。点击图表上方的**散点图**选项，查看一个散点图，*x*轴标记为*summer*，*y*轴标记为顶部结果。忽略两个轴上绘制的确切数字，因为我们只对相关性和散点图感兴趣。

在散点图上方，点击**导出数据为 CSV**，文件下载将开始。将此文件保存在与你的程序相同的目录下。

这个 CSV 文件与我们之前看到的稍有不同。文件开始部分会有一些空行和带有“#”符号的行，直到最后你会看到表头和数据。这些行对我们没有用——请使用你打开文件的任何软件手动删除它们，确保文件的第一行是表头。同时，删除文件末尾的任何空行。现在保存文件。这个步骤——我们清理文件以便更容易用 Python 处理——通常叫做*数据预处理*。

头部包含多个列。第一列包含每行数据的日期（每行的数据对应于从该日期开始的一周）。第二列是你输入的搜索查询，第三列显示与您的搜索查询具有*最高*相关性的搜索查询，其他列包括多个其他搜索查询，这些查询按与您输入的搜索查询的相关性递减顺序排列。这些列中的数字是相应搜索查询的*z*分数。*z*分数表示某个术语在特定一周内的搜索次数与该术语每周总体平均搜索次数之间的差异。正*z*分数表示该周的搜索次数高于该周的平均水平，而负*z*分数表示搜索次数低于该周的平均水平。

现在，我们只处理第二列和第三列。你可以使用以下 read_csv()函数来读取这些列：

def read_csv(filename):

with open(filename) as f:

reader = csv.reader(f)

next(reader)

summer = []

highest_correlated = []

➊         for row in reader:

summer.append(float(row[1]))

highest_correlated.append(float(row[2]))

return summer, highest_correlated

这与早期版本的 read_csv 函数非常相似；这里的主要变化是我们如何从➊开始将值添加到每个列表：我们现在读取每行的第二和第三个成员，并将它们作为浮动点数存储。

以下程序使用此函数计算你提供的搜索查询值与与其具有最高相关性的查询值之间的相关性。它还生成这些值的散点图：

import matplotlib.pyplot as plt

import csv

if __name__ == '__main__':

➊     summer, highest_correlated = read_csv('correlate-summer.csv')

corr = find_corr_x_y(summer, highest_correlated)

print('最高相关性: {0}'.format(corr))

scatter_plot(summer, highest_correlated)

假设 CSV 文件保存为*correlate-summer.csv*，我们调用 read_csv()函数读取第二列和第三列的数据 ➊。然后，我们调用之前编写的 find_corr_x_y()函数，传入两个列表 summer 和 highest_correlated。它返回相关系数，我们将其打印出来。接下来，我们再次调用之前编写的 scatter_plot()函数，传入这两个列表。在运行该程序之前，你需要包括 read_csv()、find_corr_x_y()和 scatter_plot()函数的定义。

运行时，你将看到它打印出相关系数，并且还会生成一个散点图。这两者应该与 Google 相关网站上显示的数据非常相似。

### **你学到的东西**

在本章中，你学习了计算统计量来描述一组数字以及数字集合之间的关系。你还使用图表来帮助理解这些统计量。在编写程序来计算这些统计量的过程中，你学习了许多新的编程工具和概念。

### **编程挑战**

接下来，应用你所学的知识，完成以下编程挑战。

#### ***#1: 更好的相关系数–查找程序***

我们之前编写的 find_corr_x_y() 函数用来计算两个数字集合之间的相关系数，假设这两个集合的长度是相同的。改进这个函数，使其首先检查列表的长度。如果它们相等，则函数继续进行剩余的计算；否则，它应打印错误信息，表示无法找到相关系数。

#### ***#2: 统计计算器***

实现一个统计计算器，它从文件 *mydata.txt* 中读取数字列表，然后使用本章早些时候编写的函数计算并打印它们的均值、中位数、众数、方差和标准差。

#### ***#3: 尝试其他 CSV 数据***

你可以自由地尝试互联网上许多有趣的免费数据源。网站 *[`www.quandl.com/`](http://www.quandl.com/)* 就是一个这样的数据源。对于这个挑战，从 *[`www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/`](http://www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/)* 下载以下数据作为 CVS 文件：1960 到 2012 年间美国每年年底的总人口数。然后，计算这些年间人口差异的均值、中位数、方差和标准差，并创建一个图表来展示这些差异。

#### ***#4: 查找百分位数***

百分位数是一个常用的统计量，表示给定百分比的观测值低于该值。例如，如果一名学生在考试中获得了 95 百分位数的成绩，这意味着 95% 的学生得分低于或等于该学生的成绩。另一个例子是，在数字列表 5、1、9、3、14、9 和 7 中，第 50 百分位数是 7，第 25 百分位数是 3.5，这是一个列表中没有的数字。

有多种方法可以找到与给定百分位数对应的观测值，这里介绍一种方法。²

假设我们想要计算百分位数 *p* 处的观测值：

1. 将给定的数字列表按升序排序，我们可以将其称为 data。

2. 计算

![image](img/e0090-01.jpg)

其中 *n* 是 data 中项目的数量。

3. 如果 *i* 是整数，则 data[i] 是与百分位数 *p* 对应的数字。

4. 如果 *i* 不是整数，则将 *k* 设为 *i* 的整数部分，*f* 设为 *i* 的小数部分。数字 (1-f)*data[k] + f*data[k+1] 即为百分位数 *p* 处的数字。

使用这种方法，编写一个程序，从文件中获取一组数字，并显示与输入的特定百分位数相对应的数字。

#### ***#5: 创建分组频率表***

对于这个挑战，你的任务是编写一个程序，从一组数字中创建分组频率表。分组频率表显示了数据在不同*类*中的频率。例如，我们考虑在 “创建频率表” 中讨论的分数，位于 第 69 页：7, 8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1 和 10。分组频率表将如下所示显示这些数据：

| **等级** | **频率** |
| --- | --- |
| 1–6 | 6 |
| 6–11 | 14 |

该表将等级分为两个类：1–6（包括 1，但不包括 6）和 6–11（包括 6，但不包括 11）。它显示每个类别中属于的等级数。确定类的数量和每个类中的数字范围是创建此表的两个关键步骤。在这个例子中，我展示了两个类，每个类中的数字范围平分给这两个类。

这里有一种简单的方法来创建类，它假设类的数量可以随意选择：

def create_classes(numbers, n):

low = min(numbers)

high = max(numbers)

# 每个类的宽度

width = (high - low) / n

classes = []

a = low

b = low + width

classes = []

while a < (high - width):

classes.append((a, b))

a = b

b = a + width

# 最后一组可能比宽度小

classes.append((a, high+1))

return classes

create_classes() 函数接受两个参数：一个数字列表 numbers 和 n（要创建的类的数量）。它将返回一个元组列表，每个元组代表一个类。例如，如果调用时输入的数字是 7, 8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1, 10，且 n = 4，它将返回以下列表：[(1, 3.25), (3.25, 5.5), (5.5, 7.75), (7.75, 11)]。一旦得到列表，下一步是遍历每个数字，找出它属于返回的哪个类。

你的挑战是编写一个程序，从文件中读取一组数字，并使用 create_classes() 函数打印分组频率表。
