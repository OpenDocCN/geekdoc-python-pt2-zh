## **2**

**使用图形可视化数据**

![image](img/common-01.jpg)

在本章中，你将学习一种强大的展示数值数据的方式：使用 Python 绘制图表。我们将从讨论数轴和笛卡尔平面开始。接下来，我们将了解强大的绘图库*matplotlib*以及如何使用它来创建图表。然后，我们将探索如何制作清晰且直观地展示数据的图表。最后，我们将使用图表来探索牛顿的万有引力定律和抛体运动。让我们开始吧！

### **理解笛卡尔坐标平面**

考虑一下*数轴*，如图 2-1 所示。–3 到 3 之间的整数标记在数轴上，但这两个数字之间的任何位置（比如 1 和 2 之间）都有所有可能的数字：1.1，1.2，1.3，依此类推。

![image](img/f02-01.jpg)

*图 2-1：数轴*

数轴使得某些属性在视觉上变得直观。例如，0 右侧的所有数字都是正数，左侧的则是负数。当一个数字*a*位于另一个数字*b*的右侧时，*a*总是大于*b*，而*b*总是小于*a*。

数轴两端的箭头表示这条线延伸到无限远，且这条线上的任何一点都对应一个实数，无论它有多大。一个数字足以描述数轴上的一点。

现在，考虑如图 2-2 所示的两条数轴。这两条数轴相交成直角，并在每条轴的 0 点交叉。这形成了一个*笛卡尔坐标平面*，或称*x*-*y*平面，水平的数轴叫做*x*轴，垂直的数轴叫做*y*轴。

![image](img/f02-02.jpg)

*图 2-2：笛卡尔坐标平面*

与数轴一样，我们可以在平面上有无限多个点。我们用一对数字来描述一个点，而不是用一个数字。例如，我们用两个数字*x*和*y*来描述图中的点*A*，通常写作(*x*, *y*)，并称之为该点的*坐标*。如图 2-2 所示，*x*是该点沿*x*轴到原点的距离，*y*是该点沿*y*轴的距离。两条坐标轴的交点称为*原点*，坐标为(0, 0)。

笛卡尔坐标平面使我们能够直观地展示两个数字集合之间的关系。在这里，我使用 *集合* 这个词来泛指一组数字。（我们将在 第五章 学习数学集合及如何在 Python 中操作它们。）无论这两个数字集合代表什么——温度、棒球得分或班级测试分数——你只需要这些数字本身。然后，你可以将它们绘制出来——无论是在图表纸上，还是通过在 Python 中编写程序在电脑上绘制。从本书的这一部分开始，我将使用 *绘制* 作为动词，描述绘制两个数字集合的行为，而使用 *图形* 来描述结果——一条线、一条曲线，或仅仅是笛卡尔平面上的一组点。

### **处理列表和元组**

在我们使用 Python 绘制图形时，我们将使用 *列表* 和 *元组*。在 Python 中，这两者是存储一组值的两种不同方式。大部分情况下，元组和列表非常相似，唯一的主要区别是：创建列表后，可以向其中添加值并改变值的顺序。另一方面，元组中的值一旦确定，就无法更改。我们将使用列表来存储我们要绘制的点的 *x* 和 *y* 坐标。元组将在 “定制图形” 中出现，出现在 第 41 页，当我们学习如何定制图形的范围时。首先，让我们回顾一下列表的一些特性。

你可以通过在方括号中输入用逗号分隔的值来创建一个列表。以下语句创建了一个列表，并使用标签 simplelist 来引用它：

>>> simplelist = [1, 2, 3]

现在，你可以通过标签和数字在列表中的位置来引用单个数字——1、2 和 3，这个位置叫做 *索引*。因此，simplelist[0] 指代第一个数字，simplelist[1] 指代第二个数字，simplelist[2] 指代第三个数字：

>>> simplelist[0]

1

>>> simplelist[1]

2

>>> simplelist[2]

3

请注意，列表的第一个项目位于索引 0，第二个项目位于索引 1，依此类推——也就是说，列表中的位置从 0 开始计数，而不是从 1 开始。

列表也可以存储字符串：

>>> stringlist = ['a string', 'b string', 'c string']

>>> stringlist[0]

'a string'

>>> stringlist[1]

'b string'

>>> stringlist[2]

'c string'

创建列表的一个优点是你不需要为每个值创建一个单独的标签；你只需为列表创建一个标签，并使用索引位置来引用每个项目。此外，你可以在需要时将新值添加到列表中，因此，如果你无法预先知道需要存储多少数字或字符串，列表是存储数据的最佳选择。

*空列表* 就是一个没有任何项目或元素的列表，它可以通过如下方式创建：

>>> emptylist = []

空列表主要在你事先不知道列表中的任何元素，但计划在程序执行过程中添加值时很有用。在这种情况下，你可以创建一个空列表，然后使用 append() 方法稍后添加项：

➊ >>> emptylist

[]

➋ >>> emptylist.append(1)

>>> emptylist

[1]

➌ >>> emptylist.append(2)

>>> emptylist

➍ [1, 2]

在 ➊ 处，emptylist 开始为空。接着，我们在 ➋ 处将数字 1 添加到列表中，在 ➌ 处添加 2。到 ➍ 行时，列表变为 [1, 2]。请注意，当你使用 .append() 时，值会被添加到列表的末尾。这只是向列表添加值的一种方式，其他方法我们在本章中不需要介绍。

创建元组与创建列表类似，不同的是你使用圆括号而不是方括号：

>>> simpletuple = (1, 2, 3)

你可以像对待列表一样，使用相应的索引引用 simpletuple 中的单个元素：

>>> simpletuple[0]

1

>>> simpletuple[1]

2

>>> simpletuple[2]

3

你也可以在列表和元组中使用*负索引*。例如，simplelist[-1] 和 simpletuple[-1] 会引用列表或元组中的最后一个元素，simplelist[-2] 和 simpletuple[-2] 会引用倒数第二个元素，以此类推。

元组像列表一样，可以有字符串作为值，你也可以创建一个*空元组*，其没有任何元素，例如 emptytuple=()。然而，元组没有 append() 方法来添加新的值，所以你无法向空元组添加值。一旦创建了元组，元组的内容就不能改变。

#### ***遍历列表或元组***

我们可以使用 for 循环来遍历列表或元组，如下所示：

>>> l = [1, 2, 3]

>>> for item in l:

print(item)

这将打印列表中的项：

1

2

3

元组中的项可以以相同的方式进行检索。

有时你可能需要知道列表或元组中某个项的位置或索引。你可以使用 enumerate() 函数遍历列表中的所有项，并返回项的索引以及该项本身。我们使用标签 index 和 item 来表示它们：

>>> l = [1, 2, 3]

>>> for index, item in enumerate(l):

print(index, item)

这将产生以下输出：

0 1

1 2

2 3

这同样适用于元组。

### **使用 Matplotlib 创建图表**

我们将使用 matplotlib 来使用 Python 绘制图表。Matplotlib 是一个 Python *包*，意味着它是一个包含相关功能模块的集合。在本例中，这些模块用于绘制数字和生成图表。Matplotlib 并没有与 Python 的标准库一起内置，因此你需要安装它。安装说明可以在 附录 A 中找到。安装完成后，启动一个 Python shell。按照安装说明，你可以继续使用 IDLE shell 或使用 Python 的内建 shell。

现在我们准备创建第一个图表。我们将从一个简单的图表开始，只包含三个点：(1, 2)、(2, 4) 和 (3, 6)。为了创建这个图表，我们首先创建两个数字列表——一个存储这些点的 *x*-坐标，另一个存储 *y*-坐标。以下两个语句正是执行此操作，创建了两个列表 x_numbers 和 y_numbers：

>>> x_numbers = [1, 2, 3]

>>> y_numbers = [2, 4, 6]

从这里开始，我们可以创建图表：

>>> from pylab import plot, show

>>> plot(x_numbers, y_numbers)

[<matplotlib.lines.Line2D object at 0x7f83ac60df10>]

在第一行中，我们从 pylab 模块中导入了 plot() 和 show() 函数，这两个函数是 matplotlib 包的一部分。接下来，我们在第二行调用 plot() 函数。plot() 函数的第一个参数是我们想要绘制在 *x*-轴上的数字列表，第二个参数是我们想要绘制在 *y*-轴上的对应数字列表。plot() 函数返回一个对象——或者更准确地说，是一个包含该对象的列表。这个对象包含了我们要求 Python 创建的图表信息。在此阶段，你可以为图表添加更多信息，如标题，或者你也可以仅显示当前的图表。现在我们只显示图表。

plot() 函数只会创建图表。要实际显示图表，我们必须调用 show() 函数：

>>> show()

你应该能在一个 matplotlib 窗口中看到图表，如图 2-3 所示。（显示窗口可能会因操作系统的不同而有所变化，但图表应该是相同的。）

![image](img/f02-03.jpg)

*图 2-3：一个通过点 (1, 2)、(2, 4) 和 (3, 6) 的线的图表*

请注意，图表的 *x*-轴不是从原点 (0, 0) 开始，而是从数字 1 开始，*y*-轴从数字 2 开始。这是两个列表中最小的数字。此外，你可以看到每个轴上标出了增量（例如 *y*-轴上标出了 2.5、3.0、3.5 等）。在《自定义图表》（第 41 页）中，我们将学习如何控制这些图表的方面，以及如何添加坐标轴标签和图表标题。

你会注意到，在交互式 shell 中，直到你关闭 matplotlib 窗口，才能输入更多语句。关闭图表窗口后，你就可以继续编程了。

#### ***在图表上标记点***

如果你希望图表标出你提供的绘制点，可以在调用 plot() 函数时使用一个额外的关键字参数：

>>> plot(x_numbers, y_numbers, marker='o')

通过输入 marker='o'，我们告诉 Python 用一个像 *o* 一样的小点来标记列表中的每个点。再次输入 show() 后，你将看到每个点都被一个小点标记出来（见图 2-4）。

![image](img/f02-04.jpg)

*图 2-4：显示通过点(1, 2)、(2, 4)和(3, 6)的线，并用点标记这些点的图表*

位于(2, 4)的标记很容易看到，而其他标记则隐藏在图表的角落中。你可以从几种标记选项中选择，包括'o'、'*'、'x'和'+'。使用`marker=`会在点之间连接一条线（这是默认设置）。你也可以通过省略`marker=`来创建只标记你指定的点，而不连接它们的图形：

>>> plot(x_numbers, y_numbers, 'o')

[<matplotlib.lines.Line2D object at 0x7f2549bc0bd0>]

在这里，'o'表示每个点应该用圆点标记，但点之间不应连接线条。调用 show()函数来显示图表，图表应与图 2-5 中的图表类似。

![image](img/f02-05.jpg)

*图 2-5：显示点(1, 2)、(2, 4)和(3, 6)的图表*

如你所见，现在图表上仅显示了点，没有连接它们的线条。与之前的图表一样，第一个和最后一个点几乎不可见，但我们很快就会看到如何改变这一点。

#### ***绘制纽约市年平均气温图***

让我们看一组稍大的数据集，这样我们可以探索 matplotlib 的更多功能。2000 到 2012 年期间，纽约市中央公园测得的年平均气温如下：53.9、56.3、56.4、53.4、54.5、55.8、56.8、55.0、55.3、54.0、56.7、56.4 和 57.3 华氏度。目前，这看起来像是一堆随机的数字，但我们可以将这些气温数据绘制成图表，以便更清楚地看到每年气温的变化：

>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]

>>> plot(nyc_temp, marker='o')

[<matplotlib.lines.Line2D object at 0x7f2549d52f90>]

我们将平均气温存储在列表`nyc_temp`中。然后，调用`plot()`函数，只传入这个列表（和标记字符串）。当你对单个列表使用`plot()`时，这些数字会自动绘制在*y*轴上。对应的*x*轴值则填充为列表中每个值的位置。也就是说，第一个温度值 53.9 的对应*x*轴值是 0，因为它位于列表的第 0 个位置（记住，列表的位置从 0 开始计数，而不是从 1）。因此，绘制在*x*轴上的数字是从 0 到 12 的整数，我们可以把它们看作是对应我们有气温数据的 13 年。

输入 show()以显示图表，该图表显示在图 2-6 中。图表显示了平均温度逐年上下波动。如果您快速浏览我们绘制的数字，您会发现它们之间的差距并不大。然而，图表让这些变化看起来相当戏剧化。那么，发生了什么呢？原因是 matplotlib 选择了一个* y *轴的范围，使其恰好足以包含所提供的数据。因此，在这个图表中，* y *轴的起点是 53.0，最高值是 57.5。这使得即使是微小的差异也显得被放大了，因为* y *轴的范围非常小。我们将在“自定义图表”中学习如何控制每个轴的范围，详见第 41 页。

![image](img/f02-06.jpg)

*图 2-6：显示纽约市 2000 年至 2012 年平均年温度的图表*

您还可以看到，* y *轴上的数字是浮动的小数（因为我们要求绘制这些），而* x *轴上的数字是整数。Matplotlib 可以处理这两种情况。

绘制温度数据而不显示相应的年份是一个快速且简便的方法来可视化各年之间的变化。然而，如果你打算向别人展示这个图表，你会希望通过显示每个温度对应的年份来使其更清晰。我们可以通过创建另一个包含年份的列表，并调用 plot()函数来轻松做到这一点：

>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]

>>> years = range(2000, 2013)

>>> plot(years, nyc_temp, marker='o')

[<matplotlib.lines.Line2D object at 0x7f2549a616d0>]

>>> show()

我们使用在第一章中学到的 range()函数来指定 2000 到 2012 年。现在，您将看到年份显示在* x *轴上（见图 2-7）。

![image](img/f02-07.jpg)

*图 2-7：显示纽约市平均年温度的图表，年份显示在* x *轴上*

#### ***比较纽约市每月温度趋势***

继续关注纽约市，让我们看看多年来每个月的平均温度是如何变化的。这将为我们提供一个机会，了解如何在单一图表上绘制多条线。我们将选择三个年份：2000 年、2006 年和 2012 年。对于这三个年份，我们将绘制每个月的平均温度。

首先，我们需要创建三个列表来存储温度（单位：华氏度）。每个列表将包含 12 个数字，对应每年 1 月到 12 月的平均温度：

>>> nyc_temp_2000 = [31.3, 37.3, 47.2, 51.0, 63.5, 71.3, 72.3, 72.7, 66.0, 57.0, 45.3, 31.1]

>>> nyc_temp_2006 = [40.9, 35.7, 43.1, 55.7, 63.1, 71.0, 77.9, 75.8, 66.6, 56.2, 51.9, 43.6]

>>> nyc_temp_2012 = [37.3, 40.9, 50.9, 54.8, 65.1, 71.0, 78.8, 76.7, 68.8, 58.0, 43.9, 41.5]

第一组列表对应 2000 年，接下来的两组列表分别对应 2006 年和 2012 年。我们本可以将这三组数据绘制在三个不同的图表上，但那样就不容易看出每一年的数据是如何比较的。试试看吧！

比较所有这些温度最清晰的方法是将三组数据绘制在 *同一个* 图表上，像这样：

>>> months = range(1, 13)

>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)

[<matplotlib.lines.Line2D object at 0x7f2549c1f0d0>, <matplotlib.lines.Line2D

object at 0x7f2549a61150>, <matplotlib.lines.Line2D object at 0x7f2549c1b550>]

首先，我们创建一个列表（months），使用 `range()` 函数存储数字 1、2、3，直到 12。接着，我们调用 `plot()` 函数，传入三对列表。每一对包含一个用于绘制 *x* 轴的月份列表，以及一个用于绘制 *y* 轴的每月平均温度列表（分别对应 2000、2006 和 2012 年）。到目前为止，我们只使用 `plot()` 绘制了一对列表，但你实际上可以在 `plot()` 函数中输入多个列表对。只要每对列表之间用逗号分隔，`plot()` 函数会自动为每对数据绘制不同的线条。

`plot()` 函数返回一个包含三项的列表，而不是一项。Matplotlib 将这三条曲线视为独立的，并且知道在你调用 `show()` 时将它们绘制在一起。让我们调用 `show()` 来显示图表，如图 2-8 所示。

![image](img/f02-08.jpg)

*图 2-8：显示纽约市 2000 年、2006 年和 2012 年每月平均温度的图表*

现在我们将三条图形绘制在同一个图表上。Python 会自动为每条线选择不同的颜色，以表明这些线条来自不同的数据集。

我们也可以不一次性将所有三对数据传入 `plot()` 函数，而是将 `plot()` 函数分别调用三次，每次传入一对数据：

>>> plot(months, nyc_temp_2000)

[<matplotlib.lines.Line2D object at 0x7f1e51351810>]

>>> plot(months, nyc_temp_2006)

[<matplotlib.lines.Line2D object at 0x7f1e5ae8e390>]

>>> plot(months, nyc_temp_2012)

[<matplotlib.lines.Line2D object at 0x7f1e5136ccd0>]

>>> show()

Matplotlib 会跟踪哪些图形还未显示。因此，只要我们在调用 `show()` 之前，先调用 `plot()` 三次，所有图形都会在同一个图表上显示。

然而，我们遇到了一个问题，因为我们无法知道哪种颜色对应哪个年份。为了解决这个问题，我们可以使用 `legend()` 函数，它允许我们在图表中添加一个图例。*图例* 是一个小的显示框，用于标识图表中不同部分的含义。在这里，我们将使用图例来标明每种颜色代表的年份。要添加图例，首先像之前一样调用 `plot()` 函数：

>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)

[<matplotlib.lines.Line2D object at 0x7f2549d6c410>, <matplotlib.lines.Line2D

object at 0x7f2549d6c9d0>, <matplotlib.lines.Line2D object at 0x7f2549a86850>]

然后，从 pylab 模块导入 legend() 函数并按如下方式调用：

>>> from pylab import legend

>>> legend([2000, 2006, 2012])

<matplotlib.legend.Legend object at 0x7f2549d79410>

我们使用 legend() 函数并传入一组标签，用来标识图表中的每条曲线。标签的顺序与 plot() 函数中输入的数值对的顺序相对应。也就是说，2000 将作为 plot() 函数中第一个数值对的标签；2006 作为第二个数值对的标签；2012 作为第三个数值对的标签。你还可以指定第二个参数来设置图例的位置。默认情况下，图例总是位于图表的右上角。不过，你可以指定一个特定的位置，比如“lower center”（下居中）、“center left”（左居中）或“upper left”（左上）。或者你可以将位置设置为“best”，这样图例会自动调整位置，以避免遮挡图表内容。

最后，我们调用 show() 来显示图表：

>>> show()

如图表所示（见图 2-9），现在右上角有一个图例框。它告诉我们哪条线代表 2000 年的月平均温度，哪条线代表 2006 年，哪条线代表 2012 年。

看图表，你可以得出两个有趣的结论：三个年份的最高温度都出现在大约七月（对应 *x* 轴上的 7），而且温度自 2000 年以来一直在上升，特别是在 2000 到 2006 年之间，温度的上升更为剧烈。将三条线绘制在同一图表中，使得观察这些关系更加容易。与仅仅查看一些长长的数字列表或分别查看三张图表相比，这显然更加清晰。

![image](img/f02-09.jpg)

*图 2-9：显示纽约市月平均温度的图表，图例显示每种颜色对应的年份*

#### ***自定义图表***

我们已经学习了自定义图表的一种方法——通过添加图例。现在，我们将学习通过添加标签到 *x* 轴和 *y* 轴、为图表添加标题，以及控制坐标轴的范围和步长，来进一步自定义图表并使其更清晰。

##### **添加标题和标签**

我们可以使用 title() 函数为图表添加标题，使用 xlabel() 和 ylabel() 函数为 *x* 轴和 *y* 轴添加标签。让我们重新绘制上一个图表，并添加所有这些额外的信息：

>>> from pylab import plot, show, title, xlabel, ylabel, legend

>>> plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)

[<matplotlib.lines.Line2D object at 0x7f2549a9e210>, <matplotlib.lines.Line2D

object at 0x7f2549a4be90>, <matplotlib.lines.Line2D object at 0x7f2549a82090>]

>>> title('纽约市月平均温度')

<matplotlib.text.Text object at 0x7f25499f7150>

>>> xlabel('月份')

<matplotlib.text.Text object at 0x7f2549d79210>

>>> ylabel('温度')

<matplotlib.text.Text object at 0x7f2549b8b2d0>

>>> legend([2000, 2006, 2012])

<matplotlib.legend.Legend object at 0x7f2549a82910>

所有三个函数—title()、xlabel()和 ylabel()—都被调用，并输入了我们希望显示在图表上的相应文本。调用 show()函数将显示带有所有新增信息的图表（见图 2-10）。

![image](img/f02-10.jpg)

*图 2-10：图表上已添加坐标轴标签和标题。*

加入了这三项新信息后，图表更易于理解。

##### **自定义坐标轴**

到目前为止，我们让 Python 根据传给 plot()函数的数据自动确定两个坐标轴的数字范围。对于大多数情况，这可能是可以接受的，但有时这种自动范围并不是呈现数据的最清晰方式，就像我们在绘制纽约市年平均温度的图表时所看到的那样（见图 2-7）。在那里，即使温度变化很小，似乎也很大，因为自动选择的*y*-轴范围非常狭窄。我们可以使用 axis()函数来调整坐标轴的范围。这个函数可以用来获取当前的范围，也可以设置坐标轴的新范围。

再次考虑 2000 到 2012 年间纽约市的年平均温度，并创建一个图表，就像我们之前做的那样。

>>> nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]

>>> plot(nyc_temp, marker='o')

[<matplotlib.lines.Line2D object at 0x7f3ae5b767d0>]

现在，导入 axis()函数并调用它：

>>> from pylab import axis

>>> axis()

(0.0, 12.0, 53.0, 57.5)

该函数返回了一个包含四个数字的元组，分别对应于*x*-轴（0.0, 12.0）和*y*-轴（53.0, 57.5）的范围。这些是我们之前制作的图表中的相同范围值。现在，让我们将*y*-轴的起始值改为 0，而不是 53.0：

>>> axis(ymin=0)

(0.0, 12.0, 0, 57.5)

调用 axis()函数并设置新的*y*-轴起始值（通过 ymin=0 指定）后，坐标轴范围发生了变化，返回的元组也确认了这一点。如果通过调用 show()函数显示图表，*y*-轴将从 0 开始，连续年份之间的差异看起来不那么剧烈（见图 2-11）。

![image](img/f02-11.jpg)

*图 2-11：展示了 2000 到 2012 年间纽约市年平均温度的图表。*y-*轴已被自定义，从 0 开始。*

同样，你可以使用 xmin、xmax 和 ymax 分别设置*X*-轴的最小值和最大值，以及*Y*-轴的最大值。如果你要改变这四个值，可能会发现通过 axis()函数一次性输入这四个范围值会更方便，例如`axis([0, 10, 0, 20])`。这会将*X*-轴的范围设置为(0, 10)，*Y*-轴的范围设置为(0, 20)。

##### **使用 pyplot 绘图**

pylab 模块适用于在交互式 Shell（例如 IDLE Shell）中创建图形，就像我们到目前为止所做的那样。然而，当在 IDLE Shell 之外使用 matplotlib 时——例如作为大型程序的一部分——pyplot 模块更为高效。别担心，所有你在使用 pylab 时学到的方法，在使用 pyplot 时也能正常工作。

以下程序使用 pyplot 模块重现了本章中的第一个图形：

'''

使用 pyplot 绘制简单图形

'''

➊ import matplotlib.pyplot

➋ def create_graph():

x_numbers = [1, 2, 3]

y_numbers = [2, 4, 6]

matplotlib.pyplot.plot(x_numbers, y_numbers)

matplotlib.pyplot.show()

如果 __name__ == '__main__':

create_graph()

首先，我们通过语句`import matplotlib.pyplot`导入了 pyplot 模块 ➊。这意味着我们导入了 matplotlib 包中的整个 pyplot 模块。要引用该模块中定义的任何函数或类，你需要使用语法`matplotlib.pyplot.item`，其中 item 是你要使用的函数或类。

这与我们之前逐个导入函数或类的方式不同。例如，在第一章中，我们通过`from fractions import Fraction`导入了 Fraction 类。导入整个模块在你需要使用模块中的多个函数时特别有用。你可以一次性导入整个模块，然后根据需要引用不同的函数，而不必逐个导入。

在➋的 create_graph()函数中，我们创建了两个列表，这些数字将绘制在图形上，然后将这两个列表传递给 plot()函数，就像我们之前使用 pylab 时做的一样。然而，这次我们调用的是 matplotlib.pyplot.plot()，这意味着我们正在调用 matplotlib 包中的 pyplot 模块定义的 plot()函数。接着，我们调用 show()函数来显示图形。你绘制这些数字的方式与我们之前的做法不同，仅仅是调用函数的机制不同。

为了减少我们输入的内容，可以通过输入`import matplotlib.pyplot as plt`来导入 pyplot 模块。然后，我们可以在程序中使用标签 plt 来引用 pyplot，而不需要每次都输入 matplotlib.pyplot：

'''

使用 pyplot 绘制简单图形

'''

import matplotlib.pyplot as plt

def create_graph():

x_numbers = [1, 2, 3]

y_numbers = [2, 4, 6]

plt.plot(x_numbers, y_numbers)

plt.show()

如果 __name__ == '__main__':

create_graph()

现在，我们可以通过在函数名前加上简写的 plt 来调用函数，而不必每次都使用 matplotlib.pyplot。

接下来，在本章及本书的其他部分，我们将使用 pylab 在交互式命令行中，而在其他地方则使用 pyplot。

#### ***保存图表***

如果你需要保存图表，可以使用 savefig()函数。这个函数将图表保存为图像文件，你可以在报告或演示文稿中使用。你可以选择多种图像格式，包括 PNG、PDF 和 SVG。

这是一个示例：

>>> from pylab import plot, savefig

>>> x = [1, 2, 3]

>>> y = [2, 4, 6]

>>> plot(x, y)

>>> savefig('mygraph.png')

这个程序会将图表保存为图像文件*mygraph.png*，保存在你当前的目录中。在 Microsoft Windows 系统上，通常这个目录是*C:\Python33*（你安装 Python 的地方）。在 Linux 上，当前目录通常是你的主目录*（/home/<用户名>）*，其中*<用户名>*是你登录的用户名。在 Mac 上，IDLE 默认将文件保存到*~/Documents*。如果你想将文件保存到其他目录，只需要指定完整的路径名。例如，如果你想在 Windows 的*C:\*下保存图像为*mygraph.png*，可以这样调用 savefig()函数：

>>> savefig('C:\mygraph.png')

如果你用图像查看程序打开图像，你会看到一个和调用 show()函数时一样的图表。（你会注意到图像文件只包含图表，而不是调用 show()时弹出的整个窗口）。如果要指定不同的图像格式，只需为文件命名时添加相应的扩展名。例如，mygraph.svg 将创建一个 SVG 格式的图像文件。

另一种保存图形的方法是使用弹出窗口中显示的保存按钮，该窗口在调用 show()时弹出。

### **使用公式绘图**

到目前为止，我们一直在根据观测到的科学测量数据绘制图表。在这些图表中，我们已经列出了所有的*x*和*y*值。例如，在我们想要创建纽约市的气温变化图时，记录的温度和日期数据已经为我们提供。接下来，我们将根据数学公式来创建图表。

#### ***牛顿万有引力定律***

根据牛顿万有引力定律，一个质量为*m*[1]的物体会根据公式吸引另一个质量为*m*[2]的物体，吸引力大小为*F*。

![image](img/e0046-01.jpg)

其中*r*是两个物体之间的距离，*G*是万有引力常数。我们想观察当两个物体之间的距离增大时，吸引力会发生什么变化。

让我们考虑两个物体的质量：第一个物体的质量（*m*[1]）是 0.5 千克，第二个物体的质量（*m*[2]）是 1.5 千克。万有引力常数的值为 6.674 × 10^(–11) N m² kg^(–2)。现在，我们准备计算这两个物体在 19 个不同距离下的引力：100 米、150 米、200 米、250 米、300 米，依此类推，直到 1000 米。以下程序执行这些计算，并绘制图表：

'''

引力与

两物体之间的距离

'''

import matplotlib.pyplot as plt

# 绘制图表

def draw_graph(x, y):

plt.plot(x, y, marker='o')

plt.xlabel('距离（单位：米）')

plt.ylabel('重力（单位：牛顿）')

plt.title('引力与距离的关系')

plt.show()

def generate_F_r():

# 生成 r 的值

➊     r = range(100, 1001, 50)

# 空列表，用于存储计算出的 F 值

F = []

# 常量，G

G = 6.674*(10**-11)

# 两个质量

m1 = 0.5

m2 = 1.5

# 计算引力并将其添加到列表 F 中

➋     for dist in r:

force = G*(m1*m2)/(dist**2)

F.append(force)

# 调用 draw_graph 函数

➌     draw_graph(r, F)

if __name__=='__main__':

generate_F_r()

generate_F_r()函数在上述程序中完成了大部分工作。在➊处，我们使用 range()函数创建一个名为 r 的列表，列表中包含不同的距离值，步长为 50。最终值设置为 1001，因为我们希望包含 1000。然后我们创建一个空列表（F），用来存储这些距离对应的引力。接着，我们创建表示万有引力常数（G）和两个质量（m1 和 m2）的标签。使用 for 循环➋，我们计算列表 r 中每个距离值对应的引力。我们用一个标签（force）来表示计算出的引力，并将其追加到列表 F 中。最后，我们在➌处调用函数 draw_graph()，传入距离列表和计算出的引力列表。图表的*x*轴表示引力，*y*轴表示距离。该图如图 2-12 所示。

随着距离（r）的增加，引力会减小。根据这种关系，我们说引力与两物体之间的距离是*反比*关系。此外，请注意，当两个变量中的一个发生变化时，另一个变量不一定会按照相同的比例变化。我们称这种关系为*非线性关系*。因此，图表上的曲线会呈现出弯曲，而不是直线。

![image](img/f02-12.jpg)

*图 2-12：引力与距离平方关系的可视化*

#### ***抛体运动***

现在，让我们绘制一个你在日常生活中很熟悉的图形。如果你在田野上投掷一个球，它会沿着一个轨迹运动，如图 2-13 所示。

![image](img/f02-13.jpg)

*图 2-13：投掷在点* A*的球的运动——以一个角度（*θ*）和初速度（*U*）投掷，并在点* B*着陆。

在图中，球从点* A*投掷，并在点* B*着陆。这种类型的运动被称为*抛体*运动。我们的目标是使用抛体运动的方程式绘制物体的轨迹，显示从投掷点到球再次着地的过程中球的位置。

当你投掷球时，它有一个初速度，并且该速度的方向与地面形成一定角度。我们称初速度为*u*，与地面形成的角度为*θ*（theta），如图 2-13 所示。球有两个速度分量：一个沿*x*方向，计算公式为*u[x]* = *u* cos*θ*，另一个沿*y*方向，计算公式为*u[y]* = *u* sin*θ*。

当球运动时，它的速度发生变化，我们用*v*来表示改变后的速度：水平分量是*v[x]*，垂直分量是*v[y]*。为了简化，假设水平分量（*v[x]*）在运动过程中保持不变，而垂直分量（*v[y]*）由于重力作用而减小，根据公式*v[y]* = *u[y] – gt*。在这个公式中，*g*是重力加速度，*t*是测量速度时的时间。由于*u[y]* = *u* sin*θ*，我们可以代入计算得到：

*v[y]* = *u* sin*θ* – *gt*。

由于速度的水平分量保持不变，水平位移（*S[x]*）由公式*S[x]* = *u*(cos*θ*)*t*给出。然而，垂直分量的速度会发生变化，垂直位移由公式给出：

![image](img/e0049-01.jpg)

换句话说，*S[x]*和*S[y]*给出了球在飞行过程中任何时刻的*x*和*y*坐标。当我们编写程序绘制轨迹时，我们将使用这些方程。使用这些方程时，时间（*t*）以秒为单位，速度以米每秒（m/s）为单位，投射角度（*θ*）以度为单位，重力加速度（*g*）以米每秒平方（m/s²）为单位。

然而，在我们编写程序之前，我们需要先找出球在落地之前的飞行时间，这样我们才能知道程序应该在何时停止绘制球的轨迹。为此，我们首先找出球达到最高点所需的时间。球达到最高点时，垂直分量的速度（*v[y]*）为 0，即*v[y]* = *u* sin *θ* – *gt* = 0。我们需要使用公式找出时间*t*的值：

![image](img/e0049-02.jpg)

我们称这个时间为 t_peak。达到最高点后，球将继续飞行并在另一个 t_peak 秒后落地，因此球的总飞行时间（t_flight）为：

![image](img/e0050-01.jpg)

假设我们有一个初速度(*u*)为 5 米/秒，投掷角度(*θ*)为 45 度的球。为了计算总飞行时间，我们将*u* = 5，*θ* = 45，*g* = 9.8 代入我们之前看到的公式：

![image](img/e0050-02.jpg)

在这种情况下，球的飞行时间为 0.72154 秒（四舍五入到小数点后五位）。球将在空中停留这个时间段，因此为了绘制轨迹，我们将在这段时间内定期计算其*x*和*y*坐标。我们应该多久计算一次坐标？理想情况下，尽可能频繁。在本章中，我们将每 0.001 秒计算一次坐标。

##### **生成等间距浮点数**

我们使用了 range()函数来生成等间距的整数——也就是说，如果我们想要生成 1 到 10 之间的整数，每个整数之间间隔为 1，我们会使用 range(1, 10)。如果我们想要不同的步长，可以在 range 函数中指定第三个参数。不幸的是，Python 没有内建的函数来生成等间距的浮点数。例如，Python 没有一个函数可以让我们生成从 0 到 0.72 的数字列表，并且每两个数字之间相差 0.001。为了实现这一点，我们可以使用 while 循环来创建自己的函数，如下所示：

'''

生成等间距浮点数

两个给定值之间的数字

'''

def frange(start, final, increment):

numbers = []

➊     while start < final:

➋         numbers.append(start)

start = start + increment

return numbers

我们定义了一个函数 frange()（“浮点数”范围），该函数接受三个参数：start 和 final 分别表示数值范围的起始和结束点，increment 表示两个连续数字之间的差值。我们在➊处初始化一个 while 循环，只要 start 指向的数字小于 final 的值，循环就会继续执行。在每次迭代中，我们将 start 指向的数字存储到 numbers 列表中➋，然后将我们输入的增量值加到 start 上。最后，我们返回 numbers 列表。

我们将在接下来的轨迹绘制程序中使用此函数来生成等间隔的时间点。

##### **绘制轨迹**

以下程序绘制了一颗以一定速度和角度投掷的球的轨迹——这两个参数作为输入传递给程序：

'''

绘制物体的抛射运动轨迹

'''

from matplotlib import pyplot as plt

import math

def draw_graph(x, y):

plt.plot(x, y)

plt.xlabel('x 坐标')

plt.ylabel('y 坐标')

plt.title('球的抛射运动')

def frange(start, final, interval):

numbers = []

while start < final:

numbers.append(start)

start = start + interval

return numbers

def draw_trajectory(u, theta):

➊     theta = math.radians(theta)

g = 9.8

# 飞行时间

➋     t_flight = 2*u*math.sin(theta)/g

# 查找时间间隔

intervals = frange(0, t_flight, 0.001)

# x 和 y 坐标列表

x = []

y = []

➌     for t in intervals:

x.append(u*math.cos(theta)*t)

y.append(u*math.sin(theta)*t - 0.5*g*t*t)

draw_graph(x, y)

if __name__ == '__main__':

➍     try:

u = float(input('请输入初速度（m/s）：'))

theta = float(input('请输入投射角度（度）：'))

except ValueError:

print('输入无效')

else:

draw_trajectory(u, theta)

plt.show()

在此程序中，我们使用了标准库 math 模块中定义的 radians()、cos() 和 sin() 函数，因此在开始时需要导入该模块。draw_trajectory() 函数接受两个参数，u 和 theta，分别对应投掷球的速度和角度。math 模块的正弦和余弦函数要求角度以弧度表示，因此在 ➊ 处，我们使用 math.radians() 函数将角度（theta）从度数转换为弧度。接下来，我们创建了一个标签（g）来表示重力加速度 9.8 m/s² 的值。在 ➋ 处，我们计算飞行时间，然后使用 frange() 函数，分别设置起始值、终止值和增量为 0、t_flight 和 0.001。接着，我们计算每个时间瞬间的 *x* 和 *y* 坐标，并将其分别存储在两个列表 x 和 y 中 ➌。为了计算这些坐标，我们使用了之前讨论过的距离公式 *S[x]* 和 *S[y]*。

最后，我们使用 *x* 和 *y* 坐标调用 draw_graph() 函数来绘制轨迹。请注意，draw_graph() 函数并没有调用 show() 函数（我们将在下一个程序中看到为什么）。我们使用了 try...except 块 ➍ 来报告错误信息，以防用户输入无效的内容。该程序的有效输入是任何整数或浮点数。当你运行该程序时，它会要求输入这些值，然后绘制轨迹（见 图 2-14）：

Enter the initial velocity (m/s): 25

Enter the angle of projection (degrees): 60

![image](img/f02-14.jpg)

*图 2-14：当球以 25 m/s 的速度、60 度的角度投掷时的轨迹*

##### **在不同初速度下的轨迹比较**

上一个程序允许你进行有趣的实验。例如，如果三个球以不同的速度但相同的初始角度投掷，它们的轨迹会是怎样的？为了同时绘制三条轨迹，我们可以用以下代码替换之前程序中的主要代码块：

if __name__ == '__main__':

# 三种不同初速度的列表

➊     u_list = [20, 40, 60]

theta = 45

for u in u_list:

draw_trajectory(u, theta)

# 添加图例并显示图形

➋     plt.legend(['20', '40', '60'])

plt.show()

在这里，程序不再要求用户输入速度和抛射角度，而是我们在 ➊ 处创建了一个包含速度 20、40 和 60 的列表（u_list），并将抛射角度设置为 45 度（使用标签 theta）。然后，我们使用相同的 theta 值调用 draw_trajectory() 函数，并传入 u_list 中的每个速度值，计算 *x* 和 *y* 坐标的列表，并调用 draw_graph() 函数。当我们调用 show() 函数时，所有三条曲线会显示在同一个图表上。由于现在有了多个图形的图表，我们在 ➋ 处添加了图例，然后再调用 show() 显示每条曲线的速度。当你运行上述程序时，你会看到 图 2-15 中所示的图形。

![image](img/f02-15.jpg)

*图 2-15：一个球以 60 度角、20、40 和 60 米/秒的速度抛出的轨迹*

### **你学到了什么**

在本章中，你学习了使用 matplotlib 创建图形的基础知识。你学会了如何绘制一组值，如何在同一图表上创建多个图形，以及如何为图形的各个部分添加标签，使其更具信息性。你使用图表分析了一个城市的温度变化、研究了牛顿的万有引力定律，并研究了物体的抛体运动。在下一章中，你将使用 Python 开始探索统计学，并看到如何通过绘制图形帮助更容易理解一组数字之间的关系。

### **编程挑战**

这里有一些挑战，建立在你本章所学的基础上。你可以在 *[`www.nostarch.com/doingmathwithpython/`](http://www.nostarch.com/doingmathwithpython/)* 找到示例解决方案。

#### ***#1: 温度在一天中的变化是怎样的？***

如果你在 Google 搜索引擎中输入“纽约天气”等搜索词，你会看到包括温度变化的图形，显示出当天不同时间的温度。你在这里的任务是重新创建这样的图形。

选择一个城市，找出一天中不同时间的温度。使用这些数据在你的程序中创建两个列表，并绘制一个图表，时间在 *x* 轴上，温度在 *y* 轴上。该图表应该告诉你温度随时间的变化。尝试使用不同的城市，看看两个城市的对比如何，将两条曲线绘制在同一图表上。

一天中的时间可以用诸如 '10:11 AM' 或 '09:21 PM' 这样的字符串表示。

#### ***#2: 直观探索二次函数***

在第一章中，你学习了如何找到二次方程的根，例如 *x*² + 2*x* + 1 = 0。我们可以通过将其写成 *y* = *x*² + 2*x* + 1 来将该方程转换为一个函数。对于任何 *x* 的值，二次函数都会产生一个 *y* 的值。例如，当 *x* = 1 时，*y* = 4。下面是一个程序，它计算六个不同 *x* 值对应的 *y* 值：

'''

二次函数计算器

'''

# 假设 x 的值

➊ x_values = [-1, 1, 2, 3, 4, 5]

➋ 对于 x 在 x_values 中：

# 计算二次函数的值

y = x**2 + 2*x + 1

print('x={0} y={1}'.format(x, y))

在 ➊ 处，我们创建了一个包含六个不同 x 值的列表。从 ➋ 开始的 for 循环计算每个这些值对应的函数值，并使用标签 y 来表示结果列表。接下来，我们打印 x 的值和对应的 y 值。当你运行程序时，应该会看到以下输出：

x=-1 y=0

x=1 y=4

x=2 y=9

x=3 y=16

x=4 y=25

x=5 y=36

注意，输出的第一行是二次方程的根，因为它是一个使得函数值为零的 x 值。

你的编程挑战是增强这个程序，创建一个函数图形。试着使用至少 10 个 x 值，而不是上面提到的 6 个。利用该函数计算相应的 y 值，然后使用这两组值创建图表。

创建图表后，花些时间分析 *y* 相对于 *x* 的变化。变化是线性还是非线性的？

#### ***#3: 增强的抛物线轨迹比较程序***

你的挑战是以几种方式增强轨迹比较程序。首先，程序应该打印出每个速度和投射角度组合的飞行时间、最大水平距离和最大垂直距离。

另一个增强是使程序能够处理用户输入的任意数量的初速度和投射角度。例如，程序应该以如下方式请求用户输入：

多少条轨迹？3

输入轨迹 1 的初速度（米/秒）：45

输入轨迹 1 的投射角度（度）：45

输入轨迹 2 的初速度（米/秒）：60

输入轨迹 2 的投射角度（度）：45

输入轨迹 3 的初速度（米/秒）：45

输入轨迹 3 的投射角度（度）：90

你的程序还应该确保使用 try...except 块正确处理错误输入，就像原程序中那样。

#### ***#4: 可视化你的支出***

我总是在每个月底问自己，“那笔钱到底去哪了？”我相信这并不是只有我一个人面临的问题。

对于这个挑战，你将编写一个程序来创建一个柱状图，方便比较每周支出。程序应首先询问支出的类别数量和每个类别的每周总支出，然后生成显示这些支出的柱状图。

下面是程序应该如何工作的一个示例运行：

输入类别数量：4

输入类别：食品

支出：70

输入类别：交通

支出：35

输入类别：娱乐

支出：30

输入类别：电话/互联网

支出：30

图 2-16 展示了用于比较支出的条形图。如果你为每周保存条形图，那么到月底时，你将能够看到不同类别之间各周支出的变化。

![image](img/f02-16.jpg)

*图 2-16：展示每周按类别支出的条形图*

我们还没有讨论如何使用 matplotlib 创建条形图，所以让我们尝试一个示例。

可以使用 matplotlib 的 barh()函数来创建条形图，该函数也在 pyplot 模块中定义。图 2-17 展示了一个条形图，说明了我在过去一周内步行的步数。星期天、星期一、星期二等被称为*标签*。每个横向条形从*y*轴开始，我们需要为每个条形指定该位置的*y*坐标，作为*中心*。每个条形的长度对应于指定的步数。

![image](img/f02-17.jpg)

*图 2-17：展示一周内步行步数的条形图*

以下程序创建了条形图：

'''

绘制水平条形图的示例

'''

import matplotlib.pyplot as plt

def create_bar_chart(data, labels):

# 条形数量

num_bars = len(data)

# 这个列表是每个条形对应的*y*轴位置

# 条形居中。这里它将是[1, 2, 3...]

➊     positions = range(1, num_bars+1)

➋     plt.barh(positions, data, align='center')

# 设置每个条形的标签

plt.yticks(positions, labels)

plt.xlabel('步数')

plt.ylabel('天')

plt.title('步数')

# 启用网格，这可能有助于视觉估算

plt.grid(

plt.show()

if __name__ == '__main__':

# 我在过去一周步行的步数

steps = [6534, 7000, 8900, 10786, 3467, 11045, 5095]

# 对应的天数

labels = ['周日', '周一', '周二', '周三', '周四', '周五', '周六']

create_bar_chart(steps, labels)

create_bar_chart()函数接受两个参数——data，它是一个包含我们想要通过条形表示的数字的列表，labels，它是对应的标签列表。必须指定每个条形的中心，我已经通过在➊处使用 range()函数任意选择了 1、2、3、4 等作为中心。

然后，我们调用 barh()函数，将 positions 和 data 作为前两个参数传递，再在➋处传递关键字参数 align='center'。关键字参数指定条形在*y*轴上居中显示，位置由列表指定。接着，我们使用 yticks()函数设置每个条形的标签、轴标签和标题。我们还调用 grid()函数启用网格，这可能对步数的视觉估算有帮助。最后，我们调用 show()函数。

#### ***#5：探索斐波那契数列与黄金比例之间的关系***

斐波那契数列（1, 1, 2, 3, 5, ...）是一个数字序列，其中第 *i* 个数字是前两个数字的和——即位于 (*i* - 2) 和 (*i* - 1) 位置的数字。这个序列中的连续数字显示出一种有趣的关系。随着序列项数的增加，连续数字对的比率几乎相等。这个值趋近于一个特殊的数字，称为 *黄金比例*。在数值上，黄金比例是 1.618033988 ...，它已成为音乐、建筑和自然界广泛研究的主题。对于这个挑战，编写一个程序，在图表上绘制连续斐波那契数之间的比率，例如，绘制前 100 个数字，以展示这些值趋近于黄金比例。

你可能会发现以下函数有用，它返回前 *n* 个斐波那契数的列表，这对于实现你的解决方案非常有帮助：

def fibo(n):

if n == 1:

return [1]

if n == 2:

return [1, 1]

# n > 2

a = 1

b = 1

# 序列的前两个成员

series = [a, b]

for i in range(n):

c = a + b

series.append(c)

a = b

b = c

return series

你解决方案的输出应该是一个图表，如 图 2-18 所示。

![image](img/f02-18.jpg)

*图 2-18：连续的斐波那契数之间的比率趋近于黄金比例。*
