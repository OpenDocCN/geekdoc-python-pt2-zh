
## 第八章：函数

![](img/chapterart.png)

在本章中，你将学习编写*函数*，它们是用于执行特定任务的命名代码块。当你想执行某个已经在函数中定义的特定任务时，你需要*调用*该函数。如果你需要在程序中多次执行该任务，你不需要一次又一次地编写相同的代码；只需调用专门处理该任务的函数，调用会告诉 Python 执行函数内的代码。你会发现，使用函数会使得你的程序更容易编写、阅读、测试和修复。

在本章中，你还将学习多种将信息传递给函数的方式。你将学习如何编写一些主要用于显示信息的函数，以及一些用于处理数据并返回一个或多个值的函数。最后，你将学习如何将函数存储在单独的文件中，这些文件被称为*模块*，以帮助组织你的主程序文件。

## 定义一个函数

这是一个简单的名为`greet_user()`的函数，用于打印问候语：

**greeter.py**

```py
def greet_user():
    """Display a simple greeting."""
    print("Hello!")

greet_user()
```

这个示例展示了函数最简单的结构。第一行使用关键字`def`来通知 Python 你正在定义一个函数。这是*函数定义*，它告诉 Python 函数的名称以及（如果适用）该函数执行任务所需的信息。括号中包含这些信息。在这个例子中，函数的名称是`greet_user()`，它不需要任何信息来完成工作，因此它的括号是空的。（尽管如此，括号仍然是必须的。）最后，定义以冒号结尾。

紧跟在`def greet_user():`之后的所有缩进行构成了函数的*主体*。第二行的文本是一个注释，称为*文档字符串*，它描述了该函数的功能。当 Python 为程序中的函数生成文档时，它会查找函数定义后的字符串。这些字符串通常用三重引号括起来，这样你就可以写多行文本。

`print("Hello!")`这一行是该函数主体中唯一的实际代码，因此`greet_user()`只有一个任务：`print("Hello!")`。

当你想使用这个函数时，必须调用它。*函数调用*告诉 Python 执行函数中的代码。要*调用*一个函数，你需要写出函数的名字，后面跟上括号内的必要信息。因为这里不需要额外的信息，所以调用我们的函数只需输入`greet_user()`。如预期，它会打印`Hello!`：

```py
Hello!
```

### 向函数传递信息

如果你稍微修改`greet_user()`函数，它可以通过名字问候用户。为了让函数实现这一功能，你需要在函数定义的`def greet_user()`的括号内输入`username`。通过在这里添加`username`，你允许函数接受你指定的任何`username`值。现在，每次调用该函数时，它都期望你提供一个`username`值。当你调用`greet_user()`时，你可以在括号内传递一个名字，比如`'jesse'`：

```py
def greet_user(username):
    """Display a simple greeting."""
    print(f"Hello, {username.title()}!")

greet_user('jesse')
```

输入`greet_user('jesse')`调用`greet_user()`并为函数提供执行`print()`调用所需的信息。函数接受你传递的名字，并显示该名字的问候语：

```py
Hello, Jesse!
```

同样地，输入`greet_user('sarah')`会调用`greet_user()`，并将`sarah`传递给它，然后打印`Hello, Sarah!`。你可以多次调用`greet_user()`并传递任何你想要的名字，每次都会产生可预测的输出。

### 参数和参数值

在前面的`greet_user()`函数中，我们定义了`greet_user()`需要一个`username`变量的值。当我们调用该函数并提供信息（一个人的名字）时，它打印出正确的问候语。

在`greet_user()`的定义中，变量`username`是*参数*的一个例子，它是函数完成任务所需的信息。在`greet_user('jesse')`中，值`'jesse'`是一个参数值，它是从函数调用传递给函数的信息。我们调用函数时，将我们希望函数处理的值放入括号内。在这个例子中，参数值`'jesse'`被传递给函数`greet_user()`，并赋值给参数`username`。

## 传递参数

由于一个函数定义可以有多个参数，函数调用可能需要多个参数。你可以通过多种方式向函数传递参数。你可以使用*位置参数*，它们需要按参数定义时的顺序传递；*关键字参数*，每个参数由变量名和值组成；以及值的列表和字典。我们将逐一看看这些方法。

### 位置参数

当你调用一个函数时，Python 必须将函数调用中的每个参数与函数定义中的一个参数进行匹配。实现这一点最简单的方法是根据提供参数的顺序进行匹配。通过这种方式匹配的值被称为*位置参数*。

为了理解它是如何工作的，考虑一个展示宠物信息的函数。该函数告诉我们每只宠物是什么种类的动物以及宠物的名字，如下所示：

**pets.py**

```py
❶ def describe_pet(animal_type, pet_name):
    """Display information about a pet."""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

❷ describe_pet('hamster', 'harry')
```

定义表明这个函数需要一个动物的种类和动物的名字❶。当我们调用`describe_pet()`时，我们需要按顺序提供动物种类和名字。例如，在函数调用中，参数`'hamster'`被分配给`animal_type`，参数`'harry'`被分配给`pet_name`❷。在函数体内，这两个参数被用来显示正在描述的宠物信息。

输出描述了一只名叫 Harry 的仓鼠：

```py
I have a hamster.
My hamster's name is Harry.
```

#### 多次函数调用

你可以根据需要多次调用一个函数。描述第二个不同的宠物只需要再调用一次`describe_pet()`：

```py
def describe_pet(animal_type, pet_name):
 """Display information about a pet."""
 print(f"\nI have a {animal_type}.")
 print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('hamster', 'harry')
describe_pet('dog', 'willie')
```

在第二次函数调用中，我们将`describe_pet()`的参数设置为`'dog'`和`'willie'`。和之前使用的参数组一样，Python 将`'dog'`与参数`animal_type`匹配，将`'willie'`与参数`pet_name`匹配。和之前一样，函数执行其功能，但这次它打印出一只名叫 Willie 的狗的值。现在我们有一只名叫 Harry 的仓鼠和一只名叫 Willie 的狗：

```py
I have a hamster.
My hamster's name is Harry.

I have a dog.
My dog's name is Willie.
```

多次调用一个函数是一个非常高效的工作方式。描述宠物的代码在函数中只需要写一次。然后，每当你想描述一只新宠物时，只需要用新宠物的信息再次调用该函数。即使描述宠物的代码扩展到 10 行，你依然可以通过调用函数一次，用一行代码描述一只新宠物。

#### 位置参数中的顺序很重要

如果你在函数调用中混淆了位置参数的顺序，可能会得到意想不到的结果：

```py
def describe_pet(animal_type, pet_name):
 """Display information about a pet."""
 print(f"\nI have a {animal_type}.")
 print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('harry', 'hamster')
```

在这个函数调用中，我们将名字列在前面，动物种类列在后面。因为这次`'harry'`被列在前面，所以这个值被分配给`animal_type`。同样，`'hamster'`被分配给`pet_name`。现在我们得到了一只名叫“Harry”的仓鼠：

```py
I have a harry.
My harry's name is Hamster.
```

如果你得到像这样的奇怪结果，请检查确保函数调用中的参数顺序与函数定义中的参数顺序一致。

### 关键字参数

一个*关键字参数*是你传递给函数的一个名称-值对。你在参数中直接关联名称和值，因此当你将参数传递给函数时，不会产生混淆（你不会把一只名为“哈利”的仓鼠变成狗）。关键字参数让你不必担心在函数调用中正确地排列参数的顺序，同时它们清晰地指明了每个值在函数调用中的角色。

让我们使用关键字参数重写*pets.py*来调用`describe_pet()`：

```py
def describe_pet(animal_type, pet_name):
 """Display information about a pet."""
 print(f"\nI have a {animal_type}.")
 print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(animal_type='hamster', pet_name='harry')
```

`describe_pet()`函数本身没有改变。但是当我们调用该函数时，我们显式告诉 Python 每个参数应与哪个实参匹配。当 Python 读取函数调用时，它知道将实参`'hamster'`分配给参数`animal_type`，并将实参`'harry'`分配给`pet_name`。输出结果正确地显示我们有一只名叫 Harry 的仓鼠。

关键字参数的顺序不重要，因为 Python 知道每个值应该放在哪个位置。以下两个函数调用是等效的：

```py
describe_pet(animal_type='hamster', pet_name='harry')
describe_pet(pet_name='harry', animal_type='hamster')
```

### 默认值

编写函数时，你可以为每个参数定义*默认值*。如果在函数调用中为某个参数提供了实参，Python 会使用该实参的值。如果没有提供，Python 会使用该参数的默认值。因此，当你为参数定义了默认值时，可以省略通常需要在函数调用中编写的相应实参。使用默认值可以简化你的函数调用，并明确函数通常的使用方式。

例如，如果你注意到大多数调用`describe_pet()`的地方都是用来描述狗的，你可以将`animal_type`的默认值设置为`'dog'`。现在，任何调用`describe_pet()`来描述狗的人都可以省略这一信息：

```py
def describe_pet(pet_name, animal_type='dog'):
    """Display information about a pet."""
 print(f"\nI have a {animal_type}.")
 print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(pet_name='willie')
```

我们更改了`describe_pet()`的定义，为`animal_type`添加了默认值`'dog'`。现在，当函数调用时没有指定`animal_type`，Python 会使用`'dog'`作为该参数的值：

```py
I have a dog.
My dog's name is Willie.
```

请注意，函数定义中参数的顺序必须更改。由于默认值使得不需要将动物类型作为实参，因此函数调用中唯一需要提供的实参就是宠物的名字。Python 仍然将其解释为位置参数，因此如果函数仅使用宠物的名字进行调用，该实参将与函数定义中列出的第一个参数匹配。这就是第一个参数需要是`pet_name`的原因。

现在使用此函数的最简单方法是只在函数调用中提供一只狗的名字：

```py
describe_pet('willie')
```

这个函数调用的输出与之前的示例相同。唯一提供的实参是`'willie'`，因此它与函数定义中的第一个参数`pet_name`匹配。因为没有为`animal_type`提供实参，Python 会使用默认值`'dog'`。

要描述一只不是狗的动物，你可以使用如下的函数调用：

```py
describe_pet(pet_name='harry', animal_type='hamster')
```

因为提供了`animal_type`的显式实参，Python 会忽略该参数的默认值。

### 等效的函数调用

因为位置参数、关键字参数和默认值可以一起使用，所以你通常会有几种等效的方式来调用一个函数。考虑以下为`describe_pet()`提供一个默认值的定义：

```py
def describe_pet(pet_name, animal_type='dog'):
```

根据这个定义，`pet_name`始终需要提供参数，这个值可以通过位置参数或关键字参数的形式提供。如果描述的动物不是狗，那么调用时必须包括`animal_type`的参数，这个参数也可以通过位置参数或关键字参数的形式指定。

以下所有调用都会适用于这个函数：

```py
# A dog named Willie.
describe_pet('willie')
describe_pet(pet_name='willie')

# A hamster named Harry.
describe_pet('harry', 'hamster')
describe_pet(pet_name='harry', animal_type='hamster')
describe_pet(animal_type='hamster', pet_name='harry')
```

每个函数调用的输出都将与之前的示例相同。

你使用哪种调用风格并不重要。只要你的函数调用能产生你想要的输出，就使用你最容易理解的风格。

### 避免参数错误

当你开始使用函数时，如果遇到关于不匹配参数的错误，不要感到惊讶。不匹配参数的错误发生在你提供的参数数量比函数所需的少或多。例如，如果我们尝试调用`describe_pet()`而不提供任何参数，会发生以下情况：

```py
def describe_pet(animal_type, pet_name):
 """Display information about a pet."""
 print(f"\nI have a {animal_type}.")
 print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet()
```

Python 识别出函数调用中缺少了一些信息，错误追踪告诉我们：

```py
Traceback (most recent call last):
❶   File "pets.py", line 6, in <module>
❷     describe_pet()
    ^^^^^^^^^^^^^^
❸ TypeError: describe_pet() missing 2 required positional arguments: 
    'animal_type' and 'pet_name'
```

错误追踪首先告诉我们问题所在的位置 ❶，让我们回过头来看，发现问题出现在函数调用中。接下来，错误的函数调用被列出 ❷。最后，错误追踪告诉我们调用缺少两个参数，并报告缺少的参数名称 ❸。如果这个函数在一个独立的文件中，我们可能不需要打开文件并阅读函数代码，就能正确地重写调用。

Python 很有帮助，它会读取函数的代码并告诉我们需要提供的参数名称。这也是给变量和函数命名时使用描述性名称的另一个原因。如果这样做，Python 的错误信息将更有用，帮助你或其他使用你代码的人解决问题。

如果你提供了太多参数，你应该会得到类似的错误追踪信息，帮助你正确匹配函数调用与函数定义。

## 返回值

一个函数并不总是需要直接显示它的输出。相反，它可以处理一些数据，然后返回一个值或一组值。函数返回的值称为*返回值*。`return`语句将函数内部的值取出，并发送回调用该函数的行。返回值使得你可以将程序中许多繁琐的工作移到函数中，从而简化程序的主体部分。

### 返回一个简单的值

让我们看一个接受名字和姓氏并返回格式化全名的函数：

**formatted_name.py**

```py
def get_formatted_name(first_name, last_name):
    """Return a full name, neatly formatted."""
❶     full_name = f"{first_name} {last_name}"
❷     return full_name.title()

❸ musician = get_formatted_name('jimi', 'hendrix')
print(musician)
```

`get_formatted_name()`的定义接受两个参数：名字和姓氏。该函数将这两个名字组合起来，在它们之间添加一个空格，并将结果赋值给`full_name` ❶。`full_name`的值被转换为标题大小写，然后返回给调用行 ❷。

当你调用一个返回值的函数时，需要提供一个变量来接收返回的值。在这种情况下，返回的值被赋值给变量`musician` ❸。输出显示了一个整齐格式化的名字，由一个人的名字部分组成：

```py
Jimi Hendrix
```

这可能看起来像是为了得到一个格式化好的名字而做了很多工作，但我们也可以直接写成：

```py
print("Jimi Hendrix")
```

然而，当你考虑在一个需要分别存储许多名和姓的大型程序时，像`get_formatted_name()`这样的函数就变得非常有用。你可以分别存储名和姓，然后每当你想要显示全名时调用这个函数。

### 使参数变为可选

有时将一个参数设为可选是有意义的，这样使用该函数的人可以根据需要提供额外的信息。你可以使用默认值来使参数成为可选项。

例如，假设我们想要扩展`get_formatted_name()`以处理中间名。首次尝试包括中间名可能如下所示：

```py
def get_formatted_name(first_name, middle_name, last_name):
    """Return a full name, neatly formatted."""
    full_name = f"{first_name} {middle_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('john', 'lee', 'hooker')
print(musician)
```

这个函数在提供名、中间名和姓时能正常工作。该函数接受名字的三个部分，然后将它们组合成一个字符串。函数会在适当的位置添加空格，并将全名转换为标题大小写：

```py
John Lee Hooker
```

但是中间名并非总是需要的，这个函数的写法如果你只传入名和姓时将无法正常工作。为了使中间名成为可选项，我们可以给`middle_name`参数一个空的默认值，并且只有在用户提供值时才处理该参数。为了让`get_formatted_name()`在没有中间名的情况下工作，我们将`middle_name`的默认值设为空字符串，并将其移动到参数列表的最后：

```py
def get_formatted_name(first_name, last_name, middle_name=''):
    """Return a full name, neatly formatted."""
❶     if middle_name:
        full_name = f"{first_name} {middle_name} {last_name}"
❷     else:
        full_name = f"{first_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('jimi', 'hendrix')
print(musician)

❸ musician = get_formatted_name('john', 'hooker', 'lee')
print(musician)
```

在这个示例中，名字由三个可能的部分组成。因为总是有姓和名，所以这些参数在函数定义中列出。中间名是可选的，因此它在定义中列出最后，并且其默认值为空字符串。

在函数体内，我们检查是否提供了中间名。Python 将非空字符串解释为`True`，因此条件测试`if middle_name`如果函数调用中有中间名参数，结果会评估为`True` ❶。如果提供了中间名，首先、其次和最后的名字将被组合成一个全名。这个名字然后被转换为标题大小写，并返回到函数调用行，在那里它被赋值给变量`musician`并打印。如果没有提供中间名，空字符串将使`if`测试失败，`else`块将执行 ❷。全名将只由名和姓组成，格式化后的名字返回到调用行，在那里它被赋值给`musician`并打印。

用名字和姓氏调用这个函数非常简单。然而，如果我们使用中间名，就必须确保中间名是最后一个传入的参数，这样 Python 才能正确匹配位置参数 ❸。

这个修改后的版本适用于只有名字和姓氏的人，也适用于有中间名的人：

```py
Jimi Hendrix
John Lee Hooker
```

可选值使得函数能够处理广泛的使用场景，同时保持函数调用尽可能简洁。

### 返回字典

函数可以返回任何你需要的值，包括更复杂的数据结构，如列表和字典。例如，以下函数接受姓名的各个部分，并返回一个表示人的字典：

**person.py**

```py
def build_person(first_name, last_name):
    """Return a dictionary of information about a person."""
❶     person = {'first': first_name, 'last': last_name}
❷     return person

musician = build_person('jimi', 'hendrix')
❸ print(musician)
```

函数`build_person()`接受名字和姓氏，并将这些值放入一个字典中 ❶。`first_name`的值被存储在键`'first'`下，`last_name`的值被存储在键`'last'`下。然后，表示这个人的整个字典被返回 ❷。返回值被打印 ❸，原始的两条文本信息现在被存储在字典中：

```py
{'first': 'jimi', 'last': 'hendrix'}
```

这个函数接受简单的文本信息，并将其放入更有意义的数据结构中，这样你就可以在打印信息之外，对其进行更多操作。字符串`'jimi'`和`'hendrix'`现在被标记为名字和姓氏。你可以轻松地扩展这个函数，使其接受可选的值，比如中间名、年龄、职业或你想要存储的任何其他个人信息。例如，以下的更改允许你同时存储一个人的年龄：

```py
def build_person(first_name, last_name, age=None):
 """Return a dictionary of information about a person."""
 person = {'first': first_name, 'last': last_name}
    if age:
        person['age'] = age
 return person

musician = build_person('jimi', 'hendrix', age=27)
print(musician)
```

我们在函数定义中添加了一个新的可选参数`age`，并为该参数赋予特殊值`None`，用于表示一个变量没有具体的值。你可以把`None`看作占位符值。在条件测试中，`None`会被评估为`False`。如果函数调用中包含`age`的值，那么该值将被存储在字典中。这个函数始终存储一个人的名字，但也可以修改以存储关于此人的任何其他信息。

### 使用带`while`循环的函数

你可以使用所有迄今为止学过的 Python 结构与函数。例如，让我们使用`get_formatted_name()`函数与`while`循环结合，来更正式地问候用户。这里是第一次尝试使用用户的名字和姓氏来问候他们：

**greeter.py**

```py
def get_formatted_name(first_name, last_name):
 """Return a full name, neatly formatted."""
 full_name = f"{first_name} {last_name}"
 return full_name.title()

# This is an infinite loop!
while True:
❶     print("\nPlease tell me your name:")
    f_name = input("First name: ")
    l_name = input("Last name: ")

    formatted_name = get_formatted_name(f_name, l_name)
    print(f"\nHello, {formatted_name}!")
```

对于这个例子，我们使用了一个简单版本的`get_formatted_name()`，它不涉及中间名。`while`循环会要求用户输入他们的名字，我们分别提示用户输入他们的名字和姓氏 ❶。

但是这个`while`循环有一个问题：我们没有定义退出条件。当你请求一系列输入时，应该在哪里设置退出条件呢？我们希望用户尽可能容易地退出，因此每个提示都应提供一种退出方式。`break`语句为在任意提示中退出循环提供了一种简便的方法：

```py
def get_formatted_name(first_name, last_name):
 """Return a full name, neatly formatted."""
 full_name = f"{first_name} {last_name}"
 return full_name.title()

while True:
 print("\nPlease tell me your name:")
  print("(enter 'q' at any time to quit)")

 f_name = input("First name: ")
  if f_name == 'q':
        break

 l_name = input("Last name: ")
  if l_name == 'q':
        break

 formatted_name = get_formatted_name(f_name, l_name)
 print(f"\nHello, {formatted_name}!")
```

我们添加了一条消息，告知用户如何退出，然后如果用户在任意提示中输入退出值，我们就跳出循环。现在，程序将继续向用户问候，直到有人输入`q`作为名字：

```py
Please tell me your name:
(enter 'q' at any time to quit)
First name: **eric**
Last name: **matthes**

Hello, Eric Matthes!

Please tell me your name:
(enter 'q' at any time to quit)
First name: **q**
```

## 传递一个列表

无论是名字、数字还是更复杂的对象（例如字典），将一个列表传递给函数通常是非常有用的。当你将列表传递给函数时，函数可以直接访问列表的内容。让我们通过使用函数来提高处理列表的效率。

假设我们有一个用户列表，并希望向每个用户打印问候语。以下示例将一个名字列表传递给一个名为`greet_users()`的函数，该函数会逐一向列表中的每个人问好：

**greet_users.py**

```py
def greet_users(names):
    """Print a simple greeting to each user in the list."""
    for name in names:
        msg = f"Hello, {name.title()}!"
        print(msg)

usernames = ['hannah', 'ty', 'margot']
greet_users(usernames)
```

我们定义了`greet_users()`，使其期望接收一个名字列表，并将其分配给参数`names`。该函数会遍历它收到的列表，并向每个用户打印问候语。在函数外部，我们定义了一个用户列表，然后在函数调用中将列表`usernames`传递给`greet_users()`：

```py
Hello, Hannah!
Hello, Ty!
Hello, Margot!
```

这是我们想要的输出。每个用户都会看到个性化的问候语，且你可以在任何时候调用该函数来问候特定的用户群体。

### 在函数中修改一个列表

当你将一个列表传递给函数时，函数可以修改这个列表。在函数体内对列表所做的任何更改都是永久性的，这样即使你处理大量数据，也能高效工作。

考虑一个公司，该公司创建用户提交的设计的 3D 打印模型。需要打印的设计存储在一个列表中，打印完成后，它们会被移动到另一个单独的列表。以下代码在不使用函数的情况下实现这一功能：

**printing_models.py**

```py
# Start with some designs that need to be printed.
unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
completed_models = []

# Simulate printing each design, until none are left.
#  Move each design to completed_models after printing.
while unprinted_designs:
    current_design = unprinted_designs.pop()
    print(f"Printing model: {current_design}")
    completed_models.append(current_design)

# Display all completed models.
print("\nThe following models have been printed:")
for completed_model in completed_models:
    print(completed_model)
```

这个程序以一个需要打印的设计列表开始，并有一个空列表`completed_models`，每个设计在打印完成后会被移到该列表中。只要`unprinted_designs`列表中还有设计，`while`循环就会通过从列表末尾移除一个设计、将其存储到`current_design`中，并显示当前设计正在打印的消息来模拟打印每个设计。然后，它会将该设计添加到已完成模型列表中。当循环完成后，将显示打印过的设计列表：

```py
Printing model: dodecahedron
Printing model: robot pendant
Printing model: phone case

The following models have been printed:
dodecahedron
robot pendant
phone case
```

我们可以通过编写两个函数来重新组织这段代码，每个函数执行一个特定的任务。大部分代码不会改变；我们只是更仔细地进行结构化。第一个函数将处理打印设计，第二个函数将总结已打印的设计：

```py
❶ def print_models(unprinted_designs, completed_models):
    """
    Simulate printing each design, until none are left.
 Move each design to completed_models after printing.
    """
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print(f"Printing model: {current_design}")
        completed_models.append(current_design)

❷ def show_completed_models(completed_models):
    """Show all the models that were printed."""
    print("\nThe following models have been printed:")
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
```

我们定义了`print_models()`函数，它有两个参数：一个是需要打印的设计列表，另一个是已完成模型列表❶。给定这两个列表，该函数通过清空未打印设计的列表并填充已完成模型的列表来模拟打印每个设计。然后我们定义了`show_completed_models()`函数，它有一个参数：已完成模型的列表❷。根据这个列表，`show_completed_models()`会显示每个已打印模型的名称。

这个程序的输出与没有函数的版本相同，但代码更有条理。做大部分工作的代码已被移到两个单独的函数中，这使得程序的主体部分更容易理解。看看程序主体，注意你能多么轻松地跟随发生的事情：

```py
unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
```

我们建立了一个未打印设计的列表和一个空的已完成模型列表。然后，因为我们已经定义了两个函数，我们所需要做的就是调用它们并传递正确的参数。我们调用`print_models()`并传递它所需要的两个列表；正如预期的那样，`print_models()`模拟打印这些设计。然后我们调用`show_completed_models()`并传递已完成模型的列表，以便它能报告已打印的模型。描述性的函数名称让其他人即使没有注释也能阅读这段代码并理解它。

这个程序比没有函数的版本更容易扩展和维护。如果我们以后需要打印更多设计，只需再次调用`print_models()`。如果我们意识到打印代码需要修改，我们只需修改一次代码，这些修改就会在函数被调用的所有地方生效。这种方法比在程序中的多个地方分别更新代码更高效。

```py`This example also demonstrates the idea that every function should have one specific job. The first function prints each design, and the second displays the completed models. This is more beneficial than using one function to do both jobs. If you’re writing a function and notice the function is doing too many different tasks, try to split the code into two functions. Remember that you can always call a function from another function, which can be helpful when splitting a complex task into a series of steps.    ### Preventing a Function from Modifying a List    Sometimes you’ll want to prevent a function from modifying a list. For example, say that you start with a list of unprinted designs and write a function to move them to a list of completed models, as in the previous example. You may decide that even though you’ve printed all the designs, you want to keep the original list of unprinted designs for your records. But because you moved all the design names out of `unprinted_designs`, the list is now empty, and the empty list is the only version you have; the original is gone. In this case, you can address this issue by passing the function a copy of the list, not the original. Any changes the function makes to the list will affect only the copy, leaving the original list intact.    You can send a copy of a list to a function like this:    ``` `function_name`(`list_name`[:]) ```py    The slice notation `[:]` makes a copy of the list to send to the function. If we didn’t want to empty the list of unprinted designs in *printing_models.py*, we could call `print_models()` like this:    ``` print_models(unprinted_designs[:], completed_models) ```py    The function `print_models()` can do its work because it still receives the names of all unprinted designs. But this time it uses a copy of the original unprinted designs list, not the actual `unprinted_designs` list. The list `completed_models` will fill up with the names of printed models like it did before, but the original list of unprinted designs will be unaffected by the function.    Even though you can preserve the contents of a list by passing a copy of it to your functions, you should pass the original list to functions unless you have a specific reason to pass a copy. It’s more efficient for a function to work with an existing list, because this avoids using the time and memory needed to make a separate copy. This is especially true when working with large lists.    ## Passing an Arbitrary Number of Arguments    Sometimes you won’t know ahead of time how many arguments a function needs to accept. Fortunately, Python allows a function to collect an arbitrary number of arguments from the calling statement.    For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can’t know ahead of time how many toppings a person will want. The function in the following example has one parameter, `*toppings`, but this parameter collects as many arguments as the calling line provides:    **pizza.py**    ``` def make_pizza(*toppings): """打印请求的配料列表。""" print(toppings) make_pizza('pepperoni') make_pizza('mushrooms', 'green peppers', 'extra cheese') ```py    The asterisk in the parameter name `*toppings` tells Python to make a tuple called `toppings`, containing all the values this function receives. The `print()` call in the function body produces output showing that Python can handle a function call with one value and a call with three values. It treats the different calls similarly. Note that Python packs the arguments into a tuple, even if the function receives only one value:    ``` ('pepperoni',) ('mushrooms', 'green peppers', 'extra cheese') ```py    Now we can replace the `print()` call with a loop that runs through the list of toppings and describes the pizza being ordered:    ``` def make_pizza(*toppings): """总结一下我们要做披萨。""" print("\nMaking a pizza with the following toppings:") for topping in toppings: print(f"- {topping}") make_pizza('pepperoni') make_pizza('mushrooms', 'green peppers', 'extra cheese') ```py    The function responds appropriately, whether it receives one value or three values:    ``` Making a pizza with the following toppings: - pepperoni Making a pizza with the following toppings: - mushrooms - green peppers - extra cheese ```py    This syntax works no matter how many arguments the function receives.    ### Mixing Positional and Arbitrary Arguments    If you want a function to accept several different kinds of arguments, the parameter that accepts an arbitrary number of arguments must be placed last in the function definition. Python matches positional and keyword arguments first and then collects any remaining arguments in the final parameter.    For example, if the function needs to take in a size for the pizza, that parameter must come before the parameter `*toppings`:    ``` def make_pizza(size, *toppings): """总结一下我们要做披萨。""" print(f"\nMaking a {size}-inch pizza with the following toppings:") for topping in toppings: print(f"- {topping}") make_pizza(16, 'pepperoni') make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') ```py    In the function definition, Python assigns the first value it receives to the parameter `size`. All other values that come after are stored in the tuple `toppings`. The function calls include an argument for the size first, followed by as many toppings as needed.    Now each pizza has a size and a number of toppings, and each piece of information is printed in the proper place, showing size first and toppings after:    ``` Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese ```py    ### Using Arbitrary Keyword Arguments    Sometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function `build_profile()` in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:    **user_profile.py**    ``` def build_profile(first, last, **user_info): """创建一个包含用户所有信息的字典。""" ❶ user_info['first_name'] = first user_info['last_name'] = last return user_info user_profile = build_profile('albert', 'einstein', location='princeton', field='physics') print(user_profile) ```py    The definition of `build_profile()` expects a first and last name, and then it allows the user to pass in as many name-value pairs as they want. The double asterisks before the parameter `**user_info` cause Python to create a dictionary called `user_info` containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in `user_info` just as you would for any dictionary.    In the body of `build_profile()`, we add the first and last names to the `user_info` dictionary because we’ll always receive these two pieces of information from the user ❶, and they haven’t been placed into the dictionary yet. Then we return the `user_info` dictionary to the function call line.    We call `build_profile()`, passing it the first name `'albert'`, the last name `'einstein'`, and the two key-value pairs `location='princeton'` and `field='physics'`. We assign the returned `profile` to `user_profile` and print `user_profile`:    ``` {'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'} ```py    The returned dictionary contains the user’s first and last names and, in this case, the location and field of study as well. The function will work no matter how many additional key-value pairs are provided in the function call.    You can mix positional, keyword, and arbitrary values in many different ways when writing your own functions. It’s useful to know that all these argument types exist because you’ll see them often when you start reading other people’s code. It takes practice to use the different types correctly and to know when to use each type. For now, remember to use the simplest approach that gets the job done. As you progress, you’ll learn to use the most efficient approach each time.    ## Storing Your Functions in Modules    One advantage of functions is the way they separate blocks of code from your main program. When you use descriptive names for your functions, your programs become much easier to follow. You can go a step further by storing your functions in a separate file called a *module* and then *importing* that module into your main program. An `import` statement tells Python to make the code in a module available in the currently running program file.    Storing your functions in a separate file allows you to hide the details of your program’s code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written.    There are several ways to import a module, and I’ll show you each of these briefly.    ### Importing an Entire Module    To start importing functions, we first need to create a module. A *module* is a file ending in *.py* that contains the code you want to import into your program. Let’s make a module that contains the function `make_pizza()`. To make this module, we’ll remove everything from the file *pizza.py* except the function `make_pizza()`:    **pizza.py**    ``` def make_pizza(size, *toppings): """总结一下我们要做披萨。""" print(f"\nMaking a {size}-inch pizza with the following toppings:") for topping in toppings: print(f"- {topping}") ```py    Now we’ll make a separate file called *making_pizzas.py* in the same directory as *pizza.py*. This file imports the module we just created and then makes two calls to `make_pizza()`:    **making_pizzas.py**    ``` import pizza ❶ pizza.make_pizza(16, 'pepperoni') pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') ```py    When Python reads this file, the line `import pizza` tells Python to open the file *pizza.py* and copy all the functions from it into this program. You don’t actually see code being copied between files because Python copies the code behind the scenes, just before the program runs. All you need to know is that any function defined in *pizza.py* will now be available in *making_pizzas.py*.    To call a function from an imported module, enter the name of the module you imported, `pizza`, followed by the name of the function, `make_pizza()`, separated by a dot ❶. This code produces the same output as the original program that didn’t import a module:    ``` Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese ```py    This first approach to importing, in which you simply write `import` followed by the name of the module, makes every function from the module available in your program. If you use this kind of `import` statement to import an entire module named *module_name.py*, each function in the module is available through the following syntax:    ``` `module_name`.`function_name`() ```py    ### Importing Specific Functions    You can also import a specific function from a module. Here’s the general syntax for this approach:    ``` from `module_name` import `function_name` ```py    You can import as many functions as you want from a module by separating each function’s name with a comma:    ``` from `module_name` import `function_0`, `function_1`, `function_2` ```py    The *making_pizzas.py* example would look like this if we want to import just the function we’re going to use:    ``` from pizza import make_pizza make_pizza(16, 'pepperoni') make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') ```py    With this syntax, you don’t need to use the dot notation when you call a function. Because we’ve explicitly imported the function `make_pizza()` in the `import` statement, we can call it by name when we use the function.    ### Using as to Give a Function an Alias    If the name of a function you’re importing might conflict with an existing name in your program, or if the function name is long, you can use a short, unique *alias*—an alternate name similar to a nickname for the function. You’ll give the function this special nickname when you import the function.    Here we give the function `make_pizza()` an alias, `mp()`, by importing `make_pizza as mp`. The `as` keyword renames a function using the alias you provide:    ``` from pizza import make_pizza as mp mp(16, 'pepperoni') mp(12, 'mushrooms', 'green peppers', 'extra cheese') ```py    The `import` statement shown here renames the function `make_pizza()` to `mp()` in this program. Anytime we want to call `make_pizza()` we can simply write `mp()` instead, and Python will run the code in `make_pizza()` while avoiding any confusion with another `make_pizza()` function you might have written in this program file.    The general syntax for providing an alias is:    ``` from `module_name` import `function_name` as `fn` ```py    ### Using as to Give a Module an Alias    You can also provide an alias for a module name. Giving a module a short alias, like `p` for `pizza`, allows you to call the module’s functions more quickly. Calling `p.make_pizza()` is more concise than calling `pizza.make_pizza()`:    ``` import pizza as p p.make_pizza(16, 'pepperoni') p.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') ```py    The module `pizza` is given the alias `p` in the `import` statement, but all of the module’s functions retain their original names. Calling the functions by writing `p.make_pizza()` is not only more concise than `pizza.make_pizza()`, but it also redirects your attention from the module name and allows you to focus on the descriptive names of its functions. These function names, which clearly tell you what each function does, are more important to the readability of your code than using the full module name.    The general syntax for this approach is:    ``` import `module_name` as `mn` ```py    ### Importing All Functions in a Module    You can tell Python to import every function in a module by using the asterisk (`*`) operator:    ``` from pizza import * make_pizza(16, 'pepperoni') make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') ```py    The asterisk in the `import` statement tells Python to copy every function from the module `pizza` into this program file. Because every function is imported, you can call each function by name without using the dot notation. However, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results. Python may see several functions or variables with the same name, and instead of importing all the functions separately, it will overwrite the functions.    The best approach is to import the function or functions you want, or import the entire module and use the dot notation. This leads to clear code that’s easy to read and understand. I include this section so you’ll recognize `import` statements like the following when you see them in other people’s code:    ``` from `module_name` import * ```py    ## Styling Functions    You need to keep a few details in mind when you’re styling functions. Functions should have descriptive names, and these names should use lowercase letters and underscores. Descriptive names help you and others understand what your code is trying to do. Module names should use these conventions as well.    Every function should have a comment that explains concisely what the function does. This comment should appear immediately after the function definition and use the docstring format. In a well-documented function, other programmers can use the function by reading only the description in the docstring. They should be able to trust that the code works as described, and as long as they know the name of the function, the arguments it needs, and the kind of value it returns, they should be able to use it in their programs.    If you specify a default value for a parameter, no spaces should be used on either side of the equal sign:    ``` def `function_name`(`parameter_0`, `parameter_1`='`default value`') ```py    The same convention should be used for keyword arguments in function calls:    ``` `function_name`(`value_0`, `parameter_1`='`value`') ```py    PEP 8 ([`www.python.org/dev/peps/pep-0008`](https://www.python.org/dev/peps/pep-0008)) recommends that you limit lines of code to 79 characters so every line is visible in a reasonably sized editor window. If a set of parameters causes a function’s definition to be longer than 79 characters, press ENTER after the opening parenthesis on the definition line. On the next line, press the TAB key twice to separate the list of arguments from the body of the function, which will only be indented one level.    Most editors automatically line up any additional lines of arguments to match the indentation you have established on the first line:    ``` def `function_name`( `parameter_0`, `parameter_1`, `parameter_2`, `parameter_3`, `parameter_4`, `parameter_5`): `function body...` ```py    If your program or module has more than one function, you can separate each by two blank lines to make it easier to see where one function ends and the next one begins.    All `import` statements should be written at the beginning of a file. The only exception is if you use comments at the beginning of your file to describe the overall program.    ## Summary    In this chapter, you learned how to write functions and to pass arguments so that your functions have access to the information they need to do their work. You learned how to use positional and keyword arguments, and also how to accept an arbitrary number of arguments. You saw functions that display output and functions that return values. You learned how to use functions with lists, dictionaries, `if` statements, and `while` loops. You also saw how to store your functions in separate files called *modules*, so your program files will be simpler and easier to understand. Finally, you learned to style your functions so your programs will continue to be well-structured and as easy as possible for you and others to read.    One of your goals as a programmer should be to write simple code that does what you want it to, and functions help you do this. They allow you to write blocks of code and leave them alone once you know they work. When you know a function does its job correctly, you can trust that it will continue to work and move on to your next coding task.    Functions allow you to write code once and then reuse that code as many times as you want. When you need to run the code in a function, all you need to do is write a one-line call and the function does its job. When you need to modify a function’s behavior, you only have to modify one block of code, and your change takes effect everywhere you’ve made a call to that function.    Using functions makes your programs easier to read, and good function names summarize what each part of a program does. Reading a series of function calls gives you a much quicker sense of what a program does than reading a long series of code blocks.    Functions also make your code easier to test and debug. When the bulk of your program’s work is done by a set of functions, each of which has a specific job, it’s much easier to test and maintain the code you’ve written. You can write a separate program that calls each function and tests whether each function works in all the situations it may encounter. When you do this, you can be confident that your functions will work properly each time you call them.    In Chapter 9, you’ll learn to write classes. *Classes* combine functions and data into one neat package that can be used in flexible and efficient ways.``` `  ```py`# 9 Classes  ![](img/chapterart.png)  *Object-oriented programming (OOP**)* is one of the most effective approaches to writing software. In object-oriented programming, you write *classes* that represent real-world things and situations, and you create *objects* based on these classes. When you write a class, you define the general behavior that a whole category of objects can have.    When you create individual objects from the class, each object is automatically equipped with the general behavior; you can then give each object whatever unique traits you desire. You’ll be amazed how well real-world situations can be modeled with object-oriented programming.    Making an object from a class is called *instantiation*, and you work with *instances* of a class. In this chapter you’ll write classes and create instances of those classes. You’ll specify the kind of information that can be stored in instances, and you’ll define actions that can be taken with these instances. You’ll also write classes that extend the functionality of existing classes, so similar classes can share common functionality, and you can do more with less code. You’ll store your classes in modules and import classes written by other programmers into your own program files.    Learning about object-oriented programming will help you see the world as a programmer does. It’ll help you understand your code—not just what’s happening line by line, but also the bigger concepts behind it. Knowing the logic behind classes will train you to think logically, so you can write programs that effectively address almost any problem you encounter.    Classes also make life easier for you and the other programmers you’ll work with as you take on increasingly complex challenges. When you and other programmers write code based on the same kind of logic, you’ll be able to understand each other’s work. Your programs will make sense to the people you work with, allowing everyone to accomplish more.    ## Creating and Using a Class    You can model almost anything using classes. Let’s start by writing a simple class, `Dog`, that represents a dog—not one dog in particular, but any dog. What do we know about most pet dogs? Well, they all have a name and an age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our `Dog` class because they’re common to most dogs. This class will tell Python how to make an object representing a dog. After our class is written, we’ll use it to make individual instances, each of which represents one specific dog.    ### Creating the Dog Class    Each instance created from the `Dog` class will store a `name` and an `age`, and we’ll give each dog the ability to `sit()` and `roll_over()`:    **dog.py**    ``` ❶ class Dog: """一个简单的模拟狗的尝试。""" ❷ def __init__(self, name, age): """初始化姓名和年龄属性。""" ❸ self.name = name self.age = age ❹ def sit(self): """模拟狗根据命令坐下。""" print(f"{self.name} is now sitting.") def roll_over(self): """模拟根据命令翻滚。""" print(f"{self.name} rolled over!") ```py    There’s a lot to notice here, but don’t worry. You’ll see this structure throughout this chapter and have lots of time to get used to it. We first define a class called `Dog` ❶. By convention, capitalized names refer to classes in Python. There are no parentheses in the class definition because we’re creating this class from scratch. We then write a docstring describing what this class does.    ### The __init__() Method    A function that’s part of a class is a *method*. Everything you learned about functions applies to methods as well; the only practical difference for now is the way we’ll call methods. The `__init__()` method ❷ is a special method that Python runs automatically whenever we create a new instance based on the `Dog` class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python’s default method names from conflicting with your method names. Make sure to use two underscores on each side of `__init__()`. If you use just one on each side, the method won’t be called automatically when you use your class, which can result in errors that are difficult to identify.    We define the `__init__()` method to have three parameters: `self`, `name`, and `age`. The `self` parameter is required in the method definition, and it must come first, before the other parameters. It must be included in the definition because when Python calls this method later (to create an instance of `Dog`), the method call will automatically pass the `self` argument. Every method call associated with an instance automatically passes `self`, which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class. When we make an instance of `Dog`, Python will call the `__init__()` method from the `Dog` class. We’ll pass `Dog()` a name and an age as arguments; `self` is passed automatically, so we don’t need to pass it. Whenever we want to make an instance from the `Dog` class, we’ll provide values for only the last two parameters, `name` and `age`.    The two variables defined in the body of the `__init__()` method each have the prefix `self` ❸. Any variable prefixed with `self` is available to every method in the class, and we’ll also be able to access these variables through any instance created from the class. The line `self.name = name` takes the value associated with the parameter `name` and assigns it to the variable `name`, which is then attached to the instance being created. The same process happens with `self.age = age`. Variables that are accessible through instances like this are called *attributes*.    The `Dog` class has two other methods defined: `sit()` and `roll_over()` ❹. Because these methods don’t need additional information to run, we just define them to have one parameter, `self`. The instances we create later will have access to these methods. In other words, they’ll be able to sit and roll over. For now, `sit()` and `roll_over()` don’t do much. They simply print a message saying the dog is sitting or rolling over. But the concept can be extended to realistic situations: if this class were part of a computer game, these methods would contain code to make an animated dog sit and roll over. If this class was written to control a robot, these methods would direct movements that cause a robotic dog to sit and roll over.    ### Making an Instance from a Class    Think of a class as a set of instructions for how to make an instance. The `Dog` class is a set of instructions that tells Python how to make individual instances representing specific dogs.    Let’s make an instance representing a specific dog:    ``` class Dog: *--snip--* ❶ my_dog = Dog('Willie', 6) ❷ print(f"My dog's name is {my_dog.name}.") ❸ print(f"My dog is {my_dog.age} years old.") ```py    The `Dog` class we’re using here is the one we just wrote in the previous example. Here, we tell Python to create a dog whose name is `'Willie'` and whose age is `6` ❶. When Python reads this line, it calls the `__init__()` method in `Dog` with the arguments `'Willie'` and `6`. The `__init__()` method creates an instance representing this particular dog and sets the `name` and `age` attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable `my_dog`. The naming convention is helpful here; we can usually assume that a capitalized name like `Dog` refers to a class, and a lowercase name like `my_dog` refers to a single instance created from a class.    #### Accessing Attributes    To access the attributes of an instance, you use dot notation. We access the value of `my_dog`’s attribute `name` ❷ by writing:    ``` my_dog.name ```py    Dot notation is used often in Python. This syntax demonstrates how Python finds an attribute’s value. Here, Python looks at the instance `my_dog` and then finds the attribute `name` associated with `my_dog`. This is the same attribute referred to as `self.name` in the class `Dog`. We use the same approach to work with the attribute `age` ❸.    The output is a summary of what we know about `my_dog`:    ``` My dog's name is Willie. My dog is 6 years old. ```py    #### Calling Methods    After we create an instance from the class `Dog`, we can use dot notation to call any method defined in `Dog`. Let’s make our dog sit and roll over:    ``` class Dog: *--snip--* my_dog = Dog('Willie', 6) my_dog.sit() my_dog.roll_over() ```py    To call a method, give the name of the instance (in this case, `my_dog`) and the method you want to call, separated by a dot. When Python reads `my_dog.sit()`, it looks for the method `sit()` in the class `Dog` and runs that code. Python interprets the line `my_dog.roll_over()` in the same way.    Now Willie does what we tell him to:    ``` Willie is now sitting. Willie rolled over! ```py    This syntax is quite useful. When attributes and methods have been given appropriately descriptive names like `name`, `age`, `sit()`, and `roll_over()`, we can easily infer what a block of code, even one we’ve never seen before, is supposed to do.    #### Creating Multiple Instances    You can create as many instances from a class as you need. Let’s create a second dog called `your_dog`:    ``` class Dog: *--snip--* my_dog = Dog('Willie', 6) your_dog = Dog('Lucy', 3) print(f"My dog's name is {my_dog.name}.") print(f"My dog is {my_dog.age} years old.") my_dog.sit() print(f"\nYour dog's name is {your_dog.name}.") print(f"Your dog is {your_dog.age} years old.") your_dog.sit() ```py    In this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions:    ``` My dog's name is Willie. My dog is 6 years old. Willie is now sitting. Your dog's name is Lucy. Your dog is 3 years old. Lucy is now sitting. ```py    Even if we used the same name and age for the second dog, Python would still create a separate instance from the `Dog` class. You can make as many instances from one class as you need, as long as you give each instance a unique variable name or it occupies a unique spot in a list or dictionary.    ## Working with Classes and Instances    You can use classes to represent many real-world situations. Once you write a class, you’ll spend most of your time working with instances created from that class. One of the first tasks you’ll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.    ### The Car Class    Let’s write a new class representing a car. Our class will store information about the kind of car we’re working with, and it will have a method that summarizes this information:    **car.py**    ``` class Car: """一个简单的表示汽车的尝试。""" ❶ def __init__(self, make, model, year): """初始化属性以描述汽车。""" self.make = make self.model = model self.year = year ❷ def get_descriptive_name(self): """返回一个格式整洁的描述性名称。""" long_name = f"{self.year} {self.make} {self.model}" return long_name.title() ❸ my_new_car = Car('audi', 'a4', 2024) print(my_new_car.get_descriptive_name()) ```py    In the `Car` class, we define the `__init__()` method with the `self` parameter first ❶, just like we did with the `Dog` class. We also give it three other parameters: `make`, `model`, and `year`. The `__init__()` method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new `Car` instance, we’ll need to specify a make, model, and year for our instance.    We define a method called `get_descriptive_name()` ❷ that puts a car’s `year`, `make`, and `model` into one string neatly describing the car. This will spare us from having to print each attribute’s value individually. To work with the attribute values in this method, we use `self.make`, `self.model`, and `self.year`. Outside of the class, we make an instance from the `Car` class and assign it to the variable `my_new_car` ❸. Then we call `get_descriptive_name()` to show what kind of car we have:    ``` 2024 Audi A4 ```py    To make the class more interesting, let’s add an attribute that changes over time. We’ll add an attribute that stores the car’s overall mileage.    ### Setting a Default Value for an Attribute    When an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the `__init__()` method, where they are assigned a default value.    Let’s add an attribute called `odometer_reading` that always starts with a value of 0\. We’ll also add a method `read_odometer()` that helps us read each car’s odometer:    ``` class Car: def __init__(self, make, model, year): """初始化属性以描述汽车。""" self.make = make self.model = model self.year = year ❶ self.odometer_reading = 0 def get_descriptive_name(self): *--snip--* ❷ def read_odometer(self): """打印一条显示汽车里程的语句。""" print(f"This car has {self.odometer_reading} miles on it.") my_new_car = Car('audi', 'a4', 2024) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() ```py    This time, when Python calls the `__init__()` method to create a new instance, it stores the make, model, and year values as attributes, like it did in the previous example. Then Python creates a new attribute called `odometer_reading` and sets its initial value to 0 ❶. We also have a new method called `read_odometer()` ❷ that makes it easy to read a car’s mileage.    Our car starts with a mileage of 0:    ``` 2024 Audi A4 This car has 0 miles on it. ```py    Not many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute.    ### Modifying Attribute Values    You can change an attribute’s value in three ways: you can change the value directly through an instance, set the value through a method, or increment the value (add a certain amount to it) through a method. Let’s look at each of these approaches.    #### Modifying an Attribute’s Value Directly    The simplest way to modify the value of an attribute is to access the attribute directly through an instance. Here we set the odometer reading to 23 directly:    ``` class Car: *--snip--* my_new_car = Car('audi', 'a4', 2024) print(my_new_car.get_descriptive_name()) my_new_car.odometer_reading = 23 my_new_car.read_odometer() ```py    We use dot notation to access the car’s `odometer_reading` attribute, and set its value directly. This line tells Python to take the instance `my_new_car`, find the attribute `odometer_reading` associated with it, and set the value of that attribute to 23:    ``` 2024 Audi A4 This car has 23 miles on it. ```py    Sometimes you’ll want to access attributes directly like this, but other times you’ll want to write a method that updates the value for you.    #### Modifying an Attribute’s Value Through a Method    It can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally.    Here’s an example showing a method called `update_odometer()`:    ``` class Car: *--snip--* def update_odometer(self, mileage): """将里程表读数设置为给定值。""" self.odometer_reading = mileage my_new_car = Car('audi', 'a4', 2024) print(my_new_car.get_descriptive_name()) ❶ my_new_car.update_odometer(23) my_new_car.read_odometer() ```py    The only modification to `Car` is the addition of `update_odometer()`. This method takes in a mileage value and assigns it to `self.odometer_reading`. Using the `my_new_car` instance, we call `update_odometer()` with `23` as an argument ❶. This sets the odometer reading to 23, and `read_odometer()` prints the reading:    ``` 2024 Audi A4 This car has 23 miles on it. ```py    We can extend the method `update_odometer()` to do additional work every time the odometer reading is modified. Let’s add a little logic to make sure no one tries to roll back the odometer reading:    ``` class Car: *--snip--* def update_odometer(self, mileage): """ 将里程表读数设置为给定值。 如果尝试倒转里程表，则拒绝更改。 """ ❶ if mileage >= self.odometer_reading: self.odometer_reading = mileage else: ❷ print("You can't roll back an odometer!") ```py    Now `update_odometer()` checks that the new reading makes sense before modifying the attribute. If the value provided for `mileage` is greater than or equal to the existing mileage, `self.odometer_reading`, you can update the odometer reading to the new mileage ❶. If the new mileage is less than the existing mileage, you’ll get a warning that you can’t roll back an odometer ❷.    #### Incrementing an Attribute’s Value Through a Method    Sometimes you’ll want to increment an attribute’s value by a certain amount, rather than set an entirely new value. Say we buy a used car and put 100 miles on it between the time we buy it and the time we register it. Here’s a method that allows us to pass this incremental amount and add that value to the odometer reading:    ``` class Car: *--snip--* def update_odometer(self, mileage): *--snip--* def increment_odometer(self, miles): """将给定的量添加到里程表读数。""" self.odometer_reading += miles ❶ my_used_car = Car('subaru', 'outback', 2019) print(my_used_car.get_descriptive_name()) ❷ my_used_car.update_odometer(23_500) my_used_car.read_odometer() my_used_car.increment_odometer(100) my_used_car.read_odometer() ```py    The new method `increment_odometer()` takes in a number of miles, and adds this value to `self.odometer_reading`. First, we create a used car, `my_used_car` ❶. We set its odometer to 23,500 by calling `update_odometer()` and passing it `23_500` ❷. Finally, we call `increment_odometer()` and pass it `100` to add the 100 miles that we drove between buying the car and registering it:    ``` 2019 Subaru Outback This car has 23500 miles on it. This car has 23600 miles on it. ```py    You can modify this method to reject negative increments so no one uses this function to roll back an odometer as well.    ## Inheritance    You don’t always have to start from scratch when writing a class. If the class you’re writing is a specialized version of another class you wrote, you can use *inheritance*. When one class *inherits* from another, it takes on the attributes and methods of the first class. The original class is called the *parent class*, and the new class is the *child class*. The child class can inherit any or all of the attributes and methods of its parent class, but it’s also free to define new attributes and methods of its own.    ### The __init__() Method for a Child Class    When you’re writing a new class based on an existing class, you’ll often want to call the `__init__()` method from the parent class. This will initialize any attributes that were defined in the parent `__init__()` method and make them available in the child class.    As an example, let’s model an electric car. An electric car is just a specific kind of car, so we can base our new `ElectricCar` class on the `Car` class we wrote earlier. Then we’ll only have to write code for the attributes and behaviors specific to electric cars.    Let’s start by making a simple version of the `ElectricCar` class, which does everything the `Car` class does:    **electric_car.py**    ``` ❶ class Car: """一个简单的表示汽车的尝试。""" def __init__(self, make, model, year): """初始化属性以描述汽车。""" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): """返回一个格式整洁的描述性名称。""" long_name = f"{self.year} {self.make} {self.model}" return long_name.title() def read_odometer(self): """打印一条显示汽车里程的语句。""" print(f"This car has {self.odometer_reading} miles on it.") def update_odometer(self, mileage): """将里程表读数设置为给定值。""" if mileage >= self.odometer_reading: self.odometer_reading = mileage else: print("You can't roll back an odometer!") def increment_odometer(self, miles): """将给定的量添加到里程表读数。""" self.odometer_reading += miles ❷ class ElectricCar(Car): """表示汽车的各个方面，特别是电动汽车。""" ❸ def __init__(self, make, model, year): """初始化父类的属性。""" ❹ super().__init__(make, model, year) ❺ my_leaf = ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) ```py    We start with `Car` ❶. When you create a child class, the parent class must be part of the current file and must appear before the child class in the file. We then define the child class, `ElectricCar` ❷. The name of the parent class must be included in parentheses in the definition of a child class. The `__init__()` method takes in the information required to make a `Car` instance ❸.    The `super()` function ❹ is a special function that allows you to call a method from the parent class. This line tells Python to call the `__init__()` method from `Car`, which gives an `ElectricCar` instance all the attributes defined in that method. The name *super* comes from a convention of calling the parent class a *superclass* and the child class a *subclass*.    We test whether inheritance is working properly by trying to create an electric car with the same kind of information we’d provide when making a regular car. We make an instance of the `ElectricCar` class and assign it to `my_leaf` ❺. This line calls the `__init__()` method defined in `ElectricCar`, which in turn tells Python to call the `__init__()` method defined in the parent class `Car`. We provide the arguments `'nissan'`, `'leaf'`, and `2024`.    Aside from `__init__()`, there are no attributes or methods yet that are particular to an electric car. At this point we’re just making sure the electric car has the appropriate `Car` behaviors:    ``` 2024 Nissan Leaf ```py    The `ElectricCar` instance works just like an instance of `Car`, so now we can begin defining attributes and methods specific to electric cars.    ### Defining Attributes and Methods for the Child Class    Once you have a child class that inherits from a parent class, you can add any new attributes and methods necessary to differentiate the child class from the parent class.    Let’s add an attribute that’s specific to electric cars (a battery, for example) and a method to report on this attribute. We’ll store the battery size and write a method that prints a description of the battery:    ``` class Car: *--snip--* class ElectricCar(Car): """表示汽车的各个方面，特别是电动汽车。""" def __init__(self, make, model, year): """ 初始化父类的属性。 然后初始化电动汽车特有的属性。 """ super().__init__(make, model, year) ❶ self.battery_size = 40 ❷ def describe_battery(self): """打印一条描述电池大小的语句。""" print(f"This car has a {self.battery_size}-kWh battery.") my_leaf = ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) my_leaf.describe_battery() ```py    We add a new attribute `self.battery_size` and set its initial value to `40` ❶. This attribute will be associated with all instances created from the `ElectricCar` class but won’t be associated with any instances of `Car`. We also add a method called `describe_battery()` that prints information about the battery ❷. When we call this method, we get a description that is clearly specific to an electric car:    ``` 2024 Nissan Leaf This car has a 40-kWh battery. ```py    There’s no limit to how much you can specialize the `ElectricCar` class. You can add as many attributes and methods as you need to model an electric car to whatever degree of accuracy you need. An attribute or method that could belong to any car, rather than one that’s specific to an electric car, should be added to the `Car` class instead of the `ElectricCar` class. Then anyone who uses the `Car` class will have that functionality available as well, and the `ElectricCar` class will only contain code for the information and behavior specific to electric vehicles.    ### Overriding Methods from the Parent Class    You can override any method from the parent class that doesn’t fit what you’re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class.    Say the class `Car` had a method called `fill_gas_tank()`. This method is meaningless for an all-electric vehicle, so you might want to override this method. Here’s one way to do that:    ``` class ElectricCar(Car): *--snip--* def fill_gas_tank(self): """电动汽车没有油箱。""" print("This car doesn't have a gas tank!") ```py    Now if someone tries to call `fill_gas_tank()` with an electric car, Python will ignore the method `fill_gas_tank()` in `Car` and run this code instead. When you use inheritance, you can make your child classes retain what you need and override anything you don’t need from the parent class.    ### Instances as Attributes    When modeling something from the real world in code, you may find that you’re adding more and more detail to a class. You’ll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together; this approach is called *composition*.    For example, if we continue adding detail to the `ElectricCar` class, we might notice that we’re adding many attributes and methods specific to the car’s battery. When we see this happening, we can stop and move those attributes and methods to a separate class called `Battery`. Then we can use a `Battery` instance as an attribute in the `ElectricCar` class:    ``` class Car: *--snip--* class Battery: """一个简单的电动汽车电池模型。""" ❶ def __init__(self, battery_size=40): """初始化电池的属性。""" self.battery_size = battery_size ❷ def describe_battery(self): """打印一条描述电池大小的语句。""" print(f"This car has a {self.battery_size}-kWh battery.") class ElectricCar(Car): """表示汽车的各个方面，特别是电动汽车。""" def __init__(self, make, model, year): """ 初始化父类的属性。 然后初始化电动汽车特有的属性。 """ super().__init__(make, model, year) ❸ self.battery = Battery() my_leaf = ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery() ```py    We define a new class called `Battery` that doesn’t inherit from any other class. The `__init__()` method ❶ has one parameter, `battery_size`, in addition to `self`. This is an optional parameter that sets the battery’s size to 40 if no value is provided. The method `describe_battery()` has been moved to this class as well ❷.    In the `ElectricCar` class, we now add an attribute called `self.battery` ❸. This line tells Python to create a new instance of `Battery` (with a default size of 40, because we’re not specifying a value) and assign that instance to the attribute `self.battery`. This will happen every time the `__init__()` method is called; any `ElectricCar` instance will now have a `Battery` instance created automatically.    We create an electric car and assign it to the variable `my_leaf`. When we want to describe the battery, we need to work through the car’s `battery` attribute:    ``` my_leaf.battery.describe_battery() ```py    This line tells Python to look at the instance `my_leaf`, find its `battery` attribute, and call the method `describe_battery()` that’s associated with the `Battery` instance assigned to the attribute.    The output is identical to what we saw previously:    ``` 2024 Nissan Leaf This car has a 40-kWh battery. ```py    This looks like a lot of extra work, but now we can describe the battery in as much detail as we want without cluttering the `ElectricCar` class. Let’s add another method to `Battery` that reports the range of the car based on the battery size:    ``` class Car: *--snip--* class Battery: *--snip--* def get_range(self): """打印一条关于此电池提供的续航里程的语句。""" if self.battery_size == 40: range = 150 elif self.battery_size == 65: range = 225 print(f"This car can go about {range} miles on a full charge.") class ElectricCar(Car): *--snip--* my_leaf = ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery() ❶ my_leaf.battery.get_range() ```py    The new method `get_range()` performs some simple analysis. If the battery’s capacity is 40 kWh, `get_range()` sets the range to 150 miles, and if the capacity is 65 kWh, it sets the range to 225 miles. It then reports this value. When we want to use this method, we again have to call it through the car’s `battery` attribute ❶.    The output tells us the range of the car based on its battery size:    ``` 2024 Nissan Leaf This car has a 40-kWh battery. This car can go about 150 miles on a full charge. ```py    ### Modeling Real-World Objects    As you begin to model more complicated things like electric cars, you’ll wrestle with interesting questions. Is the range of an electric car a property of the battery or of the car? If we’re only describing one car, it’s probably fine to maintain the association of the method `get_range()` with the `Battery` class. But if we’re describing a manufacturer’s entire line of cars, we probably want to move `get_range()` to the `ElectricCar` class. The `get_range()` method would still check the battery size before determining the range, but it would report a range specific to the kind of car it’s associated with. Alternatively, we could maintain the association of the `get_range()` method with the battery but pass it a parameter such as `car_model`. The `get_range()` method would then report a range based on the battery size and car model.    This brings you to an interesting point in your growth as a programmer. When you wrestle with questions like these, you’re thinking at a higher logical level rather than a syntax-focused level. You’re thinking not about Python, but about how to represent the real world in code. When you reach this point, you’ll realize there are often no right or wrong approaches to modeling real-world situations. Some approaches are more efficient than others, but it takes practice to find the most efficient representations. If your code is working as you want it to, you’re doing well! Don’t be discouraged if you find you’re ripping apart your classes and rewriting them several times using different approaches. In the quest to write accurate, efficient code, everyone goes through this process.    ## Importing Classes    As you add more functionality to your classes, your files can get long, even when you use inheritance and composition properly. In keeping with the overall philosophy of Python, you’ll want to keep your files as uncluttered as possible. To help, Python lets you store classes in modules and then import the classes you need into your main program.    ### Importing a Single Class    Let’s create a module containing just the `Car` class. This brings up a subtle naming issue: we already have a file named *car.py* in this chapter, but this module should be named *car.py* because it contains code representing a car. We’ll resolve this naming issue by storing the `Car` class in a module named *car.py*, replacing the *car.py* file we were previously using. From now on, any program that uses this module will need a more specific filename, such as *my_car.py*. Here’s *car.py* with just the code from the class `Car`:    **car.py**    ``` ❶ """一个可用于表示汽车的类。""" class Car: """一个简单的表示汽车的尝试。""" def __init__(self, make, model, year): """初始化属性以描述汽车。""" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): """返回一个格式整洁的描述性名称。""" long_name = f"{self.year} {self.make} {self.model}" return long_name.title() def read_odometer(self): """打印一条显示汽车里程的语句。""" print(f"This car has {self.odometer_reading} miles on it.") def update_odometer(self, mileage): """ 将里程表读数设置为给定值。 如果尝试倒转里程表，则拒绝更改。 """ if mileage >= self.odometer_reading: self.odometer_reading = mileage else: print("You can't roll back an odometer!") def increment_odometer(self, miles): """将给定的量添加到里程表读数。""" self.odometer_reading += miles ```py    We include a module-level docstring that briefly describes the contents of this module ❶. You should write a docstring for each module you create.    Now we make a separate file called *my_car.py*. This file will import the `Car` class and then create an instance from that class:    **my_car.py**    ``` ❶ from car import Car my_new_car = Car('audi', 'a4', 2024) print(my_new_car.get_descriptive_name()) my_new_car.odometer_reading = 23 my_new_car.read_odometer() ```py    The `import` statement ❶ tells Python to open the `car` module and import the class `Car`. Now we can use the `Car` class as if it were defined in this file. The output is the same as we saw earlier:    ``` 2024 Audi A4 This car has 23 miles on it. ```py    Importing classes is an effective way to program. Picture how long this program file would be if the entire `Car` class were included. When you instead move the class to a module and import the module, you still get all the same functionality, but you keep your main program file clean and easy to read. You also store most of the logic in separate files; once your classes work as you want them to, you can leave those files alone and focus on the higher-level logic of your main program.    ### Storing Multiple Classes in a Module    You can store as many classes as you need in a single module, although each class in a module should be related somehow. The classes `Battery` and `ElectricCar` both help represent cars, so let’s add them to the module *car.py*.    **car.py**    ``` """一组用于表示汽油和电动汽车的类。""" class Car: *--snip--* class Battery: """一个简单的电动汽车电池模型。""" def __init__(self, battery_size=40): """初始化电池的属性。""" self.battery_size = battery_size def describe_battery(self): """打印一条描述电池大小的语句。""" print(f"This car has a {self.battery_size}-kWh battery.") def get_range(self): """打印一条关于此电池提供的续航里程的语句。""" if self.battery_size == 40: range = 150 elif self.battery_size == 65: range = 225 print(f"This car can go about {range} miles on a full charge.") class ElectricCar(Car): """模拟汽车的各个方面，特别是电动汽车。""" def __init__(self, make, model, year): """ 初始化父类的属性。 然后初始化电动汽车特有的属性。 """ super().__init__(make, model, year) self.battery = Battery() ```py    Now we can make a new file called *my_electric_car.py*, import the `ElectricCar` class, and make an electric car:    **my_electric_car.py**    ``` from car import ElectricCar my_leaf = ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery() my_leaf.battery.get_range() ```py    This has the same output we saw earlier, even though most of the logic is hidden away in a module:    ``` 2024 Nissan Leaf This car has a 40-kWh battery. This car can go about 150 miles on a full charge. ```py    ### Importing Multiple Classes from a Module    You can import as many classes as you need into a program file. If we want to make a regular car and an electric car in the same file, we need to import both classes, `Car` and `ElectricCar`:    **my_cars.py**    ``` ❶ from car import Car, ElectricCar ❷ my_mustang = Car('ford', 'mustang', 2024) print(my_mustang.get_descriptive_name()) ❸ my_leaf = ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) ```py    You import multiple classes from a module by separating each class with a comma ❶. Once you’ve imported the necessary classes, you’re free to make as many instances of each class as you need.    In this example we make a gas-powered Ford Mustang ❷ and then an electric Nissan Leaf ❸:    ``` 2024 Ford Mustang 2024 Nissan Leaf ```py    ### Importing an Entire Module    You can also import an entire module and then access the classes you need using dot notation. This approach is simple and results in code that is easy to read. Because every call that creates an instance of a class includes the module name, you won’t have naming conflicts with any names used in the current file.    Here’s what it looks like to import the entire `car` module and then create a regular car and an electric car:    **my_cars.py**    ``` ❶ import car ❷ my_mustang = car.Car('ford', 'mustang', 2024) print(my_mustang.get_descriptive_name()) ❸ my_leaf = car.ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) ```py    First we import the entire `car` module ❶. We then access the classes we need through the `module_name`.`ClassName` syntax. We again create a Ford Mustang ❷, and a Nissan Leaf ❸.    ### Importing All Classes from a Module    You can import every class from a module using the following syntax:    ``` from `module_name` import * ```py    This method is not recommended for two reasons. First, it’s helpful to be able to read the `import` statements at the top of a file and get a clear sense of which classes a program uses. With this approach it’s unclear which classes you’re using from the module. This approach can also lead to confusion with names in the file. If you accidentally import a class with the same name as something else in your program file, you can create errors that are hard to diagnose. I show this here because even though it’s not a recommended approach, you’re likely to see it in other people’s code at some point.    If you need to import many classes from a module, you’re better off importing the entire module and using the `module_name.ClassName` syntax. You won’t see all the classes used at the top of the file, but you’ll see clearly where the module is used in the program. You’ll also avoid the potential naming conflicts that can arise when you import every class in a module.    ### Importing a Module into a Module    Sometimes you’ll want to spread out your classes over several modules to keep any one file from growing too large and avoid storing unrelated classes in the same module. When you store your classes in several modules, you may find that a class in one module depends on a class in another module. When this happens, you can import the required class into the first module.    For example, let’s store the `Car` class in one module and the `ElectricCar` and `Battery` classes in a separate module. We’ll make a new module called *electric_car.py*—replacing the *electric_car.py* file we created earlier—and copy just the `Battery` and `ElectricCar` classes into this file:    **electric_car.py**    ``` """一组可用于表示电动汽车的类。""" from car import Car class Battery: *--snip--* class ElectricCar(Car): *--snip--* ```py    The class `ElectricCar` needs access to its parent class `Car`, so we import `Car` directly into the module. If we forget this line, Python will raise an error when we try to import the `electric_car` module. We also need to update the `Car` module so it contains only the `Car` class:    **car.py**    ``` """一个可用于表示汽车的类。""" class Car: *--snip--* ```py    Now we can import from each module separately and create whatever kind of car we need:    **my_cars.py**    ``` from car import Car from electric_car import ElectricCar my_mustang = Car('ford', 'mustang', 2024) print(my_mustang.get_descriptive_name()) my_leaf = ElectricCar('nissan', 'leaf', 2024) print(my_leaf.get_descriptive_name()) ```py    We import `Car` from its module, and `ElectricCar` from its module. We then create one regular car and one electric car. Both cars are created correctly:    ``` 2024 Ford Mustang 2024 Nissan Leaf ```py    ### Using Aliases    As you saw in Chapter 8, aliases can be quite helpful when using modules to organize your projects’ code. You can use aliases when importing classes as well.    As an example, consider a program where you want to make a bunch of electric cars. It might get tedious to type (and read) `ElectricCar` over and over again. You can give `ElectricCar` an alias in the import statement:    ``` from electric_car import ElectricCar as EC ```py    Now you can use this alias whenever you want to make an electric car:    ``` my_leaf = EC('nissan', 'leaf', 2024) ```py    You can also give a module an alias. Here’s how to import the entire `electric_car` module using an alias:    ``` import electric_car as ec ```py    Now you can use this module alias with the full class name:    ``` my_leaf = ec.ElectricCar('nissan', 'leaf', 2024) ```py    ### Finding Your Own Workflow    As you can see, Python gives you many options for how to structure code in a large project. It’s important to know all these possibilities so you can determine the best ways to organize your projects as well as understand other people’s projects.    When you’re starting out, keep your code structure simple. Try doing everything in one file and moving your classes to separate modules once everything is working. If you like how modules and files interact, try storing your classes in modules when you start a project. Find an approach that lets you write code that works, and go from there.    ## The Python Standard Library    The *Python standard library* is a set of modules included with every Python installation. Now that you have a basic understanding of how functions and classes work, you can start to use modules like these that other programmers have written. You can use any function or class in the standard library by including a simple `import` statement at the top of your file. Let’s look at one module, `random`, which can be useful in modeling many real-world situations.    One interesting function from the random module is `randint()`. This function takes two integer arguments and returns a randomly selected integer between (and including) those numbers.    Here’s how to generate a random number between 1 and 6:    ``` >>> **from random import randint** >>> **randint(1, 6)** 3 ```py    Another useful function is `choice()`. This function takes in a list or tuple and returns a randomly chosen element:    ``` >>> **from random import choice** >>> **players = ['charles', 'martina', 'michael', 'florence', 'eli']** >>> **first_up = choice(players)** >>> **first_up** 'florence' ```py    The `random` module shouldn’t be used when building security-related applications, but it works well for many fun and interesting projects.    ## Styling Classes    A few styling issues related to classes are worth clarifying, especially as your programs become more complicated.    Class names should be written in *CamelCase*. To do this, capitalize the first letter of each word in the name, and don’t use underscores. Instance and module names should be written in lowercase, with underscores between words.    Every class should have a docstring immediately following the class definition. The docstring should be a brief description of what the class does, and you should follow the same formatting conventions you used for writing docstrings in functions. Each module should also have a docstring describing what the classes in a module can be used for.    You can use blank lines to organize code, but don’t use them excessively. Within a class you can use one blank line between methods, and within a module you can use two blank lines to separate classes.    If you need to import a module from the standard library and a module that you wrote, place the import statement for the standard library module first. Then add a blank line and the import statement for the module you wrote. In programs with multiple import statements, this convention makes it easier to see where the different modules used in the program come from.    ## Summary    In this chapter, you learned how to write your own classes. You learned how to store information in a class using attributes and how to write methods that give your classes the behavior they need. You learned to write `__init__()` methods that create instances from your classes with exactly the attributes you want. You saw how to modify the attributes of an instance directly and through methods. You learned that inheritance can simplify the creation of classes that are related to each other, and you learned to use instances of one class as attributes in another class to keep each class simple.    You saw how storing classes in modules and importing classes you need into the files where they’ll be used can keep your projects organized. You started learning about the Python standard library, and you saw an example based on the `random` module. Finally, you learned to style your classes using Python conventions.    In Chapter 10, you’ll learn to work with files so you can save the work you’ve done in a program and the work you’ve allowed users to do. You’ll also learn about *exceptions*, a special Python class designed to help you respond to errors when they arise.    # 10 Files and Exceptions  ![](img/chapterart.png)  Now that you’ve mastered the basic skills you need to write organized programs that are easy to use, it’s time to think about making your programs even more relevant and usable. In this chapter, you’ll learn to work with files so your programs can quickly analyze lots of data.    You’ll learn to handle errors so your programs don’t crash when they encounter unexpected situations. You’ll learn about *exceptions*, which are special objects Python creates to manage errors that arise while a program is running. You’ll also learn about the `json` module, which allows you to save user data so it isn’t lost when your program stops running.    Learning to work with files and save data will make your programs easier for people to use. Users will be able to choose what data to enter and when to enter it. People will be able to run your program, do some work, and then close the program and pick up where they left off. Learning to handle exceptions will help you deal with situations in which files don’t exist and deal with other problems that can cause your programs to crash. This will make your programs more robust when they encounter bad data, whether it comes from innocent mistakes or from malicious attempts to break your programs. With the skills you’ll learn in this chapter, you’ll make your programs more applicable, usable, and stable.    ## Reading from a File    An incredible amount of data is available in text files. Text files can contain weather data, traffic data, socioeconomic data, literary works, and more. Reading from a file is particularly useful in data analysis applications, but it’s also applicable to any situation in which you want to analyze or modify information stored in a file. For example, you can write a program that reads in the contents of a text file and rewrites the file with formatting that allows a browser to display it.    When you want to work with the information in a text file, the first step is to read the file into memory. You can then work through all of the file’s contents at once or work through the contents line by line.    ### Reading the Contents of a File    To begin, we need a file with a few lines of text in it. Let’s start with a file that contains *pi* to 30 decimal places, with 10 decimal places per line:    **pi_digits.txt**    ``` 3.1415926535 8979323846 2643383279 ```py    To try the following examples yourself, you can enter these lines in an editor and save the file as *pi_digits.txt*, or you can download the file from the book’s resources through [`ehmatthes.github.io/pcc_3e`](https://ehmatthes.github.io/pcc_3e). Save the file in the same directory where you’ll store this chapter’s programs.    Here’s a program that opens this file, reads it, and prints the contents of the file to the screen:    **file_reader.py**    ``` from pathlib import Path ❶ path = Path('pi_digits.txt') ❷ contents = path.read_text() print(contents) ```py    To work with the contents of a file, we need to tell Python the path to the file. A *path* is the exact location of a file or folder on a system. Python provides a module called `pathlib` that makes it easier to work with files and directories, no matter which operating system you or your program’s users are working with. A module that provides specific functionality like this is often called a *library*, hence the name `pathlib`.    We start by importing the `Path` class from `pathlib`. There’s a lot you can do with a `Path` object that points to a file. For example, you can check that the file exists before working with it, read the file’s contents, or write new data to the file. Here, we build a `Path` object representing the file *pi_digits.txt*, which we assign to the variable `path` ❶. Since this file is saved in the same directory as the *.py* file we’re writing, the filename is all that `Path` needs to access the file.    Once we have a `Path` object representing *pi_digits.txt*, we use the `read_text()` method to read the entire contents of the file ❷. The contents of the file are returned as a single string, which we assign to the variable `contents`. When we print the value of `contents`, we see the entire contents of the text file:    ``` 3.1415926535 8979323846 2643383279 ```py    The only difference between this output and the original file is the extra blank line at the end of the output. The blank line appears because `read_text()` returns an empty string when it reaches the end of the file; this empty string shows up as a blank line.    We can remove the extra blank line by using `rstrip()` on the `contents` string:    ``` from pathlib import Path path = Path('pi_digits.txt') contents = path.read_text() contents = contents.rstrip() print(contents) ```py    Recall from Chapter 2 that Python’s `rstrip()` method removes, or strips, any whitespace characters from the right side of a string. Now the output matches the contents of the original file exactly:    ``` 3.1415926535 8979323846 2643383279 ```py    We can strip the trailing newline character when we read the contents of the file, by applying the `rstrip()` method immediately after calling `read_text()`:    ``` contents = path.read_text().rstrip() ```py    This line tells Python to call the `read_text()` method on the file we’re working with. Then it applies the `rstrip()` method to the string that `read_text()` returns. The cleaned-up string is then assigned to the variable `contents`. This approach is called *method chaining*, and you’ll see it used often in programming.    ### Relative and Absolute File Paths    When you pass a simple filename like *pi_digits.txt* to `Path`, Python looks in the directory where the file that’s currently being executed (that is, your *.py* program file) is stored.    Sometimes, depending on how you organize your work, the file you want to open won’t be in the same directory as your program file. For example, you might store your program files in a folder called *python_work*; inside *python_work*, you might have another folder called *text_files* to distinguish your program files from the text files they’re manipulating. Even though *text_files* is in *python_work*, just passing `Path` the name of a file in *text_files* won’t work, because Python will only look in *python_work* and stop there; it won’t go on and look in *text_files.* To get Python to open files from a directory other than the one where your program file is stored, you need to provide the correct path.    There are two main ways to specify paths in programming. A *relative file path* tells Python to look for a given location relative to the directory where the currently running program file is stored. Since *text_files* is inside *python_work*, we need to build a path that starts with the directory *text_files*, and ends with the filename. Here’s how to build this path:    ``` path = Path('text_files/`filename`.txt') ```py    You can also tell Python exactly where the file is on your computer, regardless of where the program that’s being executed is stored. This is called an *absolute file path*. You can use an absolute path if a relative path doesn’t work. For instance, if you’ve put *text_files* in some folder other than *python_work*, then just passing `Path` the path `'text_files/``filename``.txt'` won’t work because Python will only look for that location inside *python_work*. You’ll need to write out an absolute path to clarify where you want Python to look.    Absolute paths are usually longer than relative paths, because they start at your system’s root folder:    ``` path = Path('/home/eric/data_files/text_files/`filename`.txt') ```py    Using absolute paths, you can read files from any location on your system. For now it’s easiest to store files in the same directory as your program files, or in a folder such as *text_files* within the directory that stores your program files.    ### Accessing a File’s Lines    When you’re working with a file, you’ll often want to examine each line of the file. You might be looking for certain information in the file, or you might want to modify the text in the file in some way. For example, you might want to read through a file of weather data and work with any line that includes the word *sunny* in the description of that day’s weather. In a news report, you might look for any line with the tag `<headline>` and rewrite that line with a specific kind of formatting.    You can use the `splitlines()` method to turn a long string into a set of lines, and then use a `for` loop to examine each line from a file, one at a time:    **file_reader.py**    ``` from pathlib import Path path = Path('pi_digits.txt') ❶ contents = path.read_text() ❷ lines = contents.splitlines() for line in lines: print(line) ```py    We start out by reading the entire contents of the file, as we did earlier ❶. If you’re planning to work with the individual lines in a file, you don’t need to strip any whitespace when reading the file. The `splitlines()` method returns a list of all lines in the file, and we assign this list to the variable `lines` ❷. We then loop over these lines and print each one:    ``` 3.1415926535 8979323846 2643383279 ```py    Since we haven’t modified any of the lines, the output matches the original text file exactly.    ### Working with a File’s Contents    After you’ve read the contents of a file into memory, you can do whatever you want with that data, so let’s briefly explore the digits of *pi*. First, we’ll attempt to build a single string containing all the digits in the file with no whitespace in it:    **pi_string.py**    ``` from pathlib import Path path = Path('pi_digits.txt') contents = path.read_text() lines = contents.splitlines() pi_string = '' ❶ for line in lines: pi_string += line print(pi_string) print(len(pi_string)) ```py    We start by reading the file and storing each line of digits in a list, just as we did in the previous example. We then create a variable, `pi_string`, to hold the digits of *pi*. We write a loop that adds each line of digits to `pi_string` ❶. We print this string, and also show how long the string is:    ``` 3.1415926535 8979323846 2643383279 36 ```py    The variable `pi_string` contains the whitespace that was on the left side of the digits in each line, but we can get rid of that by using `lstrip()` on each line:    ``` *--snip--* for line in lines: pi_string += line.lstrip() print(pi_string) print(len(pi_string)) ```py    Now we have a string containing *pi* to 30 decimal places. The string is 32 characters long because it also includes the leading `3` and a decimal point:    ``` 3.141592653589793238462643383279 32 ```py    ### Large Files: One Million Digits    So far, we’ve focused on analyzing a text file that contains only three lines, but the code in these examples would work just as well on much larger files. If we start with a text file that contains *pi* to 1,000,000 decimal places, instead of just 30, we can create a single string containing all these digits. We don’t need to change our program at all, except to pass it a different file. We’ll also print just the first 50 decimal places, so we don’t have to watch a million digits scroll by in the terminal:    **pi_string.py**    ``` from pathlib import Path path = Path('pi_million_digits.txt') contents = path.read_text() lines = contents.splitlines() pi_string = '' for line in lines: pi_string += line.lstrip() print(f"{pi_string[:52]}...") print(len(pi_string)) ```py    The output shows that we do indeed have a string containing *pi* to 1,000,000 decimal places:    ``` 3.14159265358979323846264338327950288419716939937510... 1000002 ```py    Python has no inherent limit to how much data you can work with; you can work with as much data as your system’s memory can handle.    ### Is Your Birthday Contained in Pi?    I’ve always been curious to know if my birthday appears anywhere in the digits of *pi*. Let’s use the program we just wrote to find out if someone’s birthday appears anywhere in the first million digits of *pi*. We can do this by expressing each birthday as a string of digits and seeing if that string appears anywhere in `pi_string`:    **pi_birthday.py**    ``` *--snip--* for line in lines: pi_string += line.strip() birthday = input("Enter your birthday, in the form mmddyy: ") if birthday in pi_string: print("Your birthday appears in the first million digits of pi!") else: print("Your birthday does not appear in the first million digits of pi.") ```py    We first prompt for the user’s birthday, and then check if that string is in `pi_string`. Let’s try it:    ``` Enter your birthdate, in the form mmddyy: **120372** Your birthday appears in the first million digits of pi! ```py    My birthday does appear in the digits of *pi*! Once you’ve read from a file, you can analyze its contents in just about any way you can imagine.    ## Writing to a File    One of the simplest ways to save data is to write it to a file. When you write text to a file, the output will still be available after you close the terminal containing your program’s output. You can examine output after a program finishes running, and you can share the output files with others as well. You can also write programs that read the text back into memory and work with it again later.    ### Writing a Single Line    Once you have a path defined, you can write to a file using the `write_text()` method. To see how this works, let’s write a simple message and store it in a file instead of printing it to the screen:    **write_message.py**    ``` from pathlib import Path path = Path('programming.txt') path.write_text("I love programming.") ```py    The `write_text()` method takes a single argument: the string that you want to write to the file. This program has no terminal output, but if you open the file *programming.txt*, you’ll see one line:    **programming.txt**    ``` I love programming. ```py    This file behaves like any other file on your computer. You can open it, write new text in it, copy from it, paste to it, and so forth.    ### Writing Multiple Lines    The `write_text()` method does a few things behind the scenes. If the file that `path` points to doesn’t exist, it creates that file. Also, after writing the string to the file, it makes sure the file is closed properly. Files that aren’t closed properly can lead to missing or corrupted data.    To write more than one line to a file, you need to build a string containing the entire contents of the file, and then call `write_text()` with that string. Let’s write several lines to the *programming.txt* file:    ``` from pathlib import Path contents = "I love programming.\n" contents += "I love creating new games.\n" contents += "I also love working with data.\n" path = Path('programming.txt') path.write_text(contents) ```py    We define a variable called `contents` that will hold the entire contents of the file. On the next line, we use the `+=` operator to add to this string. You can do this as many times as you need, to build strings of any length. In this case we include newline characters at the end of each line, to make sure each statement appears on its own line.    If you run this and then open *programming.txt*, you’ll see each of these lines in the text file:    ``` I love programming. I love creating new games. I also love working with data. ```py    You can also use spaces, tab characters, and blank lines to format your output, just as you’ve been doing with terminal-based output. There’s no limit to the length of your strings, and this is how many computer-generated documents are created.    ## Exceptions    Python uses special objects called *exceptions* to manage errors that arise during a program’s execution. Whenever an error occurs that makes Python unsure of what to do next, it creates an exception object. If you write code that handles the exception, the program will continue running. If you don’t handle the exception, the program will halt and show a *traceback*, which includes a report of the exception that was raised.    Exceptions are handled with `try`-`except` blocks. A *try*-*except* block asks Python to do something, but it also tells Python what to do if an exception is raised. When you use `try`-`except` blocks, your programs will continue running even if things start to go wrong. Instead of tracebacks, which can be confusing for users to read, users will see friendly error messages that you’ve written.    ### Handling the ZeroDivisionError Exception    Let’s look at a simple error that causes Python to raise an exception. You probably know that it’s impossible to divide a number by zero, but let’s ask Python to do it anyway:    **division_calculator.py**    ``` print(5/0) ```py    Python can’t do this, so we get a traceback:    ``` Traceback (most recent call last): File "division_calculator.py", line 1, in <module> print(5/0) ~^~ ❶ ZeroDivisionError: division by zero ```py    The error reported in the traceback, `ZeroDivisionError`, is an exception object ❶. Python creates this kind of object in response to a situation where it can’t do what we ask it to. When this happens, Python stops the program and tells us the kind of exception that was raised. We can use this information to modify our program. We’ll tell Python what to do when this kind of exception occurs; that way, if it happens again, we’ll be prepared.    ### Using try-except Blocks    When you think an error may occur, you can write a `try`-`except` block to handle the exception that might be raised. You tell Python to try running some code, and you tell it what to do if the code results in a particular kind of exception.    Here’s what a `try`-`except` block for handling the `ZeroDivisionError` exception looks like:    ``` try: print(5/0) except ZeroDivisionError: print("You can't divide by zero!") ```py    We put `print(5/0)`, the line that caused the error, inside a `try` block. If the code in a `try` block works, Python skips over the `except` block. If the code in the `try` block causes an error, Python looks for an `except` block whose error matches the one that was raised, and runs the code in that block.    In this example, the code in the `try` block produces a `ZeroDivisionError`, so Python looks for an `except` block telling it how to respond. Python then runs the code in that block, and the user sees a friendly error message instead of a traceback:    ``` You can't divide by zero! ```py    If more code followed the `try`-`except` block, the program would continue running because we told Python how to handle the error. Let’s look at an example where catching an error can allow a program to continue running.    ### Using Exceptions to Prevent Crashes    Handling errors correctly is especially important when the program has more work to do after the error occurs. This happens often in programs that prompt users for input. If the program responds to invalid input appropriately, it can prompt for more valid input instead of crashing.    Let’s create a simple calculator that does only division:    **division_calculator.py**    ``` print("Give me two numbers, and I'll divide them.") print("Enter 'q' to quit.") while True: ❶ first_number = input("\nFirst number: ") if first_number == 'q': break ❷ second_number = input("Second number: ") if second_number == 'q': break ❸ answer = int(first_number) / int(second_number) print(answer) ```py    This program prompts the user to input a `first_number` ❶ and, if the user does not enter `q` to quit, a `second_number` ❷. We then divide these two numbers to get an `answer` ❸. This program does nothing to handle errors, so asking it to divide by zero causes it to crash:    ``` Give me two numbers, and I'll divide them. Enter 'q' to quit. First number: **5** Second number: **0** Traceback (most recent call last): File "division_calculator.py", line 11, in <module> answer = int(first_number) / int(second_number) ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~ ZeroDivisionError: division by zero ```py    It’s bad that the program crashed, but it’s also not a good idea to let users see tracebacks. Nontechnical users will be confused by them, and in a malicious setting, attackers will learn more than you want them to. For example, they’ll know the name of your program file, and they’ll see a part of your code that isn’t working properly. A skilled attacker can sometimes use this information to determine which kind of attacks to use against your code.    ### The else Block    We can make this program more error resistant by wrapping the line that might produce errors in a `try`-`except` block. The error occurs on the line that performs the division, so that’s where we’ll put the `try`-`except` block. This example also includes an `else` block. Any code that depends on the `try` block executing successfully goes in the `else` block:    ``` *--snip--* while True: *--snip--* if second_number == 'q': break ❶ try: answer = int(first_number) / int(second_number) ❷ except ZeroDivisionError: print("You can't divide by 0!") ❸ else: print(answer) ```py    We ask Python to try to complete the division operation in a `try` block ❶, which includes only the code that might cause an error. Any code that depends on the `try` block succeeding is added to the `else` block. In this case, if the division operation is successful, we use the `else` block to print the result ❸.    The `except` block tells Python how to respond when a `ZeroDivisionError` arises ❷. If the `try` block doesn’t succeed because of a division-by-zero error, we print a friendly message telling the user how to avoid this kind of error. The program continues to run, and the user never sees a traceback:    ``` Give me two numbers, and I'll divide them. Enter 'q' to quit. First number: **5** Second number: **0** You can't divide by 0! First number: **5** Second number: **2** 2.5 First number: **q** ```py    The only code that should go in a `try` block is code that might cause an exception to be raised. Sometimes you’ll have additional code that should run only if the `try` block was successful; this code goes in the `else` block. The `except` block tells Python what to do in case a certain exception arises when it tries to run the code in the `try` block.    By anticipating likely sources of errors, you can write robust programs that continue to run even when they encounter invalid data and missing resources. Your code will be resistant to innocent user mistakes and malicious attacks.    ### Handling the FileNotFoundError Exception    One common issue when working with files is handling missing files. The file you’re looking for might be in a different location, the filename might be misspelled, or the file might not exist at all. You can handle all of these situations with a `try`-`except` block.    Let’s try to read a file that doesn’t exist. The following program tries to read in the contents of *Alice in Wonderland*, but I haven’t saved the file *alice.txt* in the same directory as *alice.py*:    **alice.py**    ``` from pathlib import Path path = Path('alice.txt') contents = path.read_text(encoding='utf-8') ```py    Note that we’re using `read_text()` in a slightly different way here than what you saw earlier. The `encoding` argument is needed when your system’s default encoding doesn’t match the encoding of the file that’s being read. This is most likely to happen when reading from a file that wasn’t created on your system.    Python can’t read from a missing file, so it raises an exception:    ``` Traceback (most recent call last): ❶ File "alice.py", line 4, in <module> ❷ contents = path.read_text(encoding='utf-8') ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File "/.../pathlib.py", line 1056, in read_text with self.open(mode='r', encoding=encoding, errors=errors) as f: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File "/.../pathlib.py", line 1042, in open return io.open(self, mode, buffering, encoding, errors, newline) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ❸ FileNotFoundError: [Errno 2] No such file or directory: 'alice.txt' ```py    This is a longer traceback than the ones we’ve seen previously, so let’s look at how you can make sense of more complex tracebacks. It’s often best to start at the very end of the traceback. On the last line, we can see that a `FileNotFoundError` exception was raised ❸. This is important because it tells us what kind of exception to use in the `except` block that we’ll write.    Looking back near the beginning of the traceback ❶, we can see that the error occurred at line 4 in the file *alice.py*. The next line shows the line of code that caused the error ❷. The rest of the traceback shows some code from the libraries that are involved in opening and reading from files. You don’t usually need to read through or understand all of these lines in a traceback.    To handle the error that’s being raised, the `try` block will begin with the line that was identified as problematic in the traceback. In our example, this is the line that contains `read_text()`:    ``` from pathlib import Path path = Path('alice.txt') try: contents = path.read_text(encoding='utf-8') ❶ except FileNotFoundError: print(f"Sorry, the file {path} does not exist.") ```py    In this example, the code in the `try` block produces a `FileNotFoundError`, so we write an `except` block that matches that error ❶. Python then runs the code in that block when the file can’t be found, and the result is a friendly error message instead of a traceback:    ``` Sorry, the file alice.txt does not exist. ```py    The program has nothing more to do if the file doesn’t exist, so this is all the output we see. Let’s build on this example and see how exception handling can help when you’re working with more than one file.    ### Analyzing Text    You can analyze text files containing entire books. Many classic works of literature are available as simple text files because they are in the public domain. The texts used in this section come from Project Gutenberg ([`gutenberg.org`](https://gutenberg.org)). Project Gutenberg maintains a collection of literary works that are available in the public domain, and it’s a great resource if you’re interested in working with literary texts in your programming projects.    Let’s pull in the text of *Alice in Wonderland* and try to count the number of words in the text. To do this, we’ll use the string method `split()`, which by default splits a string wherever it finds any whitespace:    ``` from pathlib import Path path = Path('alice.txt') try: contents = path.read_text(encoding='utf-8') except FileNotFoundError: print(f"Sorry, the file {path} does not exist.") else: # Count the approximate number of words in the file: ❶ words = contents.split() ❷ num_words = len(words) print(f"The file {path} has about {num_words} words.") ```py    I moved the file *alice.txt* to the correct directory, so the `try` block will work this time. We take the string `contents`, which now contains the entire text of *Alice in Wonderland* as one long string, and use `split()` to produce a list of all the words in the book ❶. Using `len()` on this list ❷ gives us a good approximation of the number of words in the original text. Lastly, we print a statement that reports how many words were found in the file. This code is placed in the `else` block because it only works if the code in the `try` block was executed successfully.    The output tells us how many words are in *alice.txt*:    ``` The file alice.txt has about 29594 words. ```py    The count is a little high because extra information is provided by the publisher in the text file used here, but it’s a good approximation of the length of *Alice in Wonderland*.    ### Working with Multiple Files    Let’s add more books to analyze, but before we do, let’s move the bulk of this program to a function called `count_words()`. This will make it easier to run the analysis for multiple books:    **word_count.py**    ``` from pathlib import Path def count_words(path): ❶ """计算文件中单词的大概数量。""" try: contents = path.read_text(encoding='utf-8') except FileNotFoundError: print(f"Sorry, the file {path} does not exist.") else: # Count the approximate number of words in the file: words = contents.split() num_words = len(words) print(f"The file {path} has about {num_words} words.") path = Path('alice.txt') count_words(path) ```py    Most of this code is unchanged. It’s only been indented, and moved into the body of `count_words()`. It’s a good habit to keep comments up to date when you’re modifying a program, so the comment has also been changed to a docstring and reworded slightly ❶.    Now we can write a short loop to count the words in any text we want to analyze. We do this by storing the names of the files we want to analyze in a list, and then we call `count_words()` for each file in the list. We’ll try to count the words for *Alice in Wonderland*, *Siddhartha*, *Moby Dick*, and *Little Women*, which are all available in the public domain. I’ve intentionally left *siddhartha.txt* out of the directory containing *word_count.py*, so we can see how well our program handles a missing file:    ``` from pathlib import Path def count_words(filename): *--snip--* filenames = ['alice.txt', 'siddhartha.txt', 'moby_dick.txt', 'little_women.txt'] for filename in filenames: ❶ path = Path(filename) count_words(path) ```py    The names of the files are stored as simple strings. Each string is then converted to a `Path` object ❶, before the call to `count_words()`. The missing *siddhartha.txt* file has no effect on the rest of the program’s execution:    ``` The file alice.txt has about 29594 words. Sorry, the file siddhartha.txt does not exist. The file moby_dick.txt has about 215864 words. The file little_women.txt has about 189142 words. ```py    Using the `try`-`except` block in this example provides two significant advantages. We prevent our users from seeing a traceback, and we let the program continue analyzing the texts it’s able to find. If we don’t catch the `FileNotFoundError` that *siddhartha.txt* raises, the user would see a full traceback, and the program would stop running after trying to analyze *Siddhartha*. It would never analyze *Moby Dick* or *Little Women*.    ### Failing Silently    In the previous example, we informed our users that one of the files was unavailable. But you don’t need to report every exception you catch. Sometimes, you’ll want the program to fail silently when an exception occurs and continue on as if nothing happened. To make a program fail silently, you write a `try` block as usual, but you explicitly tell Python to do nothing in the `except` block. Python has a `pass` statement that tells it to do nothing in a block:    ``` def count_words(path): """计算文件中单词的大概数量。""" try: *--snip--* except FileNotFoundError: pass else: *--snip--* ```py    The only difference between this listing and the previous one is the `pass` statement in the `except` block. Now when a `FileNotFoundError` is raised, the code in the `except` block runs, but nothing happens. No traceback is produced, and there’s no output in response to the error that was raised. Users see the word counts for each file that exists, but they don’t see any indication that a file wasn’t found:    ``` The file alice.txt has about 29594 words. The file moby_dick.txt has about 215864 words. The file little_women.txt has about 189142 words. ```py    The `pass` statement also acts as a placeholder. It’s a reminder that you’re choosing to do nothing at a specific point in your program’s execution and that you might want to do something there later. For example, in this program we might decide to write any missing filenames to a file called *missing_files.txt*. Our users wouldn’t see this file, but we’d be able to read the file and deal with any missing texts.    ### Deciding Which Errors to Report    How do you know when to report an error to your users and when to let your program fail silently? If users know which texts are supposed to be analyzed, they might appreciate a message informing them why some texts were not analyzed. If users expect to see some results but don’t know which books are supposed to be analyzed, they might not need to know that some texts were unavailable. Giving users information they aren’t looking for can decrease the usability of your program. Python’s error-handling structures give you fine-grained control over how much to share with users when things go wrong; it’s up to you to decide how much information to share.    Well-written, properly tested code is not very prone to internal errors, such as syntax or logical errors. But every time your program depends on something external such as user input, the existence of a file, or the availability of a network connection, there is a possibility of an exception being raised. A little experience will help you know where to include exception-handling blocks in your program and how much to report to users about errors that arise.    ## Storing Data    Many of your programs will ask users to input certain kinds of information. You might allow users to store preferences in a game or provide data for a visualization. Whatever the focus of your program is, you’ll store the information users provide in data structures such as lists and dictionaries. When users close a program, you’ll almost always want to save the information they entered. A simple way to do this involves storing your data using the `json` module.    The `json` module allows you to convert simple Python data structures into JSON-formatted strings, and then load the data from that file the next time the program runs. You can also use `json` to share data between different Python programs. Even better, the JSON data format is not specific to Python, so you can share data you store in the JSON format with people who work in many other programming languages. It’s a useful and portable format, and it’s easy to learn.    ### Using json.dumps() and json.loads()    Let’s write a short program that stores a set of numbers and another program that reads these numbers back into memory. The first program will use `json.dumps()` to store the set of numbers, and the second program will use `json.loads()`.    The `json.dumps()` function takes one argument: a piece of data that should be converted to the JSON format. The function returns a string, which we can then write to a data file:    **number_writer.py**    ``` from pathlib import Path import json numbers = [2, 3, 5, 7, 11, 13] ❶ path = Path('numbers.json') ❷ contents = json.dumps(numbers) path.write_text(contents) ```py    We first import the `json` module, and then create a list of numbers to work with. Then we choose a filename in which to store the list of numbers ❶. It’s customary to use the file extension *.json* to indicate that the data in the file is stored in the JSON format. Next, we use the `json.dumps()` ❷ function to generate a string containing the JSON representation of the data we’re working with. Once we have this string, we write it to the file using the same `write_text()` method we used earlier.    This program has no output, but let’s open the file *numbers.json* and look at it. The data is stored in a format that looks just like Python:    ``` [2, 3, 5, 7, 11, 13] ```py    Now we’ll write a separate program that uses `json.loads()` to read the list back into memory:    **number_reader.py**    ``` from pathlib import Path import json ❶ path = Path('numbers.json') ❷ contents = path.read_text() ❸ numbers = json.loads(contents) print(numbers) ```py    We make sure to read from the same file we wrote to ❶. Since the data file is just a text file with specific formatting, we can read it with the `read_text()` method ❷. We then pass the contents of the file to `json.loads()` ❸. This function takes in a JSON-formatted string and returns a Python object (in this case, a list), which we assign to `numbers`. Finally, we print the recovered list of numbers and see that it’s the same list created in *number_writer.py*:    ``` [2, 3, 5, 7, 11, 13] ```py    This is a simple way to share data between two programs.    ### Saving and Reading User-Generated Data    Saving data with `json` is useful when you’re working with user-generated data, because if you don’t store your user’s information somehow, you’ll lose it when the program stops running. Let’s look at an example where we prompt the user for their name the first time they run a program and then remember their name when they run the program again.    Let’s start by storing the user’s name:    **remember_me.py**    ``` from pathlib import Path import json ❶ username = input("What is your name? ") ❷ path = Path('username.json') contents = json.dumps(username) path.write_text(contents) ❸ print(f"We'll remember you when you come back, {username}!") ```py    We first prompt for a username to store ❶. Next, we write the data we just collected to a file called *username.json* ❷. Then we print a message informing the user that we’ve stored their information ❸:    ``` What is your name? **Eric** We'll remember you when you come back, Eric! ```py    Now let’s write a new program that greets a user whose name has already been stored:    **greet_user.py**    ``` from pathlib import Path import json ❶ path = Path('username.json') contents = path.read_text() ❷ username = json.loads(contents) print(f"Welcome back, {username}!") ```py    We read the contents of the data file ❶ and then use `json.loads()` to assign the recovered data to the variable `username` ❷. Since we’ve recovered the username, we can welcome the user back with a personalized greeting:    ``` Welcome back, Eric! ```py    We need to combine these two programs into one file. When someone runs *remember_me.py*, we want to retrieve their username from memory if possible; if not, we’ll prompt for a username and store it in *username.json* for next time. We could write a `try`-`except` block here to respond appropriately if *username.json* doesn’t exist, but instead we’ll use a handy method from the `pathlib` module:    **remember_me.py**    ``` from pathlib import Path import json path = Path('username.json') ❶ if path.exists(): contents = path.read_text() username = json.loads(contents) print(f"Welcome back, {username}!") ❷ else: username = input("What is your name? ") contents = json.dumps(username) path.write_text(contents) print(f"We'll remember you when you come back, {username}!") ```py    There are many helpful methods you can use with `Path` objects. The `exists()` method returns `True` if a file or folder exists and `False` if it doesn’t. Here we use `path.exists()` to find out if a username has already been stored ❶. If *username.json* exists, we load the username and print a personalized greeting to the user.    If the file *username.json* doesn’t exist ❷, we prompt for a username and store the value that the user enters. We also print the familiar message that we’ll remember them when they come back.    Whichever block executes, the result is a username and an appropriate greeting. If this is the first time the program runs, this is the output:    ``` What is your name? **Eric** We'll remember you when you come back, Eric! ```py    Otherwise:    ``` Welcome back, Eric! ```py    This is the output you see if the program was already run at least once. Even though the data in this section is just a single string, the program would work just as well with any data that can be converted to a JSON-formatted string.    ### Refactoring    Often, you’ll come to a point where your code will work, but you’ll recognize that you could improve the code by breaking it up into a series of functions that have specific jobs. This process is called *refactoring*. Refactoring makes your code cleaner, easier to understand, and easier to extend.    We can refactor *remember_me.py* by moving the bulk of its logic into one or more functions. The focus of *remember_me.py* is on greeting the user, so let’s move all of our existing code into a function called `greet_user()`:    **remember_me.py**    ``` from pathlib import Path import json def greet_user(): ❶ """通过姓名问候用户。""" path = Path('username.json') if path.exists(): contents = path.read_text() username = json.loads(contents) print(f"Welcome back, {username}!") else: username = input("What is your name? ") contents = json.dumps(username) path.write_text(contents) print(f"We'll remember you when you come back, {username}!") greet_user() ```py    Because we’re using a function now, we rewrite the comments as a docstring that reflects how the program currently works ❶. This file is a little cleaner, but the function `greet_user()` is doing more than just greeting the user—it’s also retrieving a stored username if one exists and prompting for a new username if one doesn’t.    Let’s refactor `greet_user()` so it’s not doing so many different tasks. We’ll start by moving the code for retrieving a stored username to a separate function:    ``` from pathlib import Path import json def get_stored_username(path): ❶ """如果可用，获取存储的用户名。""" if path.exists(): contents = path.read_text() username = json.loads(contents) return username else: ❷ return None def greet_user(): """通过姓名问候用户。""" path = Path('username.json') username = get_stored_username(path) ❸ if username: print(f"Welcome back, {username}!") else: username = input("What is your name? ") contents = json.dumps(username) path.write_text(contents) print(f"We'll remember you when you come back, {username}!") greet_user() ```py    The new function `get_stored_username()` ❶ has a clear purpose, as stated in the docstring. This function retrieves a stored username and returns the username if it finds one. If the path that’s passed to `get_stored_username()` doesn’t exist, the function returns `None` ❷. This is good practice: a function should either return the value you’re expecting, or it should return `None`. This allows us to perform a simple test with the return value of the function. We print a welcome back message to the user if the attempt to retrieve a username is successful ❸, and if it isn’t, we prompt for a new username.    We should factor one more block of code out of `greet_user()`. If the username doesn’t exist, we should move the code that prompts for a new username to a function dedicated to that purpose:    ``` from pathlib import Path import json def get_stored_username(path): """如果可用，获取存储的用户名。""" *--snip--* def get_new_username(path): """提示输入新用户名。""" username = input("What is your name? ") contents = json.dumps(username) path.write_text(contents) return username def greet_user(): """通过姓名问候用户。""" path = Path('username.json') ❶ username = get_stored_username(path) if username: print(f"Welcome back, {username}!") else: ❷ username = get_new_username(path) print(f"We'll remember you when you come back, {username}!") greet_user() ```py    Each function in this final version of *remember_me.py* has a single, clear purpose. We call `greet_user()`, and that function prints an appropriate message: it either welcomes back an existing user or greets a new user. It does this by calling `get_stored_username()` ❶, which is responsible only for retrieving a stored username if one exists. Finally, if necessary, `greet_user()` calls `get_new_username()`❷, which is responsible only for getting a new username and storing it. This compartmentalization of work is an essential part of writing clear code that will be easy to maintain and extend.    ## Summary    In this chapter, you learned how to work with files. You learned to read the entire contents of a file, and then work through the contents one line at a time if you need to. You learned to write as much text as you want to a file. You also read about exceptions and how to handle the exceptions you’re likely to see in your programs. Finally, you learned how to store Python data structures so you can save information your users provide, preventing them from having to start over each time they run a program.    In Chapter 11, you’ll learn efficient ways to test your code. This will help you trust that the code you develop is correct, and it will help you identify bugs that are introduced as you continue to build on the programs you’ve written.    # 11 Testing Your Code  ![](img/chapterart.png)  When you write a function or a class, you can also write tests for that code. Testing proves that your code works as it’s supposed to in response to all the kinds of input it’s designed to receive. When you write tests, you can be confident that your code will work correctly as more people begin to use your programs. You’ll also be able to test new code as you add it, to make sure your changes don’t break your program’s existing behavior. Every programmer makes mistakes, so every programmer must test their code often, to catch problems before users encounter them.    In this chapter, you’ll learn to test your code using `pytest`. The `pytest` library is a collection of tools that will help you write your first tests quickly and simply, while supporting your tests as they grow in complexity along with your projects. Python doesn’t include `pytest` by default, so you’ll learn to install external libraries. Knowing how to install external libraries will make a wide variety of well-designed code available to you. These libraries will expand the kinds of projects you can work on immensely.    You’ll learn to build a series of tests and check that each set of inputs results in the output you want. You’ll see what a passing test looks like and what a failing test looks like, and you’ll learn how a failing test can help you improve your code. You’ll learn to test functions and classes, and you’ll start to understand how many tests to write for a project.    ## Installing pytest with pip    While Python includes a lot of functionality in the standard library, Python developers also depend heavily on third-party packages. A *third-party package* is a library that’s developed outside the core Python language. Some popular third-party libraries are eventually adopted into the standard library, and end up being included in most Python installations from that point forward. This happens most often with libraries that are unlikely to change much once they’ve had their initial bugs worked out. These kinds of libraries can evolve at the same pace as the overall language.    Many packages, however, are kept out of the standard library so they can be developed on a timeline independent of the language itself. These packages tend to be updated more frequently than they would be if they were tied to Python’s development schedule. This is true of `pytest` and most of the libraries we’ll use in the second half of this book. You shouldn’t blindly trust every third-party package, but you also shouldn’t be put off by the fact that a lot of important functionality is implemented through such packages.    ### Updating pip    Python includes a tool called pip that’s used to install third-party packages. Because pip helps install packages from external resources, it’s updated often to address potential security issues. So, we’ll start by updating pip.    Open a new terminal window and issue the following command:    ``` $ **python -m pip install --upgrade pip** ❶ Requirement already satisfied: pip in /.../python3.11/site-packages (22.0.4) `--snip--` ❷ Successfully installed pip-22.1.2 ```py    The first part of this command, `python -m pip`, tells Python to run the module `pip`. The second part, `install --upgrade`, tells pip to update a package that’s already been installed. The last part, `pip`, specifies which third-party package should be updated. The output shows that my current version of pip, version 22.0.4 ❶, was replaced by the latest version at the time of this writing, 22.1.2 ❷.    You can use this command to update any third-party package installed on your system:    ``` $ **python -m pip install --upgrade** `package_name` ```py    ### Installing pytest    Now that pip is up to date, we can install `pytest`:    ``` $ **python -m pip install --user pytest** Collecting pytest `--snip--` Successfully installed attrs-21.4.0 iniconfig-1.1.1 ...pytest-7.`x`.`x` ```py    We’re still using the core command `pip install`, without the `--upgrade` flag this time. Instead, we’re using the `--user` flag, which tells Python to install this package for the current user only. The output shows that the latest version of `pytest` was successfully installed, along with a number of other packages that `pytest` depends on.    You can use this command to install many third-party packages:    ``` $ **python -m pip install --user** `package_name` ```py    ## Testing a Function    To learn about testing, we need code to test. Here’s a simple function that takes in a first and last name, and returns a neatly formatted full name:    **name_function.py**    ``` def get_formatted_name(first, last): """生成一个格式整洁的全名。""" full_name = f"{first} {last}" return full_name.title() ```py    The function `get_formatted_name()` combines the first and last name with a space in between to complete a full name, and then capitalizes and returns the full name. To check that `get_formatted_name()` works, let’s make a program that uses this function. The program *names.py* lets users enter a first and last name, and see a neatly formatted full name:    **names.py**    ``` from name_function import get_formatted_name print("Enter 'q' at any time to quit.") while True: first = input("\nPlease give me a first name: ") if first == 'q': break last = input("Please give me a last name: ") if last == 'q': break formatted_name = get_formatted_name(first, last) print(f"\tNeatly formatted name: {formatted_name}.") ```py    This program imports `get_formatted_name()` from *name_function.py*. The user can enter a series of first and last names and see the formatted full names that are generated:    ``` Enter 'q' at any time to quit. Please give me a first name: **janis** Please give me a last name: **joplin** Neatly formatted name: Janis Joplin. Please give me a first name: **bob** Please give me a last name: **dylan** Neatly formatted name: Bob Dylan. Please give me a first name: **q** ```py    We can see that the names generated here are correct. But say we want to modify `get_formatted_name()` so it can also handle middle names. As we do so, we want to make sure we don’t break the way the function handles names that have only a first and last name. We could test our code by running *names.py* and entering a name like `Janis Joplin` every time we modify `get_formatted_name()`, but that would become tedious. Fortunately, `pytest` provides an efficient way to automate the testing of a function’s output. If we automate the testing of `get_formatted_name()`, we can always be confident that the function will work when given the kinds of names we’ve written tests for.    ### Unit Tests and Test Cases    There is a wide variety of approaches to testing software. One of the simplest kinds of test is a unit test. A *unit test* verifies that one specific aspect of a function’s behavior is correct. A *test case* is a collection of unit tests that together prove that a function behaves as it’s supposed to, within the full range of situations you expect it to handle.    A good test case considers all the possible kinds of input a function could receive and includes tests to represent each of these situations. A test case with *full coverage* includes a full range of unit tests covering all the possible ways you can use a function. Achieving full coverage on a large project can be daunting. It’s often good enough to write tests for your code’s critical behaviors and then aim for full coverage only if the project starts to see widespread use.    ### A Passing Test    With `pytest`, writing your first unit test is pretty straightforward. We’ll write a single test function. The test function will call the function we’re testing, and we’ll make an assertion about the value that’s returned. If our assertion is correct, the test will pass; if the assertion is incorrect, the test will fail.    Here’s the first test of the function `get_formatted_name()`:    **test_name_function.py**    ``` from name_function import get_formatted_name ❶ def test_first_last_name(): """像“Janis Joplin”这样的名字有效吗？""" ❷ formatted_name = get_formatted_name('janis', 'joplin') ❸ assert formatted_name == 'Janis Joplin' ```py    Before we run the test, let’s take a closer look at this function. The name of a test file is important; it must start with *test_*. When we ask `pytest` to run the tests we’ve written, it will look for any file that begins with *test_*, and run all of the tests it finds in that file.    In the test file, we first import the function that we want to test: `get_formatted_name()`. Then we define a test function: in this case, `test_first_last_name()` ❶. This is a longer function name than we’ve been using, for a good reason. First, test functions need to start with the word *test*, followed by an underscore. Any function that starts with `test_` will be *discovered* by `pytest`, and will be run as part of the testing process.    Also, test names should be longer and more descriptive than a typical function name. You’ll never call the function yourself; `pytest` will find the function and run it for you. Test function names should be long enough that if you see the function name in a test report, you’ll have a good sense of what behavior was being tested.    Next, we call the function we’re testing ❷. Here we call `get_formatted_name()` with the arguments `'janis'` and `'joplin'`, just like we used when we ran *names.py*. We assign the return value of this function to `formatted_name`.    Finally, we make an assertion ❸. An *assertion* is a claim about a condition. Here we’re claiming that the value of `formatted_name` should be `'Janis Joplin'`.    ### Running a Test    If you run the file *test_name_function.py* directly, you won’t get any output because we never called the test function. Instead, we’ll have `pytest` run the test file for us.    To do this, open a terminal window and navigate to the folder that contains the test file. If you’re using VS Code, you can open the folder containing the test file and use the terminal that’s embedded in the editor window. In the terminal window, enter the command `pytest`. Here’s what you should see:    ``` $ **pytest** ========================= test session starts ========================= ❶ platform darwin -- Python 3.`x`.`x`, pytest-7.`x`.`x`, pluggy-1.`x`.`x` ❷ rootdir: /.../python_work/chapter_11 ❸ collected 1 item ❹ test_name_function.py . [100%] ========================== 1 passed in 0.00s ========================== ```py    Let’s try to make sense of this output. First of all, we see some information about the system the test is running on ❶. I’m testing this on a macOS system, so you may see some different output here. Most importantly, we can see which versions of Python, `pytest`, and other packages are being used to run the test.    Next, we see the directory where the test is being run from ❷: in my case, *python_work/chapter_11*. We can see that `pytest` found one test to run ❸, and we can see the test file that’s being run ❹. The single dot after the name of the file tells us that a single test passed, and the `100%` makes it clear that all of the tests have been run. A large project can have hundreds or thousands of tests, and the dots and percentage-complete indicator can be helpful in monitoring the overall progress of the test run.    The last line tells us that one test passed, and it took less than 0.01 seconds to run the test.    This output indicates that the function `get_formatted_name()` will always work for names that have a first and last name, unless we modify the function. When we modify `get_formatted_name()`, we can run this test again. If the test passes, we know the function will still work for names like Janis Joplin.    ### A Failing Test    What does a failing test look like? Let’s modify `get_formatted_name()` so it can handle middle names, but let’s do so in a way that breaks the function for names with just a first and last name, like Janis Joplin.    Here’s a new version of `get_formatted_name()` that requires a middle name argument:    **name_function.py**    ``` def get_formatted_name(first, middle, last): """生成一个格式整洁的全名。""" full_name = f"{first} {middle} {last}" return full_name.title() ```py    This version should work for people with middle names, but when we test it, we see that we’ve broken the function for people with just a first and last name.    This time, running `pytest` gives the following output:    ``` $ **pytest** ========================= test session starts ========================= `--snip--` ❶ test_name_function.py F [100%] ❷ ============================== FAILURES =============================== ❸ ________________________ test_first_last_name
