- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: THE PYTHON ENVIRONMENT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PYTHON 环境
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Python Philosophy
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 哲学
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: I believe the best place to start learning Python is not with the language itself,
    but with the guiding philosophy driving it. To write good Python code, you must
    first understand what Python is. That’s what this chapter will focus on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为学习 Python 最好的起点不是语言本身，而是驱动它的指导哲学。要写出好的 Python 代码，你必须首先理解 Python 是什么。这一章将重点介绍这一点。
- en: What Is Python, Exactly?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，Python 到底是什么？
- en: Python is a programming language developed in 1991 by Dutch programmer Guido
    van Rossum. The name refers not to the snake often used as a mascot, but to *Monty
    Python’s Flying Circus* (that fact alone should tell you a lot about the mindset
    behind the language). What began as a hobby project over Christmas break turned
    into one of the most perennially popular computer languages today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是由荷兰程序员 Guido van Rossum 于 1991 年开发的一种编程语言。这个名字并不是指常作为吉祥物的蛇，而是指 *Monty
    Python’s Flying Circus*（仅这一点就足以告诉你该语言背后思维方式的独特性）。从一个圣诞假期期间的爱好项目开始，它发展成为今天最受欢迎的计算机语言之一。
- en: From a technical perspective, Python is considered a high-level, general-purpose
    language, with full support for the procedural, object-oriented, and functional
    programming paradigms, among others.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，Python 被认为是一种高级通用语言，全面支持过程式、面向对象和函数式编程范式等。
- en: 'Fans of Python are quick to point out its famous readability and simplicity,
    which lend to an initial feeling that the language is “magic.” This has also given
    rise to a less-than-useful bit of advice for newcomers: “Python is easy; it’s
    just pseudocode!”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的爱好者们迅速指出它著名的可读性和简洁性，这给人一种语言是“魔法”的初步感觉。这也导致了一条对新手并不特别有用的建议：“Python 很简单；它只是伪代码！”
- en: 'That isn’t strictly true. Don’t let the natural readability fool you: Python
    is beautifully unique and influenced by many other languages, but it often bears
    little resemblance to any of them. To truly master it, one must take it by itself,
    not in strong comparison to other languages. That is exactly what this book will
    do.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全正确。不要让其自然的可读性误导你：Python 具有独特的优雅，受到许多其他语言的影响，但它与这些语言常常没有太大相似之处。要真正掌握它，必须将其独立看待，而不是与其他语言做强烈对比。这正是本书的目的所在。
- en: Most importantly, however, Python is an idea. It’s the collective creation of
    a diverse group of nerds, united by nothing more than an audacious desire to build
    an awesome programming language. When you truly understand Python, it alters your
    entire perspective. You’re a part of something larger; something that has taken
    on a life of its own.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，Python 是一种理念。它是由一群不同背景的极客共同创造的，他们被一个无畏的愿望所团结——构建一门出色的编程语言。当你真正理解 Python
    时，它将改变你整个的思维方式。你成为了某个更大事物的一部分；某个已经拥有了生命的事物。
- en: 'As Guido van Rossum explained in his famous King’s Day speech:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Guido van Rossum 在他著名的国王日演讲中所解释的：
- en: I believe the most important idea is that Python is developed on the Internet,
    entirely in the open, by a community of volunteers (but not amateurs!) who feel
    passion and ownership.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为最重要的理念是，Python 是在互联网环境中，由一群志愿者（但不是业余爱好者！）共同开发的，大家都怀有对语言的热情和责任感。
- en: 'Myths: What Python Isn’t'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 神话：Python 不是
- en: There are a lot of myths about Python, many of which lead to people shunning
    the language for certain applications, if not altogether.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 有很多神话，其中许多导致人们在某些应用中排斥这门语言，甚至完全放弃。
- en: 'Myth #1: Python Is Merely a Scripting Language'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #1：Python 只是一个脚本语言'
- en: 'I consider “scripting language” to be one of the most insidious terms used
    in discussing programming languages. It implies that the language is somehow unsuited
    for writing “real” software (see Myth #5).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '我认为“脚本语言”是讨论编程语言时最具误导性的术语之一。它暗示该语言不适合编写“真正的”软件（参见神话 #5）。'
- en: Python is *turing-complete*, which means that you could implement any programming
    language in Python and then be able to execute any program written in that language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是 *图灵完备* 的，这意味着你可以用 Python 实现任何编程语言，然后执行用该语言编写的任何程序。
- en: To put that another way, anything another programming language can do, Python
    can do. Whether it’s easy, or even advisable, depends on what you’re attempting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，其他编程语言能做的事情，Python 也能做。它是否容易，甚至是否可行，取决于你正在尝试做什么。
- en: 'Myth #2: Python Is Slow'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #2：Python 很慢'
- en: It’s easy to assume that high-level or interpreted languages like Python are
    naturally slower than compiled or low-level languages like C. In truth, it depends
    on the implementation of the language and how it’s used. In this book, we’ll cover
    several concepts related to improving the performance of Python code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易认为像 Python 这样的高级或解释型语言天生比像 C 这样的编译型或低级语言要慢。事实上，这取决于语言的实现方式以及它的使用方式。在本书中，我们将介绍一些与提升
    Python 代码性能相关的概念。
- en: The default implementation of the Python language interpreter, CPython, is written
    in C, and it is indeed slower than native machine code. However, there are various
    libraries and techniques—as well as other implementations of the language, including
    PyPy—which have much better performance overall (see Chapter 21) and even approach
    the speed of native machine code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言解释器的默认实现，CPython，是用 C 编写的，它确实比本地机器代码要慢。然而，也有许多库和技术——以及其他语言的实现版本，包括
    PyPy——它们的整体性能要好得多（见第 21 章），甚至接近本地机器代码的速度。
- en: With all that said, you should understand how performance actually factors into
    your project. In most situations, Python is plenty fast enough to be a good choice
    for application development, data analysis, scientific computing, game development,
    web development, and the list goes on. The performance drawbacks inherent in CPython
    usually only become problematic when you are dealing with very specific scenarios
    demanding extraordinarily high performance. Even then, there are ways around the
    bottlenecks. For the majority of projects, Python’s baseline performance is more
    than sufficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你应该理解性能实际上是如何影响你的项目的。在大多数情况下，Python 的性能足够快，足以成为应用开发、数据分析、科学计算、游戏开发、网页开发等的好选择。CPython
    中固有的性能缺陷通常只有在处理非常特殊的场景时才会成为问题，这些场景要求极高的性能。即使在这种情况下，也有办法绕过瓶颈。对于大多数项目，Python 的基础性能完全足够。
- en: 'Myth #3: Python Cannot Be Compiled'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #3：Python 不能被编译'
- en: Python is an *interpreted language*, meaning the code is read, interpreted,
    and executed at runtime by the language’s *interpreter*. An end user running a
    project written in Python will typically have to have the Python interpreter installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种*解释型语言*，意味着代码在运行时由语言的*解释器*读取、解释和执行。运行用 Python 编写的项目的最终用户通常需要安装 Python
    解释器。
- en: This contrasts with what I like to call *assembled languages*, like C, C++,
    or FORTRAN. In these languages, the final result of compilation is machine code,
    which can be executed directly on any compatible computer without needing an additional
    program on that machine (or somehow bundled with the code).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我喜欢称之为*组装语言*的语言形成对比，比如 C、C++ 或 FORTRAN。在这些语言中，编译的最终结果是机器代码，可以直接在任何兼容的计算机上执行，而无需该机器上额外的程序（或以某种方式与代码捆绑在一起）。
- en: Many developers take this to mean that Python cannot be compiled (assembled)
    to machine code, which seems like the obvious corollary. In fact, it is possible
    to compile Python to machine code, although this is rarely necessary and seldom
    done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为这意味着 Python 不能被编译（组装）为机器代码，这似乎是显而易见的推论。事实上，Python 是可以编译成机器代码的，尽管这种情况很少发生，也很少有人这么做。
- en: If you want to go this route, there are a few options. On UNIX, the built-in
    *Freeze* tool transpiles to C arrays of Python bytecode, and then it assembles
    this C code to machine code. This doesn’t result in truly assembled Python code,
    however, because the Python interpreter must still be invoked behind the scenes.
    Freeze only works on UNIX systems. The *cx_Freeze* tool, as well as *py2exe* on
    Windows, does much the same thing as Freeze.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想走这条路，有几个选项。在 UNIX 系统上，内置的 *Freeze* 工具将 Python 字节码转译为 C 数组，然后将这些 C 代码组装为机器代码。然而，这并不会产生真正的组装
    Python 代码，因为 Python 解释器仍然必须在后台调用。Freeze 仅适用于 UNIX 系统。*cx_Freeze* 工具以及 Windows
    上的 *py2exe* 做的事情与 Freeze 类似。
- en: To truly compile Python to machine code, you must use an intermediary language.
    *Nuitka* can be used to transpile Python code C and C++, which can then be assembled
    to machine code. You can also transpile Python to Java with *VOC*. *Cython* also
    allows transpiling a specialized form of Python to C, although it’s primarily
    geared toward writing Python extensions in C.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正将 Python 编译成机器代码，你必须使用中介语言。*Nuitka* 可以将 Python 代码转译为 C 和 C++，然后将其组装为机器代码。你也可以使用
    *VOC* 将 Python 转译为 Java。*Cython* 还允许将一种特殊形式的 Python 转译为 C，尽管它主要用于编写 C 语言的 Python
    扩展。
- en: 'Myth #4: Python Gets Compiled Behind the Scenes'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #4：Python 在后台被编译'
- en: 'The Python interpreter converts code to *bytecode*, which is then executed.
    The interpreter includes a *virtual machine*, which executes the Python bytecode
    similarly to how a CPU executes machine code. Sometimes, the interpreter will
    do the conversion to bytecode in advance, for performance reasons, generating
    *.pyc* files containing bytecode. While this is “compiling” in one sense of the
    term, there is a key difference between compiling to bytecode and compiling to
    machine code: bytecode is still run through the interpreter, whereas machine code
    executes directly, without needing an additional program. (Technically, “compiling”
    to machine code is called *assembling*, although this distinction is often neglected
    or overlooked.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器将代码转换为 *字节码*，然后执行这些字节码。解释器包括一个 *虚拟机*，它以类似于 CPU 执行机器代码的方式执行 Python
    字节码。有时，解释器会提前进行字节码转换，以提高性能，生成包含字节码的 *.pyc* 文件。虽然从某种意义上来说，这可以算作是“编译”，但将字节码与机器代码编译之间有一个关键的区别：字节码仍然需要通过解释器运行，而机器代码是直接执行的，不需要额外的程序。（技术上，编译成机器代码叫做
    *汇编*，尽管这个区分常常被忽略或忽视。）
- en: In practice, the majority of Python projects ship as source code, or at least
    Python bytecode, which is run in the Python interpreter installed on the user’s
    machine. There are occasions when a standard executable is preferable, such as
    for ease of installation on end-user computers or in closed-source projects. For
    those situations, tools such as *PyInstaller* and *cx_Freeze* exist. These don’t
    compile the code, but rather bundle the Python source code or bytecode with the
    interpreter so it can be executed by itself (see Chapter 18).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，大多数 Python 项目作为源代码发布，或者至少作为 Python 字节码在安装在用户机器上的 Python 解释器中运行。有些情况下，标准的可执行文件更为合适，例如在终端用户计算机上安装方便或用于闭源项目。对于这些情况，像
    *PyInstaller* 和 *cx_Freeze* 这样的工具是存在的。这些工具并不编译代码，而是将 Python 源代码或字节码与解释器捆绑在一起，使其能够独立执行（见第
    18 章）。
- en: 'Myth #5: Python Is Unsuitable for Large Projects'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #5：Python 不适合大型项目'
- en: I’ve heard some developers say, “Python is only useful if the whole project
    fits in one file.” This adage is partially based on the misconception that Python
    projects with multiple files are confusingly structured. This indeed tends to
    be the trend, but only because so few developers know how to correctly structure
    a Python project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我听过一些开发者说：“如果整个项目只能放在一个文件里，Python 才有用。”这个说法部分源于一个误解，认为多个文件的 Python 项目结构混乱。确实，很多项目呈现这种趋势，但这仅仅是因为很少有开发者知道如何正确地构建一个
    Python 项目。
- en: In reality, project structure in Python is far simpler than in C++ and Java.
    Once the developer understands the concepts of packages, modules, and the import
    system (see Chapter 4), working with multiple code files becomes trivial.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Python 的项目结构比 C++ 和 Java 要简单得多。一旦开发者理解了包、模块和导入系统的概念（见第 4 章），处理多个代码文件就变得轻松简单。
- en: Another reason for this myth has to do with the fact that Python is dynamically
    typed, rather than statically typed like Java or C++, which some believe makes
    refactoring harder. This doesn’t have to be the case, once the developer knows
    how to work with Python’s type system, instead of against it (see Chapter 5).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个神话的另一个原因与 Python 是动态类型语言有关，而不像 Java 或 C++ 是静态类型语言。有人认为这使得重构变得更加困难。但实际上，只要开发者知道如何与
    Python 的类型系统协作，而不是与之对抗（见第 5 章），这种情况是可以避免的。
- en: Python 2 vs. Python 3
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 2 与 Python 3
- en: For many years, there existed two major versions of Python. Starting in 2001,
    *Python 2* was the standard, meaning most books and articles about Python were
    written for this version. The last release was Python 2.7.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Python 存在两个主要版本。从 2001 年开始，*Python 2* 是标准版本，这意味着大多数关于 Python 的书籍和文章都是为这个版本编写的。最后一个发布版本是
    Python 2.7。
- en: The current version is *Python 3*, known during its development as *Python 3000*
    or *Py3k*. From its release in 2008 until 2019, we were in a sort of limbo between
    the two versions; a lot of existing code and packages were written in Python 2,
    while Python 3 was increasingly recommended for new projects that didn’t require
    legacy support. Many techniques and tools existed for writing code that could
    run in either version, which eased the transition for many existing projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的版本是 *Python 3*，在开发过程中被称为 *Python 3000* 或 *Py3k*。从 2008 年发布到 2019 年，我们处于两个版本之间的过渡期；大量现有代码和包是用
    Python 2 编写的，而 Python 3 则越来越多地被推荐用于不需要遗留支持的新项目。很多技术和工具已经可以编写同时支持两个版本的代码，这让很多现有项目的过渡变得更加平滑。
- en: In more recent years, especially since the release of Python 3.5, we’ve begun
    moving away from Python 2 altogether. Most major libraries officially supported
    Python 3, and legacy support became less of a priority.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在近年来，尤其是自 Python 3.5 发布以来，我们开始完全摆脱 Python 2。大多数主要库已经正式支持 Python 3，而对旧版的支持已不再是优先事项。
- en: As of January 1, 2020, Python 2 has been officially retired, and Python 3 is
    the definitive standard. Since Python 4 is still nothing more than a vague wisp
    of a rumor at this point, it’s safe to say that Python 3 will be with us for years
    to come.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2020 年 1 月 1 日，Python 2 已经正式退役，Python 3 成为最终标准。由于 Python 4 目前仍然只是一个模糊的传闻，可以肯定地说，Python
    3 将继续陪伴我们很多年。
- en: Unfortunately, many software development teams have been slow (sometimes unavoidably)
    about porting their code bases from Python 2 to Python 3\. This has left a lot
    of projects in limbo. If you use Python in a professional capacity, there is a
    good chance you’ll have to help transition some code to Python 3\. Python’s standard
    library includes a tool called *2to3*, which helps automate this process. Running
    the code through this tool is a good first step, but you will still need to manually
    update the code to use some of the newer patterns and tools Python 3 has to offer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多软件开发团队在将代码库从 Python 2 移植到 Python 3 的过程中进展缓慢（有时是不可避免的）。这使得许多项目处于停滞状态。如果你在职业生涯中使用
    Python，那么你很有可能需要帮助将一些代码过渡到 Python 3。Python 的标准库包括一个名为*2to3*的工具，帮助自动化这一过程。通过这个工具运行代码是一个好的第一步，但你仍然需要手动更新代码，以使用
    Python 3 提供的一些更新的模式和工具。
- en: Defining “Pythonic” Code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义“Pythonic”代码
- en: Among Python developers, you’ll hear a lot of talk about *Pythonic* code and
    what it constitutes, precisely. In a general sense, idiomatic code that makes
    good use of the language’s features is considered Pythonic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 开发者中，你会听到很多关于*Pythonic*代码的讨论，精确来说，这到底指的是什么。从一般意义上讲，能够充分利用语言特性的惯用代码被认为是
    Pythonic 的。
- en: Unfortunately, this is very much open to interpretation. As a result, the topic
    of best practices in Python is a regular source of heated debate in the community.
    Don’t be alarmed by this. By regularly grappling with our own conventions and
    standards, we continually improve them and our own understanding along the way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个问题非常开放，容易被解释为不同的东西。因此，关于 Python 最佳实践的话题，成为了社区中热烈争论的常见源头。不要因此感到惊讶。通过不断地与我们自己的惯例和标准作斗争，我们不断改进它们，并在过程中提高我们的理解。
- en: Our tendency to debate best practices in Python is rooted in our philosophy
    of *There’s Only One Way To Do It (TOOWTDI)*, a phrase coined by PythonLabs in
    2000 as a tongue-in-cheek response to the Perl community’s own adage of *There’s
    More Than One Way To Do It (TMTOWTDI)*. Despite the historic rivalry between these
    communities, these philosophies aren’t strictly opposing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 中辩论最佳实践的倾向源于我们的哲学——*只有一种方法可以做到（TOOWTDI）*，这是 PythonLabs 在 2000 年以一种带有戏谑的方式，针对
    Perl 社区的座右铭*有多种方法可以做到（TMTOWTDI）*的回应。尽管这两个社区之间有着历史性的竞争，但这些哲学并不完全对立。
- en: Python developers rightly assume there is some single, quantifiably “best” solution
    to any specific problem. Our task is to figure out what that solution is, but
    we also know we will often fall far short of the goal. Through continual discussion,
    debate, and experimentation, we refine our approaches in pursuit of the theoretical
    Best Solution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者理应认为，针对任何特定问题，都有一个单一、可量化的“最佳”解决方案。我们的任务是找出这个解决方案，但我们也知道，我们常常远未达到目标。通过持续的讨论、辩论和实验，我们不断完善我们的方式，以追求理论上的最佳解决方案。
- en: In the same way, the Perl community understands that it is often impossible
    to definitively arrive at that Best Solution, so they emphasize experimentation
    instead of compliance with strict standards, in an effort to discover better and
    better solutions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，Perl 社区理解到，通常很难明确地找到最佳解决方案，因此他们强调实验而非严格遵守标准，以努力发现越来越好的解决方案。
- en: 'In the end, the goal is the same: to ultimately define the best possible solution
    to a problem. Only the emphasis differs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，目标是相同的：最终定义出解决问题的最佳方案。只是强调的方向不同。
- en: In this book, I’ll focus a lot on the generally accepted Pythonic ways of writing
    code. However, I don’t claim to be the final authority. My colleagues in the Python
    community will always have plenty to add to these discussions. I never fail to
    learn something new from them!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将重点讨论一般公认的 Pythonic 写法。然而，我并不声称自己是最终权威。我的 Python 社区的同事们总会在这些讨论中增添不少内容。我从他们身上总是能学到新东西！
- en: The Zen of Python
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 之禅
- en: In 1999, a discussion started on the official Python mailing list about the
    need to write down some sort of formal guiding principles for the language. Tim
    Peters, a prominent member of the community, jokingly laid out a poetic summary
    of 19 principles to serve as an outline, leaving the 20th spot open for Guido
    van Rossum to complete (which he never did).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年，官方 Python 邮件列表上开始了关于为语言编写某种形式的正式指导原则的讨论。Tim Peters，社区中的一位重要成员，开玩笑地列出了19条原则的诗意总结，作为大纲，留下了第20条由
    Guido van Rossum 补充（但他从未补充）。
- en: Other community members quickly seized on this summary as a fantastic overview
    of Python’s philosophy, ultimately adopting it wholesale as *The Zen of Python*.
    The entire text is published by Python as PEP 20.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他社区成员迅速抓住了这个总结，认为它是对 Python 哲学的极好概述，最终将其完全采纳为 *Python之禅*。整篇文本作为 PEP 20 由 Python
    发布。
- en: Beautiful is better than ugly.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 美胜于丑。
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明确比隐式更好。
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simple is better than complex.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简单比复杂更好。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复杂比复杂化更好。
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平比嵌套更好。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 稀疏比密集更好。
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Readability counts.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可读性很重要。
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Special cases aren’t special enough to break the rules.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特殊情况不足以打破规则。
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although practicality beats purity.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管实用性胜过纯粹性。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误绝不应悄无声息地通过。
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非明确消音。
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模棱两可的情况，拒绝猜测的诱惑。
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——而且最好只有一种——显而易见的方式来做这件事。
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管除非你是荷兰人，否则这条路可能一开始并不显而易见。
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now is better than never.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在比永不更好。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although never is often better than *right* now.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管“从不”往往比*现在*更好。
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is hard to explain, it’s a bad idea.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现方式难以解释，那就是一个坏主意。
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现方式容易解释，那可能是一个不错的主意。
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是一个极好的主意——我们应该做更多这样的事！
- en: This, too, is open to interpretation, and some argue that Tim Peters was kidding
    when he wrote The Zen of Python. However, if there’s one thing I’ve learned about
    Python developers, it’s that the line between “kidding” and “serious” is fine
    as spider silk.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样是开放于解释的，有些人认为 Tim Peters 写《Python之禅》时是在开玩笑。然而，如果我从 Python 开发者身上学到一件事，那就是“开玩笑”和“认真的”之间的界限细得像蜘蛛丝一样。
- en: In any case, The Zen of Python is a great place to start when talking about
    best practices in Python. Many developers, including myself, often refer back
    to it. I’ll refer to it frequently throughout this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，《Python之禅》是讨论 Python 最佳实践时的一个绝佳起点。许多开发者，包括我自己，经常会回头参考它。我将在本书中频繁引用它。
- en: Documentation, PEPs, and You
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档、PEP 和你
- en: '*Dead Simple Python* is intended as a beginning, not an ending, to your learning
    journey. Once you are well acquainted with the Python language, you can turn to
    the language’s extensive official documentation to learn more about any particular
    features or tools. These docs are found online at [https://docs.python.org/](https://docs.python.org/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单Python* 旨在作为你学习旅程的起点，而非终点。一旦你对 Python 语言有了充分的了解，你可以转向该语言的详尽官方文档，进一步了解任何特定功能或工具。这些文档可以在网上找到，地址是
    [https://docs.python.org/](https://docs.python.org/)。'
- en: Any new feature in Python begins its life as a *Python Enhancement Proposal*
    (PEP). Each is assigned a unique number and published to the official PEP index
    at [https://python.org/dev/peps/](https://python.org/dev/peps/). Once proposed,
    a PEP will be considered, discussed, and ultimately accepted or rejected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的任何新特性都始于 *Python增强提案*（PEP）。每个提案都会被分配一个唯一的编号，并发布到官方 PEP 索引，地址是 [https://python.org/dev/peps/](https://python.org/dev/peps/)。一旦提出，PEP
    将被考虑、讨论，并最终接受或拒绝。
- en: Accepted PEPs are effectively extensions of the documentation, as they are the
    most cohesive and authoritative descriptions of the feature(s) they define. Additionally,
    there are several Meta-PEPs and Informational PEPs that provide the backbone for
    the Python community and language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 被接受的 PEP 实际上是文档的扩展，因为它们是定义功能（或功能）的最具凝聚力和权威性的描述。此外，还有一些元 PEP 和信息性 PEP，它们为 Python
    社区和语言提供了骨架。
- en: As such, the official documentation and PEP index should be the first place
    you go if you have any questions about Python. I’ll refer to these frequently
    throughout this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，官方文档和 PEP 索引应该是你有任何关于 Python 问题时首先查阅的地方。我将在本书中频繁引用这些内容。
- en: Who Calls the Shots?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁来做决策？
- en: To understand how and why the language evolves, it is important to know who’s
    in charge. When a PEP is proposed, who gets to decide if it’s accepted or rejected?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解语言如何以及为什么会进化，了解谁在负责是非常重要的。当一个PEP被提议时，谁有权决定是否接受或拒绝？
- en: Python is an open source project officially owned by the nonprofit Python Software
    Foundation. Unlike many other popular languages, no formal associations exist
    between Python and any for-profit organization.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一个由非营利组织Python软件基金会正式拥有的开源项目。与许多其他流行的语言不同，Python与任何盈利性组织之间没有正式的关联。
- en: As an open source project, Python is supported by an active and vibrant community.
    At its heart is the core team, the trusted volunteers who maintain the language
    and keep the community running smoothly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个开源项目，Python得到了一个活跃而充满活力的社区的支持。其核心是核心团队，这些受信任的志愿者负责维护语言并确保社区的平稳运行。
- en: Language creator Guido van Rossum served as the Benevolent Dictator for Life
    (BDFL), making the final decisions on all PEPs and overseeing ongoing development
    of the language. In 2018, he made the decision to step down from the role.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的创始人Guido van Rossum曾担任终身仁慈独裁者（BDFL），负责做出所有PEP的最终决策，并监督语言的持续发展。2018年，他决定卸下这一职务。
- en: A few months after his resignation, PEP 13 was created to establish a new system
    of governance. Now the language is governed by a five-person steering committee,
    elected by the core team. Every time a new release of the language comes out,
    a new steering committee is elected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在他辞职几个月后，PEP 13应运而生，旨在建立一个新的治理体系。现在，语言由一个五人指导委员会进行管理，委员会成员由核心团队选举产生。每当语言发布新版本时，都会选举新的指导委员会。
- en: The Python Community
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python社区
- en: The Python community is a vast and diverse group of individuals from all over
    the world, united by their passion for this unique language. Ever since I stumbled
    upon the community many years ago as an utter novice, I have gained immeasurable
    help, guidance, and inspiration from it and its people. I’ve been privileged to
    offer the same to others in return. This book would not have ever happened without
    the continual feedback of my Python friends!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区是一个庞大而多样化的群体，来自世界各地的人们因对这一独特语言的热情而团结在一起。从多年前作为一个完全的初学者偶然发现这个社区开始，我从它和社区成员那里得到了无数的帮助、指导和灵感。我也很荣幸能回报同样的帮助给他人。如果没有我Python朋友们持续的反馈，这本书根本不会诞生！
- en: 'The Python community is moderated by the core team and governed by the Python
    Code of Conduct. In short, it emphasizes open, considerate, and respectful behavior,
    summarizing itself as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区由核心团队进行管理，并受Python行为准则的约束。简而言之，它强调开放、体贴和尊重的行为，并总结为以下内容：
- en: Overall, we’re good to each other. We contribute to this community, not because
    we have to, but because we want to. If we remember that, these guidelines will
    come naturally.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总体来说，我们彼此友好。我们为这个社区做出贡献，不是因为我们必须，而是因为我们想要。如果我们记住这一点，这些指南就会自然而然地遵循。
- en: I strongly encourage any developer who uses Python to plug into this vibrant
    community. One of the best ways to participate is through the Libera.Chat IRC
    `#python` chatroom. You can find guides to getting onto IRC at [https://python.org/community/](https://python.org/community/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈鼓励任何使用Python的开发者加入这个充满活力的社区。参与的最佳方式之一是通过Libera.Chat IRC `#python`聊天室。你可以在[https://python.org/community/](https://python.org/community/)找到有关如何加入IRC的指南。
- en: If you have any questions about Python, including while you read through this
    book, I recommend asking for help in the IRC channel. Chances are, you’ll find
    me and most of my technical editors there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在阅读本书时有任何关于Python的问题，我建议你在IRC频道寻求帮助。很可能，你会在那儿找到我和我的大多数技术编辑。
- en: In Chapter 21, I’ll discuss the many facets of the Python community.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第21章，我将讨论Python社区的多个方面。
- en: The Pursuit of the One Obvious Way
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追求唯一明确的方式
- en: The Python mantra “There’s Only One Way to Do It” can be quite confusing at
    first. There are many possible ways to solve any one problem. Are Pythonistas
    just too enamored with their own ideas?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python的格言“只有一种方法可以做到”刚开始时可能会让人困惑。解决一个问题有许多可能的方式。Pythonista们是否只是太过迷恋自己的想法？
- en: Thankfully, no. This mantra means something much more encouraging, and it’s
    something every Python developer should understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢上帝，不是的。这句格言意味着更有鼓励意义的东西，每个Python开发者都应该理解这一点。
- en: 'Some insight comes from The Zen of Python, which includes this rather cryptic
    quip:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一些洞察力来自于《Python禅》，其中包含了这个颇为晦涩的警句：
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——而且最好只有一种——明显的解决方法。
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管这种方法最初可能并不明显，除非你是荷兰人。
- en: Tim Peters was, of course, referring to language creator Guido van Rossum, a
    Dutch national. As the creator of the language, Guido could usually cut right
    to the “most obvious way” of solving problems in Python, especially in the early
    days of the language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Tim Peters指的是编程语言的创造者，荷兰国籍的Guido van Rossum。作为语言的创始人，Guido通常能直接切入问题的“最明显的解决方案”，尤其是在语言的早期阶段。
- en: This *obvious way* is Python’s term for “the best solution”—a marriage of good
    practice, clean style, and reasonable efficiency, resulting in elegant code that
    is comprehensible to even the greenest novice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*明显的方式*是Python对“最佳解决方案”的称呼——它是良好实践、简洁风格和合理效率的结合，产生出即使是最初学者也能理解的优雅代码。
- en: 'The details of the problem being solved will usually inform this “obvious way”:
    one situation may call for a loop, another for recursion, and yet another for
    a list comprehension. Contrary to the usual implications of the word *obvious*,
    the solution is often anything but simple to work out. The best solution is only
    obvious *once you know it*; arriving at it is where things get tricky. Most of
    us aren’t Guido.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 被解决问题的细节通常会决定“明显方式”：有的情况可能需要循环，有的则需要递归，还有的需要列表推导式。与*明显*一词通常的含义相反，解决方案往往并不简单。最好的解决方案只有在你知道它之后才显得明显；而达到它的过程才是最棘手的。我们大多数人都不是Guido。
- en: However, the *pursuit* of the “one obvious way” is a defining facet of the Python
    community, and it has had a profound impact on *Dead Simple Python*. A lot of
    the insights in this book were born out of sometimes intense debate between myself
    and my fellow Pythonistas. For this reason, I hand-selected my panel of technical
    editors from those colleagues who are commonly in opposition to me, and often
    each other, on pedantic technical points.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*追求*“唯一明显的方式”是Python社区的一个定义性特点，它对*Dead Simple Python*产生了深远的影响。书中很多洞见源于我与同伴Python爱好者之间有时激烈的辩论。正因如此，我从那些在技术细节上常常与我（甚至彼此）对立的同事中精心挑选了技术编辑小组。
- en: Anything ultimately adopted as the “right way” to solve a problem is usually
    accepted as such because of its technical merit, rather than because of some like-minded
    bias among Python developers, who are among the most exacting folks I’ve had the
    privilege of working with. This approach to logic overflows into every other conversation
    we have (which leads to some rather amazing and enlightening academic debates).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最终被接受为“正确方法”的任何方案，通常是因为其技术优点，而非因为Python开发者之间的某种志同道合的偏见。Python开发者是我所合作过的最严谨的群体之一，这种逻辑思维方法也渗透到我们所有的讨论中（这引发了许多令人惊叹和启发的学术辩论）。
- en: New situations present themselves regularly. There will never come a point in
    any Python developer’s career when coding becomes truly “easy.” Situations will
    arise in every project that demand careful consideration, and often, debate. Developers
    must attempt to solve problems in the way that seems most obvious to them, then
    submit the solution to the critique of peers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新情况经常出现。在任何Python开发者的职业生涯中，永远不会有编程变得真正“容易”的时刻。在每个项目中都会出现需要认真考虑的情况，往往还需要辩论。开发者必须尝试以他们认为最明显的方式解决问题，然后将解决方案提交给同行审议。
- en: The approaches in this book are, in many cases, the most obvious according to
    my view. Most have been seconded by my colleagues, yet I dare not assert that
    I am altogether “Dutch” in the Python sense. If you find yourself debating techniques
    in the Python community, please do not wave this book in anyone’s face as evidence
    that your solution is best! Skill in finding an obvious solution is not something
    that can be taught; rather it is only learned through practice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的方法在很多情况下是我认为最明显的。大多数方法也得到了我的同事的支持，但我不敢断言自己在Python意义上完全是“荷兰人”。如果你在Python社区中与他人讨论技术，请不要把这本书作为证据，宣称你的解决方案是最好的！找到明显解决方案的技巧是无法教会的；它只能通过实践来学习。
- en: Wrapping Up
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Despite the many myths that have been tossed around over the years, Python is
    a versatile and technically sound language, capable of handling just about any
    problem you can throw at it. It’s a solid choice, whether you are writing automation,
    crunching massive datasets, building native user applications, implementing machine
    learning, or crafting web applications and APIs. Most importantly, Python is backed
    by a vibrant, diverse, and helpful community.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来有许多关于 Python 的误解，但 Python 是一种多功能且技术上可靠的语言，能够处理几乎任何问题。无论你是在编写自动化脚本、处理海量数据集、构建本地用户应用程序、实现机器学习，还是开发
    Web 应用程序和 API，Python 都是一个可靠的选择。最重要的是，Python 拥有一个充满活力、多样化且互助的社区。
- en: The key to success, then, is writing Python code that makes the most of the
    strengths and features of the language. The goal is not simply to write code that
    works, but to write code that both looks and behaves elegantly. The rest of this
    book will teach you how to do exactly that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的关键是编写充分利用 Python 语言优势和特点的代码。目标不仅仅是写出可运行的代码，而是写出既优雅又高效的代码。本书的其余部分将教你如何做到这一点。
- en: '2'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Your Workbench
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作台
- en: '![](Images/chapterart.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Your development environment is a major factor in how productive you’ll be in
    a language. Instead of contenting yourself with a bare-bones default shell, you’ll
    want to assemble a development environment worthy of any production-level project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的开发环境是你在某种语言中生产力的关键因素。与其满足于一个简单的默认命令行，你应该组建一个足以支持任何生产级项目的开发环境。
- en: A good Python development environment usually consists of the language interpreter,
    the pip package manager, a *virtual environment*, a Python-oriented code editor,
    and one or more *static analyzers* to check your code for errors and problems.
    I’ll discuss each of these in this chapter. I’ll also introduce the style conventions
    common in Python and round out the chapter with a guided tour of the most common
    Python integrated development environments (IDEs).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 Python 开发环境通常包括语言解释器、pip 包管理器、*虚拟环境*、一个 Python 导向的代码编辑器，以及一个或多个*静态分析工具*来检查你的代码是否存在错误和问题。我将在本章中讨论每一个工具。我还将介绍
    Python 中常见的代码风格约定，并通过 Python 集成开发环境（IDE）的常见工具为本章作总结。
- en: Installing Python
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Python
- en: Before you can do anything, you have to install Python itself, along with a
    couple of essential tools. As you know from Chapter 1, Python is an interpreted
    language, so you’ll need to install its *interpreter*. You must also install pip,
    the Python package manager, so you can install additional Python tools and libraries.
    The exact steps for setup depend on your platform, but I will cover the major
    platforms here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，你需要安装 Python 本身，以及一些必备的工具。正如你在第一章中了解到的，Python 是一种解释型语言，因此你需要安装其*解释器*。你还必须安装
    pip，这是 Python 的包管理器，以便你可以安装额外的 Python 工具和库。安装的具体步骤取决于你的平台，但我将在这里介绍主要平台的安装方法。
- en: In this book, I’m using Python 3.9, the latest version at the time of writing.
    If you’re reading this at a later date, just use the latest stable release of
    Python 3\. All the instructions should work the same. You need only replace the
    version number in the obvious ways on any commands run in the command line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我使用的是 Python 3.9，这是写作时的最新版本。如果你在稍后的时间阅读这本书，只需使用最新的稳定版 Python 3。所有的指令应该是相同的。你只需要在命令行中以明显的方式替换版本号即可。
- en: This is merely a quick guide to installation. For the complete, official instructions,
    which cover many more situations and advanced options, see [https://docs.python.org/using/](https://docs.python.org/using/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简短的安装指南。对于完整的官方安装说明，涵盖了更多情况和高级选项，请参见[https://docs.python.org/using/](https://docs.python.org/using/)。
- en: Installing on Windows
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装
- en: On Windows, Python is not generally installed by default, so you’ll need to
    download it yourself from [https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    and run that installer. On the first screen of the installer, be sure you check
    the boxes for **Install the launcher for all users** and **Add Python to PATH**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，Python 通常没有默认安装，因此你需要从[https://python.org/downloads/windows/](https://python.org/downloads/windows/)下载并运行安装程序。在安装程序的第一个界面上，请确保勾选**为所有用户安装启动器**和**将
    Python 添加到 PATH**选项。
- en: Python is also available through the Windows App Store. However, as of the date
    of my writing, this particular installation method is still officially considered
    unstable. I recommend downloading the official installer instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以通过 Windows 应用商店安装。然而，截止我写这篇文章的日期，这种安装方式仍然被官方认为不稳定。我建议下载官方安装程序。
- en: Installing on macOS
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装
- en: On macOS, you can use either MacPorts or Homebrew to install Python and pip.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 MacPorts 或 Homebrew 安装 Python 和 pip。
- en: 'Use the following commands to install Python and pip with MacPorts, replacing
    the `38` with whatever version you want to download (removing the decimal point):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令通过 MacPorts 安装 Python 和 pip，将 `38` 替换为你想要下载的版本（去掉小数点）：
- en: '[PRE0]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, here’s the command to install both Python and pip in one step
    with Homebrew:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，下面是通过 Homebrew 一步安装 Python 和 pip 的命令：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use only one of the two methods described above.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只需选择上述两种方法中的一种进行安装。
- en: Installing on Linux
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装
- en: If you’re running a Linux operating system, chances are that Python (`python3`)
    is installed by default, although the other tools you need may not be. (I’ll show
    you how to install Python anyway, just to be on the safe side.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Linux 操作系统，Python（`python3`）很可能已默认安装，尽管你可能还需要安装其他工具。（我会展示如何安装 Python，以确保万无一失。）
- en: 'To install Python and pip on Ubuntu, Debian, or related, run this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Ubuntu、Debian 或相关系统上安装 Python 和 pip，请运行以下命令：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Fedora, RHEL, or CentOS, you can run this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora、RHEL 或 CentOS 上，你可以运行以下命令：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On Arch Linux, run this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arch Linux 上，运行以下命令：
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For other distributions, you’ll need to search for the Python 3 and pip packages
    yourself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他发行版，你需要自行查找 Python 3 和 pip 的包。
- en: Installing from Source
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: If you’re running a UNIX-like system, and if your system either has an outdated
    version of Python 3 in the system packages or lacks a package manager altogether,
    you can build Python from source. This is how I usually install the latest Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是类 UNIX 系统，并且系统中有过时的 Python 3 版本或根本没有包管理器，你可以从源代码构建 Python。这也是我通常安装最新
    Python 的方式。
- en: Installing Dependencies
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: On macOS, there are some relatively complex considerations when it comes to
    installing Python’s build dependencies. You should consult the documentation at
    [https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，安装 Python 的构建依赖项时有一些相对复杂的考虑。你应该参考文档 [https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x)。
- en: On most Linux systems, you will need to make sure you have the development files
    for several libraries that Python relies upon. The best way to install these depends
    on your system and, more specifically, which package manager you use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 系统上，你需要确保已安装 Python 所依赖的几个库的开发文件。安装这些文件的最佳方法取决于你的系统，具体来说，还取决于你使用的包管理器。
- en: If you’re on a Linux distribution that uses the APT package manager—such as
    Ubuntu, Pop!_OS, Debian, or Linux Mint—then you should either check the box to
    enable Source Code as a source in your Software Sources or Software & Updates
    settings or make sure you have it included in your *sources.list* file. (The exact
    method depends on your system, and that topic is beyond the scope of this book.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是使用 APT 包管理器的 Linux 发行版——例如 Ubuntu、Pop!_OS、Debian 或 Linux Mint——你应该在你的软件源或软件更新设置中勾选“启用源代码作为源”选项，或者确保它已包含在你的
    *sources.list* 文件中。（具体方法取决于你的系统，详细内容超出了本书的范围。）
- en: 'Then, run the following commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you get the message `Unable to find a source package for python3.9`, change
    the `9` to a lower (or higher) number until you find one that works. The dependencies
    for Python 3 don’t really change much between minor versions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到 `Unable to find a source package for python3.9` 的消息，请将 `9` 更改为更低或更高的数字，直到找到一个有效的版本。Python
    3 的依赖项在小版本之间几乎没有变化。
- en: 'If your Linux distribution uses the DNF package manager, such as if you’re
    on modern Fedora, RHEL, or CentOS, run the following commands:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Linux 发行版使用 DNF 包管理器（例如现代的 Fedora、RHEL 或 CentOS），请运行以下命令：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you’re on an older version of Fedora or RHEL that uses the yum package manager,
    run the following commands:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是较旧版本的 Fedora 或 RHEL，且它们使用 yum 包管理器，请运行以下命令：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’re on SUSE Linux, you’ll have to install the dependencies, including
    needed libraries, one by one. [Table 2-1](#table2-1) lists these dependencies.
    If you’re on another UNIX-based system, this list will be helpful, although you
    may need to change the package names or build the dependencies from source.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 SUSE Linux，你需要逐一安装依赖项，包括所需的库。[表 2-1](#table2-1)列出了这些依赖项。如果你使用的是其他基于
    UNIX 的系统，这个列表也会有帮助，尽管你可能需要更改包名或从源代码构建依赖项。
- en: 'Table 2-1: Python 3 Build Dependencies According to SUSE Linux'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：根据 SUSE Linux 的 Python 3 构建依赖关系
- en: '| automake | intltool | netcfg |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| automake | intltool | netcfg |'
- en: '| fdupes | libbz2-devel | openssl-devel |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| fdupes | libbz2-devel | openssl-devel |'
- en: '| gcc | libexpat-devel | pkgconfig |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| gcc | libexpat-devel | pkgconfig |'
- en: '| gcc-c++ | libffi-devel | readline-devel |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| gcc-c++ | libffi-devel | readline-devel |'
- en: '| gcc-fortran | libnsl-devel | sqlite-devel |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| gcc-fortran | libnsl-devel | sqlite-devel |'
- en: '| gdbm-devel | lzma-devel | xz |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| gdbm-devel | lzma-devel | xz |'
- en: '| gettext-tools | make | zlib-devel |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| gettext-tools | make | zlib-devel |'
- en: '| gmp-devel | ncurses-devel |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| gmp-devel | ncurses-devel |  |'
- en: Downloading and Building Python
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载和构建 Python
- en: You can download the Python source as a Gzipped source tarball, which is a compressed
    file (*.tgz*), from [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/).
    I usually like to move this tarball file into a dedicated directory for Python
    source tarballs, especially as I tend to have multiple versions of Python at any
    one time. Within that directory, extract (uncompress) this file with `tar -xzvf
    Python-3.x.x.tgz`, substituting the name of the tarball you downloaded.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/)
    下载 Python 源代码作为 Gzipped 源 tarball，这是一个压缩文件（*.tgz*）。我通常喜欢将这个 tarball 文件移动到一个专门存放
    Python 源 tarball 的目录，尤其是因为我往往会同时有多个版本的 Python。在该目录中，使用 `tar -xzvf Python-3.x.x.tgz`
    解压（解压缩）这个文件，替换为你下载的 tarball 名称。
- en: 'Next, from within the extracted directory, run the following, ensuring that
    each command succeeds before running the next one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在解压后的目录中，运行以下命令，确保每个命令成功后再运行下一个：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should configure Python for normal use, ensure it won’t encounter any errors
    in the current environment, and then install it *alongside* any existing Python
    installations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置 Python 以供正常使用，确保在当前环境中不会遇到任何错误，然后将其安装到*现有*的 Python 安装旁边。
- en: Once the installation is complete, you can use Python right away.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以立即使用 Python。
- en: Meet the Interpreter
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识解释器
- en: Now that you’ve installed that interpreter, you can run Python scripts and projects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了那个解释器，可以运行 Python 脚本和项目了。
- en: Interactive Session
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式会话
- en: 'The interpreter’s *interactive session* allows you to enter and run code in
    real time and see the outcomes. You can start an interactive session on the command
    line with this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的 *交互式会话* 允许你实时输入和运行代码，并查看结果。你可以通过以下命令在命令行中启动交互式会话：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although the above should work on Windows, the same as on any other system,
    the Python documentation recommends the following alternative on Windows instead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述方法在 Windows 上应该也能工作，就像在任何其他系统上一样，但 Python 文档推荐在 Windows 上使用以下替代方案：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just to keep everything system-agnostic, I’ll use `python3` throughout the rest
    of this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持系统的通用性，我将在本书剩余部分中使用 `python3`。
- en: 'When you start the interactive session, you should see something that looks
    similar to this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动交互式会话时，应该看到类似这样的内容：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enter any Python code you want at the prompt `>`, and the interpreter will
    run it immediately. You can even enter multiline statements, such as conditional
    statements, and the interpreter will know more lines are expected before it runs
    the code. You’ll see the three-dot (`...`) prompt when the interpreter is waiting
    for more lines. When you’re done, press Enter on a blank line, and the interpreter
    will run the whole block:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符 `>` 下输入任何你想要的 Python 代码，解释器会立即执行。你甚至可以输入多行语句，如条件语句，解释器会知道在执行代码前还需要更多的行。当解释器等待更多行时，你会看到三点（`...`）提示。完成输入后，在空白行按回车键，解释器将运行整个代码块：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To quit the interactive session, run this command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出交互式会话，请运行以下命令：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The interactive session is useful for testing things out in Python, but not
    much else. You should know of its existence moving forward, but I won’t use it
    much in this book. Instead, you should be using a proper code editor.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式会话对于在 Python 中测试东西非常有用，但没有太多其他用途。你应该知道它的存在，但在本书中我不会经常使用它。相反，你应该使用一个合适的代码编辑器。
- en: Running Python Files
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Python 文件
- en: You write scripts and programs in a text or code editor. I’ll introduce several
    code editors and IDEs at the end of this chapter, but in the meantime, you can
    use your favorite text editor for writing your code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在文本或代码编辑器中编写脚本和程序。我将在本章末介绍几款代码编辑器和 IDE，但在此之前，你可以使用你喜欢的文本编辑器来编写代码。
- en: 'Python code is written in *.py* files. To run a Python file (*myfile.py*, for
    example), you’d use this in the command line (*not* the interpreter):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码是写在*.py*文件中的。要运行一个 Python 文件（例如 *myfile.py*），你需要在命令行中使用这个命令（*而不是*解释器）：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Packages and Virtual Environments
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包和虚拟环境
- en: A *package* is a collection of code, which is analogous to a library in most
    other programming languages. Python is rather famous for being “batteries included,”
    since most things “just work” with a simple `import` statement. But if you need
    to do something beyond the basics, such as creating a snazzy user interface, you
    often have to install a package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*包* 是一组代码，它类似于其他编程语言中的库。Python 因为“自带电池”而相当有名，因为大多数东西通过简单的 `import` 语句就可以“正常工作”。但是如果你需要做一些基本之外的事情，比如创建一个花哨的用户界面，你通常需要安装一个包。'
- en: Thankfully, installing most third-party libraries is easy. Library authors bundle
    their libraries into packages, which can be installed using the handy little pip
    package manager tool that we installed earlier. I’ll cover that tool later.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数第三方库的安装都很简单。库作者将他们的库打包成包，可以通过我们之前安装的方便的 pip 包管理工具来安装。我稍后会讲解这个工具。
- en: Using multiple third-party packages requires a bit of finesse. Some packages
    require other packages to be installed first. Certain packages have conflicts
    with other packages. You can also install specific versions of a package, depending
    on what exactly you need. Did I mention that some of the applications and operating
    system components on your computer rely on certain Python packages? This is why
    virtual environments exist.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个第三方包需要一些技巧。有些包要求先安装其他包。某些包与其他包之间存在冲突。你还可以根据需要安装特定版本的包。我提到过，你电脑上的一些应用程序和操作系统组件依赖于某些
    Python 包吗？这就是虚拟环境存在的原因。
- en: A *virtual environment* is a sandbox where you can install only the Python packages
    you need for a particular project, without the risk of those packages clashing
    with those for another project (or your system). You create different little sandboxes
    for each project and install only the packages you want in it. Everything stays
    neatly organized. You never actually change what Python packages are installed
    on your system, so you avoid breaking important things that have nothing to do
    with your project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟环境* 是一个沙盒，你可以在其中仅安装项目所需的 Python 包，而无需担心这些包与其他项目（或系统）的包发生冲突。你为每个项目创建不同的小沙盒，只安装你需要的包。一切都保持整洁有序。你实际上并不会改变系统中安装的
    Python 包，这样就能避免破坏与项目无关的重要内容。'
- en: You may even create virtual environments that have nothing to do with a particular
    project. For example, I have a dedicated virtual environment for running random
    code files in Python 3.10, with a particular set of tools I use for finding problems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以创建与特定项目无关的虚拟环境。例如，我有一个专门的虚拟环境用于运行随机的 Python 3.10 代码文件，里面有一套我用来查找问题的工具。
- en: Creating a Virtual Environment
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: Each virtual environment resides in a dedicated directory. Conventionally, we
    name this folder *env* or *venv*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟环境都位于一个专门的目录中。按惯例，我们将这个文件夹命名为 *env* 或 *venv*。
- en: For each project, I typically like to create a dedicated virtual environment
    inside the project folder. Python provides a tool called *venv* for this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我通常喜欢在项目文件夹中创建一个专门的虚拟环境。Python 提供了一个名为 *venv* 的工具来实现这一点。
- en: If you use Git or another *version control system* *(VCS)* for tracking changes
    to your code, there’s an additional setup step I’ll get to in a moment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Git 或其他 *版本控制系统*（*VCS*）来跟踪代码的变化，那么还有一个额外的设置步骤，我稍后会讲到。
- en: 'To create the virtual environment with the name `venv` in the current working
    directory, run the following command in the command line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前工作目录中创建一个名为 `venv` 的虚拟环境，可以在命令行中运行以下命令：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first `venv` ❶ is a command that creates a virtual environment, and the
    second `venv` ❷ is the desired path to the virtual environment. In this case,
    `venv` is just a relative path, creating a *venv/* directory in the current working
    directory. However, you could also use an absolute path, and you could call it
    whatever you want. For example, you could create a virtual environment called
    *myvirtualenv* in the */opt* directory of a UNIX system, like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `venv` ❶ 是一个创建虚拟环境的命令，第二个 `venv` ❷ 是虚拟环境的目标路径。在这个例子中，`venv` 只是一个相对路径，会在当前工作目录中创建一个
    *venv/* 目录。不过，你也可以使用绝对路径，并且可以随意命名。例如，你可以在 UNIX 系统的 */opt* 目录下创建一个名为 *myvirtualenv*
    的虚拟环境，像这样：
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note, I’m specifying `python3` here, although I can run this with whatever Python
    version I want to use, such as `python3.9 -m venv venv`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在这里指定了 `python3`，尽管我可以使用任何我想要的 Python 版本运行这个命令，比如 `python3.9 -m venv venv`。
- en: 'If you use something older than Python 3.3, make sure you install your system’s
    `virtualenv` package and then use this command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的 Python 版本低于 3.3，请确保安装了系统的 `virtualenv` 包，然后使用以下命令：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now if you look at your working directory, you’ll notice that the directory
    *venv/* has been created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看工作目录，你会注意到 *venv/* 目录已经被创建。
- en: Activating a Virtual Environment
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: To use your virtual environment, you need to activate it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你的虚拟环境，你需要先激活它。
- en: 'On UNIX-like systems, run this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 UNIX 系统上，运行以下命令：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On Windows, run this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，运行以下命令：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, if you use PowerShell on Windows, run this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你在 Windows 上使用 PowerShell，运行以下命令：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Some PowerShell users must first run `set-executionpolicy RemoteSigned` for
    virtual environments to work on Windows PowerShell. If you run into trouble, try
    this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 PowerShell 用户必须首先运行 `set-executionpolicy RemoteSigned`，才能在 Windows PowerShell
    上使用虚拟环境。如果遇到问题，可以尝试这个命令。
- en: Like magic, you’re now using your virtual environment! You should see `(venv)`
    at the start of your command line prompt (not at the end), to indicate that you’re
    using a virtual environment named `venv`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，你现在正在使用你的虚拟环境！你应该能在命令行提示符的开始处看到 `(venv)`（而不是结尾），这表示你正在使用一个名为 `venv` 的虚拟环境。
- en: While inside your virtual environment, you can still access all the same files
    on your system that you use outside the virtual environment, but your environment
    *paths* will be overridden by the virtual environment. Practically speaking, any
    packages you install in the virtual environment are only usable there, and from
    the `venv`, the system-wide packages cannot be accessed unless you explicitly
    specify otherwise.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中，你仍然可以访问系统中所有外部环境可用的文件，但你的环境 *路径* 会被虚拟环境覆盖。实际上，你在虚拟环境中安装的任何包只能在该环境中使用，并且从
    `venv` 中无法访问系统范围的包，除非你明确指定。
- en: If you want the virtual environment to also see the system-wide packages, you
    can do so with a special flag, which has to be set when you first create the virtual
    environment. You can’t change this after the virtual environment is created.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望虚拟环境也能够访问系统范围的包，你可以通过一个特殊的标志来实现，在你第一次创建虚拟环境时设置该标志。虚拟环境创建后，无法再更改此设置。
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Leaving a Virtual Environment
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离开虚拟环境
- en: To get out of the virtual environment and back to reality . . . er, *ahem*,
    the system, you need a simple command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出虚拟环境并回到现实……呃，*咳咳*，系统环境，你只需要一个简单的命令。
- en: 'You ready for this, UNIX users? Just run this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗，UNIX 用户？只需运行这个命令：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That really is it. The same works for Windows PowerShell users.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。Windows PowerShell 用户也适用同样的操作。
- en: 'Things are only slightly more complicated on the Windows command line:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 命令行中，情况稍微复杂一些：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Still pretty painless. Remember, like with activation, if you named your virtual
    environment something else, you’d have to change the `venv` in that line accordingly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还是相当简单的。记住，就像激活虚拟环境一样，如果你给虚拟环境命名为其他名称，你就需要相应地修改该行中的 `venv`。
- en: Introducing pip
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 pip
- en: Most of us have great expectations for Python’s package system. Python’s package
    manager is *pip*, which usually makes package installation trivial, especially
    in virtual environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人对 Python 的包管理系统有很高的期望。Python 的包管理工具是 *pip*，它通常使得包的安装变得非常简单，特别是在虚拟环境中。
- en: System-Wide Packages
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统范围的包
- en: 'Remember, for any Python development work, you should almost always work in
    virtual environments. This will ensure that you’re always using the right packages
    for your work, without potentially messing up which packages (and versions thereof)
    are available to other programs on your computer. If you absolutely, positively
    know you want to install packages in your system-wide Python environment, you
    may use pip for that as well. First, make sure you are *not* working in a virtual
    environment, and then use this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于任何Python开发工作，你几乎总是应该在虚拟环境中工作。这将确保你始终使用正确的包来进行工作，而不会干扰其他程序使用的包（及其版本）。如果你确实知道你要在系统级的Python环境中安装包，你也可以使用pip。首先，确保你*没有*在虚拟环境中工作，然后使用以下命令：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Replace the `command` with your pip commands, which I’ll cover next.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将`command`替换为你的pip命令，接下来我会讲解。
- en: Installing Packages
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'To install a package, run `pip install` `package`. For example, to install
    PySide6 within an activated virtual environment, you’d use this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装一个包，运行`pip install` `package`。例如，要在已激活的虚拟环境中安装PySide6，你可以使用以下命令：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want to install a specific version of something, append two equal signs
    (`==`), followed by the desired version number (no spaces):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想安装某个特定版本的包，可以添加两个等号（`==`），后跟所需的版本号（不要有空格）：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Bonus: you can even use operators like `>=`, to mean “at least this version
    or greater.” These are called *requirement specifiers*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你甚至可以使用像`>=`这样的运算符，表示“至少这个版本或更高版本”。这些被称为*版本要求规范*。
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That line would install the latest version of PySide6 that is at least version
    `6.1.2`. This is really helpful if you want the most recent version of a package
    but also want to ensure you at least install a *minimum* version of a package
    (you might not). If it isn’t possible to install a version of the package that
    meets the requirement, pip will display an error message.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将安装至少为`6.1.2`版本的最新版本PySide6。如果你想要安装包的最新版本，同时确保至少安装包的*最低*版本，这将非常有用（但也不一定需要）。如果无法安装符合要求的版本，pip将显示错误信息。
- en: If you’re on a UNIX-like system, you may need to use `pip install "PySide6>=6.1.2"`
    instead, since `>` has another meaning in the shell.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是类UNIX系统，你可能需要改用`pip install "PySide6>=6.1.2"`，因为在shell中`>`有其他含义。
- en: requirements.txt
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: requirements.txt
- en: You can save even more time for yourself and others by writing a *requirements.txt*
    file for your project. This file lists the packages your project needs. When creating
    a virtual environment, you and other users can install all the required packages
    with a single command, using this file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过为你的项目编写一个*requirements.txt*文件，节省更多时间。这个文件列出了你的项目所需的包。在创建虚拟环境时，你和其他用户可以通过一个命令使用这个文件安装所有必需的包。
- en: 'To create this file, list the name of a pip package, as well as its version
    (if required), on each line. For example, one of my projects has a *requirements.txt*
    file like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个文件，每行列出一个pip包的名称，以及其版本（如果需要）。例如，我的一个项目有一个像这样的*requirements.txt*文件：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-1: *requirements.txt*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-1：*requirements.txt*
- en: 'Now anyone can install all those packages in one shot with this command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何人都可以通过以下命令一次性安装所有这些包：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I’ll revisit *requirements.txt* in Chapter 18, when I cover packaging and distribution.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第18章重新讨论*requirements.txt*，那时我会讲解打包和分发。
- en: Upgrading Packages
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级包
- en: 'You can update an already-installed package with pip as well. For example,
    to update to the latest version of PySide6, run this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用pip更新已安装的包。例如，要更新到最新版本的PySide6，运行以下命令：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you have a *requirements.txt* file, you can also upgrade all your required
    packages at once:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个*requirements.txt*文件，你也可以一次性升级所有需要的包：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Removing Packages
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载包
- en: 'You can remove packages with this command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此命令来卸载包：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Replace `package` with the package name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将`package`替换为包的名称。
- en: There is one minor wrinkle. Installing one package will also install any other
    packages it relies upon, which we call its *dependencies*. Uninstalling a package
    does not remove its dependencies, so you may need to go through and remove them
    yourself. This can get tricky, since multiple packages may share dependencies
    and you therefore risk breaking a separate package.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小小的复杂之处。安装一个包时，还会安装它所依赖的其他包，我们称之为*依赖项*。卸载包并不会移除它的依赖项，因此你可能需要手动去删除这些依赖项。这可能会变得很棘手，因为多个包可能共享依赖项，从而有可能破坏其他包。
- en: Herein lies one more advantage of virtual environments. Once I’m in that sort
    of a pickle, I can delete the virtual environment, create a new one, and install
    only those packages I need.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是虚拟环境的另一个优势。当我遇到这种困境时，我可以删除虚拟环境，创建一个新的，并只安装我需要的包。
- en: Finding Packages
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找包
- en: Great, so now you can install, upgrade, and remove things. But how do you even
    know what packages pip has to offer?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在你可以安装、升级和删除包了。但是，你怎么知道 pip 提供了哪些包呢？
- en: 'There are two ways to find out. The first is to use pip itself to run a search.
    Say you want a package for web scraping. Run this command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以找出这些包。第一种是使用 pip 本身运行搜索。假设你想要一个网页抓取的包。运行以下命令：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That will give you a whole ton of results to sift through, but it’s helpful
    at those times when you simply forget the name of a package.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你带来大量的搜索结果，虽然很有用，但有时候你会忘记某个包的名字时，还是挺有帮助的。
- en: If you want something a lot more browsable and informative, [https://pypi.org/](https://pypi.org/%20)
    is the official Python Package Index.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个更易浏览且信息丰富的方式，[https://pypi.org/](https://pypi.org/%20) 是官方的 Python 包索引。
- en: One Warning About pip . . .
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 pip 的一个警告……
- en: Unless you have expertise in the full technical implications, ***never*** use
    `sudo pip` on a UNIX-like system! It can do so many bad things to your system
    installation—things that your system package manager cannot correct—that if you
    decide to use it, you will regret it for the remainder of your system’s lifetime.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你具备完整的技术知识，***绝对不要*** 在 UNIX 类系统上使用 `sudo pip`！它会对你的系统安装做出很多坏事——这些问题是系统包管理器无法修复的——如果你决定使用它，你会为此后悔，直到你系统的寿命结束。
- en: Usually, when someone thinks they need to use `sudo pip`, they should really
    use `python3 -m pip` or `pip install --user` to install to their local user directory.
    Most other problems can be solved with virtual environments. Unless you’re an
    expert who fully understands what you’re doing and how to reverse it, don’t *ever*
    use `sudo pip`!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当某人认为自己需要使用 `sudo pip` 时，他们实际上应该使用 `python3 -m pip` 或 `pip install --user`
    来安装到本地用户目录。大多数其他问题都可以通过虚拟环境来解决。除非你是一个完全了解自己在做什么并且知道如何逆转的专家，否则不要*永远*使用 `sudo pip`！
- en: Virtual Environments and Git
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境与 Git
- en: Working with virtual environments and a VCS, like Git, can be tricky. Within
    a virtual environment’s directory are the *actual packages* you installed with
    pip. Those would clutter up your VCS repository with big, unnecessary files, and
    you can’t necessarily copy a virtual environment folder from one computer to another
    and expect it to work anyway.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境和版本控制系统（VCS）如 Git 可能会有些棘手。在虚拟环境的目录中是你通过 pip 安装的*实际包*。这些包会把你的 VCS 仓库弄得乱七八糟，充满了大而不必要的文件，而且你不能指望将虚拟环境文件夹从一台电脑复制到另一台并期望它能正常工作。
- en: 'Thus, you *don’t* want to track these files in your VCS. There are two solutions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你*不*希望在 VCS 中跟踪这些文件。这里有两种解决方案：
- en: Only create virtual environments outside of your repository.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在仓库外创建虚拟环境。
- en: Untrack the virtual environment directory in the VCS.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VCS 中取消跟踪虚拟环境目录。
- en: There are arguments in favor of both rules, but which one you should use really
    depends on your project, environment, and particular needs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条规则都有支持的论点，但你应该使用哪一条规则，实际上取决于你的项目、环境和特定需求。
- en: 'If you’re using Git, create or edit a file called *.gitignore* in the root
    directory of your repository. Add this line somewhere in it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Git，在仓库的根目录中创建或编辑一个名为 *.gitignore* 的文件。在其中的某个位置添加以下行：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 2-2: *.gitignore*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-2: *.gitignore*'
- en: If you used a different name for your virtual environment, change that line
    to match. If you’re using a different VCS, like Subversion or Mercurial, check
    the documentation to see how to ignore a directory like *venv*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为你的虚拟环境使用了不同的名称，请更改该行以匹配。如果你使用的是其他 VCS，比如 Subversion 或 Mercurial，请查阅文档查看如何忽略像
    *venv* 这样的目录。
- en: Conventionally, every developer who clones your repository will build their
    own virtual environment, probably using that *requirements.txt* file you provided.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，每个克隆你仓库的开发者都会构建他们自己的虚拟环境，可能会使用你提供的*requirements.txt* 文件。
- en: Even if you plan to place your virtual environments outside of the repository,
    it’s good to use your *.gitignore* file, just as a little extra insurance. Best
    VCS practice is to handpick which files to commit, but mistakes happen. Since
    *venv* is one of the most conventional names for a virtual environment directory,
    adding it to the *.gitignore* at least helps prevent some accidental commits.
    If your team has other standard names for virtual environments, you might consider
    adding those as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你计划将虚拟环境放在仓库外部，使用 *.gitignore* 文件仍然是个好习惯，作为一种额外的保障。最佳版本控制实践是挑选哪些文件进行提交，但总会发生一些错误。由于
    *venv* 是虚拟环境目录最常见的名称之一，将其添加到 *.gitignore* 至少有助于避免一些意外的提交。如果你的团队有其他虚拟环境的标准名称，也可以考虑将其添加进去。
- en: The Whole Shebang
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的 Shebang
- en: Many users and developers who might be running your code will also be using
    virtual environments. Yet all of this can come apart at the seams very easily
    if the very first line of your Python file is wrong.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多运行你代码的用户和开发者也会使用虚拟环境。但如果你 Python 文件的第一行写错了，所有的东西很容易就会散架。
- en: 'I’m talking about the *shebang*, a special command at the top of a Python file,
    by which you can make that file directly executable:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我说的就是 *shebang*，它是 Python 文件顶部的一个特殊命令，借此你可以让文件直接可执行：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 2-3: *hello_world.py*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-3: *hello_world.py*'
- en: 'The shebang (short for haSH-BANG, or `#!`) ❶ provides the path to the Python
    interpreter. While it’s optional, I strongly recommend including it in your code,
    as it means the file can be marked as executable and run directly, like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: shebang（缩写自 haSH-BANG，或 `#!`）❶ 提供了 Python 解释器的路径。虽然它是可选的，但我强烈建议在代码中包含它，因为它意味着该文件可以被标记为可执行文件并直接运行，像这样：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is helpful, but as I’ve hinted before, one must be careful with shebangs.
    A shebang tells the computer where to find the exact Python interpreter to use,
    so the wrong shebang can break out of the confines of a virtual environment or
    even point to a version of the interpreter that isn’t installed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，但正如我之前提到的，使用 shebang 时必须小心。shebang 告诉计算机在哪里找到确切的 Python 解释器，所以错误的 shebang
    可能会导致跳出虚拟环境的范围，甚至指向一个未安装的解释器版本。
- en: 'You may have seen this kind of shebang in the wild:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在实际环境中看到过这种 shebang：
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 2-4: *shebang.py:1a*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-4: *shebang.py:1a*'
- en: That line is terribly wrong, because it forces the computer to use a particular
    system-wide copy of Python. Again, that dismisses the entire purpose of a virtual
    environment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那一行是完全错误的，因为它强制计算机使用特定的系统级 Python 副本。再次强调，这违背了虚拟环境的整个目的。
- en: 'Instead, you should always use this shebang for any Python file that only runs
    with Python 3:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对于任何只在 Python 3 中运行的 Python 文件，你应始终使用这个 shebang：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 2-5: *shebang.py:1b*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-5: *shebang.py:1b*'
- en: 'If you happen to have a script which runs in *both* Python 2 and Python 3,
    use this shebang instead:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好有一个同时在 *Python 2* 和 *Python 3* 中运行的脚本，使用这个 shebang：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 2-6: *shebang.py:1c*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-6: *shebang.py:1c*'
- en: The rules about shebangs and how they are handled are officially outlined in
    PEP 394 (for UNIX-like systems) and PEP 397 (for Windows systems). Regardless
    of which system you develop for, it’s good to understand the implications of shebangs
    in both UNIX and Windows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 shebang 的规则及其处理方式在 PEP 394（适用于类 UNIX 系统）和 PEP 397（适用于 Windows 系统）中有正式的说明。无论你为哪个系统开发，都了解
    UNIX 和 Windows 中 shebang 的影响是很重要的。
- en: File Encoding
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件编码
- en: Since Python 3.1, all Python files have used the *UTF-8 encoding*, allowing
    the interpreter to use all of the characters in Unicode. (Prior to that version,
    the default was to use the old ASCII encoding.)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.1 起，所有 Python 文件都使用 *UTF-8 编码*，允许解释器使用 Unicode 中的所有字符。（在此版本之前，默认使用的是旧的
    ASCII 编码。）
- en: If you need to use a different encoding system, instead of the default UTF-8,
    you need to tell the Python interpreter that outright.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用不同的编码系统，而不是默认的 UTF-8，你需要明确告诉 Python 解释器。
- en: 'For example, to use Latin-1 encoding in a Python file, include this line at
    the top of your file, right below the shebang. To work, it must be on the first
    or second line—that’s where the interpreter looks for this information:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在 Python 文件中使用 Latin-1 编码，包含这一行在文件的顶部，位于 shebang 下面。为了正常工作，它必须位于第一行或第二行
    —— 解释器就是在这里查找这些信息：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you want another encoding system, replace `latin-1` with whatever you need.
    If you specify an encoding that Python doesn’t recognize, it will throw an error.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用其他编码系统，将 `latin-1` 替换为你需要的编码。如果你指定一个 Python 无法识别的编码，它会抛出错误。
- en: 'Although the preceding is the conventional way to specify encoding, there are
    two other valid ways to write the above comment. You can use this form, without
    the hard-to-remember `-*-`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前述是指定编码的传统方式，但还有两种有效的方式来写上面的注释。你可以使用这种形式，不需要记得那么复杂的 `-*-`：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or you can use this longer but more English-like form:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用这个更长但更符合英语习惯的形式：
- en: '[PRE42]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Whatever you use, it must be *exactly* as shown above, except for swapping `latin-1`
    for whatever encoding you want. For this reason, the first or second forms are
    preferred.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么，它必须与上面显示的 *完全* 一样，唯一的例外是将 `latin-1` 替换为你想要的任何编码。因此，第一种或第二种形式是首选。
- en: To learn more, read PEP 263, which defined this feature.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多，请阅读定义此功能的 PEP 263。
- en: Most of the time, you’ll be fine using the default UTF-8 encoding anyway; if
    you need something else, now you know how to inform the interpreter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你使用默认的 UTF-8 编码就没问题；如果你需要其他编码，现在你知道该如何告知解释器了。
- en: A Few Extra Virtual Environment Tricks
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些额外的虚拟环境技巧
- en: 'As you get used to using virtual environments and pip, you’ll pick up additional
    tricks and tools to make the whole process easier. Here are a few of the more
    popular ones:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你习惯使用虚拟环境和 pip，你会掌握更多的技巧和工具来让整个过程更轻松。以下是一些更流行的工具：
- en: Using a Virtual Environment Without Activating
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不激活虚拟环境的情况下使用
- en: You can use the binaries that are a part of the virtual environment without
    activating it. For example, you can execute `venv/bin/python` to run the virtual
    environment’s own Python instance, or `venv/bin/pip` to run its instance of pip.
    It’ll work the same as if you had activated the virtual environment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不激活虚拟环境的情况下使用虚拟环境中的二进制文件。例如，你可以执行 `venv/bin/python` 来运行虚拟环境中的 Python 实例，或者执行
    `venv/bin/pip` 来运行其 pip 实例。它的效果和激活虚拟环境时一样。
- en: 'For example, assuming my virtual environment is `venv`, I could do this in
    the terminal:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我的虚拟环境是 `venv`，我可以在终端中这样做：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It works! Yet, `import pylint` still will not work on the system-wide Python
    interactive shell (unless, of course, you installed it on the system).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！然而，`import pylint` 在系统范围的 Python 交互式 shell 中仍然无法使用（除非你当然已经在系统上安装了它）。
- en: The Alternatives
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方案
- en: Throughout this book, I’ll be using pip and `venv`, as they’re the default tools
    for modern Python. However, there are a few other solutions out there worth looking
    into.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将使用 pip 和 `venv`，因为它们是现代 Python 的默认工具。然而，还有一些其他的解决方案值得一探。
- en: Pipenv
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pipenv
- en: A number of Python developers swear by *Pipenv*, which combines both pip and
    `venv` into one cohesive tool, with many additional features.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 开发者非常推崇 *Pipenv*，它将 pip 和 `venv` 结合成一个统一的工具，并具有许多额外的功能。
- en: Because the workflow is quite different, I won’t cover Pipenv here. If you’re
    interested in it, I recommend reading their superb documentation at [https://docs.pipenv.org/](https://docs.pipenv.org/).
    You’ll find comprehensive setup and usage instructions there, as well as a more
    detailed explanation of the advantages Pipenv offers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作流非常不同，我在这里不会介绍 Pipenv。如果你对它感兴趣，我建议你阅读他们出色的文档：[https://docs.pipenv.org/](https://docs.pipenv.org/)。你会在那里找到全面的设置和使用说明，以及对
    Pipenv 优势的更详细解释。
- en: pip-tools
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pip-tools
- en: A number of tasks in pip can be simplified with pip-tools, including automatic
    updating, aids for writing *requirements.txt*, and more.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pip-tools 可以简化 pip 中的许多任务，包括自动更新、帮助编写 *requirements.txt* 等等。
- en: If you use pip-tools, you should only install it within a virtual environment.
    It is designed specifically for that use case.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 pip-tools，应该仅在虚拟环境中安装它。它专门为这种使用情况设计。
- en: More information is available at [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在 [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/)
    上找到。
- en: poetry
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: poetry
- en: Some Python developers absolutely hate the entire pip workflow. One such developer
    created *poetry* as an alternative package manager. I don’t use it in this book,
    as it behaves very differently, but I’d be remiss not to point it out.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 开发者非常讨厌整个 pip 工作流。某位开发者创建了 *poetry* 作为替代的包管理器。我在本书中没有使用它，因为它的行为非常不同，但如果不提到它，我会感到遗憾。
- en: 'You can find more information, download directions (the creator does not recommend
    using pip to install it), and access documentation on their website: [https://python-poetry.org/](https://python-poetry.org/).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在他们的网站上找到更多信息、下载指南（创作者不推荐使用 pip 安装它），并访问文档：[https://python-poetry.org/](https://python-poetry.org/)。
- en: Introduction to PEP 8
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP 8 介绍
- en: Unlike many languages, where style decisions are left entirely to the discretion
    of the community at large, Python does have an official style guide, which is
    published as *PEP 8*. Although the conventions in the guide are intended primarily
    for standard library code, many Python developers choose to stick to them as a
    rule.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多语言不同，Python 有一个官方的风格指南，名为 *PEP 8*，它并非完全由社区自由决定风格。尽管指南中的约定主要是针对标准库代码，但许多 Python
    开发者选择将其作为规范遵循。
- en: 'That doesn’t make them mandatory: if you have an objective reason to follow
    a different style convention in your project, that’s fine, although you should
    apply that style consistently, as much as is reasonable.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着它们是强制性的：如果你有客观的理由在项目中遵循不同的风格约定，那也没问题，尽管你应该在合理范围内一致地应用该风格。
- en: 'PEP 8 itself makes this distinction clear, early on:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 本身在一开始就明确了这一点：
- en: A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is more important. Consistency within one module
    or function is the most important.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 风格指南是关于一致性的。遵循风格指南中的一致性很重要。而在一个项目中保持一致性更为重要。在一个模块或函数内保持一致性是最重要的。
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, know when to be inconsistent—sometimes, style guide recommendations
    just aren’t applicable. When in doubt, use your best judgment. Look at other examples
    and decide what looks best. And don’t hesitate to ask!
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，要知道什么时候可以不遵循一致性——有时候，风格指南的建议并不适用。当有疑问时，凭借你的最佳判断来决定。查看其他示例，决定什么样的格式看起来最好。如果有疑问，不要犹豫，向他人请教！
- en: In practice, you’ll likely find very little reason to deviate from PEP 8\. The
    style guide is far from all-encompassing. It leaves plenty of breathing room,
    while making it clear what constitutes a good or bad coding style.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你会发现几乎没有理由偏离 PEP 8。风格指南并不是包罗万象的，它留有很多空间，同时清楚地界定了什么样的编码风格是好还是坏。
- en: The Line Limit Debate
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行长度限制的辩论
- en: PEP 8 recommends a line limit of 79 characters, or an 80-character cutoff, though
    there’s a lot of debate on the topic. Some Python developers respect that rule,
    while others prefer cutoffs of 100 or 120 characters. What to do?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 推荐的行限制是 79 个字符，或者 80 字符的截断，尽管这个话题有很多争议。一些 Python 开发者遵守这个规则，而另一些则偏好 100
    或 120 字符的截断。该怎么做？
- en: 'The most common argument for longer limits is that modern monitors are wider
    and higher resolution. Surely, the 80-character limit is a relic of a bygone era,
    right? ***Definitely not!*** There are several reasons to stick to a common line
    limit. For example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更长的限制，最常见的论点是现代显示器更宽且分辨率更高。80 个字符的限制无疑是过去时代的遗物，对吧？ ***绝对不是！*** 坚持常见行长度限制有几个原因。例如：
- en: Vision-impaired individuals who must work with larger font sizes or zoomed-in
    interfaces
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用较大字体或缩放界面的视力障碍人士
- en: Viewing differences in a file between commits in a side-by-side diff
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看提交之间文件的差异，使用并排比较
- en: Split-screen editors, displaying multiple files simultaneously
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分屏编辑器，同时显示多个文件
- en: Vertical monitors
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直显示器
- en: Side-by-side windows on a laptop monitor, wherein the editor only has half its
    usual space
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记本电脑显示器上并排显示的窗口，编辑器只有通常空间的一半
- en: Individuals with older monitors, who cannot afford to upgrade to the latest
    1080p monster
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用旧显示器的个人，他们无法升级到最新的 1080p 显示器
- en: Viewing code on mobile devices
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动设备上查看代码
- en: Writing coding books for No Starch Press
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 No Starch Press 编写编程书籍
- en: 'In all of these scenarios, the reasoning behind the 80-character limit becomes
    apparent: there simply isn’t enough horizontal space for 120 characters or more
    per line. Soft text wrapping, wherein the remainder of a cut-off line appears
    on a separate line (without a line number), does solve some of these issues. However,
    it can be difficult to read, as many people forced to rely on it regularly will
    attest to.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，80 字符限制的背后理由变得显而易见：每行如果有 120 个字符或更多，横向空间根本不够。软文本换行，即当一行被截断时，剩余部分显示在另一行（没有行号）上，可以解决其中的一些问题。然而，阅读起来可能会很困难，因为许多人会证明，长期依赖这种方式的人会遇到阅读困难。
- en: 'This doesn’t mean that you have to follow this 79-character maximum religiously.
    There are exceptions. Above all, *readability* and *consistency* are the goals.
    Many developers embrace the 80/100 rule: an 80-character “soft” cutoff, you try
    to respect in most cases; and a 100-character “hard” cutoff, you reserve for all
    those cases where the lower limit would negatively impact readability.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你必须严格遵循这个 79 字符的最大限制。也有例外。最重要的是，*可读性*和*一致性*是目标。许多开发者遵循 80/100 规则：80 字符的“软”限制，你在大多数情况下都尽量遵守；而
    100 字符的“硬”限制，你留给那些低于此限制会影响可读性的情况。
- en: Tabs or Spaces?
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制表符还是空格？
- en: Ah yes, the civil war over which many friendships have been strained and many
    relationships have abruptly ended (okay, maybe just that one?). Most programmers
    have strong feelings on the topic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是的，这场内战让许多友谊变得紧张，许多关系突然结束（好吧，也许就那一次？）。大多数程序员对此话题有着强烈的看法。
- en: PEP 8 recommends spaces over tabs, but technically, it allows either. The important
    thing is to *never mix the two*. Use either spaces or tabs, and stick to it throughout
    your entire project.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 推荐使用空格而非制表符，但从技术上讲，它允许两者都使用。关键是*永远不要混用两者*。使用空格或制表符中的一种，并在整个项目中坚持使用。
- en: 'If you do use spaces, then there’s the debate about how many spaces to use.
    PEP 8 answers this question, too: *four spaces per indentation level*. Any less
    can negatively impact code readability, especially for people with visual impairments
    or some forms of dyslexia.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用空格，那么就有关于使用多少空格的争论。PEP 8 也回答了这个问题：*每一级缩进使用四个空格*。使用更少的空格可能会影响代码的可读性，特别是对视力障碍者或某些形式的阅读障碍者来说。
- en: By the way, most code editors are able to automatically enter four spaces when
    they press Tab, so there’s rarely an excuse to press space repeatedly.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，大多数代码编辑器在按下 Tab 键时能够自动输入四个空格，因此很少有理由反复按空格键。
- en: 'Quality Control: Static Analyzers'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量控制：静态分析工具
- en: One of the most useful tools in any programmer’s toolkit is a reliable *static
    analyzer*, which reads your source code, looking for potential problems or deviations
    from the standards. If you’ve never used one before, now is the time to change
    that. One common type of static analyzer, called a *linter*, checks your source
    code for common mistakes, potential errors, and style inconsistencies. Two of
    the most popular linters are *Pylint* and *PyFlakes*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何程序员的工具包中，最有用的工具之一就是一个可靠的*静态分析器*，它读取你的源代码，查找潜在问题或偏离标准的地方。如果你以前从未使用过静态分析器，那么现在是时候改变这一点了。静态分析器的一个常见类型叫做
    *linter*，它检查你的源代码中的常见错误、潜在问题和风格不一致。最流行的两个 linter 是 *Pylint* 和 *PyFlakes*。
- en: There are many more kinds of static analyzers available for Python, including
    static type checkers like *Mypy* and complexity analyzers like *mccabe*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还有更多种类的静态分析工具，包括像 *Mypy* 这样的静态类型检查器和像 *mccabe* 这样的复杂度分析工具。
- en: I’ll cover how to install all of these below, and I’ll discuss how to use many
    of them. I recommend you choose only one of these two linters and install the
    rest of the static analyzers.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下面介绍如何安装这些工具，并讨论如何使用其中的许多。我建议你选择其中一个 linters 并安装其余的静态分析工具。
- en: Pylint
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pylint
- en: Pylint is perhaps the most versatile static analyzer in Python. It works decently
    well by default, and it allows you to customize exactly what you want it to look
    for and ignore.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 可能是 Python 中最具多功能的静态分析工具。它默认表现得相当不错，并且允许你自定义想要检查和忽略的内容。
- en: 'You can install the Pylint package with pip, which I recommend doing in a virtual
    environment. Once installed, you pass Pylint the name of a file you want analyzed,
    like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 pip 安装 Pylint 包，我推荐在虚拟环境中进行安装。安装后，你可以传递 Pylint 一个你希望分析的文件名，像这样：
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also analyze an entire package or module at once. (I’ll define what
    modules and packages are in Chapter 4.) For example, if you want Pylint to analyze
    a package called `myawesomeproject` in the current working directory, you’d run
    this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以一次性分析整个包或模块。（我将在第 4 章定义什么是模块和包。）例如，如果你希望 Pylint 分析当前工作目录下名为 `myawesomeproject`
    的包，可以运行以下命令：
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pylint will scan the files and display its warnings and recommendations on the
    command line. Then, you can edit your file and make the necessary changes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 会扫描文件并在命令行中显示警告和建议。然后，你可以编辑文件并进行必要的更改。
- en: 'For example, consider the following Python file:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 Python 文件：
- en: '[PRE46]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 2-7: *cooking.py:1a*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-7: *cooking.py:1a*'
- en: 'I’ll run the linter on that file with the following in the system command line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在系统命令行中运行这个文件的 linter，命令如下：
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Pylint provides the following feedback:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 提供以下反馈：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The linter found five errors in my code: both the module and the function are
    missing their docstrings (see Chapter 3). I tried to use the variables `eggs`
    and `order`, neither of which exist. I also assigned a value to the variable `ham`,
    but I never used that value anywhere.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 检查工具在我的代码中发现了五个错误：模块和函数都缺少文档字符串（参见第3章）。我尝试使用`eggs`和`order`这两个变量，但它们都不存在。我还给`ham`变量赋了值，但我从未在其他地方使用过这个值。
- en: 'If Pylint takes umbrage at a particular line of code you feel should be left
    as is, you can tell the static analyzer to ignore it and move on. You do this
    with a special comment, either inline on the line in question or at the top of
    the affected block. For example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pylint对某行代码提出异议，而你认为它应该保持原样，你可以告诉静态分析器忽略这一行并继续。你可以通过特殊的注释来做到这一点，注释可以是行内的，也可以位于受影响代码块的顶部。例如：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 2-8: *cooking.py:1b*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-8: *cooking.py:1b*'
- en: 'With the first command, I tell Pylint not to alert me about the missing docstring
    on the module; that affects the entire block of code. The inline comment on the
    next line will suppress the warning about the missing docstring on the function,
    and it will only affect that line. If I ran the linter again, I’d only see the
    other two linter errors:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个命令，我告诉Pylint不要对模块缺少文档字符串发出警告；这会影响整个代码块。接下来的行内注释会抑制缺少函数文档字符串的警告，它只会影响这一行。如果我再次运行检查工具，我只会看到其他两个检查错误：
- en: '[PRE50]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, I’d edit my code and actually fix the rest of those problems.
    (Except I won’t, for this example.)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我会编辑我的代码并修复其余问题。（但为了这个例子，我不会修复。）
- en: 'You can also control Pylint’s project-wide behavior by creating a *pylintrc*
    file in the root directory of your project. To do this, run the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在项目根目录创建一个*pylintrc*文件来控制Pylint在整个项目中的行为。为此，你可以运行以下命令：
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Find that file; open it; and edit it to turn on and off different warnings,
    ignore files, and define other settings. The documentation isn’t fantastic for
    this, but you can often work out what different options do from the comments in
    that *pylintrc* file.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 找到那个文件；打开它；并编辑它以开启或关闭不同的警告，忽略文件，并定义其他设置。虽然文档并不出色，但你通常可以从那个*pylintrc*文件中的注释推断出不同选项的作用。
- en: 'When you run Pylint, it will look for a *pylintrc* (or *.pylintrc*) file in
    the current working directory. Alternatively, you can specify a different filename
    for Pylint to read its settings from, such as *myrcfile*, by passing the filename
    to the `--rcfile` option when invoking Pylint:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行Pylint时，它会在当前工作目录中查找*pylintrc*（或*.pylintrc*）文件。或者，你可以通过将文件名传递给`--rcfile`选项来指定Pylint从哪个文件读取其设置，例如*myrcfile*：
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Some regular users of Pylint like to create `.pylintrc` or `.config/pylintrc`
    in their home directory (UNIX-like systems only). If Pylint cannot find another
    configuration file, it will use the one in the home directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Pylint的常规用户喜欢在他们的主目录下创建`.pylintrc`或`.config/pylintrc`文件（仅限类UNIX系统）。如果Pylint找不到其他配置文件，它将使用主目录中的文件。
- en: Although the Pylint documentation is far from comprehensive, it can still be
    useful. You can find it at [https://pylint.readthedocs.io/](https://pylint.readthedocs.io/).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Pylint文档远非全面，但它仍然有用。你可以在[https://pylint.readthedocs.io/](https://pylint.readthedocs.io/)找到它。
- en: Flake8
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flake8
- en: 'The *Flake8* tool is actually a combination of three static analyzers:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flake8* 工具实际上是三个静态分析工具的组合：'
- en: '*PyFlakes* is a linter, similar in purpose to Pylint. It is designed to work
    faster and to avoid false positives (both being common complaints about Pylint).
    It also ignores style rules, which are handled by the next tool.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PyFlakes* 是一个类似于Pylint的代码检查工具，目的在于更快速地工作，并避免误报（这也是Pylint常见的投诉）。它还忽略了样式规则，样式规则则由下一个工具处理。'
- en: '*pycodestyle* is a style checker, to help ensure you write PEP 8-compliant
    code. (This tool used to be called `pep8`, but it was renamed to avoid confusion
    with the actual style guide.)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pycodestyle* 是一个样式检查器，用来确保你编写符合PEP 8规范的代码。（这个工具以前叫做`pep8`，但为了避免与实际的风格指南混淆，它被重新命名了。）'
- en: '*mccabe* checks the McCabe (or Cyclomatic) complexity of your code. If you
    don’t know what that is, don’t worry—its purpose is essentially just to warn you
    when your code’s structure is getting too complicated.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mccabe* 检查代码的McCabe（或圈复杂度）复杂度。如果你不知道这是什么，不用担心——它的主要目的是在你的代码结构变得过于复杂时提醒你。'
- en: You can install the Flake8 package with pip, which I typically do within a virtual
    environment.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用pip安装Flake8包，我通常在虚拟环境中进行安装。
- en: 'To scan a file, module, or package, pass it to `flake8` on the command line.
    For example, to scan my earlier *cooking.py* file ([Listing 2-8](#listing2-8)),
    I’d use this command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描文件、模块或包，请在命令行中将其传递给 `flake8`。例如，要扫描我之前的 *cooking.py* 文件（[列表 2-8](#listing2-8)），我会使用这个命令：
- en: '[PRE53]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That outputs the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: (You’ll notice that Flake8 isn’t complaining about the lack of docstrings; that’s
    disabled by default in this linter.)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: （你会注意到 Flake8 并没有抱怨缺少文档字符串；这是因为默认情况下此检查器禁用了该功能。）
- en: 'By default, only PyFlakes and pycodestyle are run. If you want to analyze the
    complexity of your code, you also need to pass the argument `--max-complexity`,
    followed by a number. Anything higher than `10` is considered too complex, but
    if you understand McCabe complexity, you can change this to suit your needs. So,
    for example, to check the complexity of the *cooking.py* file, you’d run this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只会运行 PyFlakes 和 pycodestyle。如果你想分析代码的复杂性，还需要传递参数 `--max-complexity`，后跟一个数字。任何高于
    `10` 的值都被认为过于复杂，但如果你理解 McCabe 复杂性，你可以根据需要调整这个值。例如，要检查 *cooking.py* 文件的复杂性，你可以运行这个命令：
- en: '[PRE55]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However you run Flake8, you’ll get a comprehensive list of all the errors and
    warnings in your code.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何运行 Flake8，你都会得到代码中所有错误和警告的详细列表。
- en: If you need to tell Flake8 to ignore something it thinks is a problem, you use
    a `# noqa` comment, followed by the error code to ignore. This comment should
    be inline, on the line where the error occurs. If you omit the error code, then
    `# noqa` will cause Flake8 to ignore all errors on that line.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要告诉 Flake8 忽略它认为是问题的内容，你可以使用 `# noqa` 注释，后面跟上要忽略的错误代码。这个注释应该写在出错的那一行。如果你省略了错误代码，那么
    `# noqa` 会使 Flake8 忽略该行上的所有错误。
- en: 'In my code, if I wanted to ignore both of the errors I received, it might look
    like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的代码中，如果我想忽略我收到的两个错误，可能会像这样写：
- en: '[PRE56]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 2-9: *cooking.py:1c*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-9: *cooking.py:1c*'
- en: Here, you see three different scenarios. First, I’m ignoring only warning `F841`.
    Second, I’m ignoring two errors (even though one of them isn’t actually raised;
    this is just a silly example). Third, I’m ignoring all possible errors.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到三种不同的场景。首先，我只忽略警告 `F841`。其次，我忽略了两个错误（尽管其中一个实际上并未被触发；这只是一个愚蠢的例子）。第三，我忽略了所有可能的错误。
- en: Flake8 also supports configuration files. In the project directory, you can
    create a *.flake8* file. Start a section in that file with the line `[flake8]`,
    followed by all the Flake8 settings you want to define. (See the documentation.)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 也支持配置文件。在项目目录中，你可以创建一个 *.flake8* 文件。在该文件中以 `[flake8]` 开头，接着定义你想要配置的所有
    Flake8 设置。（请参阅文档。）
- en: Flake8 will also accept project-wide configuration files called *tox.ini* or
    *setup.cfg*, so long as they have a `[flake8]` section within them.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 还会接受名为 *tox.ini* 或 *setup.cfg* 的项目范围配置文件，只要它们包含一个 `[flake8]` 部分。
- en: 'For example, if you want to automatically run mccabe each time you invoke Flake8,
    rather than specify `--max-complexity` every time, you could define a *.flake8*
    file that looks like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你希望每次调用 Flake8 时自动运行 mccabe，而不是每次都指定 `--max-complexity`，你可以定义一个 *.flake8*
    文件，内容如下：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 2-10: *.flake8*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-10: *.flake8*'
- en: Some developers like to define a system-wide configuration file for Flake8,
    which you can do (only) on a UNIX-like system. In your home folder, create the
    configuration file as either *.flake8* or *.config/flake8*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者喜欢为 Flake8 定义一个系统范围的配置文件，这只能在类 UNIX 系统上完成。在你的主文件夹中，创建配置文件，文件名为 *.flake8*
    或 *.config/flake8*。
- en: One of the chief advantages of Flake8 over Pylint is the documentation. Flake8
    has a complete list of their warnings, errors, options, and the like. You can
    find the documentation at [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 相对于 Pylint 的一个主要优点是文档。Flake8 有完整的警告、错误、选项等列表。你可以在 [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/)
    找到文档。
- en: Mypy
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mypy
- en: '*Mypy* is an unusual static analyzer because it focuses entirely on *type annotations*
    (see Chapter 6). Because it involves so many concepts I haven’t covered yet, I
    won’t go into much depth here.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mypy* 是一种不寻常的静态分析工具，因为它完全专注于 *类型注解*（参见第 6 章）。由于它涉及许多我尚未介绍的概念，因此在此我不会深入讨论。'
- en: Still, now is a good time to get it installed. Like everything else so far,
    you can install the `mypy` package from pip.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，现在是时候安装它了。像之前的所有步骤一样，你可以通过 pip 安装 `mypy` 包。
- en: 'Once installed, Mypy can be used by passing it the file, package, or module
    you wish to check:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以通过传递你想检查的文件、包或模块来使用 Mypy：
- en: '[PRE58]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Mypy will only attempt to check files that have type annotations, and it will
    ignore the rest.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 只会尝试检查具有类型注解的文件，其他文件将被忽略。
- en: 'Style Janitors: Autoformatting Tools'
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式清理工具：自动格式化工具
- en: Another tool you may find useful is an *autoformatter,* which can automatically
    change your Python code—spacing, indentation, and preferred equivalent expressions
    (such as `!=` instead of `<>`)—to be PEP 8 compliant. Two options are *autopep8*
    and *Black*.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得有用的另一个工具是 *自动格式化器*，它可以自动修改你的 Python 代码——空格、缩进以及首选的等效表达式（例如 `!=` 代替 `<>`）——以符合
    PEP 8。两个选择是 *autopep8* 和 *Black*。
- en: autopep8
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: autopep8
- en: The autopep8 tool leverages pycodestyle (part of Flake8), even using the same
    configuration file as that tool to determine what style rules it ultimately follows
    or ignores.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: autopep8 工具利用 pycodestyle（Flake8 的一部分），甚至使用与该工具相同的配置文件来确定它最终遵循或忽略哪些样式规则。
- en: As always, you can install `autopep8` with pip.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你可以通过 pip 安装 `autopep8`。
- en: By default, autopep8 only fixes whitespace, but if you pass the `--aggressive`
    argument to it, it will make additional changes. In fact, if you pass that argument
    twice, it will do even more. The complete list is beyond the scope of this explanation,
    so consult the documentation at [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/)
    to learn more.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，autopep8 只会修复空格问题，但如果你传递 `--aggressive` 参数，它会进行更多的修改。实际上，如果你传递该参数两次，它会做更多的改动。完整的选项超出了本说明的范围，因此请查阅
    [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/) 了解更多信息。
- en: 'To fix most PEP 8 issues on a Python code file by changing it in place (as
    opposed to making a copy, which is the default behavior), run this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过就地修改 Python 代码文件来修复大多数 PEP 8 问题（与默认行为——创建副本——不同），运行以下命令：
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Changing the file directly may sound a bit risky, but it really isn’t. Style
    changes are just that: style. They don’t affect the actual behavior of the code.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改文件可能听起来有些冒险，但实际上并不危险。样式更改仅仅是样式上的调整：它们不会影响代码的实际行为。
- en: Black
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Black
- en: 'The Black tool is a little more straightforward: it assumes you want to follow
    PEP 8 in its entirety, and it doesn’t overwhelm you with many options as a result.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Black 工具稍微简单一些：它假设你想要完全遵循 PEP 8，因此不会给你提供太多选项。
- en: 'Like autopep8, you install `black` with pip, although it requires Python 3.6
    or later. To format a file with it, pass the filename:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 与 autopep8 类似，你可以通过 pip 安装 `black`，不过它需要 Python 3.6 或更高版本。要用它来格式化文件，只需传递文件名：
- en: '[PRE60]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A complete list of Black’s few options can be seen via `black --help`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `black --help` 查看 Black 的所有选项。
- en: Testing Frameworks
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试框架
- en: 'Testing frameworks form an essential part of any good development workflow,
    but I won’t go into detail about them in this chapter. Python has three major
    options for testing frameworks: *Pytest*, *nose2*, and *unittest*, in addition
    to a promising new project called *ward*. All of these can be installed with pip.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架是任何良好开发工作流的核心部分，但我在本章不会详细讨论它们。Python 有三个主要的测试框架选项：*Pytest*、*nose2* 和 *unittest*，此外还有一个有前途的新项目叫做
    *ward*。所有这些都可以通过 pip 安装。
- en: More knowledge is essential to cover this topic effectively, so I’ll revisit
    it in Chapter 20.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更多的知识来有效覆盖这个话题，所以我将在第 20 章中重新讲解。
- en: An Exhibition of Code Editors
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器展示
- en: You have your Python interpreter, your virtual environments, your static analyzers,
    and other such tools. Now you are prepared to write code.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你有 Python 解释器、虚拟环境、静态分析工具以及其他类似的工具。现在，你已经准备好编写代码了。
- en: You can write Python in any basic text editor, just as you could with practically
    any other programming language. Yet you’ll probably have an easier time writing
    production-quality code with a proper code editor.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何基本的文本编辑器中编写 Python，就像你可以用几乎任何其他编程语言一样。不过，使用一个合适的代码编辑器，你会更容易编写出生产级质量的代码。
- en: Before I end this chapter, I want to take you on a tour of several of the most
    popular Python code editors and integrated development environments (*IDEs*) available.
    This is only a sampling, as there are many more options besides. **If you already
    know what code editor or IDE you want to use, skip forward to the last section
    of this chapter.**
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想带你参观几款最流行的 Python 代码编辑器和集成开发环境（*IDEs*）。这只是一个示例，还有很多其他选项可供选择。**如果你已经知道自己要使用哪款代码编辑器或
    IDE，可以跳到本章最后一节。**
- en: IDLE
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDLE
- en: 'Python has its own IDE, called *IDLE*, which ships with the standard distribution
    of Python. It’s a fairly bare-bones IDE with two components: an editor and an
    interface for the interactive shell. You could do worse than IDLE, so if you aren’t
    in the mood to install a different editor right now, start here. However, I recommend
    exploring your options, as most editors and IDEs have a host of useful features
    that IDLE lacks.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Python有自己的集成开发环境（IDE），叫做*IDLE*，它是Python标准发行版的一部分。它是一个相对简单的IDE，包含两个组件：编辑器和交互式Shell的接口。IDLE虽然功能简约，但也能胜任一些基本任务，所以如果你现在不想安装其他编辑器，可以从这里开始。不过，我建议你还是探索其他选项，因为大多数编辑器和IDE都有IDLE所缺乏的一些有用功能。
- en: Emacs and Vim
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Emacs和Vim
- en: The purists and old-school hackers among you will be glad to know that Emacs
    and Vim both have excellent Python support. Setting up either is not for the faint
    of heart, so I’m not going into any of that here.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 对于喜欢纯粹主义和老派黑客的你们来说，Emacs和Vim都提供了出色的Python支持。设置它们并非易事，因此我在这里不再赘述相关过程。
- en: If you’re already a lover of either (or both?) code editors, you can find excellent
    tutorials for both at Real Python.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是某个（或两个？）代码编辑器的忠实粉丝，可以在Real Python上找到针对这两款编辑器的优秀教程。
- en: For Emacs, see [https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Emacs，参见[https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/)。
- en: For Vim, see [https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vim，参见[https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/)。
- en: PyCharm
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyCharm
- en: 'According to “The State of Developer Ecosystem 2021” developer survey by JetBrains,
    the PyCharm IDE from JetBrains is far and away the most popular option for Python
    programming. It comes in two flavors: the free *PyCharm Community Edition* and
    the paid *PyCharm Professional Edition*. (Steps were taken by JetBrains to eliminate
    bias. See the survey here: [https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/).)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JetBrains的《2021年开发者生态调查》报告，JetBrains的PyCharm IDE远远领先于其他Python编程选项，成为最受欢迎的选择。它有两个版本：免费的*PyCharm
    Community Edition*和付费的*PyCharm Professional Edition*。（JetBrains采取了一些措施来消除偏见。详细调查报告请见：[https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/)）。
- en: Both versions offer a dedicated Python code editor with autocompletion, refactoring,
    debugging, and testing tools. It can manage and use virtual environments with
    ease, and it integrates with your version control software. It even performs static
    analysis (using its own tool). The professional edition adds tools for data, scientific
    development, and web development.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本都提供专门的Python代码编辑器，具备自动补全、重构、调试和测试工具。它能轻松管理和使用虚拟环境，并与版本控制软件集成。它甚至会执行静态分析（使用其自有工具）。专业版还增加了数据、科学开发和Web开发工具。
- en: If you’re familiar with other JetBrains IDEs, like IntelliJ IDEA or CLion, PyCharm
    would be a great Python IDE to start with. It requires more computer resources
    than many code editors, but if you have a decently powerful machine, this won’t
    be a problem. If you haven’t used JetBrains IDEs before, try the Community Edition
    before investing in the paid version.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他JetBrains的IDE，比如IntelliJ IDEA或CLion，PyCharm会是一个很好的Python IDE起点。它比许多代码编辑器占用更多的计算机资源，但如果你有一台相对较强的电脑，这不会成为问题。如果你以前没使用过JetBrains的IDE，建议先尝试Community
    Edition版，再决定是否购买付费版。
- en: You can find more information and downloads at [https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/)找到更多信息和下载内容。
- en: Visual Studio Code
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: '*Visual Studio Code* has excellent Python support. It’s the second-most popular
    Python code editor, according to that 2021 JetBrains survey. It’s free and open
    source, and it runs on virtually every platform. Install the official Python extension
    from Microsoft, and you’re ready to go!'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*Visual Studio Code*对Python的支持非常好。根据2021年JetBrains的调查，它是第二受欢迎的Python代码编辑器。它是免费的、开源的，几乎支持所有平台。安装微软官方的Python扩展后，你就可以开始使用了！'
- en: Visual Studio Code supports autocompletion, refactoring, debugging, and virtual
    environment switching, along with the usual version control integration. It integrates
    with Pylint, Flake8, and Mypy, among several other popular static analyzers. It
    even works with the most common Python unit testing tools.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code支持自动补全、重构、调试和虚拟环境切换，同时也支持常见的版本控制集成。它与Pylint、Flake8和Mypy等多个流行的静态分析工具集成，甚至与最常用的Python单元测试工具兼容。
- en: Download it at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从 [https://code.visualstudio.com/](https://code.visualstudio.com/) 下载。
- en: Sublime Text
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sublime Text
- en: '*Sublime* is another popular multilanguage code editor. It is appreciated for
    its speed and simplicity, and it is easily customized with extensions and configuration
    files. Sublime Text is free to try, but if you find you like it and wish to continue
    using it, you need to purchase it.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sublime* 是另一款流行的多语言代码编辑器。它以快速和简洁著称，并且可以通过扩展和配置文件轻松定制。Sublime Text 可以免费试用，但如果你发现自己喜欢它并希望继续使用，则需要购买。'
- en: 'The Anaconda plug-in transforms Sublime Text into a Python IDE, with everything:
    autocompletion, navigation, static analysis, autoformatting, test running, and
    even a documentation browser. It requires a little more hand-tuned configuration
    than some of the other options, especially if you want to use virtual environments.
    However, if Sublime Text is your jam, it’s worth it.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 插件将 Sublime Text 转换为一个 Python IDE，提供完整功能：自动补全、导航、静态分析、自动格式化、测试运行，甚至是文档浏览器。相比其他选项，它需要稍微更多的手动配置，尤其是当你想使用虚拟环境时。然而，如果
    Sublime Text 是你钟爱的编辑器，这一切都值得。
- en: Download Sublime Text at [https://sublimetext.com/](https://sublimetext.com/)
    and the Anaconda plug-in at [https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/).
    That second link also provides instructions for installing the plug-in in Sublime
    Text.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://sublimetext.com/](https://sublimetext.com/) 下载 Sublime Text，并在
    [https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/)
    下载 Anaconda 插件。第二个链接还提供了如何在 Sublime Text 中安装插件的说明。
- en: Spyder
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spyder
- en: If your focus is scientific programming or data analysis, or if you’re a fan
    of MATLAB’s interface, you’ll be right at home in *Spyder*, a free and open source
    Python IDE that is also written *in* Python.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的重点是科学编程或数据分析，或者你喜欢 MATLAB 的界面，那么 *Spyder* 将是你的理想选择，这是一款免费的开源 Python IDE，也用
    *Python* 编写。
- en: In addition to the usual features—a dedicated Python code editor, a debugger,
    integration with static analyzers, and documentation viewing—Spyder includes integration
    with many common Python libraries for data analysis and scientific computing.
    It integrates a full code profiler and variable explorer. Plug-ins exist for supporting
    unit tests, autoformatting, and editing Jupyter notebooks, among other features.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的功能——专用的 Python 代码编辑器、调试器、与静态分析工具的集成以及文档查看——Spyder 还集成了许多常用的 Python 库，用于数据分析和科学计算。它集成了完整的代码性能分析工具和变量浏览器。还提供支持单元测试、自动格式化和编辑
    Jupyter 笔记本等功能的插件。
- en: Download Spyder at [https://spyder-ide.org/](https://spyder-ide.org/).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://spyder-ide.org/](https://spyder-ide.org/) 下载 Spyder。
- en: Eclipse + PyDev/LiClipse
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eclipse + PyDev/LiClipse
- en: '*Eclipse* has lost a lot of ground to the newer editors, but it still has a
    loyal user base. Although it’s geared toward languages like Java, C++, PHP, and
    JavaScript, Eclipse can also become a Python IDE with the *PyDev* plug-in.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eclipse* 在新兴编辑器的竞争中失去了不少市场份额，但它仍然拥有忠实的用户群。尽管它主要针对 Java、C++、PHP 和 JavaScript
    等语言，但通过 *PyDev* 插件，Eclipse 也能变成一个 Python IDE。'
- en: If you already have installed Eclipse, which is completely free, then you only
    need to install the PyDev plug-in from the Eclipse Marketplace. Download Eclipse
    at [https://eclipse.org/ide/](https://eclipse.org/ide/) and look in the marketplace
    for the plug-in.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了完全免费的 Eclipse，那么只需要从 Eclipse Marketplace 安装 PyDev 插件即可。可以在 [https://eclipse.org/ide/](https://eclipse.org/ide/)
    下载 Eclipse，并在市场中查找该插件。
- en: Alternatively, you can install *LiClipse,* which bundles Eclipse, PyDev, and
    other useful tools. The PyDev developers recommend this approach, as it directly
    supports their development work. You can use LiClipse without a license for 30
    days, after which point, you must purchase a license. Download LiClipse from [https://liclipse.com/](https://liclipse.com/).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以安装 *LiClipse*，它将 Eclipse、PyDev 以及其他有用的工具打包在一起。PyDev 开发者推荐这种方法，因为它直接支持他们的开发工作。你可以在
    30 天内免费使用 LiClipse，之后必须购买许可证。可以从 [https://liclipse.com/](https://liclipse.com/)
    下载 LiClipse。
- en: PyDev offers autocompletion, refactoring, support for type hinting and static
    analysis, debugging, unit test integration, and many more features. You can find
    more information about PyDev at [https://pydev.org/](https://pydev.org/).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: PyDev 提供了自动补全、重构、类型提示和静态分析支持、调试、单元测试集成以及许多其他功能。你可以在 [https://pydev.org/](https://pydev.org/)
    找到更多关于 PyDev 的信息。
- en: The Eric Python IDE
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eric Python IDE
- en: '*Eric* might be the oldest IDE on the list, but it’s still as reliable as ever.
    Named after Eric Idle of *Monty Python’s Flying Circus*, Eric is a free and open
    source IDE written in Python.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eric* 可能是列表中最古老的IDE，但它依旧和以前一样可靠。它以*蒙提·派森飞行马戏团*的Eric Idle命名，是一个用Python编写的免费开源IDE。'
- en: 'It offers everything you could possibly need to write Python: autocompletion,
    debugging, refactoring, static analysis, testing integration, documentation tools,
    virtual environment management, and the list goes on.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了写Python所需的一切：自动补全、调试、重构、静态分析、测试集成、文档工具、虚拟环境管理，等等。
- en: Find information about Eric and download it at [https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/)找到有关Eric的信息并下载。
- en: Wrapping Up
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Writing code involves so much more than just code. Having set up your development
    environment, project, and IDE, you are now prepared to focus exclusively on making
    your code the best it can be.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码不仅仅是写代码。设置好开发环境、项目和IDE之后，你现在可以专心致志地将代码做到最好。
- en: By this point, you should have assembled a Python development workbench worthy
    of any production-level project. At minimum, you should have installed the Python
    interpreter, pip, `venv`, one or more static analyzers, and a Python code editor.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经搭建了一个适用于任何生产级项目的Python开发工作台。至少，你应该已安装了Python解释器、pip、`venv`、一个或多个静态分析工具，以及一个Python代码编辑器。
- en: 'Right now, in your code editor or IDE, create a *FiringRange* project for experimenting
    in while working through this book. For the moment, to be sure everything works,
    you can make a single Python file in that project with these contents:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的代码编辑器或集成开发环境（IDE）中，创建一个用于实验的*FiringRange*项目，在本书中进行操作练习。为了确保一切正常，你可以在该项目中创建一个包含以下内容的单一Python文件：
- en: '[PRE61]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 2-11: *hello_world.py*'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-11：*hello_world.py*
- en: 'Run that like this:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式运行：
- en: '[PRE62]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see the following output:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE63]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I’ll go into the correct structure for Python projects in Chapter 4, but writing
    and running individual Python files in your firing range project should be sufficient
    for Chapter 3.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第4章中讲解Python项目的正确结构，但在你的FiringRange项目中编写和运行单个Python文件应该足以完成第3章的任务。
- en: If you’re new to the IDE you have selected, take a few minutes now to familiarize
    yourself with it. You should particularly ensure you know how to navigate and
    run code, manage files, work with virtual environments, access the interactive
    console, and use the static analyzers.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对所选择的IDE不熟悉，花几分钟熟悉它吧。你尤其需要确保了解如何导航和运行代码、管理文件、使用虚拟环境、访问交互式控制台，以及使用静态分析工具。
- en: '3'
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Syntax Crash Course
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 语法速成课
- en: '![](Images/chapterart.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Python is an unusual mix of common and unique concepts. Before diving into the
    intricacies of the language, you must first grasp its essential syntax.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种常见概念与独特概念相结合的语言。在深入了解语言的细节之前，首先必须掌握其基本语法。
- en: In this chapter, you’ll learn most of the essential syntactic structures you’ll
    encounter in Python, and you’ll also become familiar with the basic mathematical
    and logical features of the language.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到大多数在Python中遇到的基本语法结构，同时你还将熟悉该语言的基本数学和逻辑特性。
- en: 'Most Python developers will point newcomers to the official Python tutorial,
    which is an excellent introduction to the language’s structure. While I’ll cover
    all of these concepts in this book in depth, the tutorial is still a good resource
    worth reading: [https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/).'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python开发者会将新手引导至官方Python教程，它是了解语言结构的极好入门资料。虽然本书会深入讲解这些概念，但该教程仍是一本值得阅读的好资源：[https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/)。
- en: Hello, World!
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'It won’t feel like a proper introduction to the language without the classic
    Hello World program. In Python, it’s written like this:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 没有经典的“你好，世界”程序，语言的介绍就不完整。在Python中，它是这样写的：
- en: '[PRE64]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 3-1: *hello_world.py*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3-1：*hello_world.py*
- en: There’s nothing novel here. You call the `print()` function to write text to
    the console, and you pass data in a string, wrapped in quotes as an argument.
    You can pass whatever sort of data you like, and it will be output on the console.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新奇的地方。你调用`print()`函数将文本输出到控制台，并将字符串数据作为参数传递。你可以传递任何类型的数据，它都会在控制台上输出。
- en: 'I can also get input from the console with the `input()` function:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以通过`input()`函数从控制台获取输入：
- en: '[PRE65]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 3-2: *hello_input.py*'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-2: *hello_input.py*'
- en: I use the `input()` function and pass my prompt as a string ❶. When I run that
    code, Python greets me using the name I entered on the console.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `input()` 函数并传入我的提示作为字符串 ❶。当我运行这段代码时，Python 会在控制台上用我输入的名字向我问好。
- en: Statements and Expression
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句和表达式
- en: Each line of code in Python that ends with a line break is a *statement*, sometimes
    more specifically known as a *simple statement*. Unlike in many C-inspired languages,
    you don’t need to end a line in Python with a special character.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行以换行符结尾的代码行在 Python 中都是一个*语句*，有时更具体地被称为*简单语句*。与许多受 C 语言启发的语言不同，在 Python 中你不需要用特殊字符来结束一行。
- en: A section of code that evaluates to a single value is called an *expression*.
    In Python, you can put expressions nearly anywhere a value is expected. The expression
    is evaluated down to a value, and that value is used in that position in the statement.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 一段求值为单个值的代码叫做*表达式*。在 Python 中，你几乎可以将表达式放在任何期望值的地方。表达式会被求值为一个值，这个值会在语句中相应的位置使用。
- en: 'For example, in one statement, I can create a variable, and in another statement,
    I can print its contents to the console:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一条语句中，我可以创建一个变量，而在另一条语句中，我可以将其内容打印到控制台：
- en: '[PRE66]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 3-3: *hello_statements.py:1a*'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-3: *hello_statements.py:1a*'
- en: I assign the expression `"Hello, world!"` to `message`, and then I pass the
    expression `message` to `print()`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我将表达式 `"Hello, world!"` 赋值给 `message`，然后将表达式 `message` 传递给 `print()`。
- en: 'If you ever need to place multiple statements on the same line, you can separate
    them with a semicolon (`;`). To demonstrate this, here are the same two statements
    as earlier, but packed onto one line, with a semicolon to separate them:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将多个语句放在同一行，你可以用分号 (`;`) 分隔它们。为了演示这一点，这里是之前的两条语句，但是被压缩到一行，用分号分隔：
- en: '[PRE67]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 3-4: *hello_statements.py:1b*'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-4: *hello_statements.py:1b*'
- en: While this is valid code, using this technique is somewhat discouraged. The
    Python philosophy places a high value on readability, and the placement of multiple
    statements on the same line often detracts from that.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码是有效的，但使用这种技术是有些不推荐的。Python 的哲学非常重视可读性，将多个语句放在同一行通常会削弱这一点。
- en: Stick to placing one statement per line, unless you have a specific reason to
    do otherwise.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有特殊的理由，否则应该坚持每行只写一个语句。
- en: The Importance of Whitespace
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白字符的重要性
- en: When you’re looking at a sample of Python source code, the first thing that
    will probably jump out at you is the use of indentation for nesting. A *compound
    statement* is made up of one or more *clauses*, each of which consists of a line
    of code called a *header* and a block of code called a *suite*, which is associated
    with the header.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看一段 Python 源代码时，首先可能会引起你注意的是用于嵌套的缩进。一个*复合语句*由一个或多个*子句*组成，每个子句由一行代码组成，这行代码称为*头部*，以及与头部相关联的代码块，称为*代码块*。
- en: 'For example, this program prints different messages, depending on whether a
    `name` is specified:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个程序会根据是否指定了 `name` 来打印不同的消息：
- en: '[PRE68]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 3-5: *hello_conditional.py*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-5: *hello_conditional.py*'
- en: I set up a conditional statement with an `if` header ❶, after which I have a
    suite made up of two indented lines of code, which “belongs” to the header. These
    lines of code are executed only if the conditional expression in the header is
    evaluated to `True`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个带有 `if` 头部 ❶ 的条件语句，之后我有一个由两行缩进代码组成的代码块，这两行代码“属于”该头部。只有当头部的条件表达式被评估为 `True`
    时，这些代码才会执行。
- en: The unindented line ❷ is not part of the suite that belongs to the conditional
    statement, and it will be run every time.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 没有缩进的行 ❷ 不属于条件语句的代码块，它会每次都执行。
- en: 'As I nest deeper, I need to add more indentation:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当我嵌套得更深时，我需要添加更多的缩进：
- en: '[PRE69]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 3-6: *weather_nested_conditional.py*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-6: *weather_nested_conditional.py*'
- en: The first `print` statement is indented twice, which is how Python knows that
    it belongs to both preceding conditional statements.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `print` 语句缩进了两次，这样 Python 就知道它属于前面两个条件语句。
- en: Given the importance of whitespace, the “tabs versus spaces” war is fairly common
    in Python world. You’ll remember from Chapter 2 that the PEP 8 style guide stresses
    using either four spaces or a single tab per indentation level. ***Consistency
    is key!*** Python really doesn’t care whether you use tabs, two spaces, four spaces,
    or even seven spaces (although that’s probably a step too far) for each level
    of indentation. The point is to be consistent within any and every given block
    of code.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空白符的重要性，“Tab 与空格”的争论在 Python 世界中相当常见。你会记得在第二章中提到的 PEP 8 风格指南强调每个缩进级别使用四个空格或一个
    Tab。***一致性是关键！*** Python 并不在意你每个缩进级别是使用 Tab、两个空格、四个空格，还是甚至七个空格（尽管这可能有点过头）。关键是确保在每一段代码块中保持一致。
- en: You should use only one indentation style throughout your project, even if your
    situation provides a technical loophole. Don’t mix tabs and spaces. Chances are
    your IDE has tools to help you with this.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目中，你应该只使用一种缩进风格，即使你的情况提供了技术上的漏洞。不要混合使用 Tab 和空格。你的 IDE 很可能有工具来帮助你处理这个问题。
- en: For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout
    my code examples. While I’d recommend you follow this same convention—you can
    even configure your editor to insert four spaces each time you hit the Tab key—if
    you have a strong preference for tabs, you’re welcome to use those instead. It
    really doesn’t matter.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我在所有代码示例中会使用 PEP 8 约定的四个空格缩进。虽然我建议你遵循这一约定——你甚至可以配置编辑器，让每次按下 Tab 键时插入四个空格——但如果你更喜欢使用
    Tab 键，你也可以选择使用它。实际上，这并不重要。
- en: Doing Nothing
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么都不做
- en: On occasion, you will need to insert a statement that has absolutely no effect.
    This is particularly useful when you need to put a syntactically valid placeholder
    where a suite of code will exist later. For this purpose, Python provides the
    `pass` keyword.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要插入一个完全没有效果的语句。尤其当你需要在稍后某个代码块的位置插入一个语法上有效的占位符时，这非常有用。为此，Python 提供了 `pass`
    关键字。
- en: 'For example, I can employ the `pass` keyword as a placeholder in my `if raining`
    conditional, until I’m able to write the final code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以在 `if raining` 条件语句中使用 `pass` 关键字作为占位符，直到我能编写最终的代码：
- en: '[PRE70]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 3-7: *raining_pass.py*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：*raining_pass.py*
- en: Just remember, `pass` does absolutely nothing. That’s the only reason it exists.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 只要记住，`pass` 是不做任何事情的。这就是它存在的唯一原因。
- en: Comments and Docstrings
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释与文档字符串
- en: To write comments in Python, precede the line with a hash (`#`). Everything
    between the hash and the end of the line is a comment and will be ignored by the
    interpreter.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中写注释时，在行前加上井号符号（`#`）。井号和该行末尾之间的内容都是注释，解释器会忽略它们。
- en: '[PRE71]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 3-8: *comments.py*'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-8：*comments.py*
- en: If you ran this program, the `print` statements would both execute. The rest
    of the second `print` statement, from the hash onward, is an inline comment ❶
    and would be ignored by the interpreter. All the other lines are only comments.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，两个 `print` 语句都会执行。第二个 `print` 语句从井号开始的部分是内联注释 ❶，解释器会忽略它。其他所有行仅为注释。
- en: Docstrings
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串
- en: 'Officially, there is no syntax for “multiline” comments; you just comment each
    line. There is one special exception: the *docstring*. It looks like this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 官方来说，Python 没有“多行”注释的语法；你只能对每一行进行注释。有一个特殊的例外：*文档字符串（docstring）*。它的格式如下：
- en: '[PRE72]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Listing 3-9: *docstrings.py:1*'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-9：*docstrings.py:1*
- en: I define a function that would (theoretically) make tea, and I place the description
    of the function inside a docstring.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个（理论上）可以泡茶的函数，并将函数的描述放在文档字符串中。
- en: Docstrings exist to provide documentation for functions, classes, and modules,
    especially public ones. They conventionally begin and end with three quotation
    marks (`"""`), allowing the string to automatically span multiple lines. You would
    typically place docstrings at the top, inside of whatever they’re defining, such
    as in the function above.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串用于为函数、类和模块提供文档，尤其是公共的。它们通常以三个双引号（`"""`）开始和结束，这样字符串就可以自动跨越多行。通常你会把文档字符串放在它们定义的内容的顶部，例如上面的函数。
- en: 'There are three important distinctions between comments and docstrings:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 注释和文档字符串之间有三个重要的区别：
- en: Docstrings are string literals, and they are seen by the interpreter; comments
    are ignored.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串是字符串文字，它们会被解释器识别；而注释则会被忽略。
- en: Docstrings are used in automatic documentation generation.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串用于自动生成文档。
- en: Docstrings are generally only docstrings when they appear at the top of the
    module, function, class, or method they define. Comments can live anywhere.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串通常只有在出现在它们定义的模块、函数、类或方法的顶部时才算作文档字符串。注释可以出现在任何地方。
- en: It is perfectly possible to use a triple-quoted string literal to write a sort
    of “multiline comment,” but it’s not recommended, since a string literal can easily
    get left in a place where Python will try to use it as a value.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以使用三引号字符串字面量来写一种“多行注释”，但不推荐这样做，因为字符串字面量可能会被遗忘在 Python 尝试将其作为值使用的地方。
- en: In short, use docstrings as intended, and stick with comments for everything
    else. Many Python IDEs have hotkeys for toggling comments on a selection, which
    can save you a lot of time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，按预期使用文档字符串，其他情况则使用注释。许多 Python IDE 都有切换注释的快捷键，这可以节省你大量时间。
- en: 'I can access these docstrings later in my code. For instance, given the previous
    example, I can do this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在代码中稍后访问这些文档字符串。例如，给定前面的例子，我可以这样做：
- en: '[PRE73]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 3-10: *docstrings.py:2*'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-10：*docstrings.py:2*
- en: Docstrings have their own style conventions, which are outlined in depth in
    PEP 257.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串有自己的一套风格约定，详细内容可以参考 PEP 257。
- en: Declaring Variables
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'You may have already noticed that Python doesn’t have a distinct keyword for
    declaring a new variable (technically called a *name* in this language; see Chapter
    5). Here, I define two variables—`name` and `points`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Python 没有明确的关键字来声明一个新变量（在这个语言中，技术上称之为*名称*；见第 5 章）。在这里，我定义了两个变量——`name`
    和 `points`：
- en: '[PRE74]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 3-11: *variables.py*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-11：*variables.py*
- en: Python is *dynamically typed*, meaning the data type of a value is determined
    when it is evaluated. This contrasts with statically typed languages, in which
    you declare the data type initially. (C++ and Java are both statically typed.)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是*动态类型语言*，意味着值的数据类型是在评估时确定的。这与静态类型语言形成对比，后者在初始时就声明了数据类型。（C++ 和 Java 都是静态类型语言。）
- en: With Python, you can assign a value to a name anytime, by using the assignment
    operator (`=`). It infers the data type. If the name is a new variable, Python
    will create it; if the name already exists, Python will change the value. It’s
    a pretty straightforward system.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python，你可以通过赋值运算符（`=`）随时将一个值赋给一个名称。Python 会自动推断数据类型。如果这个名称是一个新的变量，Python
    会创建它；如果名称已经存在，Python 会修改其值。这是一个相当直接的系统。
- en: 'In general, there are only two rules to follow with Python variables:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用 Python 变量时，只需要遵守两条规则：
- en: Define a variable before you access it; otherwise, you’ll get an error.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问变量之前必须先定义它；否则，你会遇到错误。
- en: Don’t change what kind of data you’re storing in the variable, even when replacing
    a value.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在替换值时，不要改变你在变量中存储的数据类型。
- en: Python is considered a *strongly typed language*, meaning you usually can’t
    magically combine data of different types. For example, it won’t allow you to
    add an integer and a string together. On the other hand, *weakly typed* languages
    let you do practically anything with different data types, and they try to figure
    out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire
    spectrum between those last two terms and plenty of debate about what behaviors
    qualify under which name. While Python is decidedly in the “strongly typed” camp,
    it still has weaker typing than some languages.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Python 被认为是一个*强类型语言*，意味着你通常不能将不同类型的数据任意组合。例如，它不会允许你将整数和字符串相加。另一方面，*弱类型语言*允许你几乎对不同数据类型做任何事情，并且它们会尝试找出如何执行你要求的操作。（JavaScript
    是弱类型语言。）在这两个术语之间有一个完整的光谱，关于哪些行为属于哪个名称，也有很多争议。尽管 Python 明确属于“强类型”阵营，但它的类型约束比某些语言要弱。
- en: Python is, however, *weakly bound*, so it is possible to assign a value of a
    different type to an existing variable. While this is technically permissible,
    it is strongly discouraged, as it can produce confusing code.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 是*弱绑定*的，因此你可以将不同类型的值赋给现有的变量。虽然从技术上讲，这是允许的，但强烈不建议这样做，因为这可能会导致混乱的代码。
- en: What About Constants?
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量呢？
- en: Python doesn’t have any formally defined constants. In keeping with PEP 8, you
    would indicate a variable is intended to be treated as a constant by using all-caps
    names with underscores. This naming convention is sometimes humorously referred
    to as *screaming snake case* for the all-caps (screaming) and the underscores
    (snakes). For example, the name `INTEREST_RATE` indicates that you don’t want
    the variable redefined or changed in any way. While the interpreter itself won’t
    prevent the variable from being modified, your linter will usually complain if
    you do.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有正式定义的常量。根据 PEP 8，你可以通过使用全大写字母和下划线的变量名来表示一个变量应该被视为常量。这种命名约定有时被幽默地称为
    *尖叫蛇形命名法*，因为它既有全大写（尖叫）又有下划线（蛇）。例如，`INTEREST_RATE` 这个名字表示你不希望这个变量被重新定义或更改。虽然解释器本身不会阻止修改这个变量，但通常如果你修改了它，静态检查工具会给出警告。
- en: Mathematics
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学
- en: Python has all the math functionality you would expect from a good programming
    language; its excellent support for both simple and complicated mathematics is
    one of the reasons Python is popular for scientific programming, data processing,
    and statistical analysis.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有你期望的所有数学功能；它对简单和复杂数学的优秀支持是 Python 在科学编程、数据处理和统计分析中广受欢迎的原因之一。
- en: Meet the Number Types
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认识数字类型
- en: Before I get into the operations, you should be aware of the three data types
    used for storing numbers.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入运算之前，你应该了解用于存储数字的三种数据类型。
- en: '*Integers* (`int`) store whole numbers. In Python, integers are always signed
    and effectively have no maximum value. Integers use decimal base (base-10) by
    default, but they can also be specified in binary (`0b101010`), octal (`0o52`),
    or hexadecimal (`0x2A`).'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数*（`int`）用于存储整数。在 Python 中，整数始终是有符号的，实际上没有最大值。整数默认使用十进制（base-10），但也可以用二进制（`0b101010`）、八进制（`0o52`）或十六进制（`0x2A`）表示。'
- en: '*Floating-point numbers* (`float`) store numbers with a decimal part (for example,
    `3.141592`). You can also use scientific notation (for example, `2.49e4`). Internally,
    values are stored as double-precision, IEEE 754 floating-point numbers, which
    are subject to the limits inherent in that format. (For more insight into the
    limits and gotchas of floating-point arithmetic, read the article “What Every
    Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg:
    [https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*.*)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点数*（`float`）用于存储带有小数部分的数字（例如，`3.141592`）。你还可以使用科学记数法（例如，`2.49e4`）。在内部，值以双精度、IEEE
    754 浮点数的形式存储，这些值受到该格式固有限制的影响。（想深入了解浮点运算的限制和陷阱，可以阅读 David Goldberg 的文章《每个计算机科学家都应该知道的浮点算术》：[https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*。*'
- en: You can also specify an invalid number with `float("nan")`, a number larger
    than the largest possible value with `float("inf")`, or a number smaller than
    the smallest possible value with `float("-inf")`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 `float("nan")` 指定一个无效的数字，使用 `float("inf")` 指定一个大于最大可能值的数字，或使用 `float("-inf")`
    指定一个小于最小可能值的数字。
- en: Notice that I wrapped the special values in quotes. This is necessary if you
    want to use these values without *importing* the `math` module (see Chapter 4
    for more about importing). If you have imported the `math` module (see “The `math`
    Module” subsection below), you can use the constants `nan`, `inf`, and so forth,
    instead of the quoted versions.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我将特殊值用引号括起来了。如果你不想 *导入* `math` 模块（更多关于导入的内容请参见第 4 章），这样做是必要的。如果你已经导入了 `math`
    模块（参见下文的 “`math` 模块” 小节），你可以直接使用常量 `nan`、`inf` 等，而不需要用引号。
- en: '*Complex numbers* (`complex`) can store imaginary numbers by appending `j`
    to the value, as in `42j`. You can combine a real part with the imaginary part,
    using addition: `24+42j`.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*复数*（`complex`）可以通过在值后添加 `j` 来存储虚数，例如 `42j`。你可以通过加法将实部和虚部结合起来，例如 `24+42j`。'
- en: In case you missed it in math class, an imaginary number has the square root
    of negative one as one of its factors, even though this value is utterly impossible;
    there is no value that you can multiply by itself to get negative one! Yet imaginary
    numbers definitely show up in real-world math. Spooky, no?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在数学课上没学过，虚数的一个因子是负一的平方根，尽管这个值从数学上看是完全不可能的；没有任何值能够与自身相乘得到负一！然而，虚数确实在实际数学中出现。吓人吧？
- en: '*Decimal* and *Fraction* are two of the additional object types for storing
    numeric data. `Decimal` stores fixed-point decimal numbers, while `Fraction` does
    the same for fractions. To use either, you’ll need to import them first.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '*Decimal* 和 *Fraction* 是两个用于存储数值数据的附加对象类型。`Decimal` 用于存储定点小数，而 `Fraction` 用于存储分数。要使用这两者，你需要先导入它们。'
- en: 'Here’s a brief example that uses both types:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简短的示例，演示了如何同时使用这两种类型：
- en: '[PRE75]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 3-12: *fractions_and_decimals.py*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-12: *fractions_and_decimals.py*'
- en: The `float()` function turns `Fraction` and `Decimal` objects into floats.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`float()` 函数可以将 `Fraction` 和 `Decimal` 对象转换为浮点数。'
- en: Operators
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符
- en: Python has the usual operators, with a couple of additions that may not be familiar
    to some developers.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有常见的运算符，此外还添加了一些可能对某些开发者不熟悉的运算符。
- en: 'Here’s a bit of code that will demonstrate the math operators. I’ll wrap each
    equation inside a `print()` statement, so you can run the code and see the results:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一段代码示例，演示了数学运算符。我会将每个方程包裹在 `print()` 语句中，这样你可以运行代码并查看结果：
- en: '[PRE76]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 3-13: *math_operators.py*'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-13: *math_operators.py*'
- en: The *unary* (one-operand) negative operator flips the sign of whatever follows
    it. The `abs()` function is technically considered a unary operator as well. The
    rest of the operators here are *binary*, meaning they accept two operands.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元*（单操作数）负号运算符会改变其后跟随的数字的符号。`abs()` 函数在技术上也被认为是一元运算符。其余的运算符都是 *二元* 运算符，意味着它们接受两个操作数。'
- en: '[PRE77]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 3-14: *augmented_assignment_operators.py*'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-14: *augmented_assignment_operators.py*'
- en: If you need both floor division (`//`) and modulo (`%`) on the same operands,
    Python provides the `divmod()` function to efficiently perform the calculation,
    returning the two results in a tuple. Thus, `c = divmod(a, b)` is the same as
    `c = (a // b, a % b)`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对同一操作数进行地板除法 (`//`) 和取余 (`%`)，Python 提供了 `divmod()` 函数，可以高效地进行计算，并返回一个包含两个结果的元组。因此，`c
    = divmod(a, b)` 相当于 `c = (a // b, a % b)`。
- en: 'Python also has `bitwise` operators, which I’ll list below for those readers
    already familiar with bitwise arithmetic. I won’t introduce these concepts until
    Chapter 12:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还具有 `bitwise` 运算符，下面我会列出这些运算符，供那些已经熟悉位运算的读者参考。直到第 12 章才会介绍这些概念：
- en: '[PRE78]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 3-15: *bitwise_operators.py*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-15: *bitwise_operators.py*'
- en: The math Module
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学模块
- en: 'Python provides plenty of additional functions in the `math` module, along
    with the five most common math constants: `pi`, `tau`, `e`, `inf`, and `nan`.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在 `math` 模块中提供了许多额外的函数，以及五个最常见的数学常量：`pi`、`tau`、`e`、`inf` 和 `nan`。
- en: '[PRE79]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 3-16: *math_constants.py*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-16: *math_constants.py*'
- en: All five constants are floats and can be directly used as such ❶. The official
    documentation provides a complete list of everything available in the `math` module.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个常量都是浮点数，可以直接作为浮点数使用 ❶。官方文档提供了 `math` 模块中所有可用项的完整列表。
- en: 'You might remember a little trick from high school trigonometry, where you
    could calculate the height of something using your distance to it and the angle
    from your vantage point to the top of the object. Here’s a way to calculate that
    with Python, using the `math` module:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你或许还记得高中三角学中的一个小技巧，通过已知与目标物体的距离和从你所在位置到物体顶部的角度，就可以计算物体的高度。这里有一种方法可以用 Python
    和 `math` 模块来进行计算：
- en: '[PRE80]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 3-17: *surveying_height.py*'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-17: *surveying_height.py*'
- en: 'I use two functions from the `math` module: `math.radians()` ❶ and `math.tan()`
    ❷. The `round()` function ❸ is built into the language itself.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `math` 模块中的两个函数：`math.radians()` ❶ 和 `math.tan()` ❷。`round()` 函数 ❸ 是语言本身内置的。
- en: Logic
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑
- en: Python’s clean, obvious syntax for logical expressions is one of the attractive
    elements of the language. Here, I’ll cover conditional statements and expressions,
    as well as the comparison and logic operators.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: Python 逻辑表达式的简洁而直观的语法是该语言的一个吸引力元素。在这里，我将讲解条件语句和表达式，以及比较运算符和逻辑运算符。
- en: Conditionals
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditionals are compound statements composed of `if`, `elif`, and `else` clauses,
    each made up of a header and a suite. As with most languages, you can have as
    many `elif` conditionals in Python as you want, sandwiched between `if` and (optionally)
    `else`. Here’s a really simple example:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句是由 `if`、`elif` 和 `else` 子句组成的复合语句，每个子句都由一个头部和一个语句块构成。和大多数语言一样，在 Python 中，你可以根据需要添加任意多个
    `elif` 条件语句，它们位于 `if` 和（可选的）`else` 之间。下面是一个非常简单的例子：
- en: '[PRE81]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 3-18: *conditional_greet.py*'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-18: *conditional_greet.py*'
- en: This conditional statement is made up of three clauses. The `if` clause evaluates
    first, and if the expression in its header evaluates to `True`, its suite runs,
    printing `"Hello!"` Otherwise, it evaluates the expression in the `elif` header
    next. If none of the expressions evaluate to `True`, then the `else` clause runs.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件语句由三个子句组成。首先会评估 `if` 子句，如果其头部的表达式为 `True`，则会执行该部分，打印 `"Hello!"`。否则，接着评估
    `elif` 头部的表达式。如果没有任何表达式为 `True`，则执行 `else` 子句。
- en: You’ll notice you don’t need to wrap the conditional expressions, such as `command
    == "greet"`, in parentheses, although you may do so anyway if it helps clarify
    your code. You’ll see an example of this shortly.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，你不需要将条件表达式（如 `command == "greet"`）用括号括起来，尽管如果括起来能帮助澄清代码，你依然可以这么做。很快你就会看到这个例子。
- en: If you’re looking for something similar to the `switch` statement from your
    favorite programming language, see the “Structural Pattern Matching” section toward
    the end of this chapter.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找类似于你最喜欢的编程语言中的 `switch` 语句，可以参考本章末尾的“结构模式匹配”部分。
- en: Comparison Operators
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'Python has all the comparison operators you’d expect. Take a look at these
    in the context of comparing two integers:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Python 拥有你所期望的所有比较运算符。看一下在比较两个整数时它们的使用：
- en: '[PRE82]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 3-19: *comparison_operators.py*'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-19: *comparison_operators.py*'
- en: As you can see, Python has operators for `equals`, `not equals`, `less than`,
    `less than or equals`, `greater than`, and `greater than or equals`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 有 `等于`、`不等于`、`小于`、`小于或等于`、`大于`、`大于或等于`等运算符。
- en: No surprises there, but what about boolean comparisons? This is where Python
    takes a different line.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶，但布尔比较呢？这正是 Python 与其他语言不同的地方。
- en: Boolean, None, and Identity Operators
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔、None 和身份运算符
- en: Python offers the values `True` and `False`, which are the two values for boolean
    (type `bool`) variables. It also has a dedicated `None` value (type `NoneType`),
    which serves in the capacity of a “null” value.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 `True` 和 `False` 两个布尔值（类型 `bool`）。它还有一个专用的 `None` 值（类型 `NoneType`），用于表示“空值”。
- en: You check for these values in a very different way than with other data types.
    Instead of the comparison operators, use the special *identity operator* `is`.
    (I’ll also use the logical operator `not` below, which I’ll discuss separately
    in a bit.)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要用一种不同的方式来检查这些值，而不是使用比较运算符，而是使用特殊的 *身份运算符* `is`。（我在下面还会使用逻辑运算符 `not`，稍后我会单独讨论它。）
- en: 'Here’s an example:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE83]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 3-20: *boolean_identity_operators.py*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-20: *boolean_identity_operators.py*'
- en: Aside from being a little high in sodium, that code shows the many ways of testing
    boolean values and checking for `None`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 除了略显高钠外，这段代码展示了测试布尔值和检查 `None` 的多种方式。
- en: You can test if a variable is set to `True`, `False`, or `None` by comparing
    with the `is` operator. You can also invert the logic with `is not`.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `is` 运算符来测试一个变量是否设置为 `True`、`False` 或 `None`。你还可以通过 `is not` 来反转逻辑。
- en: Most commonly, when testing against `True`, you can use the variable as the
    entire condition ❶. For `False`, invert that condition test with `not` ❷.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，当测试 `True` 时，你可以将变量作为整个条件 ❶。对于 `False`，则使用 `not` 来反转该条件测试 ❷。
- en: Take particular note of the last condition, which illustrates an important gotcha
    with the `is` operator ❸. It actually compares the identity of the variables,
    rather than the value. This is particularly troublesome, as the logic looks sound
    but is a bug waiting for a place to happen. That probably doesn’t mean much to
    you yet, but rest assured, I’ll cover this concept in depth in Chapter 5.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意最后一个条件，它展示了 `is` 运算符的一个重要陷阱 ❸。它实际上比较的是变量的身份，而不是值。这是一个相当棘手的问题，因为逻辑看起来是对的，但却是一个潜在的
    bug。虽然你可能现在还不太理解，但放心，我会在第五章深入讲解这个概念。
- en: 'For now, you can take this rule for granted: use `is` *only* for comparing
    directly to `None`, and use regular comparison operators for everything else.
    In practice, we usually say `if spam` or `if not spam`, instead of directly comparing
    to `True` or `False`.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以将这个规则牢记在心：*仅*用于直接与 `None` 进行比较时使用 `is`，对于其他所有情况，使用常规的比较运算符。在实践中，我们通常会使用
    `if spam` 或 `if not spam`，而不是直接与 `True` 或 `False` 比较。
- en: Truthiness
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值性
- en: Most expressions and values in Python can be evaluated to a `True` or `False`
    value. This is typically done by using the value as an expression by itself, although
    you can also pass it to the `bool()` function to convert it explicitly.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，大多数表达式和值都可以评估为`True`或`False`值。通常，这通过将值本身作为表达式来实现，尽管你也可以将它传递给`bool()`函数来显式地转换它。
- en: '[PRE84]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Listing 3-21: *truthiness.py*'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-21: *truthiness.py*'
- en: When an expression will evaluate to `True`, it is considered “truthy.” When
    it will evaluate to `False`, it is “falsey.” The `None` constant, values representing
    zero, and empty collections are all considered “falsey,” while most other values
    are “truthy.”
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式评估为`True`时，它被认为是“真值（truthy）”。当它评估为`False`时，它是“假值（falsey）”。`None`常量、表示零的值和空集合都被视为“假值”，而大多数其他值被视为“真值”。
- en: Logical Operators
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'If you’re coming from a language where logical operators are a little more
    difficult to remember, you’ll find Python refreshing: it simply uses the keywords
    `and`, `or`, and `not`!'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个逻辑运算符更难记住的语言，你会觉得 Python 刷新了你的思维：它只需使用关键字`and`、`or`和`not`！
- en: '[PRE85]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 3-22: *logical_operators.py*'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-22: *logical_operators.py*'
- en: With the `and` condition, both expressions must evaluate to `True`. With the
    `or` condition, one or the other (or both) must evaluate to `True`. The third
    condition adds `not` to the picture, requiring that `eggs` be `False` and `spam`
    be `True`.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`and`条件时，两个表达式都必须评估为`True`。使用`or`条件时，两个表达式中的一个或两个必须评估为`True`。第三个条件加入了`not`，要求`eggs`为`False`，`spam`为`True`。
- en: I could have omitted the parentheses on the third condition, as `not` takes
    precedence and so is evaluated before `and`. However, the parentheses help to
    clarify my intended logic.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以省略第三个条件中的括号，因为`not`的优先级较高，因此会在`and`之前被计算。然而，括号有助于澄清我想表达的逻辑。
- en: 'In practice, you can use the `not` keyword to invert any conditional expression,
    such as in the following:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用`not`关键字来反转任何条件表达式，例如下面这样：
- en: '[PRE86]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 3-23: *not_operators.py*'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-23: *not_operators.py*'
- en: 'Both comparisons do the same thing; the issue becomes readability. In this
    case, the expression using `not` is less readable because your eyes might skip
    over the `not` keyword, so you might not catch what’s happening in the code. The
    condition employing the `!=` operator is preferred for readability. While you
    might find situations where `not` is the best way to invert your conditional logic,
    remember The Zen of Python: ***Readability counts!***'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '两个比较做的是一样的事；问题出在可读性上。在这种情况下，使用`not`的表达式可读性较差，因为你的眼睛可能会跳过`not`关键字，因此你可能没有注意到代码中的实际发生情况。使用`!=`运算符的条件更有利于可读性。虽然你可能会遇到`not`是反转条件逻辑的最佳方式的情况，但请记住
    Python 的 Zen: ***可读性很重要！***'
- en: The Walrus Operator
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 海象运算符
- en: Python 3.8 introduced *assignment expressions*, which allow you to assign a
    value to a variable and use that variable in another expression at the same time.
    This is possible with the so-called *walrus operator* (`:=`).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.8 引入了*赋值表达式*，这使得你可以将值赋给一个变量，并同时在另一个表达式中使用该变量。这是通过所谓的*海象运算符*（`:=`）实现的。
- en: '[PRE87]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 3-24: *walrus.py*'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-24: *walrus.py*'
- en: With the walrus operator, Python first evaluates the expression on the left
    (`7+5`) and then assigns it to the variable `eggs`. The assignment expression
    is enclosed in parentheses for readability, although I technically could have
    omitted them.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 使用海象运算符时，Python首先计算左侧的表达式（`7+5`），然后将其赋值给变量`eggs`。赋值表达式被括号括起来以提高可读性，尽管从技术上讲，我本可以省略它们。
- en: The assignment expression is then evaluated to a single value, namely the value
    of `eggs`, which is used in the comparison. Since the value is `12`, the condition
    evaluates to `True`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，赋值表达式被计算为一个单一的值，即`eggs`的值，该值被用于比较中。由于值为`12`，条件计算结果为`True`。
- en: What’s interesting about the assignment expression is that `eggs` is now a valid
    variable in the outer scope, so I can print its value outside of the conditional.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，赋值表达式使得`eggs`现在成为外部作用域中的有效变量，因此我可以在条件外部打印它的值。
- en: This feature is potentially useful in many scenarios, not only in conditional
    expressions, as above.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在许多场景中都可能非常有用，不仅仅是在像上面那样的条件表达式中。
- en: 'Assignment expressions and the walrus operator were defined in PEP 572, which
    also contains an in-depth discussion about when and where this feature should
    be used. Two particularly useful style rules are put forth by this PEP:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式和海象运算符在 PEP 572 中被定义，该提案还深入讨论了何时以及在何处应使用此特性。该 PEP 提出了两条特别有用的风格规则：
- en: If either assignment statements or assignment expressions can be used, then
    prefer statements; they are clear declarations of intent.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以使用赋值语句或赋值表达式，则优先使用语句；它们是意图的明确声明。
- en: If using assignment expressions would lead to ambiguity about execution order,
    then restructure to use statements instead.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用赋值表达式会导致执行顺序的不明确，应该重构为使用语句。
- en: As of the writing of this book, Python assignment expressions are still in their
    infancy. A lot of debate and controversy still surrounds them. In any case, resist
    the temptation to abuse the walrus operator to cram as much logic onto one line
    as possible. You should always aim for readability and clarity in your code, above
    all else.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本书写作时，Python 的赋值表达式仍处于初期阶段，围绕它的争论和争议依然存在。无论如何，请避免滥用海象运算符，将尽可能多的逻辑塞进一行代码中。你应该始终以代码的可读性和清晰度为首要目标。
- en: Ellipsis
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 省略号
- en: 'One seldom-used piece of syntax is the *Ellipsis*:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很少使用的语法是*省略号*：
- en: '[PRE88]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is sometimes used by various libraries and modules, but seldom consistently.
    For example, it’s used with multidimensional arrays in the NumPy third-party library
    and when working with type hints from the built-in `typing` module. When you see
    it come up, consult the documentation for whatever module you’re using.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这在各种库和模块中有时会使用，但并不一致。例如，在 NumPy 第三方库中的多维数组，或者在处理内置 `typing` 模块中的类型提示时都会用到。当你遇到这种情况时，查阅你所使用的模块的文档。
- en: Strings
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'There are a few things to know about strings as you move forward. Here, I’ll
    cover the three kinds of strings: string literals, raw strings, and formatted
    strings.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续深入之前，有一些关于字符串的知识需要了解。在这里，我将介绍三种类型的字符串：字符串字面量、原始字符串和格式化字符串。
- en: String Literals
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'There are multiple ways of defining a *string literal*:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*字符串字面量*的方法有很多种：
- en: '[PRE89]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 3-25: *string_literals.py*'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-25: *string_literals.py*'
- en: You can wrap a literal in double quotes (`"`), single quotes (`'`), or triple
    quotes (`"""`) of either type. You may remember from earlier that there’s something
    special about triple quotes, but I’ll come back to that in a moment.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用双引号（`"`）、单引号（`'`）或三引号（`"""`）包围一个字面量。你可能记得之前提到过三引号有些特殊，但稍后我会再回来讲。
- en: 'PEP 8 addresses the use of single and double quotes:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 规范了单引号和双引号的使用：
- en: In Python, single-quoted strings and double-quoted strings are the same. This
    PEP does not make a recommendation for this. Pick a rule and stick to it. When
    a string contains single or double quote characters, however, use the other one
    to avoid backslashes in the string. It improves readability.
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Python 中，单引号字符串和双引号字符串是一样的。这个 PEP 并没有对此做推荐。选择一个规则并坚持使用。然而，当字符串中包含单引号或双引号字符时，最好使用另一种引号类型来避免字符串中的反斜杠，这样能提高可读性。
- en: 'The advice about placing quotes inside a string comes in handy when dealing
    with something like this:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在字符串内放置引号的建议，当处理类似情况时非常有用：
- en: '[PRE90]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Listing 3-26: *escaping_quotes.py:1a*'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-26: *escaping_quotes.py:1a*'
- en: This version escapes the double quotes I want to include in the string literal
    itself. The backslash (`\`) before the quotes means I want the string to contain
    that *literal character*, not to have Python treat the double quote as the boundary
    of a string. The string literal must always be wrapped in matching quotes.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本转义了我想在字符串字面量中包含的双引号。引号前的反斜杠（`\`）表示我希望字符串包含那个*字面字符*，而不是让 Python 将双引号视为字符串的边界。字符串字面量必须始终用匹配的引号括起来。
- en: 'It is possible to avoid backslashes in this scenario, however:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，是可以避免使用反斜杠的：
- en: '[PRE91]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 3-27: *escaping_quotes.py:1b*'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-27: *escaping_quotes.py:1b*'
- en: This second version wraps the literal in single quotes, so the double quotes
    will be automatically interpreted as part of the string literal. That approach
    is much more readable. By wrapping the string in single quotes, Python will assume
    the double quotes are characters in the string.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本将字面量用单引号包围，这样双引号会自动被解释为字符串字面量的一部分。这种方式更加易读。通过使用单引号包围字符串，Python 会将双引号视为字符串中的字符。
- en: 'The only time you’d really need to escape either single or double quotes with
    backslashes would be if you had both types of quotes in the string at once:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 你真正需要用反斜杠转义单引号或双引号的唯一情况是，当字符串中同时包含这两种类型的引号时：
- en: '[PRE92]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 3-28: *escaping_quotes.py:2a*'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-28: *escaping_quotes.py:2a*'
- en: Personally, in cases like that, I’d prefer to use (and escape) the double quotes,
    because they don’t evade my attention like an apostrophe would tend to do.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，在这种情况下，我更倾向于使用（并转义）双引号，因为它们不像撇号那样容易分散我的注意力。
- en: 'You also have the option to use triple quotes:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择使用三重引号：
- en: '[PRE93]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 3-29: *escaping_quotes.py:2b*'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-29：*escaping_quotes.py:2b*
- en: 'Remember that triple quotes define *multiline string literals*. In other words,
    I can use them to do this:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，三重引号定义了*多行字符串字面量*。换句话说，我可以用它们做这个：
- en: '[PRE94]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 3-30: *multiline_string.py*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-30：*multiline_string.py*
- en: Everything, including newlines and leading whitespace, is literal in triple
    quotes. If I `print("parrot")`, it will display exactly like this in the terminal.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在三重引号中，所有内容，包括换行符和前导空格，都是字面量。如果我执行`print("parrot")`，它将在终端中显示如下：
- en: The only exception occurs when you use a backslash (`\`) to escape a particular
    character, like I did with that newline at the beginning ❶. It is conventional
    to escape the first newline after the opening triple quotes, just to make the
    code look cleaner.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是在你使用反斜杠（`\`）转义某个特定字符时，就像我在开头用它转义换行符一样❶。常规做法是转义开头三重引号后的第一个换行符，这样可以使代码看起来更整洁。
- en: The built-in `textwrap` module has some functions for working with multiline
    strings, including tools that allow you remove leading indentation (`textwrap.dedent`).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 内建的`textwrap`模块提供了一些处理多行字符串的函数，包括允许你删除前导缩进的工具（`textwrap.dedent`）。
- en: Alternatively, you can *concatenate* (combine) string literals, simply by writing
    them next to one another, without any operators between them. For example, `spam
    = "Hello " "world" "!"` is valid, resulting in the string `Hello world!.` If you
    wrap the assignment expression in parentheses, you can even span multiple lines.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以*连接*（合并）字符串字面量，只需将它们紧挨着写在一起，不需要中间加任何操作符。例如，`spam = "Hello " "world" "!"`是有效的，结果是字符串`Hello
    world!`。如果你将赋值表达式包裹在括号中，你甚至可以跨越多行。
- en: Raw Strings
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串
- en: '*Raw strings* constitute another form of string literal, wherein the backslash
    (`\`) is always treated as a literal character. They’re preceded with an `r`,
    such as in this example:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始字符串*是另一种字符串字面量形式，其中反斜杠（`\`）始终被视为字面字符。它们前面加上一个`r`，例如以下示例：'
- en: '[PRE95]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 3-31: *raw_string.py*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-31：*raw_string.py*
- en: 'The backslash is treated like a literal character, which means that nothing
    can be escaped inside of a raw string. The output of that line of code looks like
    this:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠被视为字面字符，这意味着在原始字符串中不能进行转义。那行代码的输出如下所示：
- en: '[PRE96]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This has implications for what type of quotes you use, so beware.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你使用哪种引号有一定的影响，所以需要注意。
- en: 'Compare these two lines and their outputs:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两行及其输出：
- en: '[PRE97]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Listing 3-32: *raw_or_not.py*'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-32：*raw_or_not.py*
- en: 'The first string is ordinary, so `\n` is treated as a normal escape sequence:
    specifically, the newline character. That line break appears in the output, like
    this:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串是普通的，因此`\n`被视为一个普通的转义序列：具体来说，是换行符。该换行符会出现在输出中，像这样：
- en: '[PRE98]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The second string is a raw string, so the backslash (`\`) is treated as a literal
    character in its own right. The output would be as follows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字符串是原始字符串，因此反斜杠（`\`）被视为字面字符。输出将如下所示：
- en: '[PRE99]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is particularly useful for regular expression patterns, where you’re likely
    to have plenty of backslashes that you want as part of the *pattern*, not interpreted
    by Python before it gets there. ***Always use raw strings for regular expression
    patterns.***
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于正则表达式模式尤其有用，因为你很可能会有很多反斜杠，你希望它们作为*模式*的一部分，而不是在到达那里之前被Python解释。***始终使用原始字符串处理正则表达式模式。***
- en: Formatted Strings
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: A third kind of string literal is a *formatted string* or *f-string*, which
    is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values
    of variables into a string in a very elegant manner.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种字符串字面量是*格式化字符串*或*f-string*，这是Python 3.6中新引入的（在PEP 498中定义）。它允许你以非常优雅的方式将变量的值插入到字符串中。
- en: 'If I wanted to include the value of a variable in a string without an f-string,
    the code might look like this:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在没有f-string的情况下将变量的值包含在字符串中，代码可能看起来是这样的：
- en: '[PRE100]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 3-33: *cheese_shop.py:1a*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-33：*cheese_shop.py:1a*
- en: The `str()` function converts the value passed to it into a string, and then
    the three strings are *concatenated*, or combined, into one, using the `+` operator.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()`函数将传入的值转换为字符串，然后将三个字符串*连接*，或合并成一个，使用`+`操作符。'
- en: Using f-strings, this code becomes more elegant.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 使用f-string，这段代码变得更加优雅。
- en: '[PRE101]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Listing 3-34: *cheese_shop.py:1b*'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-34: *cheese_shop.py:1b*'
- en: You precede the string literal with an `f`. Inside, you can substitute a variable
    by wrapping it in curly braces (`{ }`). The `f` tells Python to interpret and
    evaluate as an expression anything in the string that’s wrapped in curly braces.
    This means you’re not limited to variables in those curly braces. You can put
    just about any valid Python code in there, including math, function calls, conditional
    expressions, or whatever you need.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 你在字符串字面量前加上一个 `f`。在其中，你可以通过将变量包裹在大括号（`{ }`）内来替换变量。这个 `f` 告诉 Python 解释并评估字符串中任何被大括号包围的部分作为表达式。这意味着你不仅仅局限于在大括号中使用变量。你可以在其中放入几乎任何有效的
    Python 代码，包括数学运算、函数调用、条件表达式等。
- en: As of Python 3.8, you can even display both the expression *and* its result
    by appending a trailing equal sign (`=`).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.8 开始，你甚至可以通过在表达式后添加等号（`=`）来同时显示表达式 *及其* 结果。
- en: '[PRE102]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Listing 3-35: *expression_fstring.py*'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-35: *expression_fstring.py*'
- en: 'There are a couple of gotchas when using f-strings:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-strings 时有一些需要注意的事项：
- en: 'First, if you want to wrap an expression in literal curly braces, you must
    use two curly braces (`{{ }}`) for every one you want displayed:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你想在字面上显示大括号表达式，你必须为每个需要显示的大括号使用两个大括号（`{{ }}`）：
- en: '[PRE103]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 3-36: *literal_curly_braces.py*'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-36: *literal_curly_braces.py*'
- en: 'If you have an odd number of braces, one pair will be ignored. So, if I used
    five pairs, the result would be the same as if I only had four: two literal pairs
    would be printed.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有奇数个大括号，最后一对会被忽略。因此，如果我使用了五对大括号，结果就和只有四对一样：会打印出两对字面的大括号。
- en: 'Second, you cannot use backslashes within an expression in an f-string. This
    makes it difficult to escape quotes inside expressions. For example, this would
    not work:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你不能在 f-string 表达式中使用反斜杠。这使得在表达式内部转义引号变得困难。例如，以下代码是无效的：
- en: '[PRE104]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: To get around this, I’d need to use triple quotes on the outside of the string,
    to ensure I can employ both single and double quotes inside of the expression.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个限制，我需要在字符串外部使用三重引号，以确保可以在表达式内部使用单引号和双引号。
- en: '[PRE105]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Backslashes have other roles. The documentation points out the following problematic
    situation:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠有其他的作用。文档指出了以下问题情况：
- en: '[PRE106]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: There’s no direct way around this limitation. Instead, you’d have to evaluate
    that expression in advance, assign the result to a name, and use it in the f-string.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 没有直接的方式绕过这个限制。相反，你必须提前评估该表达式，将结果赋给一个变量，然后在 f-string 中使用它。
- en: '[PRE107]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Third, and perhaps least surprising, you cannot put comments inside of f-string
    expressions; the hash (`#`) symbol isn’t allowed, except as a string literal.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，可能最不令人惊讶的是，你不能在 f-string 表达式内部放置注释；井号（`#`）符号是不允许的，除非它作为字符串字面量使用。
- en: '[PRE108]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Lastly, you can never use f-strings as docstrings.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你不能将 f-strings 用作文档字符串（docstrings）。
- en: These small wrinkles aside, f-strings are incredibly straightforward to work
    with.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些小细节，f-strings 是非常直观易用的。
- en: Format Specifications
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式说明
- en: Besides arbitrary expressions, f-strings support *format specifications*, which
    allow you to control how values are displayed. This is a fairly in-depth topic
    that could easily become a main section on its own, so I will entrust you to the
    guidance of the documentation for the bulk of it. I’ll breeze over the essentials
    herein.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 除了任意表达式外，f-strings 还支持 *格式说明*，它们允许你控制值的显示方式。这是一个相当深入的话题，足以成为一个独立的章节，因此我会将大部分内容交给文档中的指导。这里我将简单讲解其中的要点。
- en: 'Immediately after the expression, you may choose to include one of three special
    flags: `!r`, `!a`, or `!s` (although that last one is the default behavior, so
    it can be omitted in most cases). These determine which function is used to fetch
    the string representation of some value: `repr()`, `ascii()`, or `str()`, respectively
    (see “String Conversion” below).'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式之后，你可以选择添加三个特殊标志之一：`!r`、`!a` 或 `!s`（不过最后一个是默认行为，因此在大多数情况下可以省略）。这些标志决定了用哪个函数来获取某个值的字符串表示：`repr()`、`ascii()`
    或 `str()`，具体请见下文“字符串转换”部分。
- en: 'Next comes the format specification itself, which always begins with a colon
    (`:`), followed by one or more flags. These have to be specified in a particular
    order to work, although any of them may be omitted if they’re not desired:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是格式说明本身，它总是以冒号（`:`）开始，后面跟一个或多个标志。这些标志必须按照特定顺序指定，尽管如果不需要某些标志，可以省略它们：
- en: Align An alignment flag, specifying left (`<`), right (`>`), center (`^`), or
    (if numeric) split with the sign aligned left but the digits aligned right (`=`).
    This is optionally preceded by a character that will be used to fill any blank
    space in the alignment.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐 对齐标志，指定左对齐（`<`）、右对齐（`>`）、居中对齐（`^`），或者（如果是数字）分割符号左对齐而数字右对齐（`=`）。该标志前可选加一个字符，用于填充对齐中的空白区域。
- en: Sign A flag controlling when the sign is displayed on a number. The plus (`+`)
    flag displays the sign on both positive and negative numbers, while the minus
    (`–`) flag only displays it on negative numbers. A third option is to show a leading
    space on positive numbers and a sign on negative numbers (space).
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 控制数字显示符号的标志。加号（`+`）标志会在正负数上都显示符号，而减号（`–`）标志仅在负数上显示。第三种选项是在正数前显示空格，在负数前显示符号（空格）。
- en: Alternative form The hash (`#`) flag turns on the “alternative form,” which
    has different meanings for different types (see documentation).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 替代形式 井号（`#`）标志启用“替代形式”，不同类型有不同的意义（见文档）。
- en: Leading zeros The zero (`0`) flag causes leading zeros to be displayed (unless
    a fill character is specified for alignment).
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 前导零 `0` 标志会导致显示前导零（除非指定了填充字符用于对齐）。
- en: Width The width of the output string in characters. This is where the alignment
    comes into play.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度 输出字符串的宽度（以字符为单位）。这时对齐方式就发挥作用了。
- en: Grouping A flag controlling whether numbers should separate thousands with a
    comma (`,`) or an underscore (`_`). If omitted, no separator is used. If enabled,
    the underscore separator also appears every four digits in octal, hexadecimal,
    and binary numbers.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 分组 一个控制数字是否使用逗号（`,`）或下划线（`_`）分隔千位的标志。如果省略，则不使用分隔符。如果启用，四位数的分隔符还会在八进制、十六进制和二进制数中每隔四位出现。
- en: Precision A dot (`.`), followed by an integer for decimal precision.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 精度 一个点（`.`），后面跟着一个整数表示小数精度。
- en: Type A flag controlling how numbers are displayed; common options include binary
    (`b`), character (`c`), decimal (`d`), hexadecimal (`x`), exponent notation (`e`),
    fixed-point (`f`), and general (`g`). There are more (see documentation).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 控制数字显示方式的标志；常见选项包括二进制（`b`）、字符（`c`）、十进制（`d`）、十六进制（`x`）、指数表示法（`e`）、定点表示法（`f`）和通用表示法（`g`）。还有更多选项（见文档）。
- en: 'All that is a bit abstract, so here are a few quick examples:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有点抽象，因此这里给出一些简短的例子：
- en: '[PRE109]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 3-37: *formatting_strings.py*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-37：*formatting_strings.py*
- en: 'Complete details about the format specification can be found in the official
    Python documentation: [https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax).'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 有关格式规范的完整详情，可以在官方 Python 文档中找到：[https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax)。
- en: Another useful reference is [https://pyformat.info](https://pyformat.info),
    although as of this writing, it only shows the format specification in the context
    of the old `format()` function. You will need to apply it to f-strings yourself.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的参考是 [https://pyformat.info](https://pyformat.info)，尽管截至目前，它仅在旧的 `format()`
    函数上下文中显示格式规范。你需要自行将其应用于 f-strings。
- en: Previous String-Formatting Methods
  id: totrans-772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 之前的字符串格式化方法
- en: 'If you’re reading older Python code, you may encounter the two previous forms
    of string formatting: `%` notation and the newer `format()`. These have both been
    superseded by f-strings, which have superior performance. That’s because they’re
    parsed and converted to bytecode *before* the code is run.'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在阅读较旧的 Python 代码，可能会遇到两种以前的字符串格式化方式：`%` 符号和较新的 `format()`。这两种方式都已被 f-strings
    取代，后者性能更优。这是因为 f-strings 在代码执行之前就已经被解析并转换为字节码。
- en: If you find yourself needing to rewrite a `format()` call as an f-string, the
    process is thankfully quite simple.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要将 `format()` 调用改写为 f-string，幸运的是这个过程相当简单。
- en: 'Here’s an example. I’ll start out with a couple of variables:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子。我将从几个变量开始：
- en: '[PRE110]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 3-38: *format_to_fstring.py:1*'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-38：*format_to_fstring.py:1*
- en: 'Before the advent of f-strings, if I wanted to print out a message containing
    the values of those two variables, I’d have used `format()`:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在 f-strings 出现之前，如果我想打印出包含这两个变量值的消息，我会使用 `format()`：
- en: '[PRE111]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 3-39: *format_to_fstring.py:2a*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-39：*format_to_fstring.py:2a*
- en: In the old format, a string literal ❶ would contain sets of curly braces, optionally
    containing the format specifications. The `format()` function would be called
    on that string literal (or on a name referencing it). Then, the expressions to
    be evaluated would be passed to the `format()` function in order ❷.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧格式中，一个字符串文字 ❶ 将包含一组大括号，可能包含格式规范。`format()` 函数会被调用在这个字符串文字（或引用它的名称）上。然后，要计算的表达式将按顺序传递给
    `format()` 函数 ❷。
- en: 'That would have the following output:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE112]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Converting this to an f-string is as simple as moving the expressions into
    the string literal in order and then prepending an `f` to the literal to make
    it an f-string:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为 f-string 就像是将表达式按顺序放入字符串文字中，然后在字面量前加上一个 `f`，使其成为 f-string：
- en: '[PRE113]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 3-40: *format_to_fstring.py:2b*'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-40：*format_to_fstring.py:2b*
- en: The output is the same as before.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与之前相同。
- en: 'Optionally, with `format()`, you could refer to the index of the expression
    in the argument list:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，使用`format()`，你可以引用表达式在参数列表中的索引：
- en: '[PRE114]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 3-41: *format_to_fstring.py:3a*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-41：*format_to_fstring.py:3a*
- en: 'That produces this output:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE115]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'To convert this code to an f-string, you substitute the expressions in place
    of the indices in the string literal, which you (again) turn into an f-string
    by prepending an `f`:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这段代码转换为 f-string，你将表达式代替字符串文字中的索引，再通过在字面量前加 `f` 将其变成一个 f-string：
- en: '[PRE116]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 3-42: *format_to_fstring.py:3b*'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-42：*format_to_fstring.py:3b*
- en: Converting from `%` notation is a little less trivial, but most Python 3 code
    uses `format()` anyway. If you find yourself needing to do this, [https://pyformat.info](https://pyformat.info)
    does an excellent job of comparing `%` notation and `format()`.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `%` 语法转换过来稍微有点复杂，但大多数 Python 3 代码反正都会使用 `format()`。如果你需要进行这种转换，[https://pyformat.info](https://pyformat.info)
    对 `%` 语法和 `format()` 的比较做得非常好。
- en: Template Strings
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板字符串
- en: '*Template strings* constitute one more alternative to f-strings that is worth
    knowing about, especially as it still fulfills some use cases, including internationalizing
    user interfaces. Personally, I find template strings a bit more reusable. On the
    other hand, the drawback is that they’re considerably more limited in terms of
    formatting.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板字符串* 是 f-strings 的另一种替代方案，值得了解，特别是它仍然能满足一些使用场景，包括国际化用户界面。就个人而言，我觉得模板字符串更具可复用性。另一方面，缺点是它在格式化方面有显著的限制。'
- en: If you know how they work, you’ll be equipped to decide for yourself which tool
    is best for your particular situation.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道它们是如何工作的，你就能决定哪个工具最适合你的特定情况。
- en: 'Here’s a template string for greeting a user:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于问候用户的模板字符串：
- en: '[PRE117]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 3-43: *template_string.py:1*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-43：*template_string.py:1*
- en: To use template strings, I first have to import `Template` from the `string`
    module.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模板字符串，我首先需要从 `string` 模块导入 `Template`。
- en: 'Then I can create a new `Template` and pass it a string literal:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以创建一个新的 `Template` 并将一个字符串文字传递给它：
- en: '[PRE118]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Listing 3-44: *template_string.py:2*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-44：*template_string.py:2*
- en: I can name my fields whatever I want, preceding each with a dollar sign (`$`).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将字段命名为任何我想要的名字，在每个字段前加上一个美元符号（`$`）。
- en: 'Finally, I call the `substitute()` function on the template I created (`s`)
    and pass expressions to each of the fields:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我调用我创建的模板（`s`）上的 `substitute()` 函数，并将表达式传递给每个字段：
- en: '[PRE119]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Listing 3-45: *template_string.py:3*'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-45：*template_string.py:3*
- en: 'The finished string is returned, and in this case, it is passed to `print()`
    and displayed:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的字符串被返回，在这种情况下，它被传递给 `print()` 并显示出来：
- en: '[PRE120]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'There are a couple of odd syntax rules with template strings. First, to show
    a literal dollar sign in the string literal, use two dollar signs (`$$`). Second,
    to substitute an expression as part of a word, wrap the name of the field in curly
    braces (`{ }`). Both of these rules are demonstrated below:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串有一些奇怪的语法规则。首先，要在字符串文字中显示一个字面量美元符号，使用两个美元符号（`$$`）。其次，要将表达式作为单词的一部分进行替换，请将字段名用大括号（`{
    }`）括起来。以下展示了这两条规则：
- en: '[PRE121]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 3-46: *template_string.py:4*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-46：*template_string.py:4*
- en: 'That outputs the following:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE122]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There’s a handful of additional abilities contained within string templates,
    but I’ll entrust you to the official Python documentation for the rest of that.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板中包含了一些额外的功能，但其余部分我会交给你去参考官方的 Python 文档。
- en: String Conversion
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串转换
- en: 'I previously mentioned that there are three ways to get the string representation
    of a value: `str()`, `repr()`, and `ascii()`.'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，有三种方法可以获取一个值的字符串表示：`str()`、`repr()` 和 `ascii()`。
- en: The first function, `str()`, is the one you’ll use most often, as it returns
    the *human-readable* representation of the value.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `str()` 是你最常使用的函数，因为它返回值的 *人类可读* 表示。
- en: 'By contrast, `repr()` returns the *canonical string representation* of the
    value: that is, (usually) the value as Python sees it. In the case of many basic
    data types, this will return the same thing as `str()`, but when used on most
    objects, the output contains additional information useful in debugging.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`repr()` 返回值的 *标准字符串表示*：也就是说，(通常)是 Python 看到的值。对于许多基本数据类型，这将返回与 `str()`
    相同的内容，但在大多数对象上使用时，输出包含更多有助于调试的附加信息。
- en: The `ascii()` function is the same as `repr()`, except that the string literal
    it returns is completely ASCII-compatible, having escaped any non-ASCII (for example,
    Unicode) characters.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '`ascii()` 函数与 `repr()` 相同，只是它返回的字符串字面量完全兼容 ASCII，已经转义了任何非 ASCII 字符（例如 Unicode
    字符）。'
- en: I’ll return to this concept in Chapter 7, when I start defining my own objects.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第七章返回讨论这个概念，当时我将开始定义自己的对象。
- en: A Note on String Concatenation
  id: totrans-825
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接的注意事项
- en: Up to this point, I’ve been using the addition (`+`) operator for concatenating
    strings together. This is acceptable in basic situations.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在使用加法（`+`）操作符将字符串连接在一起。在基本情况下，这是可以接受的。
- en: However, this is seldom the most efficient solution, especially when combining
    multiple strings. Therefore, it is recommended to prefer the `join()` method,
    which is called on a string or string literal instead.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常不是最有效的解决方案，特别是在连接多个字符串时。因此，建议优先使用 `join()` 方法，它是在字符串或字符串字面量上调用的。
- en: 'Here’s a comparison between the two. I start with a couple of string variables:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两者的比较。我从几个字符串变量开始：
- en: '[PRE123]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 3-47: *concat_strings.py:1*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-47: *concat_strings.py:1*'
- en: 'So far, you’ve seen concatenation with the addition (`+`) operator, like this:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到过使用加法（`+`）操作符的连接方式，如下所示：
- en: '[PRE124]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Listing 3-48: *concat_strings.py:2a*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-48: *concat_strings.py:2a*'
- en: 'Alternatively, I can use the `join()` method:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以使用 `join()` 方法：
- en: '[PRE125]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 3-49: *concat_strings.py:2b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-49: *concat_strings.py:2b*'
- en: I call the `join()` method on the string that will appear between each piece.
    In this case, I use an empty string. The `join()` method accepts a *tuple* of
    strings—an array-like structure wrapped in parentheses, and therefore, the double
    set of parentheses in the code. I’ll introduce tuples in an upcoming section.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 我在每个字符串片段之间调用 `join()` 方法。在这个例子中，我使用的是空字符串。`join()` 方法接受一个 *元组* 类型的字符串——一个类似数组的结构，括在圆括号中，因此代码中的双括号。我将在后续部分介绍元组。
- en: Typical concatenation with `+` or the `join()` function has the same result,
    but the latter function will be *as fast or faster*, especially when you’re using
    other implementations of Python besides CPython. Therefore, whenever you need
    to concatenate and f-strings aren’t right for the job, you should consider using
    `join()` instead of the `+` or `+=` operators. In practice, f-strings are the
    fastest, but `join()` is your next-best option.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `+` 或 `join()` 函数进行的典型字符串连接具有相同的结果，但后者的函数将会 *更快或者同样快*，尤其是在你使用除了 CPython 之外的
    Python 实现时。因此，每当你需要进行字符串连接而 f-strings 不适合时，应该考虑使用 `join()`，而不是 `+` 或 `+=` 操作符。在实践中，f-strings
    是最快的，但 `join()` 是你的第二选择。
- en: Functions
  id: totrans-839
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Python functions are *first-class citizens*, which means they can be treated
    like any other object. Even so, you call them as you would in any other programming
    language.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数是 *一等公民*，这意味着它们可以像其他任何对象一样被处理。即便如此，调用它们的方式与在其他编程语言中的调用方式相同。
- en: Here’s an example of a very basic function, which prints a selected type of
    joke to the terminal.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基础的函数示例，它会将选定类型的笑话打印到终端。
- en: 'I start with the function header:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 我从函数头部开始：
- en: '[PRE126]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 3-50: *joke_function.py:1*'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-50: *joke_function.py:1*'
- en: I declared the function with the `def` keyword, followed by the name of the
    function. Parameters are named in the parentheses after the function name. The
    entire header is concluded with a colon (`:`).
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `def` 关键字声明函数，后面跟着函数的名称。参数在函数名后的括号内命名。整个函数头以冒号（`:`）结束。
- en: 'Below the header, indented one level, is the *suite* (or body) of the function:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题下方，缩进一级，是函数的 *代码块*（或主体）：
- en: '[PRE127]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Listing 3-51: *joke_function.py:2*'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-51: *joke_function.py:2*'
- en: 'You call functions in much the same way as in most languages:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用函数的方式与大多数语言中相同：
- en: '[PRE128]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Listing 3-52: *joke_function.py:3*'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-52: *joke_function.py:3*'
- en: I’ll go into depth on functions and their many cousins in Chapter 6.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第六章深入讨论函数及其许多相关概念。
- en: Classes and Objects
  id: totrans-853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: Python fully supports object-oriented programming. In fact, one of the language’s
    design principles is that “everything is an object,” at least behind the scenes.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持面向对象编程。事实上，这种语言的设计原则之一是“万物皆对象”，至少在幕后是如此。
- en: There’s a lot more to classes than meets the eye, but for now, you should just
    get an absolutely bare-bones familiarity with the syntax.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 类比眼前的印象，类远比它看起来的要复杂，但目前你只需要对语法有一个最基本的了解。
- en: 'The following class contains a joke of a selected type and displays it on demand:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类包含一个选定类型的笑话，并按需显示它：
- en: '[PRE129]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 3-53: *joke_class.py:1*'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-53: *joke_class.py:1*'
- en: I define the class using the `class` keyword, the name of the class, and a colon
    (`:`) at the end of the header.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `class` 关键字、类名和头部末尾的冒号（`:`）来定义类。
- en: 'This is followed by the suite of the class, indented one level:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是类的代码块，缩进一级：
- en: '[PRE130]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 3-54: *joke_class.py:2*'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-54: *joke_class.py:2*'
- en: The initializer, which is similar in purpose to the constructor in other OOP
    languages, is a member function, or *method*, with the name `__init__()` and at
    least one parameter, `self`.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器，类似于其他面向对象语言中的构造函数，是一个成员函数或 *方法*，其名称为 `__init__()`，并且至少有一个参数 `self`。
- en: '[PRE131]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 3-55: *joke_class.py:3*'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-55: *joke_class.py:3*'
- en: 'Functions that belong to the class are called methods and are part of the class
    suite. Methods must accept at least one parameter: `self`.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 属于类的函数称为方法，是类代码块的一部分。方法必须接受至少一个参数：`self`。
- en: 'You would use this class like so:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用这个类：
- en: '[PRE132]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 3-56: *joke_class.py:4*'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-56: *joke_class.py:4*'
- en: You create a new instance of the `Joke` class by passing the string `"lethal"`
    to its *initializer*, the `__init__()` from earlier. The new object is stored
    in the variable `lethal_joke`.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串 `"lethal"` 传递给其 *初始化器*，即前面提到的 `__init__()`，来创建 `Joke` 类的新实例。新对象会存储在变量
    `lethal_joke` 中。
- en: Then, you use the *dot operator* (`.`) to call the function `tell()` within
    the object. Take note that you didn’t have to pass any argument for `self`. That’s
    done automatically when you call the function in this manner.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 *点操作符*（`.`）在对象内调用函数 `tell()`。请注意，你无需为 `self` 传递任何参数。这在你以这种方式调用函数时会自动完成。
- en: I’ll discuss classes and objects in detail in Chapter 7 and further in Chapter
    13.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 7 章和第 13 章中详细讨论类和对象。
- en: Error Handling
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Python offers error and exception handling functionality through the `try` compound
    statement.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过 `try` 复合语句提供错误和异常处理功能。
- en: For example, if I wanted to get a number from the user, I couldn’t reliably
    predict what they would type in. Trying to convert a string, like `"spam"`, to
    an integer would cause an error. I can use error handling to take a different
    action if it isn’t possible to convert the user `input`.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想从用户那里获取一个数字，我无法可靠地预测他们会输入什么。如果尝试将字符串，例如 `"spam"`，转换为整数，就会导致错误。我可以使用错误处理，在无法转换用户的
    `input` 时采取不同的措施。
- en: '[PRE133]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 3-57: *try_except.py*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-57: *try_except.py*'
- en: I get a string from the user, and then in the `try` clause, I attempt to convert
    it to an integer with the `int()` function. That would raise a `ValueError` exception
    if the string it’s trying to convert is not a valid whole number (base 10).
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 我从用户那里获取一个字符串，然后在 `try` 子句中，我尝试用 `int()` 函数将其转换为整数。如果字符串无法转换为有效的整数（十进制），就会引发
    `ValueError` 异常。
- en: If that exception is raised, I catch it in the `except` clause and handle the
    failure.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引发了那个异常，我会在 `except` 子句中捕获它并处理失败。
- en: In any case, the last line would always be run.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，最后一行总是会被执行。
- en: There are additional features and subtleties to the `try` statement, including
    `finally` and `else` clauses, which I’ll cover in Chapter 8. For now, it’s better
    to avoid these concepts rather than use them incorrectly.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句还有更多的功能和细节，包括 `finally` 和 `else` 子句，我将在第 8 章中介绍。现在，最好避免使用这些概念，避免错误使用。'
- en: Tuples and Lists
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组和列表
- en: Two of Python’s most common built-in data structures, called *collections*,
    are tuples and lists.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中两个最常见的内置数据结构，称为 *集合*，是元组和列表。
- en: '*Lists* constitute the most array-like collection in Python. In CPython, they
    are implemented as variable-length arrays, not as linked lists like the name might
    suggest.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是 Python 中最类似数组的集合。在 CPython 中，它们实现为可变长度的数组，而不是像名称可能暗示的那样是链表。'
- en: 'For example, here is a list of strings with names of cheeses:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个包含奶酪名称的字符串列表：
- en: '[PRE134]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 3-58: *cheese_list.py:1*'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-58: *cheese_list.py:1*'
- en: You enclose a list literal in square brackets, separating each item in the list
    with commas.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 你将列表字面量用方括号括起来，每个项之间用逗号分隔。
- en: 'You can access or reassign the values of individual items with the same bracket
    notation used by most programming languages:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用大多数编程语言采用的相同括号符号访问或重新赋值单个项的值：
- en: '[PRE135]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 3-59: *cheese_list.py:2*'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-59: *cheese_list.py:2*'
- en: A *tuple* is somewhat similar to a list, but with a few key differences. First,
    a tuple cannot have items added, reassigned, or removed after its creation. Attempting
    to modify the contents of a tuple with bracket notation will result in a `TypeError`.
    This is because tuples, unlike lists, are *immutable*, effectively meaning their
    contents cannot be modified (see Chapter 5 for the full explanation).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 有点类似于列表，但有一些关键的区别。首先，元组在创建后不能添加、重新赋值或删除项。尝试使用方括号符号修改元组的内容会导致 `TypeError`
    错误。这是因为元组与列表不同，元组是 *不可变* 的，意味着它们的内容不能被修改（完整解释请参见第 5 章）。'
- en: 'Here is an example of a tuple:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个元组的示例：
- en: '[PRE136]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 3-60: *knight_tuple.py:1*'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-60: *knight_tuple.py:1*'
- en: 'You enclose tuple literals in parentheses (`( )`), instead of brackets (`[
    ]`). Nevertheless, you still use bracket notation to access individual items:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 你将元组字面量用圆括号（`( )`）括起来，而不是方括号（`[ ]`）。不过，你仍然可以使用方括号符号来访问单个项：
- en: '[PRE137]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 3-61: *knight_tuple.py:2*'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-61: *knight_tuple.py:2*'
- en: 'As I said, you cannot change the items of a tuple after creation, such as if
    you tried to reassign the first item:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，创建后你不能改变元组中的项，例如尝试重新赋值第一个项：
- en: '[PRE138]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 3-62: *knight_tuple.py:3*'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-62: *knight_tuple.py:3*'
- en: The guideline is to use tuples for collections of items of different types (*heterogeneous*
    collections) and to use lists for collections of items of the same type (*homogeneous*
    collections).
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 指导原则是将元组用于不同类型项的集合（*异质* 集合），而将列表用于相同类型项的集合（*同质* 集合）。
- en: I’ll discuss these collections, and many more, in Chapter 9.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 9 章讨论这些集合，以及更多内容。
- en: Loops
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Python has two basic loop types: *while* and *for*.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两种基本的循环类型：*while* 循环和 *for* 循环。
- en: while Loop
  id: totrans-906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: 'The `while` loop probably looks familiar from other languages:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环可能在其他语言中看起来很熟悉：'
- en: '[PRE139]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 3-63: *while_loop.py*'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-63: *while_loop.py*'
- en: I start the loop with the `while` keyword, follow it with the condition to test,
    and finish the header with a colon (`:`). As long as that condition evaluates
    to `True`, the code in the suite of the loop is executed.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 我以 `while` 关键字开始循环，后面跟着测试条件，并以冒号（`:`）结束循环头部。只要条件的结果为 `True`，循环体中的代码就会执行。
- en: When you need to keep running a loop until some condition is met, use `while`
    loops. These are particularly useful when you don’t know how many iterations of
    the loop will take place before the condition is met.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在满足某个条件之前不断运行循环时，使用 `while` 循环。这在你不知道循环会迭代多少次才能满足条件时特别有用。
- en: Loop Control
  id: totrans-912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环控制
- en: You can manually control the loop, using two keywords. The `continue` keyword
    abandons the current iteration and jumps to the next one. The `break` keyword
    exits the loop altogether.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两个关键字手动控制循环。`continue` 关键字放弃当前迭代并跳到下一次迭代。`break` 关键字则完全退出循环。
- en: 'One common scenario where you may use these keywords is in an infinite loop
    used for running a game or a user interface. For example, here’s a very simple
    command prompt:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在某些场景中使用这些关键字，典型的情况是在运行游戏或用户界面时使用的无限循环。例如，下面是一个非常简单的命令提示符：
- en: '[PRE140]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 3-64: *loop_control.py*'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-64: *loop_control.py*'
- en: The loop `while True` is inherently infinite; `True` is always `True`. That’s
    the behavior I actually want here, since I want to keep iterating until the user
    enters the string `"exit"`, at which point, I manually end the loop with `break`.
    (By the way, if you’ve been waiting for a `do-while` loop, this is effectively
    the way to recreate that behavior.)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True` 循环本质上是无限的；`True` 总是 `True`。这正是我在这里需要的行为，因为我希望不断迭代，直到用户输入字符串 `"exit"`，然后我手动用
    `break` 结束循环。（顺便提一下，如果你一直在等待 `do-while` 循环，这实际上就是重现该行为的方法。）'
- en: The command `"sing"` has a different behavior, after which I’d want to immediately
    go to the top and prompt the user for another command, skipping the last print
    statement. The `continue` keyword does exactly that, immediately abandoning the
    current iteration and jumping back to the top of the loop.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `"sing"` 的行为不同，之后我想立即返回到循环顶部，并提示用户输入另一个命令，同时跳过最后的打印语句。`continue` 关键字正好完成了这一点，立即放弃当前迭代并跳回到循环顶部。
- en: for Loop
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: Python’s `for` loop is a little different from loops in many languages. It’s
    generally used for iterating over a range, list, or other collection.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`for`循环与许多语言中的循环稍有不同。它通常用于迭代一个范围、列表或其他集合。
- en: '[PRE141]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 3-65: *for_loop.py*'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-65：*for_loop.py*
- en: I start the loop header with the `for` keyword. Technically, this kind of loop
    is a `for`-`in` (or “`for`-`each`”) loop, meaning the loop iterates once for each
    item in the given range, list, or other collection. This means the loop needs
    something to iterate over—in this case, a special object called `range()`—which
    iterates over a range of values, returning each one in turn. I’ve specified that
    I want the range to start with the value `1` and end before `11`. The local variable
    `i` will refer to the current item for each iteration. Finally, the `in` keyword
    precedes the thing I’m iterating over—that is, before `range()` in this example.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 我从`for`关键字开始循环头。严格来说，这种循环是一个`for`-`in`（或“`for`-`each`”）循环，这意味着循环会针对给定范围、列表或其他集合中的每个项执行一次。因此，循环需要有一个可以迭代的对象——在本例中是一个特殊的对象`range()`——它会迭代一系列值，并依次返回每个值。我指定了范围从`1`开始，到`11`之前结束。局部变量`i`将在每次迭代时引用当前项。最后，`in`关键字位于我正在迭代的对象之前——即，在本例中是`range()`之前。
- en: As long as there are items to iterate over, the code belonging to the loop will
    be executed—in this case, printing out the value of the current item. The loop
    stops when the last item is iterated over.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有项可以迭代，循环内的代码就会执行——在这个例子中，就是打印出当前项的值。当最后一项迭代完时，循环就会停止。
- en: Running this code would print the numbers 1 through 10.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会打印出数字1到10。
- en: This only scratches the surface of loops. See Chapter 9 for more.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是循环的冰山一角。更多内容请参见第9章。
- en: Structural Pattern Matching
  id: totrans-927
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化模式匹配
- en: For many years, developers coming to Python from languages like C, C++, Java,
    or Javascript would ask if there was a Python equivalent to the `switch`/`case`
    statement (or `match`/`case` in Scala, `case`/`when` in Ruby, and so on). They’d
    always be disappointed to hear a resounding “No!” Python only had conditional
    statements.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，从C、C++、Java或Javascript等语言转到Python的开发者经常询问是否有类似于`switch`/`case`语句的Python语法（在Scala中是`match`/`case`，在Ruby中是`case`/`when`，等等）。他们总是失望地听到一个响亮的“不！”。Python只有条件语句。
- en: At long last, Python 3.10 gained *structural pattern matching* via PEP 634\.
    This provides conditional logic that is at least syntactically similar to `switch`
    statements of other languages. In short, you test a single *subject*, such as
    a variable, against one or more *patterns*. If the subject matches the pattern,
    the associated suite of code runs.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Python 3.10通过PEP 634引入了*结构化模式匹配*。这提供了至少在语法上类似于其他语言中的`switch`语句的条件逻辑。简而言之，你将一个单一的*主题*（如一个变量）与一个或多个*模式*进行匹配。如果主题与模式匹配，则运行相关的代码块。
- en: Literal Patterns and Wildcards
  id: totrans-930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面模式和通配符
- en: 'In the most basic use case, you can check a variable against different possible
    values. These are called *literal patterns*. For example, perhaps I want to display
    different messages, depending on a user’s `input` `lunch` `order`:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的用例中，你可以检查一个变量与不同可能值的匹配。这些叫做*字面模式*。例如，也许我想根据用户的`input` `lunch` `order`显示不同的消息：
- en: '[PRE142]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 3-66: *pattern_match.py:1a*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-66：*pattern_match.py:1a*
- en: The value of `lunch_order` is compared to each case until it matches one. Once
    a match is found, the case’s suite is run, and the match statement is finished;
    the value won’t be checked against additional patterns once it matches one. So,
    if the user inputs `"pizza"`, the `"Pizza` `time!"` message is displayed. Similarly,
    if they input `"taco"`, the message `"Taco,` `taco,` `TACO,` `tacotacotaco!"`
    is displayed instead.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '`lunch_order`的值与每个案例进行比较，直到找到匹配的为止。一旦匹配成功，相关的代码块就会执行，匹配语句结束；匹配后，值将不再与其他模式进行检查。因此，如果用户输入`"pizza"`，就会显示消息`"Pizza`
    `time!"`。类似地，如果输入`"taco"`，则会显示消息`"Taco,` `taco,` `TACO,` `tacotacotaco!"`。'
- en: The underscore (`_`) in the last case is the *wildcard*, which will match any
    value. This serves as a fallback case, and it must come last, as it will match
    anything.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况下的下划线（`_`）是*通配符*，它可以匹配任何值。这作为一个备用案例，它必须放在最后，因为它会匹配任何内容。
- en: Or Patterns
  id: totrans-936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 或模式
- en: 'A single case can cover multiple possible values. One way to do this is with
    an *or pattern*, where possible literal values are separated by the bar character:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一的案例可以覆盖多个可能的值。一种实现方式是使用*或模式*，将可能的字面值用竖线符号分隔开：
- en: '[PRE143]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 3-67: *pattern_match.py:1b*'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-67：*pattern_match.py:1b*
- en: This pattern will match if the user enters either `"salad"` or `"soup"` at the
    prompt.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在提示符中输入`"salad"`或`"soup"`，则此模式将匹配。
- en: Capture Patterns
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获模式
- en: 'One particularly helpful feature of structural pattern matching is the ability
    to capture part or all of the subject. For example, it isn’t very helpful in our
    example that the fallback case only says `"Yummy."`. Instead, I’d like to have
    a default message announcing the user’s selection. To do that, I write a *capture
    pattern* like this:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式匹配的一个特别有用的功能是能够捕获部分或全部主题。例如，在我们的示例中，如果回退情况只显示`"Yummy."`，这并不是很有帮助。相反，我希望有一个默认消息来宣布用户的选择。为此，我编写了一个*捕获模式*，如下所示：
- en: '[PRE144]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 3-68: *pattern_match.py:1c*'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-68: *pattern_match.py:1c*'
- en: This pattern acts like a wildcard, except the value of `lunch_order` is captured
    as `order`. Now, no matter what the user enters, if it doesn’t match any of the
    previous patterns, the value will be captured and displayed in the message here.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式像通配符一样工作，只不过`lunch_order`的值被捕获为`order`。现在，无论用户输入什么，如果它与之前的模式都不匹配，值将被捕获并在此处的消息中显示。
- en: 'Capture patterns don’t just have to capture the entire value. For example,
    I can write a pattern that matches a tuple or list (a *sequence*) and then captures
    only part of that sequence:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获模式不仅仅是捕获整个值。例如，我可以写一个匹配元组或列表（*序列*）的模式，然后只捕获该序列的一部分：
- en: '[PRE145]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 3-69: *pattern_match.py:1d*'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-69: *pattern_match.py:1d*'
- en: In this version, if the lunch order has a space, I split the string into two
    parts, which are stored in a list. Then, if the second item in the sequence has
    the value `"ice cream"`, the first part is captured as `flavor`. Thus, the code
    can account for Bojan if he decides to break down and have strawberry ice cream
    for lunch. (And I’m not stopping him!)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，如果午餐订单中有空格，我将字符串分割成两部分，并将其存储在一个列表中。然后，如果序列中的第二项值为`"ice cream"`，则第一部分被捕获为`flavor`。这样，代码就能考虑到如果Bojan决定放松一下，午餐吃草莓冰淇淋的情况。（而且我不会阻止他！）
- en: 'The capture pattern feature has one surprising downside: all *unqualified*
    names in patterns—that is, any bare variable names with no dots—will be used to
    capture. This means that if you want to use the value assigned to some variable,
    it must be *qualified*, meaning you must access it within some class or module
    with the dot operator:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获模式功能有一个令人惊讶的缺点：所有*不合格*的名称在模式中——即任何没有点号的裸变量名——都会被用来捕获。这意味着，如果你想使用某个变量赋值的值，它必须是*合格的*，即你必须通过点操作符在某个类或模块中访问它：
- en: '[PRE146]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 3-70: *pattern_match.py:1e*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-70: *pattern_match.py:1e*'
- en: Guard Statements
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 守卫语句
- en: One last trick I’ll demonstrate with pattern matching is the *guard statement*,
    an additional conditional statement that must be satisfied for a pattern to match.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示的最后一个模式匹配技巧是*守卫语句*，这是一个额外的条件语句，必须满足这个条件才能使模式匹配。
- en: For example, in the current version of my lunch order example, using the logic
    to split the order by spaces means the code doesn’t behave very nicely with other
    foods with spaces in them. Also, if I enter `"rocky road ice cream"`, it won’t
    match the current ice cream pattern.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我目前的午餐订单示例中，使用按空格分割订单的逻辑意味着代码在处理包含空格的其他食品时表现得不是很好。此外，如果我输入`"rocky road ice
    cream"`，它将不会匹配当前的冰淇淋模式。
- en: Instead of splitting my string by spaces, I can write a pattern with a guard
    statement that looks for the words *ice cream* in the lunch order.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以编写一个带有守卫语句的模式，而不是按空格分割我的字符串，守卫语句会查找午餐订单中的*ice cream*。
- en: '[PRE147]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 3-71: *pattern_match_object.py:1f*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-71: *pattern_match_object.py:1f*'
- en: The pattern here captures the value as `ice_cream`, but only if the guard statement
    `if 'ice cream' in ice_cream` is satisfied. In that case, I use `.replace()` to
    remove the words *ice cream* from the captured value, leaving me with only the
    name of the flavor. I also use `.strip()` to remove any leading or trailing whitespace
    from the new string. Finally, I print out my message.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式在满足守卫语句`if 'ice cream' in ice_cream`的情况下，将值捕获为`ice_cream`。在这种情况下，我使用`.replace()`去除捕获值中的*ice
    cream*，只留下口味的名称。我还使用`.strip()`去除新字符串的前后空白字符。最后，我打印出我的消息。
- en: More About Structural Pattern Matching
  id: totrans-960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于结构模式匹配的内容
- en: There are quite a few other tricks and techniques that work with structural
    pattern matching. They work with objects (see Chapter 7), with dictionaries via
    mapping patterns (see Chapter 9), and even by support nesting patterns within
    other patterns.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他技巧和技术可以与结构模式匹配一起使用。它们可以与对象一起使用（见第7章），通过映射模式与字典一起使用（见第9章），甚至支持在其他模式中嵌套模式。
- en: As with many Python techniques, pattern matching feels like “magic,” and there’s
    a strong temptation to use it everywhere possible. Resist this urge! Structural
    pattern matching is very useful for checking a single subject against multiple
    possible patterns, but as you can even see from the “ice cream” situation in the
    lunch order example, it quickly reaches its limits as the possible values of the
    subject get more elaborate. As a rule, if you’re unsure whether you need structural
    pattern matching in a particular situation, stick with conditional statements.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多 Python 技巧一样，模式匹配看起来像是“魔法”，而且有很强的诱惑让人想要到处使用它。要抵制这种冲动！结构化模式匹配对于将一个对象与多个可能的模式进行匹配非常有用，但正如你从午餐订单中的“冰淇淋”例子中看到的那样，随着对象的可能值变得越来越复杂，它很快就会遇到局限性。作为一个原则，如果你不确定某个情况下是否需要使用结构化模式匹配，还是坚持使用条件语句。
- en: 'To learn even more, read PEP 636, which serves as the official tutorial for
    this topic and demonstrates all of the functionality available with this language
    feature: [https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/).'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多内容，请阅读 PEP 636，这是该主题的官方教程，展示了此语言特性提供的所有功能：[https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/)。
- en: Wrapping Up
  id: totrans-964
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You should now have a feeling for Python’s syntax and a basic familiarity with
    its key structures. If you were to stop here, you could probably write Python
    code that at least works. In fact, many developers new to the language do indeed
    work with about this much information, implicitly bringing the habits and practices
    of whatever language they know best.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经对 Python 的语法有所了解，并且对其关键结构有了基本的熟悉。如果你现在停止学习，可能仍然能写出至少能运行的 Python 代码。事实上，许多刚接触这门语言的开发者在掌握这些基础后，往往会凭借他们熟悉的其他编程语言的习惯和实践来写代码。
- en: There is a profound difference between valid code and idiomatic, Pythonic code.
    Writing the latter is the focus of this book.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 有效代码与地道的 Python 代码之间存在着深刻的区别。写出后者是本书的重点。
- en: '4'
  id: totrans-967
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Project Structure and Imports
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构与导入
- en: '![](Images/chapterart.png)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: I’ve found that structuring a Python project is one of the most often overlooked
    components of teaching the language. Many developers therefore get their project
    structure wrong, stumbling through a jumble of common mistakes until they arrive
    at something that at least works.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，Python 项目的结构化往往是教学中最被忽视的一个环节。因此，许多开发者在项目结构上出错，常常因为常见的错误而绊倒，直到他们找到至少能运行的结构。
- en: 'Here’s the good news: you don’t have to be one of them!'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 这是好消息：你不必成为他们中的一员！
- en: In this chapter, I’ll introduce import statements, modules, and packages, and
    I’ll show you how to fit everything together without tearing your hair out.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍导入语句、模块和包，并向你展示如何将一切组合在一起而不至于让你抓狂。
- en: 'Be aware, I’m skipping over one critical piece of project structure in this
    chapter: *setup.cfg*, as it relies on concepts we haven’t yet covered. Without
    a *setup.cfg* or *setup.py* file, your project will not be ready to ship to end
    users. In this chapter, you’ll put everything in the right place for development.
    From there, preparing your project for distribution will be a fairly simple process.
    I’ll cover *setup.cfg*, *setup.py*, and other project structure issues relating
    to distribution in Chapter 18.'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章中我跳过了一个关键的项目结构部分：*setup.cfg*，因为它依赖于我们尚未涉及的概念。没有 *setup.cfg* 或 *setup.py*
    文件，你的项目将无法准备好交付给最终用户。在本章中，你将把所有内容放到正确的位置以进行开发。从那时起，准备项目进行分发将是一个相对简单的过程。我将在第 18
    章中介绍 *setup.cfg*、*setup.py* 以及与分发相关的其他项目结构问题。
- en: Setting Up the Repository
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置代码库
- en: Before delving into the actual project structure, I want to address how it will
    fit into your *version control system (VCS)*, which I recommend using. For the
    rest of this book, I’ll assume you’re using Git, as that’s the most common option.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论实际的项目结构之前，我想先说明它如何融入到你的 *版本控制系统（VCS）* 中，我建议你使用该系统。在本书的剩余部分，我将假设你正在使用 Git，因为它是最常见的选择。
- en: 'Once you’ve created your repository and cloned a local copy to your computer,
    you can begin to set up your project. At minimum, create the following files:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了代码库并将其克隆到本地计算机上，你就可以开始设置你的项目。至少，创建以下文件：
- en: '*README*, which is a description of your project and its goals'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*README*，这是对你的项目及其目标的描述'
- en: '*LICENSE*, which is your project’s license'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LICENSE*，这是你项目的许可证'
- en: '*.gitignore*, which is a special file that tells Git what files and directories
    to ignore'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.gitignore*，这是一个特殊文件，用于告诉 Git 哪些文件和目录应该被忽略'
- en: A directory, which has the name of your project
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目录，包含你的项目名称
- en: Your Python code belongs in a separate subdirectory and not in the root of the
    repository. This is very important, as your repository’s root directory will get
    mighty cluttered with build files, packaging scripts, documentation, virtual environments,
    and all manner of other things that aren’t actually part of the source code.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Python 代码应该放在一个单独的子目录中，而不是放在仓库的根目录下。这一点非常重要，因为你仓库的根目录会因为构建文件、打包脚本、文档、虚拟环境以及各种其他不是源代码的文件而变得非常混乱。
- en: 'As an example, in this chapter, I’ll use one of my own Python projects: *omission*.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，在本章中，我会使用我自己的一个 Python 项目：*omission*。
- en: A Python project is composed of modules and packages. In the next section, I’ll
    cover what those are and how to create them.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python 项目由模块和包组成。在下一节中，我将介绍它们是什么以及如何创建它们。
- en: Modules and Packages
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和包
- en: A *module* is any Python (*.py*) file. (Anticlimactic, isn’t it?)
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是任何 Python (*.py*) 文件。（有点反高潮，不是吗？）'
- en: A *package*, occasionally called a *regular package*, is one or more modules
    within a directory. That directory must include a file called *__init__.py* (which
    can be empty). The *__init__.py* file is important! If it isn’t there, Python
    will not know the directory constitutes a package.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '*包*，有时也叫做 *常规包*，是一个或多个模块组成的目录。该目录必须包含一个名为 *__init__.py* 的文件（该文件可以是空的）。 *__init__.py*
    文件非常重要！如果没有它，Python 将无法识别该目录是一个包。'
- en: You can leave the *__init__.py* file empty (it often is), or you can use it
    to run certain code when the package is first imported. For example, you might
    use `__init__.py` to select and rename certain functions, so the end user of the
    package doesn’t need to understand how the modules are laid out. (See the subsection
    “Controlling Package Imports” later in the chapter.)
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 *__init__.py* 文件留空（它通常是空的），或者在包第一次导入时使用它来运行某些代码。例如，你可以使用 `__init__.py`
    来选择和重命名某些函数，这样包的最终用户就不需要了解模块的布局方式。（参见本章后面的小节“控制包的导入”）
- en: If you do forget *__init__.py* in your package, it becomes an *implicit namespace
    package*, also just known as a *namespace package*. These behave differently from
    regular packages. ***The two are not interchangeable!*** A namespace package allows
    you to distribute a package in multiple pieces, called *portions*. There are some
    cool advanced things you can do with namespace packages, but you will seldom need
    them. As this is a doozy of a rabbit hole, if you need namespace packages, see
    the documentation at [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/).
    You can also read PEP 420, which officially defined the concept.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记在包中包含 *__init__.py* 文件，它就会变成一个 *隐式命名空间包*，也叫做 *命名空间包*。这些包的行为与常规包不同。***两者不可互换！***
    命名空间包允许你将一个包分发成多个部分，称为 *部分*。你可以用命名空间包做一些很酷的高级操作，但你很少需要它们。由于这是一个复杂的坑，如果你需要命名空间包，可以查看文档
    [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/)。你还可以阅读
    PEP 420，它正式定义了这个概念。
- en: In my project structure, *omission* is a package that contains other packages.
    Thus, *omission* is my *top-level package*, and all the packages underneath it
    are its *subpackages*. This convention will be important once you start importing
    stuff.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的项目结构中，*omission* 是一个包含其他包的包。因此，*omission* 是我的 *顶级包*，其下所有的包都是它的 *子包*。一旦你开始导入内容，这个约定将变得非常重要。
- en: PEP 8 and Naming
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEP 8 和命名
- en: 'Your packages and modules need clear names to identify them. Consulting with
    PEP 8 about the naming conventions reveals this:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包和模块需要清晰的名称来标识它们。参考 PEP 8 的命名约定可以发现：
- en: Modules should have short, all-lowercase names. Underscores can be used in the
    module name if it improves readability. Python packages should also have short,
    all-lowercase names, although the use of underscores is discouraged.
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块应该有简短的全小写名称。如果使用下划线可以提高可读性，可以在模块名中使用下划线。Python 包也应该有简短的全小写名称，尽管不鼓励使用下划线。
- en: Understand that modules are named by filenames and packages are named by their
    directory name. Thus, these conventions define how you name your directories and
    code files.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，模块是通过文件名命名的，而包是通过目录名命名的。因此，这些约定定义了如何命名你的目录和代码文件。
- en: To reiterate, filenames should be all lowercase, with underscores (`_`) if that
    improves readability. Similarly, directory names should be all lowercase, without
    underscores if at all possible. To put that another way . . .
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一遍，文件名应该全部小写，如果下划线（`_`）有助于提高可读性，则可以使用下划线。同样，目录名应该全部小写，尽量避免使用下划线。换句话说 . . .
- en: 'Do this: *omission/data/data_loader.py*'
  id: totrans-995
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这个： *omission/data/data_loader.py*
- en: 'NOT this: *omission/Data/DataLoader.py*'
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不是这样： *omission/Data/DataLoader.py*
- en: Project Directory Structure
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目目录结构
- en: 'With that covered, take a look at my project’s repository directory structure:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分介绍完后，来看看我项目的仓库目录结构：
- en: '[PRE148]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 4-1: Directory structure of *omission-git/*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：*omission-git/* 目录结构
- en: 'You’ll see that I have one top-level package called *omission*, with four subpackages:
    *common/*, *data/*, *game/*, and *tests/*. Each subpackage contains an *__init__.py*
    file, which is what designates them as packages. Every file that ends in *.py*
    is a module.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，我有一个名为 *omission* 的顶层包，里面有四个子包：*common/*、*data/*、*game/* 和 *tests/*。每个子包都包含一个
    *__init__.py* 文件，这个文件标志着它们是包。每个以 *.py* 结尾的文件都是一个模块。
- en: I also have the directory *resources/*, but that only contains game audio, images,
    and other sundry files (omitted here for brevity). The *resources/* directory
    is *not* a regular package, as it doesn’t contain an *__init__.py*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 我还有一个目录 *resources/*，但是它只包含游戏音频、图片和其他杂项文件（为了简洁，这里省略了）。*resources/* 目录 *不是* 一个常规的包，因为它不包含
    *__init__.py* 文件。
- en: 'I have another special file in my top-level package: *__main__.py*. This is
    the file that runs when I execute my top-level package directly, via this command:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 我的顶层包中还有一个特殊文件： *__main__.py*。这是当我直接执行顶层包时运行的文件，使用如下命令：
- en: '[PRE149]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: I’ll come back to *__main__.py* in a bit (see the subsection “Package Entry
    Points” later in the chapter), as well as explain that lonely little *omission.py*
    file outside the top-level package.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会回到 *__main__.py* 文件（请参见本章稍后的“包入口点”小节），同时解释位于顶层包之外的那个孤独的小 *omission.py* 文件。
- en: How import Works
  id: totrans-1006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入是如何工作的
- en: 'If you’ve written any meaningful Python code before, you’re almost certainly
    familiar with the `import` statement for importing modules. For example, to use
    it to import the module for regex, you’d enter this:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前写过任何有意义的 Python 代码，你几乎肯定熟悉用于导入模块的 `import` 语句。例如，要使用它导入正则表达式模块，你可以这样写：
- en: '[PRE150]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Once you’ve imported a module, you can access any variables, functions, or classes
    defined within it.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你导入了一个模块，你就可以访问其中定义的任何变量、函数或类。
- en: When you import the module, you are actually running it, which in turn executes
    any other `import` statements in the module. If there are any errors or performance
    costs in those secondarily (and onward) imported modules, they might seem to originate
    from your otherwise innocent import statement. It also means that Python has to
    be able to find all those modules.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入模块时，你实际上是在运行它，这会执行模块中的其他 `import` 语句。如果这些被间接（及后续）导入的模块中有错误或性能开销，它们可能看起来是由你那条原本无害的导入语句引起的。这也意味着
    Python 必须能够找到所有这些模块。
- en: 'For example, the module *re.py*, which is part of the Python standard library,
    has several import statements of its own, which are executed when you `import
    re`. The contents of those imported modules aren’t automatically available to
    the file you imported `re` from, but those module files have to exist for `import
    re` to succeed. If, for some unlikely reason, *enum.py* (another module that is
    part of the Python standard library) got deleted from your Python environment
    and you ran `import re`, it would fail with an error:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Python 标准库中的模块 *re.py* 自带几个导入语句，这些语句会在你执行 `import re` 时运行。这些被导入模块的内容并不会自动提供给你导入
    `re` 的文件，但这些模块文件必须存在，才能使 `import re` 成功。如果因为某种不太可能的原因，*enum.py*（另一个 Python 标准库中的模块）被从你的
    Python 环境中删除，然后你执行 `import re`，就会失败并抛出错误：
- en: '[PRE151]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This might seem like a confusing error message. I’ve seen people erroneously
    wonder why the outer module (in this example, `re`) couldn’t be found. Others
    have wondered why the inner module (`enum` here) is being imported at all, since
    they didn’t ask for it directly in their code.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个让人困惑的错误信息。我见过有人错误地怀疑为什么外部模块（在这个例子中是`re`）找不到。也有人疑惑为什么要导入内部模块（这里是`enum`），因为他们在代码中并没有直接请求它。
- en: The problem is that the `re` module was imported, and that in turn imported
    the `enum` module. However, because the `enum` module is missing, importing `re`
    fails with a `ModuleNotFoundError`.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`re`模块已被导入，而它又导入了`enum`模块。然而，由于`enum`模块缺失，导入`re`时会因为`ModuleNotFoundError`而失败。
- en: 'Take note that this scenario is fictional: `import enum` and `import re` will
    never fail under normal circumstances, because both modules are part of Python’s
    standard library. However, this little example demonstrates the common problem
    of `import` statements failing due to missing modules.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个场景是虚构的：`import enum`和`import re`在正常情况下永远不会失败，因为这两个模块都是 Python 标准库的一部分。然而，这个小示例演示了由于缺少模块，`import`语句失败的常见问题。
- en: Import Dos and Don’ts
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入的注意事项
- en: There are various ways of importing, but most of them should rarely, if ever,
    be used.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种导入方式，但其中大多数情况应该很少使用，甚至永远不使用。
- en: 'For the upcoming examples, I’ll be using a module called *smart_door.py*, which
    reads as follows:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的例子中，我将使用一个名为*smart_door.py*的模块，其内容如下：
- en: '[PRE152]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Listing 4-2: *smart_door.py*'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-2: *smart_door.py*'
- en: 'Let’s say I want to use this module in another Python file, which (in this
    example) is in the same directory. To run the functions defined in that module,
    I’d have to first import the module `smart_door`. The easiest way to do this is
    as follows:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想在另一个 Python 文件中使用这个模块，（在这个例子中）它位于相同的目录下。为了运行该模块中定义的函数，我必须首先导入模块`smart_door`。实现这一点的最简单方法如下：
- en: '[PRE153]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Listing 4-3: *use_smart_door.py:1a*'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-3: *use_smart_door.py:1a*'
- en: The *namespace* of `open()` and `close()` is `smart_door`. A *namespace* is
    an explicitly defined path to something, such as a function. The function `open()`
    has the namespace `smart_door`, which tells me that `open()` belongs to that particular
    module. Remember this from The Zen of Python?
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`和`close()`的*命名空间*是`smart_door`。*命名空间*是指向某个对象的显式路径，比如一个函数。`open()`函数的命名空间是`smart_door`，这告诉我`open()`属于该特定模块。你还记得《Python之禅》中的这一点吗？'
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间真是一个绝妙的主意——我们应该多用点！
- en: Python developers really like namespaces because they make it obvious where
    functions and whatnot are coming from. That comes in handy when you have multiple
    functions that have similar names or the same name, but that are defined in different
    modules. Without that bit of namespace, `smart_door`, you would not know that
    `open()` had anything to do with opening the smart door. Appropriately using namespaces
    can help you avoid massive errors in your code. However, as important as namespaces
    are, they can get out of hand very quickly if used improperly.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者非常喜欢命名空间，因为它们能够清晰地表明函数等是从哪里来的。当你有多个名称相似或相同的函数，但它们定义在不同的模块中时，这一点非常有用。如果没有`smart_door`这样的命名空间，你就无法知道`open()`与开启智能门有关。恰当使用命名空间可以帮助你避免代码中的重大错误。然而，命名空间尽管重要，如果使用不当，也很容易迅速变得难以管理。
- en: Be advised, in referring to *namespaces*, I’m not necessarily talking about
    *implicit namespace packages*, which I don’t cover in this book.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在提到*命名空间*时，我并不一定在谈论*隐式命名空间包*，我在本书中没有涉及这个内容。
- en: Here’s a look at some good and bad examples of namespaces in action.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些命名空间实际应用中的好例子和坏例子。
- en: Importing Functions from Modules
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模块导入函数
- en: In my previous `smart_door` function calls, I referenced the namespace on every
    function call. This is usually best when a function is called only a handful of
    times, but if you use a function often, it gets tedious to use a namespace for
    every single function call.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前的`smart_door`函数调用中，每次调用函数时我都会引用命名空间。通常，当函数调用次数较少时，这种做法是最好的，但如果频繁使用一个函数，每次都使用命名空间就会显得非常麻烦。
- en: 'Thankfully, Python provides a way around that. To be able to use the `open()`
    function without constantly having to precede it with its module name (`smart_door`),
    I need only know the *qualified name*—that is, the name of the function, class,
    or variable, preceded by its complete namespace within one of its modules or packages
    (if any). Within the *smart_door.py* module, the qualified name of the function
    I want is just `open`. Thus, I import that function like this, instead:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 提供了一个解决方案。为了能够使用`open()`函数，而无需每次都在前面加上模块名（`smart_door`），我只需知道*限定名*——即函数、类或变量的名称，并且在其模块或包内带有完整的命名空间（如果有的话）。在*smart_door.py*模块中，我需要的函数的限定名就是`open`。因此，我可以像这样导入该函数：
- en: '[PRE154]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 4-4: *use_smart_door.py:1b*'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-4: *use_smart_door.py:1b*'
- en: 'This introduces a new problem. Neither `close()` nor `smart_door.close()` will
    work in this example, because I didn’t import the function outright. The entire
    `smart_door` module was still run by the import command, but only the `open()`
    function was actually imported. To use `smart_door.close()`, I’d need to change
    the code to this:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个新问题。在这个例子中，`close()` 和 `smart_door.close()` 都不起作用，因为我并没有直接导入这个函数。整个 `smart_door`
    模块仍然通过导入命令被执行，但只有 `open()` 函数被实际导入。要使用 `smart_door.close()`，我需要将代码更改为这样：
- en: '[PRE155]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 4-5: *use_smart_door.py:1c*'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-5: *use_smart_door.py:1c*'
- en: This gives me access to both functions, no namespace required.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我可以访问这两个函数，不需要命名空间。
- en: The Problem of Shadowing
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遮蔽的问题
- en: 'You might have noticed another problem: `open()` is already a built-in Python
    function! Assume I also need to read a file called *data.txt*, which exists in
    my current directory. If I try this after importing `open()` from the `smart_door`
    function ([Listing 4-5](#listing4-5)), my program is going to behave very badly:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到另一个问题：`open()` 已经是一个内置的 Python 函数！假设我还需要读取一个名为 *data.txt* 的文件，它存在于当前目录中。如果我在导入
    `open()` 之后尝试这样做（参考[Listing 4-5](#listing4-5)），我的程序会出现很严重的问题：
- en: '[PRE156]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Listing 4-6: *use_smart_door.py:2*'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-6: *use_smart_door.py:2*'
- en: When I used `open()` earlier ([Listing 4-5](#listing4-5)), I wanted to use `smart_door.open()`.
    Now, in the same file, I’m trying to call Python’s built-in `open()` function
    to open a text file for reading. Unfortunately, because of the earlier import,
    the built-in `open()` function has been *shadowed* by `smart_door.open()`, meaning
    the presence of the latter is making it impossible for Python to even find the
    former. This code will fail!
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 当我之前使用 `open()` 时（参考[Listing 4-5](#listing4-5)），我原本是想使用 `smart_door.open()`。现在，在同一个文件中，我试图调用
    Python 内置的 `open()` 函数来打开一个文本文件进行读取。不幸的是，由于之前的导入，内置的 `open()` 函数已经被 `smart_door.open()`
    所*遮蔽*，这意味着后者的存在使得 Python 根本无法找到前者。这个代码会失败！
- en: '[PRE157]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: I got that error because I’m trying to use the built-in `open()` function, which
    accepts two arguments, but I unintentionally called `smart_door.open()`, which
    doesn’t accept any arguments.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以得到那个错误，是因为我试图使用内置的 `open()` 函数，它接受两个参数，但我不小心调用了 `smart_door.open()`，而后者不接受任何参数。
- en: Getting an actual error message is one of the better failure scenarios for this
    sort of mistake. Imagine if `smart_door.open()` did accept similar arguments to
    the built-in `open()`. Depending on my code, I might wind up with an error elsewhere
    (perhaps from trying to use a file I hadn’t opened), or worse, some form of incorrect
    but technically valid behavior. This sort of mistake is infamously difficult to
    debug, so it is wise to avoid.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实际的错误信息是这种错误的较好失败场景之一。试想，如果 `smart_door.open()` 确实接受与内置 `open()` 相似的参数。根据我的代码，我可能会在其他地方遇到错误（例如尝试使用未打开的文件），或者更糟糕的是，出现某种形式的错误但却在技术上是有效的行为。这类错误通常非常难以调试，所以最好避免。
- en: 'So how should I fix this? If I were the one who wrote *smart_door.py*, I should
    just go and change the function name. It’s universally considered bad practice
    to use function names that shadow built-in Python functions anyhow, unless the
    entire point *is* to shadow. However, assume that I’m not the author of that module
    and I need another solution. Thankfully, Python offers one in the `as` keyword,
    which allows me to create an alias for that function:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我应该如何修复这个问题呢？如果我是 *smart_door.py* 的作者，我应该直接去修改函数名。一般来说，使用会遮蔽 Python 内置函数的函数名是被视为不好的编程实践，除非其本身的目的是为了遮蔽。然而，假设我并不是该模块的作者，需要一个其他解决方案。幸运的是，Python
    提供了 `as` 关键字，让我能够为该函数创建一个别名：
- en: '[PRE158]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Listing 4-7: *use_smart_door.py:1d*'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-7: *use_smart_door.py:1d*'
- en: In the import, I use the `as` keyword to rename `smart_door.open()` to `door_open()`,
    but only in the context of this file. Then, I can refer to `door_open()` where
    I wanted `smart_door.open()`.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入时，我使用 `as` 关键字将 `smart_door.open()` 重命名为 `door_open()`，但仅在当前文件的上下文中有效。然后，我可以在需要
    `smart_door.open()` 的地方使用 `door_open()`。
- en: This leaves Python’s built-in `open()` function unshadowed, so the earlier code
    for working with the file ([Listing 4-6](#listing4-6)) can function properly.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 这让 Python 的内置 `open()` 函数不再被遮蔽，因此之前处理文件的代码（参考[Listing 4-6](#listing4-6)）能够正常工作。
- en: '[PRE159]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The Trouble with Nested Packages
  id: totrans-1052
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套包的问题
- en: 'As you’ve seen, packages can contain other packages. In my *omission* project,
    if I wanted to import the module *data_loader.py*, I could use this line (refer
    back to the *omission* project structure):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，包可以包含其他包。在我的 *omission* 项目中，如果我想导入模块 *data_loader.py*，我可以使用这一行（参考 *omission*
    项目的结构）：
- en: '[PRE160]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The Python interpreter looks for the *omission* package, the *data* package
    inside that, and the *data_loader* module inside that. The *data_loader* module
    (and only that module) is imported. This is a good structure, and all’s well.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器会查找*omission*包、其中的*data*包，以及其中的*data_loader*模块。仅仅是*data_loader*模块被导入。这是一个良好的结构，一切都很好。
- en: 'At a certain point, however, nesting packages can become a pain. A function
    call like `musicapp.player.data.library.song.play()` is just ugly, not to mention,
    difficult to read. As The Zen of Python muses:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某个时刻，嵌套包会变得很麻烦。像`musicapp.player.data.library.song.play()`这样的函数调用不仅丑陋，而且难以阅读。正如《Python禅》所说：
- en: Flat is better than nested.
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平结构比嵌套结构更好。
- en: Some nesting of packages is certainly okay, but when your project starts looking
    like an elaborate set of Matryoshka dolls, you’ve done something wrong. Organize
    your modules into packages, but keep the structure reasonably simple. Nesting
    two or three packages deep is okay; deeper is generally not advisable, if it can
    be avoided.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套一些包是可以的，但当你的项目开始看起来像一套精致的俄罗斯套娃时，你就做错了什么。组织你的模块为包，但保持结构尽量简单。嵌套两到三层包是可以的；更深的嵌套一般不建议，如果可以避免的话。
- en: 'Although we’d never have overly nested nightmares in an ideal world, real-life
    projects aren’t always that neat. Sometimes, it isn’t possible to avoid deep nesting
    structures. I need another way to keep my import statements sane. Graciously,
    the import system can handle this:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在理想的世界里我们永远不会有过度嵌套的噩梦，但现实中的项目往往不会那么整洁。有时，避免深度嵌套结构是不可能的。我需要另一种方式来保持我的导入语句清晰。幸运的是，导入系统能够处理这个问题：
- en: '[PRE161]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: I only have to deal with the deeply nested namespace once, in the actual import
    statement. After that, I just use the function name, `play()`.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要在实际的导入语句中处理一次深度嵌套的命名空间。之后，我只需要使用函数名`play()`。
- en: 'Alternatively, if I want a little bit of namespace, I can have that, too:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果我只想要一些命名空间，我也可以做到：
- en: '[PRE162]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: My import statement has resolved all but that last bit of namespace, `song`,
    so I still know where the `play()` function is coming from.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 我的导入语句解决了除了最后一个命名空间`song`之外的所有问题，所以我仍然知道`play()`函数来自哪里。
- en: The import system is deliciously flexible like that.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统在这方面非常灵活。
- en: Beware of Importing All
  id: totrans-1066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当心导入所有内容
- en: 'Before long, you’ll probably find yourself tempted to import all of the hundreds
    of functions in your module, to save time. This is the point at which many developers
    go off the rails:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，你可能会发现自己忍不住想导入模块中的所有数百个函数，以节省时间。这正是许多开发者走偏的地方：
- en: '[PRE163]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This statement imports nearly everything in the module directly, except for
    anything preceded by one or more underscores. This import-all pattern is a Very
    Bad Idea, as you won’t know what all is getting imported or what will be shadowed
    in the process.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句几乎直接导入了模块中的所有内容，除了以一个或多个下划线开头的内容。这个导入所有内容的模式是一个非常糟糕的主意，因为你无法知道所有导入了什么，或者在这个过程中会被覆盖什么。
- en: 'The problem gets even worse when you start importing all from multiple modules:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始从多个模块中导入所有内容时，问题变得更糟：
- en: '[PRE164]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Doing this, you may be blissfully unaware that `open()`, `smart_door.open()`,
    and `gzip.open()` all exist and are fighting over the same name in your file!
    The function `gzip.open()` will win out in this example, because it’s the last
    version of `open()` that was imported. The other two functions have been shadowed,
    which means you effectively can’t call them at all.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，你可能会愉快地忽视`open()`、`smart_door.open()`和`gzip.open()`都存在并在同一个文件中争夺相同的名称！在这个例子中，`gzip.open()`会获胜，因为它是最后一个被导入的`open()`版本。其他两个函数已经被隐藏，意味着你实际上无法调用它们。
- en: Since no one is likely to remember every single function, class, and variable
    in every module that gets imported, one can easily wind up with a whole lot of
    messes.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有人能记住每个模块中导入的每个函数、类和变量，结果很容易变成一团糟。
- en: 'The Zen of Python applies to this situation:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 《Python禅》适用于这种情况：
- en: Explicit is better than implicit.
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明确优于隐式。
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (. . .)
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （...）
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊性时，拒绝猜测的诱惑。
- en: You should never have to guess where a function or variable is coming from.
    There should be code somewhere in the file that explicitly tells you where everything
    comes from, as seen in the preceding examples.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该猜测一个函数或变量来自哪里。文件中的某个地方应该有明确的代码告诉你每个东西的来源，就像前面的示例一样。
- en: This `import *` doesn’t quite work the same way with packages. By default, a
    line like `from some_package import *` will be functionally the same as `import
    some_package`, unless the package has been configured to work with `import *`.
    I’ll come back to this later.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`import *`在包中并不像其他地方那样工作。默认情况下，像`from some_package import *`这样的语句在功能上与`import
    some_package`相同，除非包已经配置为支持`import *`。稍后我会再讲到这一点。
- en: Importing Within Your Project
  id: totrans-1082
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在项目中导入
- en: Now that you know how to structure your project and import from packages and
    modules, I’ll tie everything together.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何构建项目并从包和模块中导入，我将把所有内容结合起来。
- en: 'Recall my *omission* project structure from [Listing 4-1](#listing4-1). Here’s
    a subsection of that project directory:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我的*omission*项目结构，见[列表 4-1](#listing4-1)。这是该项目目录的一个子部分：
- en: '[PRE165]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Listing 4-8: Directory structure of *omission-git/*'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-8：*omission-git/* 的目录结构
- en: Any one module in my project may need to be able to import from another module,
    whether it’s within the same package or somewhere else in the project structure.
    I’ll explain how to handle both scenarios.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我项目中的任何一个模块都可能需要从另一个模块导入，无论它是否在同一个包中，或在项目结构中的其他地方。我将解释如何处理这两种情况。
- en: Absolute Imports
  id: totrans-1088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对导入
- en: I have a class `GameMode` defined within the *game_enums.py* module, which lives
    in the *omission/common* package. I want to use that class within my *game_round_settings.py*
    module, defined in the *omission/data* package. How do I get to it?
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*game_enums.py*模块中定义了一个`GameMode`类，这个模块位于*omission/common*包中。我想在我的*game_round_settings.py*模块中使用这个类，这个模块位于*omission/data*包中。我要怎么做才能访问它？
- en: 'Because I defined *omission* as a top-level package and organized my modules
    into subpackages, it’s pretty straightforward. In *game_round_settings.py*, I’d
    write the following:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我把*omission*定义为顶层包，并将模块组织成子包，所以这非常直接。在*game_round_settings.py*中，我会写如下语句：
- en: '[PRE166]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Listing 4-9: *game_round_settings.py:1a*'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-9：*game_round_settings.py:1a*
- en: This line is an *absolute import*. It starts at the top-level package, *omission*,
    and walks down into the *common* package, where it looks for *game_enums.py*.
    Inside that module, it finds whatever has the name `GameMode` and imports that.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 这行是*绝对导入*。它从顶层包*omission*开始，然后进入*common*包，在那里查找*game_enums.py*。在这个模块内部，它会找到名为`GameMode`的内容并导入它。
- en: Relative Imports
  id: totrans-1094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'You can also import from a module in the same package or subpackage. This is
    known as a *relative import* or an *intrapackage reference*. In practice, intra-package
    references are easy to do wrong. If some developer wanted to import `GameMode`
    (which is provided by *omission/common/game_enums.py*) into *omission/data/game_round_settings.py*,
    they might incorrectly attempt to use something like the following:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从同一个包或子包中的模块导入。这被称为*相对导入*或*包内引用*。实际上，包内引用很容易出错。如果某个开发者想从*omission/common/game_enums.py*导入`GameMode`类到*omission/data/game_round_settings.py*中，他们可能会错误地尝试使用如下语句：
- en: '[PRE167]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Listing 4-10: *game_round_settings.py:1b*'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-10：*game_round_settings.py:1b*
- en: This fails, leaving the developer wondering why it doesn’t work. The *data*
    package (where *game_round_settings.py* lives) has no knowledge of its sibling
    packages, such as *common*.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会失败，导致开发者疑惑为什么它不工作。*data*包（*game_round_settings.py*所在的包）并不知晓它的兄弟包，比如*common*。
- en: A module knows what package it belongs to, and a package knows its parent package
    (if it has one). Because of this, relative imports can start the search from the
    current package and move up and down through the project structure.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块知道它属于哪个包，一个包也知道它的父包（如果有的话）。因此，相对导入可以从当前包开始，向上或向下遍历项目结构。
- en: 'Within *omission/data/game_round_settings.py*, I can use the following import
    statement:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*omission/data/game_round_settings.py*中，我可以使用以下导入语句：
- en: '[PRE168]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Listing 4-11: *game_round_settings.py:1c*'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-11：*game_round_settings.py:1c*
- en: The two dots (`..`) mean “the current package’s direct parent package,” which,
    in this case, is *omission*. The import steps up one level, walks down into *common*,
    and finds *game_enums.py*.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点（`..`）表示“当前包的直接父包”，在这个例子中是*omission*。导入操作上升一级，然后进入*common*包，找到*game_enums.py*。
- en: There’s some difference of opinion among Python developers about whether to
    use absolute or relative imports. Personally, I prefer to use absolute imports
    whenever possible, because I feel it makes the code a lot more readable. You can
    make up your own mind. The only important factor is that the result should be
    *obvious*—there should be no mystery about where anything comes from.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 开发者中，关于使用绝对导入还是相对导入有一些不同的意见。就个人而言，我倾向于尽可能使用绝对导入，因为我觉得它让代码更加易读。你可以自己做决定。唯一重要的因素是结果应该是*显而易见*的——不应有任何疑问，无法确定任何东西的来源。
- en: Importing from the Same Package
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从同一包导入
- en: 'There is one other lurking gotcha here. In *omission/data/settings.py*, I have
    this statement for importing a class from the module *omission/data/game_round_settings.py*:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个潜在的陷阱。在 *omission/data/settings.py* 中，我有这样的语句来从模块 *omission/data/game_round_settings.py*
    导入一个类：
- en: '[PRE169]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Listing 4-12: *settings.py:1a*'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-12: *settings.py:1a*'
- en: 'You might think that since both *settings.py* and *game_round_settings.py*
    are in the same package, *data*, I should be able to just use this:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，由于 *settings.py* 和 *game_round_settings.py* 都在同一个包 *data* 中，我应该能够直接使用这个：
- en: '[PRE170]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Listing 4-13: *settings.py:1b*'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-13: *settings.py:1b*'
- en: However, that will not work. It will fail to locate the *game_round_settings.py*
    module because I am running the top-level package (`python3 -m omission`), and
    absolute imports for anything within the package being executed (*omission*) have
    to start from the top.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做行不通。它将无法定位到 *game_round_settings.py* 模块，因为我正在运行顶层包（`python3 -m omission`），而在执行的包（*omission*）内，绝对导入必须从顶层开始。
- en: 'I can instead use a relative import, which looks much simpler than the absolute
    import:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以改用相对导入，这看起来比绝对导入简单得多：
- en: '[PRE171]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Listing 4-14: *settings.py:1c*'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-14: *settings.py:1c*'
- en: In this case, the single dot (`.`) means “this package.”
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，单个点（`.`）表示“这个包”。
- en: 'This probably feels familiar if you’re used to the typical UNIX filesystem,
    although Python takes the concept a bit further:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了典型的 UNIX 文件系统，这可能会让你感到熟悉，尽管 Python 将这个概念做得更进一步：
- en: One dot (`.`) means the current package.
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个点（`.`）表示当前包。
- en: Two dots (`..`) takes you back one level, to the parent package.
  id: totrans-1119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个点（`..`）将带你返回一层，到父包。
- en: Three dots (`...`) takes you back two levels, to the parent of the parent package.
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个点（`...`）将带你返回两层，到父包的父包。
- en: Four dots (`....`) takes you back three levels.
  id: totrans-1121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个点（`....`）将带你返回三层。
- en: And so on, and so forth.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。
- en: Keep in mind that those “levels” aren’t just plain directories; they’re packages.
    If you have two distinct packages in a plain directory that isn’t a package, you
    can’t use relative imports to jump from one to another. You’ll have to work with
    the Python search path for that. I’ll talk more about that later in this chapter.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些“层级”不仅仅是普通的目录；它们是包。如果你在一个不是包的普通目录下有两个不同的包，你不能使用相对导入从一个包跳到另一个包。你必须使用 Python
    的搜索路径来处理这个问题。我将在本章稍后部分详细讲解。
- en: Entry Points
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点
- en: So far, you’ve learned how to create modules, packages, and projects, and how
    to make full use of the import system. The last piece of this puzzle is gaining
    the ability to control what happens when a package is imported or executed. The
    parts of the project that are run first when importing or executing are called
    *entry points*.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何创建模块、包和项目，并如何充分利用导入系统。这个难题的最后一块拼图是获得控制包被导入或执行时发生什么的能力。当导入或执行时，首先运行的项目部分被称为*入口点*。
- en: Module Entry Points
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块入口点
- en: 'When you import a Python module or package, it is given a special variable
    called `__name__`. This contains the *fully qualified name* of the module or package,
    which is the name as the import system sees it. For example, the fully qualified
    name of the module *omission/common/game_enums.py* would be `omission.common.game_enums`.
    There is one exception: when a module or package is run directly, its `__name__`
    is set to the value `"__main__"`.'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个 Python 模块或包时，它会被赋予一个特殊的变量，叫做 `__name__`。这个变量包含了模块或包的*完全限定名*，即导入系统看到的名称。例如，模块
    *omission/common/game_enums.py* 的完全限定名是 `omission.common.game_enums`。有一个例外：当一个模块或包被直接运行时，其
    `__name__` 会被设置为 `"__main__"`。
- en: 'To demonstrate this, assume I have a package called *testpkg*, which contains
    the module *awesome.py*. It defines a function, `greet()`:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，假设我有一个叫做 *testpkg* 的包，里面有一个模块 *awesome.py*。它定义了一个函数 `greet()`：
- en: '[PRE172]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Listing 4-15: *awesome.py:1*'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-15: *awesome.py:1*'
- en: 'The bottom of that same file also contains a `print` message:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 同一文件的底部还包含一个 `print` 消息：
- en: '[PRE173]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Listing 4-16: *awesome.py:2a*'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-16: *awesome.py:2a*'
- en: 'In another module in the same directory as *testpkg*, I have this module (*example.py*),
    which I run directly with `python3 example.py`:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 *testpkg* 同一目录中的另一个模块（*example.py*）里，我通过 `python3 example.py` 直接运行了这个模块：
- en: '[PRE174]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Listing 4-17: *example.py*'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-17: *example.py*'
- en: If I look at the `_name_` local variable—which is the `__name__` presently assigned
    to the current module, *example.py*—I’ll see the value is `"__main__"` because
    I executed *example.py* directly.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我查看 `_name_` 本地变量——即当前模块 *example.py* 中被赋值的 `__name__`——我会发现它的值是 `"__main__"`，因为我直接执行了
    *example.py*。
- en: The package `awesome` I imported also has a `__name__` variable, which has the
    value `"testpkg.awesome"`, representing where the package came from in the import
    system.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 我导入的包 `awesome` 也有一个 `__name__` 变量，其值为 `"testpkg.awesome"`，表示包在导入系统中的来源。
- en: 'If you ran that module, you’d get the following output:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行该模块，你将看到以下输出：
- en: '[PRE175]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: That first line is coming from *testpkg/awesome.py*, which is run by the import
    command. The rest is coming from the two print commands in *example.py*.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 那一行来自 *testpkg/awesome.py*，它是通过导入命令执行的。其余部分来自 *example.py* 中的两个打印命令。
- en: 'But what if I want that first message to appear only if *awesome.py* is executed
    directly, and *not* when the module is only imported? To accomplish that, I’d
    check the value of `__name__` variable in a conditional statement. I’ve rewritten
    my *awesome.py* file to do exactly that:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我希望第一个消息仅在直接执行 *awesome.py* 时显示，而在模块仅被导入时不显示该消息，该怎么做呢？为了实现这一点，我会在条件语句中检查
    `__name__` 变量的值。我已经重写了我的 *awesome.py* 文件，正是为了实现这一点：
- en: '[PRE176]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Listing 4-18: *awesome.py:2b*'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-18: *awesome.py:2b*'
- en: If *awesome.py* is executed directly, `__name__` will have the value `"__main__"`,
    so the print statement will run. Otherwise, if *awesome.py* is being imported
    (or otherwise run indirectly), the conditional will fail.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直接执行 *awesome.py*，`__name__` 将会是 `"__main__"`，因此打印语句会执行。否则，如果 *awesome.py*
    是被导入（或者间接执行），条件语句会失败。
- en: While you’ll frequently see this pattern in Python, some Python experts consider
    it an anti-pattern, because it can encourage you to both execute and import a
    module at the same time. While I don’t agree that using `if__name__ == "__main__"`
    is an anti-pattern, you often don’t need it. In any case, be certain you never
    import your main module from anywhere else in your package.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在 Python 中经常会看到这种模式，一些 Python 专家认为它是一种反模式，因为它可能促使你同时执行和导入一个模块。虽然我不认为使用 `if__name__
    == "__main__"` 是一种反模式，但你通常不需要它。不管怎样，确保你从包的其他地方永远不要导入你的主模块。
- en: Package Entry Points
  id: totrans-1147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包入口点
- en: Notice that my *omission* project has a file called `__main__` in the top-level
    package. This file is automatically run when a package is executed directly, but
    never when importing the package.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我的 *omission* 项目在顶级包中有一个名为 `__main__` 的文件。这个文件在包被直接执行时会自动运行，但在导入包时不会运行。
- en: So, when executing *omission* via `python3 -m omission`, Python first runs the
    *__init__.py* module (as always), followed by its *__main__.py* module. Otherwise,
    if the package is imported instead, only *__init__.py* is executed.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当通过 `python3 -m omission` 执行 *omission* 时，Python 会首先运行 *__init__.py* 模块（像往常一样），然后运行其
    *__main__.py* 模块。否则，如果包是被导入，只有 *__init__.py* 会被执行。
- en: If you omit *__main__.py* from a package, it cannot be executed directly.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从包中省略了 *__main__.py*，该包就不能被直接执行。
- en: 'A good *__main__.py* for a top-level package would look something like the
    following:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个适合顶级包的 *__main__.py* 文件可能如下所示：
- en: '[PRE177]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Listing 4-19: *__main__.py*'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-19: *__main__.py*'
- en: All the logic for starting the package belongs in the `main()` function. Then,
    the `if` statement checks the `__name__` assigned to the *__main__.py* module.
    Since this package is being executed directly, the value of `__name__` is `"__main__"`,
    and the code within the `if` statement, being the call to the `main()` function,
    is run. Otherwise, if *__main__.py* were only being imported, its fully qualified
    name would include its containing package (for example, `omission.__main__`),
    the condition would fail, and the code wouldn’t run.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有启动包的逻辑都应该放在 `main()` 函数中。然后，`if` 语句会检查赋值给 *__main__.py* 模块的 `__name__`。由于该包是直接执行的，因此
    `__name__` 的值是 `"__main__"`，`if` 语句中的代码（即调用 `main()` 函数）会被执行。否则，如果 *__main__.py*
    仅仅是被导入，它的完全限定名将包含它所在的包（例如，`omission.__main__`），条件就会失败，代码不会执行。
- en: Controlling Package Imports
  id: totrans-1155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制包的导入
- en: A package’s *__init__.py* file can come in handy when you want to change what
    is available for import and how it can be used. The most common uses for this
    file are to simplify imports and to control the behavior of import-all (`import
    *`).
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 包的 *__init__.py* 文件在你想更改导入内容和使用方式时非常有用。这个文件最常见的用途是简化导入并控制导入所有内容（`import *`）的行为。
- en: Simplifying Imports
  id: totrans-1157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简化导入
- en: 'Imagine I have a particularly complicated package, `rockets`, which is made
    up of dozens of subpackages and hundreds of modules. I can safely assume that
    many developers using the package won’t want to know about most of that functionality.
    They only want one thing: to define a rocket and then launch it! Instead of expecting
    all the users of my package to know where those few basic bits of functionality
    exist in the package structure, I can use *__init__.py* to expose said functionality
    directly, making the bits easier to import later:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个特别复杂的包 `rockets`，它由数十个子包和数百个模块组成。我可以安全地假设，许多使用这个包的开发者并不想了解大多数功能。他们只想做一件事：定义一个火箭然后发射它！与其期望包的所有用户都知道那些基本功能在包结构中的位置，不如使用
    *__init__.py* 直接暴露这些功能，让它们以后更容易导入：
- en: '[PRE178]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Listing 4-20: *__init__.py:1*'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-20： *__init__.py:1*
- en: 'This greatly simplifies the usage of the package. I no longer need to remember
    where things like the `SmallRocket` and `Launchpad` classes live in the `rockets`
    package structure. I can import them directly from the top-level package and use
    them:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 这大大简化了包的使用。我不再需要记住 `rockets` 包结构中像 `SmallRocket` 和 `Launchpad` 类的具体位置。我可以直接从顶层包导入并使用它们：
- en: '[PRE179]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Listing 4-21: *rocket_usage.py*'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-21： *rocket_usage.py*
- en: Beautifully simple, isn’t it? Still, nothing is actually *preventing* me from
    importing things the long-form way (such as `from rockets.smallrocket.rocket import
    SmallRocket`) if I need to. The shortcut is there, but it’s optional.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮的简洁，不是吗？然而，实际上并没有什么*阻止*我以长格式方式导入东西（例如`from rockets.smallrocket.rocket import
    SmallRocket`），如果我需要的话。快捷方式在这里，但它是可选的。
- en: Because simplicity is such an essential part of the Python philosophy, it is
    also an essential component of package design. If you can anticipate the most
    common ways a user might interact with your package, you can greatly simplify
    their code by adding a few lines to *__init__.py*.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为简洁性是 Python 哲学中至关重要的一部分，它也是包设计中一个重要的组成部分。如果你能预见到用户与你的包最常见的交互方式，你就可以通过在 *__init__.py*
    中添加几行代码，极大简化他们的代码。
- en: Controlling Import-All
  id: totrans-1166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制导入所有内容
- en: By default, import-all doesn’t work with a package. You use *__init__.py* to
    enable and control the behavior of `import *`, even though such an import statement
    is generally discouraged. This can be done by assigning a list of strings to `__all__`,
    with each string containing something (such as a package or module) to import
    from the current package.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，导入所有内容在包中并不适用。你可以使用 *__init__.py* 来启用并控制 `import *` 的行为，即便这种导入语句通常是不推荐的。这可以通过将一个包含字符串列表分配给
    `__all__` 来完成，每个字符串包含要从当前包导入的内容（例如包或模块）。
- en: 'This works well with the previous trick ([Listing 4-20](#listing4-20)):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面的小技巧（[列表 4-20](#listing4-20)）搭配使用效果很好：
- en: '[PRE180]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Listing 4-22: *__init__.py:2a*'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-22： *__init__.py:2a*
- en: 'When Python encounters a line like `from rockets import *`, that list from
    `__all__` (seen as `rockets.__all__`) is unpacked in place of the asterisk (`*`).
    This is important in figuring out what you can include in `__all__`: each item
    in my list should make sense when substituted for the asterisk in `from rockets
    import *`.'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 遇到类似 `from rockets import *` 这样的语句时，来自 `__all__` 的列表（即 `rockets.__all__`）会被解包并替换掉星号（`*`）。这对于弄清楚你可以在
    `__all__` 中包含什么非常重要：我的列表中的每一项在替代星号时都应该是有意义的，像在 `from rockets import *` 中那样。
- en: 'In other words, I could change the last line of my *__init__.py* to this, and
    there would be no error in the code:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我可以将我的 *__init__.py* 的最后一行改成这样，代码中就不会出现错误：
- en: '[PRE181]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Listing 4-23: *__init__.py:2b*'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-23： *__init__.py:2b*
- en: This works because, as you already know, the line `from rockets import smallrocket`
    is a valid import statement.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为你已经知道，`from rockets import smallrocket` 这一行是有效的导入语句。
- en: 'On the other hand, this example would *not* work:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个例子*不会*起作用：
- en: '[PRE182]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Listing 4-24: *__init__.py:2c*'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-24： *__init__.py:2c*
- en: It fails because `from rockets import smallrocket.rocket` does not make sense.
    You’ll have to consider this principle when defining `__all__`.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了，因为 `from rockets import smallrocket.rocket` 没有意义。你需要在定义 `__all__` 时考虑这个原则。
- en: If `__all__` is not defined in *__init__.py*, then `from rockets import *` will
    behave the same as `import rockets`.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`__all__`没有在*__init__.py*中定义，那么`from rockets import *`的行为将与`import rockets`相同。
- en: Program Entry Points
  id: totrans-1181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序入口点
- en: If you’ve applied all the concepts in this chapter to your project’s structure,
    you can run `python3 -m yourproject` to start your program.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将本章的所有概念应用到项目结构中，你可以运行`python3 -m yourproject`来启动你的程序。
- en: However, you (or your eventual end user) may want to run the program merely
    by double-clicking or directly executing some single Python file. With everything
    else in place, this is trivial to implement.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你（或最终的终端用户）可能希望通过双击或直接执行某个单独的Python文件来运行程序。其他设置完成后，实现这一点非常简单。
- en: 'To make my *omission* project easy to run, I created a single script file *outside
    the top-level package*, named *omission.py*:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我的*omission*项目更容易运行，我创建了一个单独的脚本文件，位于*顶级包外*，命名为*omission.py*：
- en: '[PRE183]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Listing 4-25: *omission.py*'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-25: *omission.py*'
- en: I import the `main()` function from *omission/__main__.py* and then execute
    that function. This is effectively the same as executing that package directly
    with `python3 -m omission`.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 我从*omission/__main__.py*导入`main()`函数，然后执行该函数。这实际上与直接使用`python3 -m omission`执行该包是一样的。
- en: There are better ways to create a program entry point, but I’ll cover those
    in Chapter 18, once I’ve created the all-important *setup.cfg* file. Again, what
    you have so far will be enough for development.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更好的方法来创建程序入口点，但我会在第18章中讲解那些方法，当我创建了至关重要的*setup.cfg*文件后。再次强调，迄今为止你所做的已经足够用于开发了。
- en: The Python Module Search Path
  id: totrans-1189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python模块搜索路径
- en: The *module search path*, or *import path*, defines where Python looks for packages
    and modules and what order it searches in. When you first start the Python interpreter,
    the module search path is assembled in order, from the directory of the module
    being executed, the system variable `PYTHONPATH`, and the default path for the
    Python instance being used.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块搜索路径*，或*导入路径*，定义了Python查找包和模块的顺序以及它的搜索顺序。当你第一次启动Python解释器时，模块搜索路径是按顺序组装的，从正在执行的模块所在的目录开始，接着是系统变量`PYTHONPATH`，然后是所用Python实例的默认路径。'
- en: 'You can view the resulting module search path with the following commands:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令查看结果的模块搜索路径：
- en: '[PRE184]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Running that code within the context of a virtual environment (in my case,
    */home/jason/.venvs/venv310*) on my system gives me the following output:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统中，在虚拟环境的上下文中运行该代码（在我的例子中是*/home/jason/.venvs/venv310*）会得到以下输出：
- en: '[PRE185]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The import system looks through each of the locations in the module search path
    *in order*. As soon as it finds a match for the module or package being imported,
    it stops. You can see here that it searches the directory containing the module
    or script I’m running ❶, the standard libraries ❷ ❸ ❹, and then everything installed
    with pip in the virtual environment ❺.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统会按顺序查看模块搜索路径中的每个位置。当它找到与被导入的模块或包匹配的项时，它会停止搜索。你可以看到，它会先搜索我正在运行的模块或脚本所在的目录❶，然后是标准库❷❸❹，最后是通过pip安装的虚拟环境中的所有内容❺。
- en: If you need to add locations to the module search path, the best way is to use
    a virtual environment and add a file ending in *.pth* to the *lib/python3.x/site-packages*
    directory. The name of the file doesn’t matter, as long as the file extension
    is *.pth*.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向模块搜索路径添加位置，最好的方法是使用虚拟环境，并在*lib/python3.x/site-packages*目录中添加一个以*.pth*结尾的文件。文件的名称无关紧要，只要文件扩展名是*.pth*即可。
- en: 'For example, consider the following:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下情况：
- en: '[PRE186]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Listing 4-26: *venv/lib/python3.10/site-packages/stuff.pth*'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-26: *venv/lib/python3.10/site-packages/stuff.pth*'
- en: Each line must contain exactly one path to be appended. The absolute path */home/jason/bunch_of_code*
    will be appended to the module search path. The relative path *../../../awesomesauce*
    is relative to the .*pth* file, so it will point to *venv/awesomesauce*.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 每行必须包含一个需要添加的路径。绝对路径*/home/jason/bunch_of_code*将被添加到模块搜索路径中。相对路径*../../../awesomesauce*是相对于.*pth*文件的，所以它将指向*venv/awesomesauce*。
- en: Because these are appended to the module search path, this technique cannot
    be used to replace any packages or modules installed on the system or virtual
    environment. However, any new modules or packages in my *bunch_of_code/* or *awesomesauce/*
    directories will be available for import within the virtual environment.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些是追加到模块搜索路径中的，所以这种方法不能用于替代系统或虚拟环境中安装的任何包或模块。然而，我的*bunch_of_code/*或*awesomesauce/*目录中的任何新模块或包将可以在虚拟环境中导入。
- en: What Really Happens
  id: totrans-1202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实发生的事情
- en: Let’s look at what really happens under the hood when you import a module. Most
    of the time, those details won’t matter, but every now and then (such as when
    the wrong module seems to be imported instead of the one you expect), the technical
    details leak to the surface. It never hurts to know what’s going on.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在导入模块时，底层究竟发生了什么。大多数时候，这些细节并不重要，但偶尔（比如当导入了错误的模块而不是预期的模块时），这些技术细节就会浮出水面。了解这些内容总是有益的。
- en: The `import` statement calls the built-in`__import__()` function.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句调用内建的`__import__()`函数。'
- en: 'To import a module, Python uses two special objects: a *finder* and a *loader*.
    In some cases, it uses an *importer* object, which serves as both a finder and
    a loader.'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入模块，Python使用两个特殊对象：*查找器*和*加载器*。在某些情况下，它使用*导入器*对象，作为查找器和加载器的结合体。
- en: The *finder* is responsible for locating the module being imported. There are
    many places to look for modules—they aren’t even necessarily files—and a number
    of special situations exist that must be handled. Python has several types of
    finders to handle these different situations, and it gives each one an opportunity
    to locate a module with a given name.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '*查找器*负责定位要导入的模块。查找模块的地方有很多——它们甚至不一定是文件——而且有许多特殊情况需要处理。Python有几种类型的查找器来处理这些不同的情况，每种查找器都会有机会查找具有给定名称的模块。'
- en: 'First, Python uses *meta path finders*, which are stored in the `sys.meta_path`
    list. By default, there are three meta path finders:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python使用*元路径查找器*，这些查找器存储在`sys.meta_path`列表中。默认情况下，有三个元路径查找器：
- en: The *built-in importer* finds and loads built-in modules.
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内建导入器*查找并加载内建模块。'
- en: The *frozen importer* finds and loads *frozen* modules, meaning modules that
    have been converted to compiled bytecode (see Chapter 1).
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冻结导入器*查找并加载*冻结*模块，意味着那些已被转换为编译字节码的模块（参见第一章）。'
- en: The *path-based finder* looks in the filesystem for the module.
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于路径的查找器*在文件系统中查找模块。'
- en: This search order is the reason why you cannot globally shadow a built-in module;
    the built-in importer runs before the path-based finder. If you need some additional
    meta path finder, such as if you were importing a module from a novel location
    not already supported, you can add it as a *meta hook* by appending it to the
    `sys.meta_path` list.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种搜索顺序是你无法全局遮蔽内建模块的原因；内建导入器会在基于路径的查找器之前运行。如果你需要额外的元路径查找器，比如当你从一个不被支持的新位置导入模块时，你可以通过将其附加到`sys.meta_path`列表中，作为*元钩子*添加。
- en: There’s some additional complexity to the path-based finder that is worth breaking
    down. The path-based finder tries each of the *path entry finders* in turn. These
    path entry finders, also known as *path entry hooks*, are stored in `sys.path_hooks`.
    Each one searches every location (known as a *path* entry) listed on the import
    path, as specified by `sys.path` or the `__path__` attribute of the current package.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 基于路径的查找器有一些额外的复杂性，值得拆解一下。基于路径的查找器会依次尝试每个*路径条目查找器*。这些路径条目查找器，也被称为*路径条目钩子*，存储在`sys.path_hooks`中。每个查找器会在导入路径上列出的每个位置（称为*路径*条目）中进行搜索，这些路径由`sys.path`或当前包的`__path__`属性指定。
- en: If any of the finders locates the module, it returns a *module spec* object
    with all the information about how to load the module. However, if all the meta
    path finders return `None`, you’ll get a `ModuleNotFoundError`.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何查找器找到模块，它会返回一个包含加载模块信息的*模块规范*对象。然而，如果所有的元路径查找器都返回`None`，你将会得到一个`ModuleNotFoundError`。
- en: Once the module is found, the module spec goes to the *loader*, which is responsible
    for actually loading the module.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到模块，模块规范会传递给*加载器*，它负责实际加载模块。
- en: There’s a lot of technical detail regarding loading that’s beyond the scope
    of this book, but one thing worth noting is how the loader deals with *cached
    bytecode*. Ordinarily, once a Python module has been run, a *.pyc* file is generated.
    The file contains the bytecode, which from then on is *cached*. You’ll often see
    these *.pyc* files hanging out in your project directories. The loader always
    needs to be sure that the cached bytecode is not out of date before loading it,
    by using one of two strategies. The first strategy is for the bytecode to also
    store the timestamp from the last time the source code file was modified. When
    loading the module, the timestamp of the source code is checked against this cached
    timestamp. If it doesn’t match, the bytecode is out of date, and the source will
    be recompiled. The second strategy, introduced in Python 3.7, instead stores a
    *hash*, which is a short and (relatively) unique value algorithmically generated
    from the source code itself. If the source code changes, the hash will be different
    from the one stored in the cached bytecode. Python bytecode files that contain
    this hash are appropriately called *hash-based .pyc* files.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加载的技术细节有很多，超出了本书的范围，但值得注意的一点是加载器如何处理*缓存字节码*。通常，一旦Python模块被执行，就会生成一个*.pyc*文件。该文件包含字节码，从此以后它会被*缓存*。你经常会在项目目录中看到这些*.pyc*文件。加载器总是需要确保在加载字节码之前，缓存的字节码没有过期，可以通过两种策略之一来实现。第一种策略是字节码还会存储最后一次修改源代码文件的时间戳。在加载模块时，会检查源代码的时间戳与缓存的时间戳是否匹配。如果不匹配，字节码就过时了，源代码将重新编译。第二种策略是Python
    3.7中引入的，它改为存储一个*哈希值*，这个哈希值是从源代码本身通过算法生成的一个简短且（相对）唯一的值。如果源代码发生变化，哈希值与缓存字节码中存储的哈希值会不同。包含此哈希值的Python字节码文件被称为*基于哈希的.pyc*文件。
- en: Regardless of how the loader is loading the module, it will add the module object
    to `sys.modules`—adding it, in fact, just before actually loading, to prevent
    an import loop if the module being loaded imports itself. Finally, the loader
    will bind the imported module object to a name in the module importing it, so
    the imported module can be referenced. (I’ll cover name binding in Chapter 5.)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 无论加载器如何加载模块，它都会将模块对象添加到`sys.modules`中——实际上，它是在实际加载之前添加的，以防止如果正在加载的模块导入自身而发生导入循环。最后，加载器会将导入的模块对象绑定到导入它的模块中的一个名称上，以便引用已导入的模块。（我将在第5章中讲解名称绑定。）
- en: Once the module has been imported, it’s cached in `sys.path_importer_cache`,
    along with the importer object used to import it. This is actually the first place
    the import system will check for an imported module, even before running through
    the finders, so importing a module multiple times in a project will still only
    go through the finding-and-loading process once.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块被导入，它会被缓存到`sys.path_importer_cache`中，连同用于导入它的导入器对象。这实际上是导入系统在检查已导入模块时的第一个地方，甚至在遍历查找器之前。因此，在一个项目中多次导入一个模块，仍然只会经过查找和加载过程一次。
- en: This is a very broad overview of the import system, but most of the time, it’s
    all you’ll need to know. To learn all the intricate details, you can read the
    official documentation at [https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html).
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对导入系统的一个非常广泛的概述，但大多数情况下，这就是你需要知道的全部内容。要了解所有复杂的细节，你可以阅读官方文档：[https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html)。
- en: Wrapping Up
  id: totrans-1219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The Python import system is often overlooked when learning the language, leading
    to many headaches for new users. By understanding how to use and import modules
    and packages, you will greatly reduce the roadblocks between you and a viable
    project. A little effort now will save you countless hours of confusion and trouble
    later!
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习Python时，导入系统常常被忽视，这使得新用户常常头痛不已。通过了解如何使用和导入模块和包，你将大大减少你与可行项目之间的障碍。现在稍加努力，将为你后续节省无数的困惑和麻烦！
