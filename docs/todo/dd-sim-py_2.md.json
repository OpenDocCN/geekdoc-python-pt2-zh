["```py\nanswer = 42\n```", "```py\ninsight = answer\n```", "```py\nspam = 123456789\nmaps = spam\neggs = 123456789\n```", "```py\nprint(spam == maps)  # prints True\nprint(spam == eggs)  # prints True\n```", "```py\nprint(spam is maps)  # prints True\nprint(spam is eggs)  # prints False (probably)\n```", "```py\nanswer = 42\ninsight = 42\nprint(answer is insight)  # prints True\n```", "```py\nanswer = 42\n```", "```py\nprint(type(answer))  # prints <class 'int'>\n```", "```py\nif type(answer) is int:\n    print(\"What's the question?\")\n```", "```py\nif **isinstance(answer, int):**\n    print(\"What's the question?\")\n```", "```py\ndef spam():\n    message = \"Spam\"\n    word = \"spam\"\n    for _ in range(100):\n        separator = \", \"\n        message += separator + word\n    message += separator\n    message += \"spam!\"\n\n    return message\n```", "```py\nprint(message)  # NameError: name 'message' is not defined\n```", "```py\noutput = spam()\nprint(output)\n```", "```py\nhigh_score = 10\n```", "```py\ndef score():\n    new_score = 465               # SCORING LOGIC HERE\n    if new_score > ❶ high_score:  # ERROR: UnboundLocalError\n        print(\"New high score\")\n      ❷ high_score = new_score\n\nscore()\nprint(high_score)\n```", "```py\ndef score():\n    **global high_score**\n    new_score = 465  # SCORING LOGIC HERE\n    if new_score > high_score:\n        print(\"New high score\")\n        high_score = new_score\n\nscore()\nprint(high_score)   # prints 465\n```", "```py\ncurrent_score = 0\n\ndef score():\n    new_score = 465   # SCORING LOGIC HERE\n    current_score = new_score\n\nscore()\nprint(current_score)  # prints 0\n```", "```py\ncurrent_score = 0\n\ndef score():\n    **global current_score**\n new_score = 465  # SCORING LOGIC HERE\n    current_score = new_score\n\nscore()\nprint(current_score)  # prints 465\n```", "```py\nspam = True\n\ndef order():\n    eggs = 12\n\n    def cook():\n      ❶ nonlocal eggs\n\n        if spam:\n            print(\"Spam!\")\n\n        if eggs:\n            eggs -= 1\n            print(\"...and eggs.\")\n\n    cook()\n\norder()\n```", "```py\nclass Nutrimatic:\n  ❶ output = \"Something almost, but not quite, entirely unlike tea.\"\n\n    def request(self, beverage):\n        return ❷ self.output\n\nmachine = Nutrimatic()\nmug = machine.request(\"Tea\")\nprint(mug)   # prints \"Something almost, but not quite, entirely unlike tea.\"\n\nprint( ❸ machine.output)\nprint( ❹ Nutrimatic.output)\n```", "```py\nSomething almost, but not quite, entirely unlike tea.\nSomething almost, but not quite, entirely unlike tea.\nSomething almost, but not quite, entirely unlike tea.\n```", "```py\neggs = 12\ncarton = eggs\nprint(eggs is carton)  # prints True\neggs += 1\nprint(eggs is carton)  # prints False\nprint(eggs)            # prints 13\nprint(carton)          # prints 12\n```", "```py\ntemps = [87, 76, 79]\nhighs = temps\nprint(temps is highs)  # prints True\n❶ temps += [81]\nprint(temps is highs)  # prints True\nprint(highs)           # prints [87, 76, 79, 81]\nprint(temps)           # prints [87, 76, 79, 81]\n```", "```py\ndef greet(person):\n    print(f\"Hello, {person}.\")\n\nmy_name = \"Jason\"\ngreet(my_name)\n```", "```py\ndef find_lowest(temperatures):\n    temperatures.sort()\n    print(temperatures[0])\n```", "```py\ntemps = [85, 76, 79, 72, 81]\nfind_lowest(temps)\nprint(temps)\n```", "```py\n72\n[72, 76, 79, 81, 85]\n```", "```py\ndef find_lowest(temperatures):\n    **sorted_temps =** ❶ **sorted(**temperatures**)**  # sorted returns a new list\n    print(sorted_temps[0])\n```", "```py\nboard = [[\"-\"] ❶ * 3] * 3  # Create a board\n```", "```py\n❷ board[1][0] = \"X\"  # Make a move\n\n# Print board to screen\nfor row in board:\n    print(f\"{row[0]} {row[1]} {row[2]}\")\n```", "```py\n- - -\nX - -\n- - -\n```", "```py\nX - -\nX - -\nX - -\n```", "```py\nboard = **[[\"-\"] * 3 for _ in range(3)]**\n```", "```py\n- - -\nX - -\n- - -\n```", "```py\nscores_team_1 = [100, 95, 120]\nscores_team_2 = [45, 30, 10]\nscores_team_3 = [200, 35, 190]\n\nscores = (scores_team_1, scores_team_2, scores_team_3)\n```", "```py\nscores_team_1[0] = 300\nprint(scores[0])  # prints [300, 95, 120]\n```", "```py\nscores[0][0] = 400\nprint(scores[0])  # prints [400, 95, 120]\n```", "```py\nclass Taco:\n\n    def __init__(self, toppings):\n        self.ingredients = toppings\n\n    def add_sauce(self, sauce):\n        self.ingredients.append(sauce)\n```", "```py\ndefault_toppings = [\"Lettuce\", \"Tomato\", \"Beef\"]\nmild_taco = Taco(default_toppings)\nhot_taco = Taco(default_toppings)\nhot_taco.add_sauce(\"Salsa\")\n```", "```py\nprint(f\"Hot: {hot_taco.ingredients}\")\nprint(f\"Mild: {mild_taco.ingredients}\")\nprint(f\"Default: {default_toppings}\")\n```", "```py\nHot: ['Lettuce', 'Tomato', 'Beef', 'Salsa']\nMild: ['Lettuce', 'Tomato', 'Beef', 'Salsa']\nDefault: ['Lettuce', 'Tomato', 'Beef', 'Salsa']\n```", "```py\n**import copy**\n\nclass Taco:\n\n    def __init__(self, toppings):\n        self.ingredients = ❶ **copy.copy(toppings)**\n\n    def add_sauce(self, sauce):\n        self.ingredients.append(sauce)\n```", "```py\nHot: ['Lettuce', 'Tomato', 'Beef', 'Salsa']\nMild: ['Lettuce', 'Tomato', 'Beef']\nDefault: ['Lettuce', 'Tomato', 'Beef']\n```", "```py\ndefault_toppings = [\"Lettuce\", \"Tomato\", \"Beef\"]\nmild_taco = Taco(default_toppings)\nhot_taco = ❶ **copy.copy(mild_taco)**\nhot_taco.add_sauce(\"Salsa\")\n```", "```py\nHot: [\"Lettuce\", \"Tomato\", \"Beef\", \"Salsa\"]\nMild: [\"Lettuce\", \"Tomato\", \"Beef\", \"Salsa\"]\nDefault: [\"Lettuce\", \"Tomato\", \"Beef\"]\n```", "```py\ndefault_toppings = [\"Lettuce\", \"Tomato\", \"Beef\"]\nmild_taco = Taco(default_toppings)\nhot_taco = ❶ copy.**deepcopy**(mild_taco)\nhot_taco.add_sauce(\"Salsa\")\n```", "```py\nHot: [\"Lettuce\", \"Tomato\", \"Cheese\", \"Beef\", \"Salsa\"]\nMild: [\"Lettuce\", \"Tomato\", \"Cheese\", \"Beef\"]\nDefault: [\"Lettuce\", \"Tomato\", \"Cheese\", \"Beef\"]\n```", "```py\nprint(42.5)   # coerces to a string\nx = 5 + 1.5   # coerces to a float (6.5)\ny = 5 + True  # coerces to an int (6)...and is also considered a bad idea\n```", "```py\nlife_universe_everything = \"42\"\n\nanswer = float(life_universe_everything)\n```", "```py\nprint(type(answer))\nprint(answer)\n```", "```py\n<class 'float'>\n42.0\n```", "```py\ndef calculate_age(intBirthYear, intCurrentYear):\n    intAge = intCurrentYear - intBirthYear\n    return intAge\n\ndef calculate_third_age_year(intCurrentAge, intCurrentYear):\n    floatThirdAge = intCurrentAge / 3\n    floatCurrentYear = float(intCurrentYear)\n    floatThirdAgeYear = floatCurrentYear - floatThirdAge\n    intThirdAgeYear = int(floatThirdAgeYear)\n    return intThirdAgeYear\n\nstrBirthYear = \"1985\"    # get from user, assume data validation\nintBirthYear = int(strBirthYear)\n\nstrCurrentYear = \"2010\"  # get from system\nintCurrentYear = int(strCurrentYear)\n\nintCurrentAge = calculate_age(intBirthYear, intCurrentYear)\nintThirdAgeYear = calculate_third_age_year(intCurrentAge, intCurrentYear)\nprint(intThirdAgeYear)\n```", "```py\ndef calculate_age(birth_year, current_year):\n    return (current_year - birth_year)\n\ndef calculate_third_age_year(current_age, current_year):\n    return int(current_year - (current_age / 3))\n\nbirth_year = \"1985\"    # get from user, assume data validation\nbirth_year = int(birth_year)\n\ncurrent_year = \"2010\"  # get from system\ncurrent_year = int(current_year)\n\ncurrent_age = calculate_age(birth_year, current_year)\nthird_age_year = calculate_third_age_year(current_age, current_year)\nprint(third_age_year)\n```", "```py\nimport random\n\ndef roll_dice(sides):\n    return random.randint(1, sides)\n```", "```py\nprint(\"Roll for initiative...\")\nplayer1 = ❶ roll_dice(20)\nplayer2 = roll_dice(20)\nif player1 >= player2:\n    print(f\"Player 1 goes first (rolled {player1}).\")\nelse:\n    print(f\"Player 2 goes first (rolled {player2}).\")\n```", "```py\nimport random\n\ndef roll_dice(sides, dice):\n    **return tuple(random.randint(1, sides) for** ****_ in range(dice))****\n```", "```py\nprint(\"Roll for initiative...\")\nplayer1**, player2** = roll_dice(20**, 2**)\nif player1 >= player2:\n    print(f\"Player 1 goes first (rolled {player1}).\")\nelse:\n    print(f\"Player 2 goes first (rolled {player2}).\")\n```", "```py\nimport random\n\ndef roll_dice(sides, dice):\n    **if dice < 1:**\n        **return ()**\n    roll = random.randint(1, sides)\n    return **(roll, ) + roll_dice(sides, dice-1)**\n```", "```py\ndice_cup = roll_dice(6, 5)\nprint(dice_cup)\n```", "```py\n()\n(2,)\n(3, 2)\n(6, 3, 2)\n(4, 6, 3, 2)\n(4, 4, 6, 3, 2)\n```", "```py\nRecursionError: maximum recursion depth exceeded while calling a Python object\n```", "```py\n if dice < 1:\n        return ()\n```", "```py\nimport sys\nsys.setrecursionlimit(2000)\n```", "```py\nresult, = roll_dice(20, 1)\n```", "```py\nimport random\n\ndef roll_dice(sides, dice**=1**):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\nresult, = roll_dice(6)\n```", "```py\nplayer1, player2 = roll_dice(20, 2)\n```", "```py\ndef fibonacci_next(series ❶ =[1, 1]):\n  ❷ series.append(series[-1] + series[-2])\n    return series\n```", "```py\nfib1 = fibonacci_next()\nprint(fib1)  # prints [1, 1, 2]\nfib1 = fibonacci_next(fib1)\nprint(fib1)  # prints [1, 1, 2, 3]\n\nfib2 = fibonacci_next()\nprint(fib2)  # should be [1, 1, 2] riiiiight?\n```", "```py\n[1, 1, 2]\n[1, 1, 2, 3]\n[1, 1, 2]\n```", "```py\n[1, 1, 2]\n[1, 1, 2, 3]\n[1, 1, 2, 3, 5]\n```", "```py\ndef fibonacci_next(series**=None**):\n    **if series is None:**\n        **series = [1, 1]**\n    series.append(series[-1] + series[-2])\n    return series\n```", "```py\n[1, 1, 2]\n[1, 1, 2, 3]\n[1, 1, 2]\n```", "```py\ndice_cup = roll_dice(6, 5)\n```", "```py\ndice_cup = roll_dice(**sides=6, dice=5**)\n```", "```py\ndice_cups = roll_dice(**dice=5, sides=6**)\n```", "```py\nimport random\n\ndef roll_dice(sides=6, dice=1):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\ndice_cups = roll_dice(**dice=5**)\n```", "```py\ndice_cups = roll_dice(6**, dice=5**)\n```", "```py\nimport random\n\ndef roll_dice(*dice):\n    return tuple(random.randint(1, d) for d in dice)\n```", "```py\ndice_cup = roll_dice(6, 6, 6, 6, 6)\nprint(dice_cup)\n\nbunch_o_dice = roll_dice(20, 6, 8, 4)\nprint(bunch_o_dice)\n```", "```py\ndef roll_dice(*dice):\n **if dice:**\n **roll = random.randint(1, dice[0])**\n **return (roll,) + roll_dice(**❶ ***dice** ❷ **[1:])**\n **return ()**\n```", "```py\ndef call_something_else(func, *args, **kwargs):\n    return func(*args, **kwargs)\n```", "```py\ndef say_hi(name):\n    print(f\"Hello, {name}!\")\n\ncall_something_else(say_hi, name=\"Bob\")\n```", "```py\nHello, Bob!\n```", "```py\nimport random\n\ndef roll_dice(*, sides=6, dice=1):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\ndice_cup = roll_dice(sides=6, dice=5)\nprint(dice_cup)\n```", "```py\ndice_cup = roll_dice(6, 5)  # raises TypeError\nprint(dice_cup) \n```", "```py\nimport random\n\ndef roll_dice(dice=1, /, sides=6):\n    return tuple(random.randint(1, sides) for _ in range(dice))\n```", "```py\nroll_dice(4, 20)             # OK; dice=4, sides=20\nroll_dice(4)                 # OK; dice=4, sides=6\nroll_dice(sides=20)          # OK; dice=1, sides=20\nroll_dice(4, sides=20)       # OK; dice=4, sides=20\n\nroll_dice(dice=4)            # TypeError\nroll_dice(dice=4, sides=20)  # TypeError\n```", "```py\ndef func(pos_only=None, /, pos_kw=None, *, kw_only=None):\n```", "```py\nimport random\n\ndef roll_dice(sides**=6**, dice**=1**):\n    **def roll():**\n        **return** random.randint(1, sides)\n\n    if dice < 1:\n        return ()\n    return (**roll()**, ) + roll_dice(sides, dice-1)\n```", "```py\ndice_cup = roll_dice(**sides=**6, **dice=**5)\nprint(dice_cup)\n```", "```py\nimport random\n\ndef make_dice_cup(sides=6, dice=1):\n    def roll():\n        return tuple(random.randint(1, sides) for _ in range(dice))\n\n  ❶ return roll\n```", "```py\nroll_for_damage = make_dice_cup(sides=8, dice=5)\ndamage = roll_for_damage()\nprint(damage)\n```", "```py\nimport random\n\ndef make_dice_cup(sides=6, dice=1):\n    def roll():\n        nonlocal dice\n        if dice < 1:\n            return ()\n        die = random.randint(1, sides)\n        dice -= 1\n        return (die, ) + roll()\n\n    return roll\n```", "```py\nroll_for_damage = make_dice_cup(sides=8, dice=5)\ndamage = roll_for_damage()\nprint(damage)\n\ndamage = roll_for_damage()\nprint(damage)\n```", "```py\n(1, 3, 4, 3, 7)\n()\n```", "```py\nimport random\n\ndef make_dice_cup(sides=6, dice=1):\n    def roll(**dice=dice**):\n        if dice < 1:\n            return ()\n        die = random.randint(1, sides)\n        return (die, ) + roll(**dice - 1**)\n\n    return roll\n```", "```py\nimport random\n\ndef start_turn(limit, dice=5, sides=6):\n    def roll():\n        nonlocal limit\n        if limit < 1:\n            return None\n        limit -= 1\n        return tuple(random.randint(1, sides) for _ in range(dice))\n\n    return roll\n```", "```py\nturn1 = start_turn(limit=3)\nwhile toss := turn1():\n    print(toss)\n\nturn2 = start_turn(limit=3)\nwhile toss := turn2():\n    print(toss)\n```", "```py\n(4, 1, 2, 1, 1)\n(4, 2, 3, 1, 5)\n(1, 6, 3, 4, 2)\n(1, 6, 4, 5, 5)\n(2, 1, 4, 5, 3)\n(2, 4, 1, 6, 1)\n```", "```py\nlambda x, y: x + y\n```", "```py\nadd = lambda x, y: x + y\nanswer = add(20, 22)\nprint(answer)  # outputs \"42\"\n```", "```py\nimport random\n\nhealth = 10\nxp = 10\n```", "```py\ndef attempt(action, min_roll, ❶ outcome):\n    global health, xp\n    roll = random.randint(1, 20)\n    if roll >= min_roll:\n        print(f\"{action} SUCCEEDED.\")\n        result = True\n    else:\n        print(f\"{action} FAILED.\")\n        result = False\n\n    scores = ❷ outcome(result)\n    health = health + scores[0]\n    print(f\"Health is now {health}\")\n    xp = xp + scores[1]\n    print(f\"Experience is now {xp}\")\n\n    return result\n```", "```py\ndef eat_bread(success):\n    if success:\n        return (1, 0)\n    return (-1, 0)\n\ndef fight_ice_weasel(success):\n    if success:\n        return (0, 10)\n    return (-10, 10)\n\n❶ attempt(\"Eating bread\", 5, eat_bread)\nattempt(\"Fighting ice weasel\", 15, fight_ice_weasel)\n```", "```py\nattempt(\"Eating bread\", 5,\n        **lambda success: (1, 0) if success else (-1, 0)**)\n\nattempt(\"Fighting ice weasel\", 15,\n        **lambda success: (0, 10) if success else (-10, 10)**)\n```", "```py\nlambda success: (1, 0) if success else (-1, 0))\n```", "```py\npeople = [\n    (\"Jason\", \"McDonald\"),\n    (\"Denis\", \"Pobedrya\"),\n    (\"Daniel\", \"Foerster\"),\n    (\"Jaime\", \"López\"),\n    (\"James\", \"Beecham\")\n]\n\nby_last_name = sorted(people, ❶ key=lambda x: x[1])\nprint(by_last_name)\n```", "```py\nimport random\n\ncharacter = \"Sir Bob\"\nhealth = 15\nxp = 0\n```", "```py\ndef eat_food(food):\n    global health\n  ❶ if health <= 0:\n        print(f\"{character} is too weak.\")\n        return\n\n    print(f\"{character} ate {food}.\")\n    health += 1\n  ❷ print(f\"    Health: {health} | XP: {xp}\")\n\ndef fight_monster(monster, strength):\n    global health, xp\n  ❸ if health <= 0:\n        print(f\"{character} is too weak.\")\n        return\n\n    if random.randint(1, 20) >= strength:\n        print(f\"{character} defeated {monster}.\")\n        xp += 10\n    else:\n        print(f\"{character} flees from {monster}.\")\n        health -= 10\n        xp += 5\n  ❹ print(f\"    Health: {health} | XP: {xp}\")\n```", "```py\neat_food(\"bread\")\nfight_monster(\"Imp\", 15)\nfight_monster(\"Direwolf\", 15)\nfight_monster(\"Minotaur\", 19)\n```", "```py\n❶ **import functools**\nimport random\n\ncharacter = \"Sir Bob\"\nhealth = 15\nxp = 0\n\n**def character_action(func):**\n  ❷ **@functools.wraps(func)**\n  ❸ **def wrapper(*args, **kwargs):**\n **if health <= 0:**\n **print(f\"{character} is too weak.\")**\n **return**\n\n **result = func(*args, **kwargs)**\n **print(f\"    Health: {health} | XP: {xp}\")**\n **return result**\n\n  ❹ **return wrapper**\n```", "```py\n**@character_action**\ndef eat_food(food):\n    global health\n    print(f\"{character} ate {food}.\")\n    health += 1\n\n**@character_action**\ndef fight_monster(monster, strength):\n    global health, xp\n    if random.randint(1, 20) >= strength:\n        print(f\"{character} defeated {monster}.\")\n        xp += 10\n    else:\n        print(f\"{character} flees from {monster}.\")\n        health -= 10\n        xp += 5\n```", "```py\nanswer: int = 42\n```", "```py\nimport random\n**import typing**\n\ndef roll_dice(sides**: int** = 6, dice**: int** = 1) **-> typing.Tuple[int, ...]**:\n    # `--snip--`\n```", "```py\nimport random\nimport typing\n\n**TupleInts = typing.Tuple[int, ...]**\n\ndef roll_dice(sides: int = 6, dice: int = 1) -> **TupleInts**:\n    # `--snip--`\n```", "```py\nmypy dice_roll.py\n```", "```py\ndef search(within: typing.Iterable[typing.Any]):\n```", "```py\nclass SecretAgent:\n```", "```py\nclass SecretAgent(object):\n```", "```py\nclass SecretAgent:\n\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n```", "```py\nfrom secret_agent import SecretAgent\nmouse = SecretAgent(\"Mouse\")\narmadillo = SecretAgent(\"Armadillo\")\nfox = SecretAgent(\"Fox\")\n```", "```py\n def __new__(cls, *args, **kwargs):\n        return super().__new__(cls, *args, **kwargs)\n```", "```py\n def __del__(self):\n        print(f\"Agent {self.codename} has been disavowed!\")\n```", "```py\nfrom secret_agent import SecretAgent\nweasel = SecretAgent(\"Weasel\")\ndel weasel\n```", "```py\nAgent Weasel has been disavowed!\n```", "```py\nclass SecretAgent:\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n```", "```py\nclass SecretAgent:\n\n    **_codeword = \"\"**\n\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n```", "```py\n❶ SecretAgent._codeword = \"Parmesan\"\nprint(armadillo._codeword)  # prints \"Parmesan\"\nprint(mouse._codeword)      # prints \"Parmesan\"\n\n❷ mouse._codeword = \"Cheese\"\nprint(mouse._codeword)      # prints \"Cheese\"\nprint(armadillo._codeword)  # prints \"Parmesan\"\n```", "```py\nclass Message:\n\n    def __init__(self):\n        self.__format = \"UTF-8\"\n```", "```py\nmsg = Message()\nprint(msg.__format)  # AttributeError\n```", "```py\nprint(msg._Message__format)\n```", "```py\n def remember(self, secret):\n        self._secrets.append(secret)\n```", "```py\nmouse.remember((\"42.864025, -72.568511\"))\n```", "```py\n @classmethod\n    def inform(cls, codeword):\n        cls._codeword = codeword\n```", "```py\nSecretAgent.inform(\"The goose honks at midnight.\")\nprint(mouse._codeword)  # prints \"The goose honks at midnight.\"\n\nfox.inform(\"The duck quacks at midnight.\")\nprint(mouse._codeword)  # prints \"The duck quacks at midnight.\"\n```", "```py\n @staticmethod\n    def inquire(question):\n        print(\"I know nothing.\")\n```", "```py\nclass SecretAgent:\n\n    _codeword = None\n\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n\n    def __del__(self):\n        print(f\"Agent {self.codename} has been disavowed!\")\n\n    def remember(self, secret):\n        self._secrets.append(secret)\n\n @classmethod\n    def inform(cls, codeword):\n        cls._codeword = codeword\n\n    @staticmethod\n    def inquire(question):\n        print(\"I know nothing.\")\n```", "```py\n @classmethod\n    def _encrypt(cls, message, *, decrypt=False):\n        code = sum(ord(c) for c in cls._codeword)\n        if decrypt:\n            code = -code\n        return ''.join(chr(ord(m) + code) for m in message)\n```", "```py\n def _getsecret(self):\n        return self._secrets[-1] if self._secrets else None\n```", "```py\n def _setsecret(self, value):\n        self._secrets.append(self._encrypt(value))\n```", "```py\n def _delsecret(self):\n        self._secrets = []\n```", "```py\n secret = property(fget=_getsecret, fset=_setsecret, fdel=_delsecret)\n```", "```py\nmouse = SecretAgent(\"Mouse\")\nmouse.inform(\"Parmesano\")\n\nprint(mouse.secret)     # prints \"None\"\nmouse.secret = \"12345 Main Street\"\nprint(mouse.secret)     # prints \"ϗϘϙϚϛφϳЇЏДφϹКИЋЋК\"\nmouse.secret = \"555-1234\"\nprint(mouse.secret)     # prints \"ϛϛϛϓϗϘϙϚ\"\n\nprint(mouse._secrets)   # prints two values\ndel mouse.secret\nprint(mouse._secrets)   # prints empty list\n```", "```py\n def _setsecret(self, value):\n        self._secrets.append(self._encrypt(value))\n\n    def _delsecret(self):\n        self._secrets = []\n\n    secret = property( ❶ fset=_setsecret, fdel=_delsecret)\n```", "```py\nmouse = SecretAgent(\"Mouse\")\nmouse.inform(\"Parmesano\")\n\nmouse.secret = \"12345 Main Street\"\nmouse.secret = \"555-1234\"\n\nprint(mouse.secret)  # AttributeError\n```", "```py\n secret = property**()**\n```", "```py\n **@secret.getter**\n    def **secret**(self):\n        return self._secrets[-1] if self._secrets else None\n```", "```py\n **@secret.setter**\n    def **secret**(self, value):\n        self._secrets.append(self._encrypt(value))\n```", "```py\n **@secret.deleter**\n    def **secret**(self):\n        self._secrets = []\n```", "```py\n **@property**\n    def secret(self):\n        return self._secrets[-1] if self._secrets else None\n\n    @secret.setter\n    def secret(self, value):\n        self._secrets.append(self._encrypt(value))\n\n @secret.deleter\n    def secret(self):\n        self._secrets = [] \n```", "```py\n ❶ secret = property()\n\n    @secret.setter\n    def secret(self, value):\n        self._secrets.append(self._encrypt(value))\n\n    @secret.deleter\n    def secret(self):\n        self._secrets = []\n```", "```py\nimport math\nclass GlobalCoordinates:\n\n    def __init__(self, *, latitude, longitude):\n\n        self._lat_deg = latitude[0]\n        self._lat_min = latitude[1]\n        self._lat_sec = latitude[2]\n        self._lat_dir = latitude[3]\n\n        self._lon_deg = longitude[0]\n        self._lon_min = longitude[1]\n        self._lon_sec = longitude[2]\n        self._lon_dir = longitude[3]\n\n    @staticmethod\n    def degrees_from_decimal(dec, *, lat):\n        if lat:\n            direction = \"S\" if dec < 0 else \"N\"\n        else:\n            direction = \"W\" if dec < 0 else \"E\"\n        dec = abs(dec)\n        degrees = int(dec)\n dec -= degrees\n        minutes = int(dec * 60)\n        dec -= minutes / 60\n        seconds = round(dec * 3600, 1)\n        return (degrees, minutes, seconds, direction)\n\n    @staticmethod\n    def decimal_from_degrees(degrees, minutes, seconds, direction):\n        dec = degrees + minutes/60 + seconds/3600\n        if direction == \"S\" or direction == \"W\":\n            dec = -dec\n        return round(dec, 6)\n\n    @property\n    def latitude(self):\n        return self.decimal_from_degrees(\n            self._lat_deg, self._lat_min, self._lat_sec, self._lat_dir\n        )\n\n    @property\n    def longitude(self):\n        return self.decimal_from_degrees(\n            self._lon_deg, self._lon_min, self._lon_sec, self._lon_dir\n        )\n```", "```py\nfrom global_coordinates import GlobalCoordinates\nnsp = GlobalCoordinates(latitude=(37, 46, 32.6, \"N\"),\n                        longitude=(122, 24, 39.4, \"W\"))\nprint(repr(nsp))\n```", "```py\n<__main__.GlobalCoordinates object at 0x7f61b0c4c7b8>\n```", "```py\n def __repr__(self):\n        return (\n            f\"<GlobalCoordinates \"\n            f\"lat={self._lat_deg}°{self._lat_min}'\"\n            f\"{self._lat_sec}\\\"{self._lat_dir}  \"\n            f\"lon={self._lon_deg}°{self._lon_min}'\"\n            f\"{self._lon_sec}\\\"{self._lon_dir}>\"\n        )\n```", "```py\n<GlobalCoordinates lat=37°46'32.6\"N  lon=122°24'39.4\"W>\n```", "```py\n def __str__(self):\n        return (\n            f\"{self._lat_deg}°{self._lat_min}'\"\n            f\"{self._lat_sec}\\\"{self._lat_dir} \"\n f\"{self._lon_deg}°{self._lon_min}'\"\n            f\"{self._lon_sec}\\\"{self._lon_dir}\"\n        )\n```", "```py\nprint(f\"No Starch Press's offices are at {nsp}\")\n```", "```py\nNo Starch Press's offices are at 37°46'32.6\"N 122°24'39.4\"W\n```", "```py\n def __hash__(self):\n        return hash((\n            self._lat_deg, self._lat_min, self._lat_sec, self._lat_dir,\n            self._lon_deg, self._lon_min, self._lon_sec, self._lon_dir\n        ))\n```", "```py\n def __eq__(self, other):\n        if not ❶ isinstance(other, GlobalCoordinates):\n            return ❷ NotImplemented\n\n        return (\n            self._lat_deg == other._lat_deg\n            and self._lat_min == other._lat_min\n            and self._lat_sec == other._lat_sec\n            and self._lat_dir == other._lat_dir\n            and self._lon_deg == other._lon_deg\n            and self._lon_min == other._lon_min\n            and self._lon_sec == other._lon_sec\n            and self._lon_dir == other._lon_dir\n        )\n```", "```py`Be careful with this reflection, however! If you want to support comparing objects of different types, you should define both special methods in the pair.    In my particular example, there’s no clear logic for less than or greater than on two `GlobalCoordinates`, so I’m not defining any of those four special methods. Since I don’t define them, calls to any of them will return `NotImplemented`.    ### Binary Operator Support    Special methods will also let you add support for *binary operators*—operators with two operands—to your class. If any of the methods are undefined, they will default to returning `NotImplemented`, which, in the context of an expression, will usually cause an error to be raised.    With `GlobalCoordinates`, I’ll only implement the subtraction operator (`-`) via the `__sub__()` method:    ```", "```py    Listing 7-37: *global_coordinates.py:6*    As with comparison special methods, binary-operator special methods require two parameters: `self` and `other`. In my case, it’s logical for these operands to be `GlobalCoordinates` class instances; if `other` is of a different type, I return `NotImplemented`. Otherwise, I perform the math and return a tuple representing the difference between latitudes and longitudes in decimal degrees.    Because I’m only supporting subtraction of two `GlobalCoordinates` instances, I’m done. However, if I were supporting subtracting some other type, I’d have to also implement `__rsub__()`, which is the reflection of `__sub__()`. The expression `a - b` calls `a.__sub__(b)`, but if that returns `NotImplemented`, then Python tries to call `b.__rsub__(a)` behind the scenes. Because `a - b` is not the same as `b - a`, I must define those two methods separately; `b.__rsub__(a)` should return the value of `a - b`.    A third method, `__isub__()`, corresponds to the subtraction-augmented assignment operator (`-=`). If this method is undefined, that operator will fall back on the `__sub__()` and `__rsub__()` functions (`a -= b` becomes `a = a - b`), so you’d only need to define `__isub__()` if you needed some special behavior.    All 13 binary operators, as well as `divmod()`, rely on the same three sorts of special methods, although there is no augmented assignment for `divmod()`. For your reference, [Table 7-1](#table7-1) outlines them all.      Table 7-1: Operator Special Methods       | **Operator** | **Method** | **Reflected method** | **Augmented method** | | --- | --- | --- | --- | | Addition (`+`) | `__add__()` | `__radd__()` | `__iadd__()` | | Subtraction (`-`) | `__sub__()` | `__rsub__()` | `__isub__()` | | Multiplication (`*`) | `__mul__()` | `__rmul__()` | `__imul__()` | | Matrix multiplication (`@`) | `__matmul__()` | `__rmatmul__()` | `__imatmul__()` | | Division (`/`) | `__truediv__()` | `__rtruediv__()` | `__itruediv__()` | | Floor division (`//`) | `__floordiv__()` | `__rfloordiv__()` | `__ifloordiv__()` | | Modulo (`%`) | `__mod__()` | `__mod__()` | `__imod__()` | | `divmod()` | `__divmod__()` | `__rdivmod__()` | N/A | | Power/exponent (`**`) | `__pow__()` | `__rpow__()` | `__ipow()__` | | Left shift (`<<`) | `__lshift__()` | `__rlshift__()` | `__ilshift__()` | | Right shift (`>>`) | `__rshift__()` | `__rrshift__()` | `__irshift__()` | | Logical AND (`and`) | `__and__()` | `__rand__()` | `__iand__()` | | Logical OR (`or`) | `__or__()` | `__ror__()` | `__ior__()` | | Logical XOR (`xor`) | `__xor__()` | `__rxor__()` | `__ixor__()` |    ### Unary Operator Support    You can also add support for unary operators—those with only one operand. Unary-operator special methods accept one parameter: `self`. As before, all three default to returning `NotImplemented` if undefined.    In the case of my `GlobalCoordinates`, I’d like to override the invert operator (`~`) to return a `GlobalCoordinates` instance that is the opposite position on the globe, in terms of both latitude and longitude:    ```", "```py    Listing 7-38: *global_coordinates.py:7*    Not much new there; I’m creating and returning a new instance of `GlobalCoordinates` from the negated current latitude and longitude.    The unary operators and their special methods are as follows:    1.  `__abs__()` handles the absolute value `abs()` operation function. 2.  `__invert__()` handles the invert/binary flip `~` operator. 3.  `__neg__()` handles the negative-sign operator `-`. 4.  `__pos__()` handles the positive-sign operator `+`.    ### Making Callable    The last of the special methods I’ll cover in this chapter concerns making an instance *callable*, meaning the instance can be treated like a function. This special method, `__call__()`, can accept any number of arguments and return anything.    To wrap up my example, I’ll write a `__call__()` method that, when passed another `GlobalCoordinate` instance, will return the distance between the two in degrees, minutes, and seconds. This is a rather contrived example without obvious usage, however, and I wouldn’t have made `GlobalCoordinates` callable in real life. This merely completes my example:    ```", "```py    Listing 7-39: *global_coordinates.py:8*    Remember, `__call__()` can be written to accept any parameters you want. In my case, I accept another `GlobalCoordinate` class instance on `other` ❶. Then, I calculate the distance between the two points in kilometers and return that result as a float ❷.    Now, I can use any class instance of `GlobalCoordinate` in the same manner as a function:    ```", "```py    Listing 7-40: *global_coordinates_usage.py:3*    I define two instances of `GlobalCoordinate`, and then I calculate the distance between them by passing one instance to the other and storing the result. Indeed, the distance from No Starch Press’s offices to those of the Python Software Foundation is about 852 kilometers (529 miles).    ### More Special Methods: Looking Ahead    There are several more special methods, but I’ll cover those in chapters where their functionality is relevant. Be on the lookout for special methods relating to *iterables* (Chapter 9), *context managers* (Chapter 11), and *async* (Chapter 16). You can also refer to Appendix A for a complete list of special methods.    ## Class Decorators    Classes support *decorators*, much like functions do. Class decorators wrap the instantiation of the class, allowing you to intervene in any number of ways: adding attributes, initializing another class containing an instance of the one being decorated, or performing some behavior immediately on the new object.    To demonstrate this, I need to set up for a decently believable example. I’ll create a class for `CoffeeRecipe` that contains the recipe for a particular coffee shop menu item. I’ll also create a separate class for a `CoffeeOrder`, which is a single person’s coffee order:    ```", "```py    Listing 7-41: *coffee_order_decorator.py:1*    By this point, you can probably figure out what’s going on here.    Next, I’m opening a drive-thru coffee shack that only does to-go orders, so I don’t want to have to specify each order as to go manually.    Instead of writing a whole new `CoffeeOrder` class, I can define a class decorator that allows me to specify that all orders are to go (or not) up front:    ```", "```py    Listing 7-42: *coffee_order_decorator.py:2*    This decorator accepts the additional argument `to_go`, so I have to wrap the decorator itself in another function, creating a double closure ❶. The decorator is returned from the outermost function ❹, but the decorator’s effective name will always come from the outermost function name. This pattern works with all decorators, not just class decorators.    The decorator, itself, will look pretty familiar, if you recall Chapter 6. After initializing an instance of the wrapped class ❷, I immediately use that instance to initialize a `CoffeeOrder` instance, which I return in a tuple with the `CoffeeShackRecipe` instance ❸.    I can now create a new `CoffeeShackRecipe` that inherits from `CoffeeRecipe` and adds nothing new, and then I can apply the decorator to make it always make orders to go:    ```", "```py    Listing 7-43: *coffee_order_decorator.py:3*    The only reason I created this new class is to extend it with the `@auto_order` decorator, without losing the ability to create `CoffeeRecipe` instances when I want them.    In the usage, you see that I can now specify a `CoffeeShackRecipe` as I would a `CoffeeRecipe`, but the `CoffeeShackRecipe` instance will return both a `CoffeeOrder` instance and a `CoffeeShackRecipe` instance. I call `brew()` on the `CoffeeOrder`. Neat trick, no?    ## Structural Pattern Matching with Objects    Structural pattern matching, which was added in Python 3.10, supports matching objects in patterns by their attributes.    For example, I might have a class that represents a pizza, and I might want to perform structural pattern matching based on attributes in a given `Pizza` object:    ```", "```py    Listing 7-44: *pattern_match_object.py:1a*    In each pattern, I specify the object that I’m expecting the subject `order` to be—in this case, `Pizza`—and then I list the attributes of that object and the expected values thereof. For example, if `order.first` is `\"pepperoni\"` and `order.second` is `\"mushroom\"`, then I print `\"ANSI standard pizza\"`.    In the second case, you’ll see I don’t even need to specify an expected value for each attribute. If `order.first` is `\"pineapple\"`, then the message `\"Is this even pizza?\"` will be displayed, regardless of the second value. (However, I like pineapple on pizza! Sorry, not sorry.)    Capture patterns can come into play here, too. If the second topping is `\"cheese\"`, but the first is something else, I want to capture the first topping as `first`, so I can use the value in the case suite:    ```", "```py    Listing 7-45: *pattern_match_object.py:1b*    Here, if the value of `order.second` is `\"cheese\"`, then the value of `order.first` is captured as `first`, which I use in the message.    I’ll also use capture patterns to create a fallback case here:    ```", "```py    Listing 7-46: *pattern_match_object.py:1c*    Here, if none of the preceding patterns match, then I capture both `order.first` and `order.second` and use them to compose a generic message about the pizza.    This works well if you don’t mind typing out the names of the attributes. However, there are times when this feels redundant. For example, if you have a `Point` class that represents a point in three-dimensional space, it would feel a bit tedious to spell out *x*, *y*, and *z* every time:    ```", "```py    Listing 7-47: *point.py:1a*    That pattern feels pretty long for something, especially when most people would expect to specify a point in 3D space as *x, y, z*.    Instead of writing out the attributes every time, I can define the special `__match_args__` class attribute, which specifies how a pattern’s values map positionally to the object’s attributes:    ```", "```py    Listing 7-48: *point.py:1b*    I define `__match_args__` as a tuple of strings representing the attributes I want to map to positional values in pattern matching on the object. That is, the first positional value in the pattern maps to `x_pos`, the second maps to `y_pos`, and so on. Now, I can shorten my patterns by omitting the names of the attributes.    ## Functional Meets Object Oriented    As I’ve mentioned, functional and object-oriented programming can fit together very well. Here are the functional programming rules for methods (adapted slightly from the function rules in Chapter 6):    1.  Every method should do one specific thing. 2.  A method’s implementation should never affect other methods, nor should it affect the behavior of the rest of the program. 3.  Avoid side effects! A method should only directly mutate attributes belonging to its class, and only when that behavior is an expected part of the method’s purpose. 4.  In general, methods shouldn’t have (or be affected by) state, other than the attributes belonging to its class. Providing the same input should always yield the same output, unless the method’s expected behavior dictates otherwise.    To summarize all that in another way, the only state that methods should have is the attributes of their class or instance, and only when relying on that state is essential to the purpose of the method.    Don’t hesitate to use functional patterns in the context of object-oriented programming. Treat an instance like you would any other variable. Attributes should only be modified by their instance’s or class’s methods, called via the dot operator:    ```", "```py    When an object is passed to a function, it should not be mutated (no side effects):    ```", "```py    If you combine the rules of functional and object-oriented programming, your code will be much easier to maintain.    ## When to Use Classes    Unlike with class-centric languages such as Java and C#, it is not always necessary to write classes in Python. An important part of object-oriented programming in Python is to know when to use classes and when *not* to.    ### Classes Aren’t Modules    You shouldn’t use a class where a module will be sufficient. Python modules already allow you to organize variables and functions by purpose or category, so you don’t need to use classes in the same manner.    The purpose of a class is to bundle data with the methods responsible for accessing and modifying that data. Thus, your decision on whether to make a class should be based on the data. Do the attributes make sense as a cohesive object? Let the word *attribute* be the hint: is the data descriptive of the thing your object is attempting to represent?    Also, you should ensure that any methods included in the class directly relate to the attributes. In other words, think of methods as things the object can *do*. Any method that doesn’t fit this criteria doesn’t belong in the class.    Similarly, beware of how you structure classes. A `House` has a kitchen sink, but the attributes and methods relating to the kitchen sink belong in their own `KitchenSink` class, and an *instance* of said class belongs in the house. (This is a compositional relationship between the two classes.)    ### Single Responsibility    One of the essential rules in object-oriented programming is the *single-responsibility principle*. Just like a function, a class should have a single, well-defined responsibility. A function *does* something, while a class *is* something.    Avoid writing *god classes*, which try to do many different things in one class. Not only are these bug prone and difficult to maintain, but they also make for a very confusing code structure.    ### Sharing State    Class attributes and class methods allow you to write *static classes*, which provide one of the preferred ways to share state across multiple modules in your program. Static classes are cleaner and more predictable than global variables, and they are easier to write, maintain, and debug than the singleton design pattern. (And if you’ve never heard of singletons, all the better for you.)    The single-responsibility principle still applies here. For example, a static class containing current user preferences might make sense, but the current user profile shouldn’t be thrown into that same class.    ### Are Objects Right for You?    Just because you *can* write your entire program with classes and objects doesn’t mean you *should*.    Instead, you should reserve classes and objects for what they’re best at: *encapsulation*. Remember:    1.  Modules organize things by purpose and category. 2.  Functions perform tasks with provided data (arguments) and return values. 3.  Collections store cohesive sets of data, which are accessed predictably (see Chapter 9). 4.  Classes define objects, which contain attributes and related behaviors (methods).    Take the time to select the right tools for the job. When you do this, you’ll find that classes and objects complement modules, functions (and functional programming), and collections.    ## Wrapping Up    Depending on the language you come from, classes and objects are probably either your bread and butter or things you seldom use, if at all. In Python, you can’t get away from objects—everything is one, after all—but you do get to decide what role classes will play in your code.    In any case, whether you follow more traditional object-oriented programming techniques or favor a functional approach, Python classes provide a reliable way of organizing data. Properties make it possible to write getters and setters that look the same as accessing an ordinary attribute. Special methods even make it possible to create whole new data types that work with all of Python’s language features.    Objectively speaking, Python is one classy language.```", "```py`# 8 Errors and Exceptions  ![](Images/chapterart.png)  In many languages, exceptions are regarded as the archnemeses of programmers and the hallmarks of some degree of failure. Something, somewhere was used improperly! Python developers, on the other hand, recognize exceptions as friends that help write better code.    Python offers many familiar error-handling tools, but the way we use them may look different from what you’re used to. These tools can help you do more than clean up messes. You might even say, error handling in Python is “exceptional.”    I’ll start by demonstrating what exceptions look like in Python and how to read their accompanying messages. I’ll cover catching exceptions, handling them, and raising them. Then, I’ll show you how to leverage errors to control the flow of your program. Finally, I’ll give you a tour of the common exception types.    ## Exceptions in Python    If case *exceptions*, which are sometimes called *errors* in Python, are unfamiliar to you, here’s the general definition:    > exception: (computing) An interruption in normal processing, typically caused by an error condition, that can be handled by another part of the program. (Wiktionary)    Let’s start with a seemingly innocuous program: a number-guessing game. I’m only using concepts introduced in previous chapters, so see if you can spot the bug before I point it out.    First, I create a function that selects a random number, which the player will have to try to guess:    ```", "```py    Listing 8-1: *number_guess.py:1*    Next, I create a function that gets a guess from the user and outputs whether the number guessed was too high, too low, or correct:    ```", "```py    Listing 8-2: *number_guess.py:2a*    I return a boolean value to indicate whether the `guess` is correct or not.    The following function is responsible for running the game and tracking how many guesses the player has left:    ```", "```py    Listing 8-3: *number_guess.py:3*    I call the `play()` function when the module is executed directly, thereby starting the game:    ```", "```py    Listing 8-4: *number_guess.py:4*    If I test this game by playing it the normal way, everything seems to work as expected. Here’s my first playthrough:    ```", "```py    Our first instinct as programmers is to test things politely. We have a subconscious sense about what will cause the code to break, and we inherently tiptoe around those possible errors. However, if you’ve done any meaningful testing, you know the value of “doing horrible things to your code,” as Stack Overflow cofounder Jeff Atwood says.    Or, as programmer Bill Sempf puts it:    > QA Engineer walks into a bar. Orders a beer. Orders 0 beers. Orders 999999999 beers. Orders a lizard. Orders ‒1 beers. Orders a sfdeljknesv.    So, proper testing of this code involves throwing input to it that it doesn’t expect or understand, like so:    ```", "```py    Listing 8-5: Traceback from running *number_guess.py*    Eww, a bug! My program can’t handle numbers spelled out as words. Clearly, I need to do something about this.    ## Reading Tracebacks    That block of output you receive when an error occurs is called the *traceback*, and it tells you what went wrong and where. It includes the details of the error that occurred, the line where it happened, and the entire *call stack*—which contains the function calls leading directly from the main function to the error. The entire call stack will always be displayed; it is up to you to determine the location of the coding mistake.    I recommend reading tracebacks from the bottom up. Let’s take apart that traceback I received in [Listing 8-5](#listing8-5), piece by piece, starting from the final line:    ```", "```py    This tells you what went wrong. Specifically, a `ValueError` was raised because the value `'Fifty'` was passed to the `int()` function. The `with base 10` part has to do with the default value of the `base` parameter. In other words, Python can’t convert the string `'Fifty'` to an integer using the `int()` function.    This last line of the traceback is the single-most important. Always read and completely understand it before moving forward with fixing the bug!    The two lines above the error tell you precisely where the error occurred: in file `./number_guess.py`, on line 10, in the `make_guess()` function:    ```", "```py    Python even gives you the offending line in question, and sure enough, you can see the `int()` function wrapped around `input()`.    Sometimes, you can stop there and go fix the problem. In this case, the problem is right here. In other situations, the error may occur because of a mistake in the code further up in the call stack, such as passing bad data to a parameter. Even though I know that’s not the problem here, I’ll go up another step:    ```", "```py    You already know that the error is occurring in the `make_guess()` function, and that is being called from within `./number_guess.py`, on line 25, in the `play()` function. No problem here; the argument `target` had nothing to do with the error. Likewise, this part of the code can’t possibly have caused the error:    ```", "```py    Now I’m at the top of the traceback. The `play()` function is being called on line 35 of `./number_guess.py`, and the call isn’t occurring inside of any function; rather it’s coming from the module scope, as indicated by `<module>`.    That first line is always the same, but it’s a useful reminder if you ever forget how to read a traceback properly:    ```", "```py    The most recently executed code is always listed last! Thus, as I’ve said before, always read tracebacks from the bottom up.    ## Catching Exceptions: LBYL vs. EAFP    In many languages, the common practice is to test the input before trying to convert it to an integer. This is known as the *Look Before You Leap (LBYL)* philosophy.    Python has a different approach, officially known as *Easier to Ask Forgiveness than Permission (EAFP)*. Instead of preventing errors, we embrace them, using `try` statements to handle exceptional situations.    I’ll rewrite my `make_guess()` function to use error handling:    ```", "```py    Listing 8-6: *number_guess.py:2b*    I initially set the value of `guess` to `None`, so that as long as I don’t have something usable assigned to guess, I keep prompting the user for input. I use `None` instead of `0`, since `0` is still technically a valid integer.    On each iteration of the loop, in the context of `try`, I attempt to get the user input and convert it to an `int()`. If that conversion fails, `int()` will raise a `ValueError`, as you saw earlier.    If `ValueError` is raised, it can only mean that the user entered some non-numeric input, such as `'Fifty'` or an empty string. I catch that error and handle the situation by printing an error message. Because `guess` is still `None`, the entire loop repeats to prompt for input again.    If `int()` is successful, no further action is taken in this section of code, and I move on to the rest of the function. The so-called *happy path*, the one with no errors, is efficient.    To understand why the EAFP approach is the preferred error-handling philosophy, compare it to the LBYL strategy. Here’s the LBYL approach to confirming that the string only contains digits:    ```", "```py    Listing 8-7: *number_guess.py:2c*    While this code is perfectly valid, it’s not very efficient. I run `isdigit()` on *every single guess*, whether it’s erroneous or not, and then I run the `int()` conversion if it passes the test. Thus, I process the string in `guess` *twice* on the happy path, and once in the case of an error. Contrast this with the EAFP strategy with the `try` statement from earlier, where I only ever process the string once.    Some will complain, “Yes, but, error handling is expensive!” True, but only on the exceptions. A successful try typically has very little overhead in Python. The extra code for handling special cases is run when an error occurs. If you’ve designed your code right, the happy path should be far more common than the exceptional path, such as in the example above.    The EAFP approach is also easier to think about. Instead of coming up with tests to anticipate every possible erroneous input—an arduous task in more complex, real-world scenarios—you only need to anticipate the likely exceptions, catch them, and handle them accordingly. That said, it can sometimes take some real effort to figure out what errors to expect. Be prepared to invest time here, either way.    ## Multiple Exceptions    The `try` statement is not limited to a single error type. I can handle multiple scenarios in one compound statement.    To demonstrate this, I’ll create a simple, callable `AverageCalculator` class that will accept a list of inputs and use them to recalculate a stored running average:    ```", "```py    Listing 8-8: *average_calculator.py:1*    There are a few possible errors that can occur while using this `AverageCalculator` class, but I’d prefer to let the user interface code handle those, so they can be used for displaying error messages.    Here’s a basic command line interface for the calculator:    ```", "```py    Listing 8-9: *average_calculator.py:2*    There are three errors that can occur when calling `average()`:    1.  The user might pass no values, meaning `total` (the divisor of the division in `__call__()`) might be zero and thus raise a `ZeroDivisionError` ❶. 2.  One or more of the inputs might not be convertible by `float()`, thus raising a `ValueError` ❷. 3.  There might be a problem encoding or decoding Unicode, which will raise a `UnicodeError` ❸. (Actually, that last one is entirely redundant with `ValueError` in this case; I’m only including it to demonstrate the concept.)    I handle all three exceptional cases by calling `average()` within the `try` clause’s suite and then catching the errors in the `except` clauses.    When a `ZeroDivisionError` is caught ❶, I print that no values were provided by the user.    I handle the `ValueError` ❷ and the (redundant) `UnicodeError` ❸ in the same way; either error would occur if the user tried inputting something non-numeric. By specifying both in a tuple after `except`, I catch either error and handle both the same way—in this case, by printing a message that some inputs weren’t numeric.    To demonstrate this in a reasonably contained example, I’ve written slightly convoluted code here. In the real world, I’d place the `try` statement within the `__call__()` method itself. While this example code departs from idiomatic Python, it demonstrates a more complex `try` statement, albeit without any truly useful error-handling behavior (which I’ll get to shortly).    ## Beware the Diaper Anti-pattern    Sooner or later, every Python developer will discover that a bare `except` clause will work:    ```", "```py    Listing 8-10: *diaper_antipattern.py*    Here, a bare `except` allows you to catch all exceptions in one. This is one of the most insidious anti-patterns in Python. It catches and silences literally every conceivable exception, whether you expect it to or not.    The entire point of an exception is to alert you that your program is now in an *exceptional state*, meaning it can no longer proceed along the ordinary, intended happy path without unexpected or even disastrous results. By silencing every error, you have created a situation where you have no idea what those exceptional states are or what is causing them. You’ve thrown away your precious traceback and forced the program to continue as if nothing had happened.    In his book *How to Make Mistakes in Python*, Mike Pirnat calls this the *diaper pattern*:    > [A]ll the precious context for the actual error is being trapped in the diaper, never to see the light of day or the inside of your issue tracker. When the “blowout” exception occurs later on, the stack trace points to the location where the secondary error happened, not to the actual failure inside the try block.    Worse yet, if your program never raises another exception but keeps attempting to work in its invalid state, weird behavior will often abound.    Instead, always explicitly catch a particular exception type! Any error that you cannot foresee is probably related to some bug that needs to be resolved.    As usual, The Zen of Python has something to say about this:    > Errors should never pass silently. >  > Unless explicitly silenced.    There’s another diabolical side effect of this anti-pattern, which I can demonstrate with this simple program for greeting someone by name:    ```", "```py    Listing 8-11: *no_escape.py:1a*    If I were running this program in the Linux terminal and decided I wanted to quit, I’d press Ctrl-C. Look what happens when I do exactly that:    ```", "```py    Ack! I’m trapped! The trouble is, the `KeyboardInterrupt`, which is produced by pressing Ctrl-C on a UNIX terminal, uses the `except` system. It’s getting caught, “handled,” and utterly ignored. There’s no escape from this program, except to kill my terminal altogether and manually kill the Python process. (Thankfully in this example, you can still quit by typing a name.)    The `KeyboardInterrupt` exception does not itself inherit from the `Exception` class, like errors do. Thus, some (overly) clever developer might try this:    ```", "```py    Listing 8-12: *no_escape.py:1b*    I’m no longer catching `KeyboardInterrupt`, which is good, so I can now escape with Ctrl-C. Unfortunately, this is still a form of the *diaper anti-pattern*, for the reasons I mentioned earlier: it catches every conceivable error! The one time this might be acceptable would be in conjunction with logging, which I’ll address later in this chapter.    ## Raising Exceptions    You can also *raise* exceptions to indicate the occurrence of a problem that your code cannot recover from automatically, such as when someone calling a function you wrote passes an unusable argument. There are several dozen common exceptions available for you to raise as needed (see “A Gallery of Exceptions” near the end of this chapter).    To demonstrate this, here’s a function that accepts a string containing numbers (separated by spaces) and calculates the average. Here, I’m catching the most common error scenario and providing a more useful and relevant error:    ```", "```py    Listing 8-13: *average.py:1*    I split the provided string into the individual space-separated parts, looping through each part. Within a `try` clause ❶, I attempt to convert each part to a floating-point number and add it to the `total` accumulator. If any of the values cannot be converted to a number, thereby raising a `ValueError` ❷, I mark that I’ve skipped an item, and I move on.    I continue with that function:    ```", "```py    Listing 8-14: *average.py:2*    Once I’ve processed the string, I check whether I’ve skipped all the values ❸. If I have, I’ll `raise` another `ValueError`, passing my error message to the constructor of the exception. Otherwise, if only some of the values have been skipped, I’ll print a helpful message and move on.    Raising an exception breaks out of the function *immediately*, in the same manner as a `return` statement. Thus, I don’t need to worry about the final `return` statement being run if I have no values (such as if the user passed in an empty string).    The usage of that function is as follows:    ```", "```py    Listing 8-15: *average.py:3a*    I’ll run that code and try some inputs:    ```", "```py    The first input works just fine, returning the average of the four numbers I specified.    ```", "```py    The second input works as well, skipping my two invalid values and returning the average of the other two.    ```", "```py    The third input contains no valid numbers, so it crashes the program, which is exactly what I wanted. Reading the traceback, you can see the exception I raised earlier and where I raised it from.    I wouldn’t ship a program like this, so I can, in turn, catch the exception I raised. I’ll rewrite my infinite loop at the bottom of the program, like so:    ```", "```py    Listing 8-16: *average.py:3b*    I wrap the user input/output logic in a `try` clause, and then I catch the `ValueError` and print a nice message instead. Let’s try out this new version:    ```", "```py    Perfect! When the input is bad, the exception I raised inside the `average()` function is caught here, and the appropriate message is printed. (I can press CTRL-C to quit.)    ## Using Exceptions    Like everything else in Python, exceptions are objects that you can both use directly and extract information from.    You can, for example, use exceptions to handle the logic of accessing values from a dictionary, without knowing in advance whether the key you specified is valid. (There’s some debate about whether and when to use this approach, which I’ll revisit in Chapter 9.)    As an example of using exceptions with dictionaries, here’s a program that allows a user to look up an email address by a person’s name.    I start by defining a dictionary containing names and email addresses:    ```", "```py    Listing 8-17: *address_book.py:1*    Here is my lookup function:    ```", "```py    Listing 8-18: *address_book.py:2*    I start by trying to use the `name` argument as a key on my dictionary, within the context of a `try` clause. If the key is not in the dictionary, a `KeyError` will be raised, which I’ll catch. I capture said exception with `as e` ❶, allowing me to use the exception object later. In the case of a `KeyError`, `str(e)` will return the value that I just tried to use as a key in the dictionary.    Finally, here’s the code using that function:    ```", "```py    Listing 8-19: *address_book.py:3*    If I run this code and pass a name that isn’t in my dictionary, I see the result of the error handling:    ```", "```py    ### Exceptions and Logging    An unusual aspect of `KeyError` is that its message consists purely of the erroneous key. Most exceptions contain their complete error message, one use of which is *logging*, wherein errors, warnings, and other informational messages are printed to the terminal or saved to a file for inspection by the end user, in case of bugs. Users expect programs to behave well and not crash, but errors aren’t always avoidable. It’s common for software to log errors to a file or the terminal, to aid in debugging crashes and bugs.    To demonstrate this, I’ll write a very basic calculator program, which is intended to demonstrate the concept without getting too deep into the logging tools and practices themselves. I’ll cover logging more thoroughly in Chapter 19.    #### Logging Configuration    My calculator program will need a few imports that may be unfamiliar to you:    ```", "```py    Listing 8-20: *calculator.py:1*    The `logging` module contains Python’s built-in logging tools, which I’ll use in a moment. The `operator` module contains optimized functions for performing mathematical operations on arbitrary values, which I’ll use in my calculator function. Third, `sys` provides tools for interacting with the interpreter itself; in my case, I’ll use one of its functions later on to tell my program to exit.    The `logging.basicConfig()` function allows me to configure my logging level, as well as specify things like which file to write the log to:    ```", "```py    Listing 8-21: *calculator.py:2*    There are five increasing severity levels of logging: `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL`. By passing `level=logging.INFO`, I’m telling the logging module to log all messages of that level, as well as the three severity levels above it (`WARNING`, `ERROR`, and `CRITICAL`). That means only log messages marked as `DEBUG` are ignored on this setting.    With the argument `filename=log.txt`, I also specify that the log should be written to a file called *log.txt*. I could also leave this blank if I wanted to print the log to the console instead.    Here is my actual `calculator()` function:    ```", "```py    Listing 8-22: *calculator.py:3*    The math operator functions, such as `add()` ❶, are coming from the `operator` module I imported earlier.    The `calculator()` function doesn’t perform error checking by design, according to the *single-responsibility principle* from Chapter 7. Code that uses the `calculator()` function should provide the right arguments to the function, anticipate and handle the errors itself, or crash with an explicit unhandled error (thereby indicating the code is erroneous).    There is one exception (no pun intended). If the user specifies an operator in the `op` parameter that I don’t support in my `calculator()` function, I raise `NotImplementedError` ❷. This exception should be raised anytime functionality that doesn’t exist is requested.    #### Logging Errors    The following is my usage of the `calculator()` function, along with all the error handling and logging code. I’ll break this down into several pieces and discuss each separately:    ```", "```py    Listing 8-23: *calculator.py:4*    First, I print the program name and some user instructions. Then, in my program loop ❶, within a `try` ❷, I attempt to collect the input from the user and pass it to the `calculator()` function. If that works, I print the result, and the loop starts over. However, there are a number of errors that can occur, and I handle them in my `except` clauses:    ```", "```py    Listing 8-24: *calculator.py:5*    If I encounter the `NotImplementedError`, which I capture as a usable object with `as e`, it means an invalid operator was specified in the `op=` argument passed to `calculator()`. After printing some information for the user, I log this (as level `INFO`) by passing the error, `e`, to the `logging.info()` function. That logs the error message (which you’ll see in a moment), but it throws away the traceback, which I do not need to show to the program’s user, since the problem was their input.    ```", "```py    Listing 8-25: *calculator.py:6*    The `ValueError` is raised if `float()` was not able to convert the arguments `a` or `b` to floating-point numbers. That might mean that the user entered non-numeric characters for one of the operands, or that the operator was specified in the wrong order. Remember, I ask the user for *postfix notation*, meaning the operator comes after the two operands. In either case, I remind the user of the format they need to use, and once again, I log the error to level `INFO`:    ```", "```py    Listing 8-26: *calculator.py:7*    The `TypeError` shows up if the user passes either too many or too few arguments to the `calculator()` function. Once again, I log this as level `INFO`, print a reminder for the user about the proper format of input, and move on:    ```", "```py    Listing 8-27: *calculator.py:8*    If the user tries to divide by zero, it raises the error `ZeroDivisionError`. Handling that error is, again, a matter of logging to `INFO` and notifying the user:    ```", "```py    Listing 8-28: *calculator.py:9*    Lastly, I use `KeyboardInterrupt` and `EOFError` to catch the UNIX terminal keystrokes Ctrl-C (abort) and Ctrl-D (end of file), respectively. In either case, I print a friendly farewell message and then use `sys.exit(0)` to properly quit the program. Technically, I could have left both of these uncaught, but that would have resulted in an ugly error message appearing upon quitting the program. That might scare some users into thinking there’s a bug in the program.    I’ll run this program now and try things out:    ```", "```py    All in all, this is a clean user experience. All the errors I’ve anticipated are being caught and handled appropriately, and I can quit nicely.    #### Reviewing the Logs and Cleaning Up    Take a look at the *log.txt* file that’s been created:    ```", "```py    Listing 8-29: *log.txt*    Here are all five of the error messages that were logged while I used the program.    Practically speaking, in production software, I’d never write any of the expected errors to a file, because it would result in a huge and unwieldy file! Thus, I might change all my logging commands to `logging.debug()`, to log the error messages at the `DEBUG` level. That way, if I were to need to peruse the errors during debugging, I’d only need to change my logging configuration to `logging.basicConfig(filename='log.txt', level=logging.DEBUG)`. I’d ship with a logging level of `INFO`, thereby suppressing the `DEBUG` messages. That way, the end user wouldn’t see a bloated log.    ### Bubbling Up    There’s one nonoptimal part of the logging scheme I’ve created: any unexpected errors won’t get logged. Ideally, any exception I haven’t anticipated should be logged at level `ERROR` but still be allowed to crash the program, so the code doesn’t try to carry on in an unhandled exceptional state.    Thankfully, any error you catch can be re-raised, or *bubbled up* in Python terminology. Since the error isn’t caught again after being re-raised, the program will crash.    I’m leaving the rest of the earlier `try` statement the same (Listings 8-23 through 8-28), but I’m adding one more `except` to the end:    ```", "```py    Listing 8-30: *calculator.py:10*    The `except` clauses are evaluated in order, which is why this new clause has to appear at the end of the current `try` statement. I don’t want this “catch-all” to gobble up the exceptions I specifically want to handle separately.    This may seem dangerously close to the diaper anti-pattern, except here, I don’t hide the error, and I’m only catching *actual errors*—that is, any object that inherits from `Exception`. Non-error “exceptions” like `StopIteration` and `KeyboardInterrupt`, which don’t inherit from `Exception`, won’t get caught by this `except` clause.    I log the error message, *along with the traceback*, at `ERROR` level, using the special method `logging.exception(e)`. When the user sends me the log file with his bug report, I, the developer, will need this traceback to find and fix the bug.    Then, I bubble up the error with a bare `raise` statement, which raises the *last-caught* exception ❶. (I could also have done `raise e`, but the bare `raise` is preferred in this context for brevity in my code and traceback.) It is *absolutely essential* that I bubble up the error here, lest this become a case of the diaper anti-pattern.    ### Exception Chaining    When you catch one exception and then raise another, you’re at risk of losing the context of the original error. To avoid this situation, Python offers *exception chaining*, whereby you can raise a new exception without throwing away all the helpful information already provided. This feature was added in Python 3.0 (via PEP 3134).    I’ll apply this concept to a program for looking up the city and state of famous landmarks. I start by defining the dictionaries for the program:    ```", "```py    Listing 8-31: *landmarks.py:1*    Here is the function for looking up landmarks and their corresponding cities in the dictionaries:    ```", "```py    Listing 8-32: *landmarks.py:2*    In this function, I try to find the landmark in the `landmarks` dictionary. If it’s not there, a `KeyError` is raised, which I catch ❶ and then re-raise with more useful information in the error message ❷. When I raise the new exception, I use `from e` to specify that it was caused by the exception (`e`) I caught. This ensures that the traceback shows what led to the error: either the city or the landmark not being found.    Here’s an example usage of this function:    ```", "```py    Listing 8-33: *landmarks.py:3*    I test the `lookup_landmark()` function by looking up three landmarks, two of which (`\"alamo\"` and `\"golden gate bridge\"`) are going to throw an exception, but for different reasons. In the case of the Alamo, although the landmark is in the `landmarks` dictionary, the corresponding city of \"`SAN ANTONIO`\" is missing from the cities dictionary. In the case of the Golden Gate Bridge, the landmark isn’t even in the `landmarks` dictionary. (Sorry, San Francisco!)    The code as written won’t get to the last line, because the second-to-last line will throw an exception, as you’ll see in the output:    ```", "```py    The first call to `lookup_landmark()` works, as you can see from the output. Remembering that you read traceback from the bottom up, you see that the second call fails, raising the `\"Landmark not found\"` error ❸.    Above that traceback is a notification that the exception was caused by a different exception ❷.    Sure enough, in the traceback above that, you find the problem; Python couldn’t find the city of `\"SAN ANTONIO\"` in the `cities` dictionary ❶.    Even if I hadn’t taken the time to add `raise KeyError from e` earlier, Python would ordinarily have included the context, although the two tracebacks would have been separated with a message I consider far more cryptic and less helpful:    ```", "```py    So, even though you might be able to get away without explicit exception chaining, it’s just a good habit to take on.    ## Else and Finally    Up to this point, all my error handling examples have relied on `try` and `except`, which leaves the rest of the code to run the same in any case, whatever happens, unless I call `return` or take advantage of the breaking behavior of a `raise` statement to bail out of a function.    There are two more optional clauses for `try` statements: `else` runs if there is no exception, and `finally` runs in any situation, but in a surprising way.    ### Else: “If All Goes Well”    You would use the `else` clause for any section of code that should only run if none of the `except` clauses caught anything.    To demonstrate this, I’ll revise my program for finding the average of a list of numbers. This time, I want it to always output a valid `float` value. The average of an empty string should be the constant `math.inf` (the result of division by zero), and the presence of any non-numeric values should produce the constant `math.nan`.    ```", "```py    Listing 8-34: *average_string.py:1*    Every time the `average_string()` function is called, it first tries to create a list of `float` values. If any part of the string is non-numeric, a `ValueError` is raised. I catch that exception, assign the value `math.nan` to `total`, and ensure there is a `1` in `values`, which I will use as the divisor in the upcoming division.    If no exception was raised by that first `try` clause, the `else` clause is run:    ```", "```py    Listing 8-35: *average_string.py:2*    The `total` and `values` are calculated based on the now-valid assumption that `numbers` is a list of `float` values. *The* `else` *clause only runs if the* `try` *raises no exceptions.*    So, why not just return `math.nan` in the `except ValueError` clause? That would certainly be a bit more efficient, but there are two reasons I chose not to do that:    1.  This approach better accommodates later refactoring; the rest of the math is always executed, and it always produces a valid result (except for the division-by-zero scenario I handle separately in the next part of the code). 2.  If I need to add a `finally` clause anywhere, the code will still behave as expected (see next section).    Here’s the rest of the program. Notice that I have a separate `try` statement to handle attempted division by zero:    ```", "```py    Listing 8-36: *average_string.py:3*    I’ve handled all of the exceptional paths that could be reasonably anticipated in the code. Testing this out, everything behaves as expected, with no unhandled exceptions.    ```", "```py    ### Finally: “After Everything”    The `finally` clause is always executed, no matter what! There aren’t any exceptions to this: even `raise` or `return` will not prevent the `finally` clause from being executed. This is what sets `finally` apart from plain code after the `try` statement.    Because of this, `finally` is especially well-suited for any cleanup code you need to run, *no matter what*.    Here’s a function that reads numbers from a file, one number per line, and finds the average. In this case, I want exceptions to be raised if the file contains non-numeric data or if the file cannot be found.    For this example, I’ll use manual opening and closing of a file—although in production, I’d use a *context manager* for this instead (see Chapter 11).    ```", "```py    Listing 8-37: *average_file.py:1*    When the `average_file()` function is called, it attempts to open the file indicated by the argument `path`. If this file doesn’t exist, `file.open()` will raise a `FileNotFoundError` exception, which I’m allowing as is, in this case.    Once the file is opened, I try to iterate over it, converting it into a list of numbers ❶. (You’re welcome to take this particular line of code for granted for now. See Chapters 10 and 11.)    ```", "```py    Listing 8-38: *average_file.py:2*    If any of the values are non-numeric, I catch the `ValueError`. In this clause, I raise a chained exception with more specific information describing what was wrong with the file.    Otherwise, if no errors were raised by the `try` clause, the `else` clause runs:    ```", "```py    Listing 8-39: *average_file.py:3*    This clause’s suite attempts to calculate and return the average, but it also contains a nested `try` statement to handle an empty file.    After either the `except` or the `else` clause has run, the `finally` clause is always executed, *even after a* `raise` *or* `return`! This is important, because no matter the outcome, the file needs to be closed:    ```", "```py    Listing 8-40: *average_file.py:4*    I’ll test the program with four files, three of which I’ve created: a file containing integers called *numbers_good.txt*, a file containing words called *numbers_bad.txt*, an empty file called *numbers_empty.txt*, and a nonexistent file called *nonexistent.txt*.    Let’s examine the output of these four scenarios one by one. These have to be run separately, because the program execution ceases when an exception is raised:    ```", "```py    Listing 8-41: *average_file.py:5a*    The file *numbers_good.txt* contains 12 integers, each on a separate line. Running that scenario, I get the following output:    ```", "```py    The function works correctly; it opens the file and calculates the average of the values. Notice when the `finally` clause runs, as evidenced by the printed message \"`Closing file.`\" Although it is running *after* the `return` statement in the `average_file()` function from earlier, it appears *before* the function returns. This is a good thing, because the `finally` clause in this function is responsible for closing the file, which absolutely *must* happen.    Now for the second scenario:    ```", "```py    Listing 8-42: *average_file_usage.py:5b*    The *numbers_bad.txt* file contains words, not numbers. This output is a lot longer because of the exception:    ```", "```py    In this case, a `ValueError` is raised. Yet, once again, the `finally` clause is run ❶ before the exception is raised, even though the `raise` statement seems to come first in the function’s source code.    Here’s the third scenario:    ```", "```py    Listing 8-43: *average_file_usage.py:5c*    The file *numbers_empty.txt* is, as its name suggests, an empty file. The output is as follows:    ```", "```py    You can see that the error message about the empty file is working as well ❷. Also, as before, it is evident the `finally` clause is running ❶ before the exception is raised.    Now for the last scenario:    ```", "```py    Listing 8-44: *average_file_usage.py:5d*    This is attempting to read from a file that *doesn’t exist*. Here’s the output of that scenario:    ```", "```py    This exception comes from the `file.open()` call, which, if you refer back to the source code for `average_file()`, you’ll notice occurs *before* the `try` statement. The `finally` clause only runs if its connected `try` clause is executed; since control flow never reached the `try`, the `finally` never gets called. Just as well, since there’s no point in trying to close a file that was never opened.    ## Creating Exceptions    Python has quite the menagerie of exceptions, and their uses are very well documented. Sometimes, however, you need something a bit more customized.    All error-type exception classes inherit from the `Exception` class, which in turn inherits from the `BaseException` class. This dual hierarchy exists to let you catch all error exceptions, as I did earlier, without also reacting to the special, non-error exceptions like `KeyboardInterrupt`, which inherit from `BaseException` and not `Exception`.    When making a custom exception class, you can inherit from any exception class you like. However, avoid inheriting from `BaseException`, as that class is not designed to be directly inherited from by custom classes. Sometimes, it’s best to inherit from the exception class that is closest in purpose to the one you’re making (see the next section). However, if you’re at a loss, you can inherit from `Exception`.    Before going through all the effort to write a custom exception, consider why you *want* to. My recommendation is to ensure your use case fits at least two of these three criteria:    1.  No existing exception effectively describes the error, even if you provide a custom message. 2.  You will raise or catch the exception more than once. 3.  You need to be able to catch this specific exception, without catching any of the similar built-in exceptions.    If your use case cannot satisfy at least two of these criteria, you *probably* don’t need a custom exception and can instead use one of the existing exceptions.    Most of the time, the need for custom exceptions arises in more complicated projects, so it’s very difficult to create a practical example for this. For demonstration purposes, here’s the code for a uselessly simple and rather silly custom exception and its usage:    ```", "```py    Listing 8-45: *silly_walk_exception.py*    I define a new class with the name of the exception ❶, and I inherit from the most *specific* exception class that makes sense ❷. In this case, I’m inheriting from `RuntimeError` because my exception doesn’t fit into the description of any of the other built-in exceptions.    There’s some debate about whether it’s necessary to write an initializer for custom exceptions. I prefer to, because it provides an opportunity to specify a default error message ❸. Writing your own initializer also allows you to accept and store multiple parameters for various bits of information, not just the message attribute that all `Exception` classes must have (although I don’t do that here).    If you accept a string for a message and don’t want to provide a default, you can get away with this version to define the custom exception class with nothing more than a header and a docstring:    ```", "```py    Either way, the custom exception can be raised ❹ and caught ❺ in the same way as any other exception.    ## A Gallery of Exceptions    The Python documentation provides an exhaustive list of all the built-in exceptions and their uses. You can find this list at [https://docs.python.org/library/exceptions.html](https://docs.python.org/library/exceptions.html).    However, since that documentation can feel like an information dump, I’ll briefly cover the most common exception classes. There are four base classes from which all the other exceptions are inherited; when you need to catch an entire category of exceptions, you can often use these:    1.  `BaseException` is the base class for all exceptions. Remember not to inherit directly from this; it’s not designed to be used as such. 2.  `Exception` is the base class for all error-type exceptions. 3.  `ArithmeticError` is the base class for arithmetic-related errors. 4.  `LookupError` is the base class for any error related to finding values in collections.    Next, after the base exception classes, come the *concrete exceptions*, each of which describes a particular type of error. As of this writing, there are 35 concrete exceptions in the Python language, although I’m only covering some of the most common of these (see the documentation for the rest). A few others will be introduced in later chapters. All of these inherit directly from `Exception`, except as noted:    1.  `AttributeError` is raised when accessing or assigning to a class attribute that doesn’t exist. 2.  `ImportError` is raised when an `import` statement isn’t able to find a package, module, or a name within the module. You may also encounter the subclass exception `ModuleNotFoundError`. 3.  `IndexError` is raised when an index (subscript) is out of range for a sequential collection, such as a list or tuple. This inherits from `LookupError`. 4.  `KeyError` is raised when a key is not found in a dictionary. This inherits from `LookupError`. 5.  `KeyboardInterrupt` is raised when the user presses a key-key combination to interrupt the running program, such as with Ctrl-C on UNIX-like systems. This inherits from `BaseException`, not `Exception`. 6.  `MemoryError` is raised when Python runs out of memory. However, there are still steps you can take to (probably) fix the problem, usually by deleting stuff. 7.  `NameError` is raised when a name is not found in the local or global scope. This isn’t used in relation to class attributes (see `AttributeError`) or imports (see `ImportError`). 8.  `OSError` is both a concrete error and a base class for many exceptions relating to the operating system, including `FileNotFoundError` (which is raised when a file cannot be opened). I’ll explore some of these in later chapters. 9.  `OverflowError` is raised when an arithmetic operation would produce a result that is too large to be represented or stored. This mainly occurs with floating-point numbers. Integers never raise `OverflowError`, because they have no official size limits in Python; they will raise a `BufferError` if a similar situation occurs. This inherits from `ArithmeticError`. 10.  `RecursionError` is raised when a function calls itself too many times (see Chapter 6), whether directly or indirectly. This inherits from `RuntimeError`. 11.  `RuntimeError` is a sort of catch-all for any error that doesn’t fit into the other categories. 12.  `SyntaxError` is raised if there are any syntax errors in the Python code. These often come up when you run your program, but you may encounter them at any point during runtime when using arbitrary execution (see Chapter 15). This also includes the subclasses `IndentationError` and `TabError`. 13.  `SystemError` is raised when the interpreter has an internal error. There’s not much you can do about these errors; report them to the developers of the Python implementation you use. 14.  `SystemExit` is raised when `sys.exit()` is called. Be careful about catching this, as you can prevent your program from quitting normally! This inherits from `BaseException`. 15.  `TypeError` is raised when an operation or function tries to act on an object of the wrong type. This is the best exception to raise if your function is not intended to work on a particular value type received as an argument. 16.  `UnboundLocalError`, a subclass of `NameError`, is raised when you try to access a local name that has no value yet assigned to it. This inherits from `NameError`. 17.  `ValueError` is raised when an operation or function tries to act on an argument that is the right *type*, but the wrong *value*. 18.  `ZeroDivisionError` is raised when trying to divide by zero, whether through the true division (`/`), floor division (`//`), modulo (`%`), or `divmod()` operators. This inherits from `ArithmeticError`.    ## Wrapping Up    I’ve spent a lot of time discussing how and when to use exceptions and error handling. This is a vast topic, yet the syntax itself boils down to the structure of `try`, `except`, `else`, `finally`, and the `raise` keyword.```"]