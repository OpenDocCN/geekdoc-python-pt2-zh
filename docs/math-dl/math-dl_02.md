## **2

PROBABILITY**

![image](Images/common.jpg)

概率影响着我们生活的方方面面，但实际上，我们在这方面做得都不好，正如本章中的一些例子所展示的那样。我们需要学习概率，以便正确理解它。而我们之所以需要弄明白它，是因为深度学习广泛涉及概率论中的一些概念。概率无处不在，从神经网络的输出到不同类别在现实世界中出现的频率，再到用于初始化深度网络的分布。

本章的目标是让你接触到在深度学习中你会经常遇到的与概率相关的概念和术语。我们将从关于概率的基本概念开始，并介绍随机变量的概念。接着，我们将进入概率的规则。这些内容涵盖了基本概念，为我们接下来讨论*联合概率和边际概率*打下基础。你将在深度学习的探索过程中反复遇到这些术语。一旦你理解了如何使用联合概率和边际概率，我将解释书中讨论的两个链式法则中的第一个。第二个将在[第6章](ch06.xhtml#ch06)的微积分部分讲解。我们将在[第3章](ch03.xhtml#ch03)继续学习概率。

### 基本概念

一个*概率*是介于零和一之间的数字，用来衡量某件事发生的可能性。如果某件事不可能发生，它的概率是零。如果它肯定会发生，它的概率是1。我们通常会这样表示概率，尽管在日常使用中，人们似乎不喜欢说像“明天下雨的概率是0.25”这样的话。相反，我们会说“明天下雨的概率是25%”。在日常语言中，我们将分数概率转换为百分比。在本章中，我们也会采用这种方式。

前面一段话使用了与概率相关的多个词汇：*可能性*、*机会*和*确定性*。在日常使用中这样说没有问题，甚至在深度学习中也能接受，但当我们需要明确表达时，我们会坚持使用*概率*，并将其以数字形式表示，范围为零到一，[0, 1]。方括号表示上限和下限都包含在内。如果范围内不包含某个限值，则使用普通括号。例如，NumPy 函数 np.random.random() 返回一个在[0, 1)范围内的伪随机浮动数。所以，它可能返回零，但永远不会返回一。

接下来，我将介绍样本空间、事件和随机变量的基础概念。最后，我会给出一些例子，说明人类在概率方面的不足。

#### 样本空间和事件

简而言之，*样本空间*是一个离散集合或连续范围，表示事件的所有可能结果。*事件*是某个发生的事情，通常是某种物理过程的结果，比如抛硬币或掷骰子。我们将所有可能的事件汇总在一起，构成我们正在使用的样本空间。每个事件都是样本空间中的一个*样本*，样本空间代表着*所有*可能的事件。让我们来看几个例子。

抛硬币的可能结果是正面（H）或反面（T）；因此，硬币抛掷的样本空间是集合{H, T}。标准骰子的抛掷样本空间是集合{1, 2, 3, 4, 5, 6}，因为如果不考虑骰子停在边缘的情况，骰子停下时其六个面中的一个会朝上。这些是离散样本空间的例子。在深度学习中，大多数样本空间是连续的，包含的是浮点数，而不是整数或集合的元素。例如，如果神经网络的一个特征输入可以取[0, 1]范围内的任何值，那么[0, 1]就是该特征的样本空间。

我们可以询问某些事件发生的可能性。对于硬币，我们可以问，硬币翻转时正面朝上的可能性是多少？直观地说，假设硬币没有加权使得某一面比另一面更可能出现，我们可以说正面朝上的可能性是50%。因此，正面朝上的概率是0.5（50%的百分比）。我们可以看到，反面朝上的概率也是0.5。最后，由于正面和反面是唯一的可能结果，我们看到所有可能结果的概率总和是0.5 + 0.5 = 1.0。概率*总是*在所有可能的样本空间值上加起来为1.0。

掷一个六面骰子得到四点的概率是多少？同样，骰子的每个面都有相同的可能性，且六个面中只有一个面有四个点，所以概率是六分之一，1/6 ≈ 0.166666 . . . 或大约17%。

#### 随机变量

让我们用一个变量*X*表示硬币翻转的结果。*X*是所谓的*随机变量*，它从样本空间中取值，并具有一定的概率。由于这里的样本空间是离散的，*X*是一个*离散随机变量*，我们用大写字母表示。对于硬币，*X*是正面的概率等于*X*是反面的概率，都是0.5。为了正式写出这个公式，我们使用

*P*(*X* = 正面) = *P*(*X* = 反面) = 0.5

其中，*P* 是表示指定随机变量事件的概率的符号，通常用于括号内的事件概率。*连续随机变量*是指来自连续样本空间的随机变量，用小写字母表示，比如 *x*。我们通常讨论的是随机变量位于样本空间某一范围内的概率，而不是某个特定的实数。例如，如果我们使用 NumPy 的随机函数返回 [0, 1) 区间内的值，我们可以问：它返回值位于 [0, 0.25) 区间的概率是多少？由于任何数字出现的概率都是相等的，我们可以说，位于该区间的概率是0.25或25%。

#### 人类在概率方面很差

我们将在下一节深入探讨概率的数学。然而，在此之前，让我们来看两个涉及概率的例子，这些例子展示了人类在概率上的误判。两个例子都让专家们困惑，不是因为专家们有什么缺陷，而是因为我们对概率的直觉通常是完全错误的，即使是专家也难以避免这一点。

##### 蒙提霍尔难题

这个问题是我特别喜欢的一个问题，因为它甚至让具有高级学位的数学家感到困惑。这个难题来源于一个老的美国游戏节目，叫做*让我们做交易*。节目原主持人蒙提·霍尔会从观众中选择一位成员，并展示三个标有1、2、3的大门。在其中一扇门后面是辆新车，另外两扇门后面是一些笑话奖品，比如一只活山羊。

参赛者被要求选择一扇门。然后，霍尔会要求打开参赛者*没有*选择的那扇门，显然是没有车的那扇门。当观众停止为那扇门后面的笑话奖品发笑后，霍尔会问参赛者是否想保持原来选择的门，还是想换到剩下的那扇门。这个难题就是这么简单：他们是保持原来的选择，还是换到剩下的那扇门？

如果你想思考一会儿，随意。放下书本，走走，拿出铅笔和纸，做些笔记，然后，当你有了答案（或放弃）时，再继续阅读……

这是正确的答案：换门。如果你换，你将有 2/3 的几率赢得那辆车。如果你不换，你将只有 1/3 的几率赢得那辆车，因为这就是最初选择正确门的概率：三个选择中只有一个是正确的。

当Marilyn vos Savant在1990年在她的*Parade*杂志专栏中提出这个问题，并声明正确的解决方法是更换门时，她收到了大量的信件，许多来自数学家，有些甚至愤怒地坚称她是错的。但她并没有错。我们可以通过使用计算机程序来模拟这个游戏，直观地看到她是对的。我们这里不打算开发代码，但其实并不难。如果你写一个并运行它，你会发现，当更换门时，获胜的概率会随着模拟游戏次数的增加而趋近于2/3。然而，我们也可以运用常识和基础的概率知识来理解这个解决方案。

首先，如果我们不更换门，我们知道有1/3的概率能赢得汽车。那么，考虑一下更换门时可能发生的情况。如果我们更换门，我们唯一可能*失败*的情况是我们一开始就选中了正确的门。为什么？假设我们最初选择了一个笑话奖品的门，而Hall知道汽车在哪扇门后，他永远不会打开汽车所在的门。既然我们已经选择了一个笑话奖品门，他只好选择剩下的一个笑话奖品门并为我们打开，从而确保汽车在唯一剩下的那扇门后。如果我们更换门，我们就能赢得汽车。由于有两扇门后没有汽车，我们最初选择错误门的概率是2/3。然而，我们刚刚看到，如果我们最初选择了错误的门并在有机会时更换，我们会赢得汽车。因此，通过更换猜测，我们有2/3的概率赢得汽车。当然，1/3的概率是我们最初选择了正确的门。

##### 有癌症还是没有癌症？

这个例子出现在几本关于概率与统计的流行书籍中（例如，Joel Best的*More Damned Lies and Statistics* [UC Press, 2004]，以及Leonard Mlodinow的*The Drunkard’s Walk* [Pantheon, 2008]）。它基于一项实际研究。任务是要确定一位40多岁女性在乳腺X光检查结果为阳性时，她患有乳腺癌的概率。请注意，以下的数据在研究时可能是准确的，但现在可能已不再有效。请仅将它们作为一个示例。

我们被告知以下内容：

1.  随机选择一位40多岁的女性，她患有乳腺癌的概率为0.8%（每1,000人中有8人）。

1.  患有乳腺癌的女性有90%的概率会得到阳性乳腺X光检查结果。

1.  没有乳腺癌的女性有7%的概率会得到阳性乳腺X光检查结果。

一位女性来到诊所进行筛查，乳腺X光检查结果为阳性。根据我们所知道的信息，她实际上患有乳腺癌的概率是多少？

根据上面的第1条，我们知道，如果随机选取1,000位40多岁的女性，其中大约8人会患有乳腺癌。因此，在这8人中，90%的人（根据第2条）将会有阳性乳腺X光结果。这意味着7位患癌症的女性会有阳性乳腺X光结果，因为 8 × 0.9 = 7.2。剩下的992位没有乳腺癌的女性中，根据第3条，992 × 0.07 = 69.4，因此，69位没有乳腺癌的女性也会有阳性乳腺X光结果，最终总共有7 + 69 = 76个阳性乳腺X光结果，其中7个是真正的癌症病例，69个是假阳性结果。因此，阳性乳腺X光结果表明有癌症的概率是7/76，约为9%。

医生在面对这个问题时给出的中位数估计是癌症的概率大约为70%，其中超过三分之一的医生估计为90%。即使对于经过大量训练的专业人士来说，概率问题也是困难的。医生们的错误在于没有正确考虑到随机选取一位40多岁的女性患乳腺癌的概率。我们将在[第3章](ch03.xhtml#ch03)中看到如何利用贝叶斯定理来计算这个结果，它会考虑到这个概率。

现在，让我们从直觉转向数学的严谨形式。

### 概率规则

让我们开始学习概率的基本规则。这些是我们在本章及之后章节中需要的基础规则。我们将学习事件的概率、概率的求和规则，以及条件概率的含义。之后，乘积规则将帮助我们解决生日悖论。在生日悖论中，我们将学习如何计算最少需要多少人聚在一个房间里，使得至少两个人共享生日的概率超过50%。这个数字比你想象的要少。

#### 事件的概率

我们之前提到过，样本空间中所有概率的总和为1。这意味着任何来自样本空间的事件的概率始终小于或等于1，因为该事件来自样本空间，而样本空间涵盖了所有可能的事件。由此可得，对于任何事件 *A*，

![image](Images/02equ01.jpg)

并且，对于样本空间中的所有事件 *A[i]*，

![image](Images/02equ02.jpg)

其中 ∑（sigma）表示对右侧表达式中的每个 *i* 进行求和。可以将其理解为Python中的for循环，右侧的表达式是循环体。

如果我们掷一个六面骰子，我们直观地（而且是正确的）理解，获得任何一个数值的概率是相同的：六种可能中的一种，或者1/6。因此，[公式2.1](ch02.xhtml#ch02equ01)告诉我们，*P*(1)，掷出1的概率，介于零和一之间。这是因为![image](Images/022equ01.jpg)。此外，[公式2.2](ch02.xhtml#ch02equ02)告诉我们，样本空间中所有事件的概率和必须为1。对于六面骰子来说，这也是正确的，因为![image](Images/022equ02.jpg)和![image](Images/022equ03.jpg)。

如果事件发生的概率是*P(A)*，那么事件* A 不发生*的概率是

![image](Images/02equ03.jpg)

其中![image](Images/022equ04.jpg)表示“非*A*”。![image](Images/022equ04.jpg)被称为*A*的*补集*。你有时会看到![image](Images/022equ04.jpg)被写作*P*(¬*A*)，其中¬是“非”的逻辑符号。

[公式2.3](ch02.xhtml#ch02equ03)来自[公式2.1](ch02.xhtml#ch02equ01)和[公式2.2](ch02.xhtml#ch02equ02)，因为事件的概率小于1，而样本空间中任何事件发生的概率是1，因此，事件* A *没有发生的概率必须是1减去事件* A *发生的概率。

例如，当掷骰子时，获得[1, 6]范围内的数值的概率为1，但获得四的概率是1/6。因此，*不*掷出四的概率是去掉掷出四的概率后剩下的所有概率，

![image](Images/022equ05.jpg)

这意味着我们有83%的概率不会掷出四。

如果我们掷两个骰子并求和呢？样本空间是从2到12的整数集合。然而，在这种情况下，每个和的可能性并不相同，这种情况正是赌场游戏“掷骰子”中的核心，例如。我们通过列举所有可能的组合来计算每个和的概率。通过计算事件发生的方式，并将其除以事件的总数，我们可以确定概率。[表2-1](ch02.xhtml#ch02tab01)展示了生成每个和的所有可能方式。

**表2-1：** 两个骰子导致不同和的组合数量

| **和** | **组合方式** | **计数** | **概率** |
| --- | --- | --- | --- |
| 2 | 1 + 1 | 1 | 0.0278 |
| 3 | 1 + 2, 2 + 1 | 2 | 0.0556 |
| 4 | 1 + 3, 2 + 2, 3 + 1 | 3 | 0.0833 |
| 5 | 1 + 4, 2 + 3, 3 + 2, 4 + 1 | 4 | 0.1111 |
| 6 | 1 + 5, 2 + 4, 3 + 3, 4 + 2, 5 + 1 | 5 | 0.1389 |
| 7 | 1 + 6, 2 + 5, 3 + 4, 4 + 3, 5 + 2, 6 + 1 | 6 | 0.1667 |
| 8 | 2 + 6, 3 + 5, 4 + 4, 5 + 3, 6 + 2 | 5 | 0.1389 |
| 9 | 3 + 6, 4 + 5, 5 + 4, 6 + 3 | 4 | 0.1111 |
| 10 | 4 + 6, 5 + 5, 6 + 4 | 3 | 0.0833 |
| 11 | 5 + 6, 6 + 5 | 2 | 0.0556 |
| 12 | 6 + 6 | 1 | 0.0278 |
|  |  | 36 | 1.0000 |

在[表2-1](ch02.xhtml#ch02tab01)中，有36种不同的掷骰子组合。我们看到最常见的和是7，因为有六种组合的和为7。最不常见的和是2和12，因为只有一种方式可以得到这两个数字。如果得到7有六种方式，那么得到7的概率就是“36中有6”，即6/36 ≈ 0.1667。我们将在下一章讨论概率分布和贝叶斯定理时再回到[表2-1](ch02.xhtml#ch02tab01)。[表2-1](ch02.xhtml#ch02tab01)展示了一个通用规则：如果我们能列举样本空间，那么我们就能计算特定事件的概率。

作为一个最终示例，如果你同时抛三枚硬币，得到零个正面、一个正面、两个正面或三个正面的概率是多少？我们可以列举出所有可能的结果并查看。结果如下：

| **正面** | **组合** | **计数** | **概率** |
| --- | --- | --- | --- |
| 0 | TTT | 1 | 0.125 |
| 1 | HTT, THT, TTH | 3 | 0.375 |
| 2 | HHT, HTH, THH | 3 | 0.375 |
| 3 | HHH | 1 | 0.125 |
|  |  | 8 | 1.000 |

从这个表格中，我们可以看出在抛三枚硬币时，得到一个或两个正面的概率是相同的：37.5%。让我们用一些代码来验证这个结果：

import numpy as np

N = 1000000

M = 3

heads = np.zeros(M+1)

for i in range(N):

flips = np.random.randint(0,2,M)

h, _ = np.bincount(flips, minlength=2)

heads[h] += 1

prob = heads / N

print("概率: %s" % np.array2string(prob))

这段代码运行了1,000,000次测试（N），模拟了抛三枚硬币（M）。每次测试的结果会记录0、1、2或3个正面的出现次数，这些数据保存在heads中。每次测试选择三组[0, 1]的值（flips），并计算出现了多少个正面（零）。我们使用np.bincount来进行此操作，忽略反面数量。正面的数量随后会被统计，并且进行下一次抛硬币。

当所有的N次模拟完成后，我们通过将正面数量除以总模拟次数（prob）来转换为概率。最后，我们打印出相应的概率。对于零个、一个、两个或三个正面的结果，一次运行返回了如下结果：

概率：[0.125236, 0.3751, 0.37505, 0.124614]

这些结果与我们之前计算的概率非常接近，因此我们可以确信我们是正确的。

#### 求和规则

我们从一个定义开始：如果两个事件*A*和*B*不能同时发生，我们称它们为*互斥*事件；它们只能其中一个发生。举例来说，抛硬币的结果要么是正面，要么是反面，不能是正面*和*反面同时出现。互斥事件意味着如果事件*A*发生了，那么事件*B*就被排除了，反之亦然。此外，如果两个事件的发生概率完全没有关系，即事件*A*的概率不受事件*B*是否发生的影响，我们称这两个事件是*独立*的。

加法规则涉及多个互斥事件发生的概率。它告诉我们其中一个事件发生的概率。例如，掷一颗标准骰子，掷出四点或五点的概率是多少？我们知道掷出四点的概率是1/6，掷出五点的概率也是1/6。由于这些事件是互斥的，我们可以直觉地认为，掷出四点*或*五点的概率是它们的总和，因为四点和五点作为结果都属于样本空间，而要么发生四点，要么发生五点，或者都不发生。所以，我们得到如下结果：

![image](Images/02equ04.jpg)

这里的∪表示“或”或“并集”。你会经常看到∪。对于标准骰子，掷出四点或五点的概率是![image](Images/024equ01.jpg)，大约是33%。

两次抛硬币的样本空间是{HH, HT, TH, TT}；因此，这就是掷出两个正面或两个反面的概率：

![image](Images/024equ02.jpg)

加法规则有更多内容，但在我们看到这些内容之前，我们需要考虑乘法规则。

#### 乘法规则

加法规则告诉我们事件*A*或*B*发生的概率。乘法规则则告诉我们事件*A 和 B*同时发生的概率：

![image](Images/02equ05.jpg)

这里的∩表示“与”或“交集”。

如果事件*A*和*B*是互斥的，我们可以立即看到*P*(*A* ∩ *B*) = 0，因为如果事件*A*发生的概率是*P*(*A*)，那么事件*B*的概率是*P*(*B*) = 0，它们的乘积也为零。如果事件*B*发生，则*P*(*A*) = 0，结果也是一样的。

当然，并不是所有事件都是互斥的。例如，假设世界上80%的人有棕色眼睛，50%的人是女性。那么，随机选择一个人是棕眼女性的概率是多少？我们可以使用乘法规则来计算，

*P*(女性，棕眼) = *P*(女性)*P*(棕眼) = 0.5(0.8) = 0.4

可以看出，随机选择一个人是棕眼女性的概率是40%。

乘法规则是有道理的，如果我们稍微思考一下。计算女性的比例（即概率）不会改变这些女性中有棕色眼睛的比例。一个事件——成为女性——对另一个事件——有棕色眼睛——没有影响。

乘法规则不仅限于两个事件。考虑以下情况。根据保险公司数据，在美国，每年被闪电击中的概率大约是1/1,222,000，即0.000082%。假设你住在美国，成为一个棕眼女性并在任何一年内被闪电击中的概率是多少？同样，我们可以使用乘法规则：

![image](Images/025equ01.jpg)

美国的人口大约为3.31亿，其中0.000033%是今年将被闪电击中的棕眼女性：按照我们之前的计算，大约109人。根据美国国家气象局的数据，每年大约有270人会被闪电击中。如前所述，这些人中40%是棕眼女性，这就得出270(0.4) = 108。因此，我们的计算完全可信。

#### 总和法则再探

我们之前提到过，总和法则不仅仅是这么简单。现在让我们看看之前遗漏了什么。[方程2.4](ch02.xhtml#ch02equ04)给出了互斥事件*A*和*B*的总和法则。如果事件不是互斥的呢？在这种情况下，总和法则需要进行修改：

![image](Images/02equ06.jpg)

让我们来看一个例子。

一位考古学家发现了一个包含20枚古代硬币的小宝藏。他注意到其中12枚是罗马硬币，8枚是希腊硬币。他还注意到，6枚罗马硬币和3枚希腊硬币是银币。剩下的硬币是铜币。从这个宝藏中选出一枚银币或罗马硬币的概率是多少？

如果我们认为银币和罗马硬币是互斥的，我们可能会倾向于说如下：

![image](Images/026equ01.jpg)

然而，两个概率的总和是![image](Images/026equ02.jpg)，而我们*不能*得到一个大于1的概率。出了点问题。

问题在于，宝藏中有些罗马硬币是银币。我们把它们计算了两次——一次在*P*(银币)中，另一次在*P*(罗马硬币)中——所以现在我们需要从总和中减去它们。这里有6枚银色罗马硬币。所以，银色罗马硬币的概率是*P*(银币且罗马硬币)![image](Images/026equ03.jpg)。减去这一部分后，我们看到选择银币或罗马硬币的概率是75%：

![image](Images/026equ04.jpg)

与总和法则一样，乘法法则也不止这么简单，我们很快会深入了解。但首先，让我们利用乘法法则看看是否能解决生日悖论。

#### 生日悖论

平均来说，我们需要多少人在一个房间里，才能有超过50%的概率，保证其中两个人共享同一个生日？这个问题被称为*生日悖论*。让我们看看是否可以运用我们对概率的乘法法则，来解决这个问题。

我们将忽略闰年，假设一年有365天。直观上，我们看到，随机选择的人共享生日的概率是365天中有一天（共享的生日）与365天中的所有生日相比。所以我们得到了以下结果：

![image](Images/027equ01.jpg)

他们要么共享生日，要么不共享：1 – 1/365 = 365/365 – 1/365 = 364/365。所以我们得到了以下结果：

![image](Images/027equ02.jpg)

一年中的365天，有一天是可能匹配的，剩下364天不匹配。

随机选择的人中有0.3%的机会共享生日，这个概率相当低。这意味着如果你随机选择一对人，并询问他们是否共享生日，平均每千对中会有三对匹配，这不太可能发生。

对于我们的计算，我们将以另一种方式来看待事情。我们要找到需要聚集在一起的人数，以便使得没有两个人分享生日的概率低于50%。

我们知道两个随机选择的人不共享生日的概率是![image](Images/027equ03.jpg)。因此，如果我们随机选择两对人，两对都不共享生日的概率如下：

![image](Images/027equ04.jpg)

在这里，我们使用乘法法则。同样，对于三个人*(A*, *B*, *C*)，我们可以形成三个不同的对，*(A*, *B*)，(*A*, *C*)和(*B*, *C*)，所以我们计算如下：

![image](Images/027equ05.jpg)

对于*n*次比较，这里是没有共享生日的概率：

![image](Images/02equ07.jpg)

我们的任务是找到最小的比较次数*n*，使得没有共同生日的概率小于50%，其中*n*是房间中人数*m*的函数。为什么小于50%？因为如果我们找到一个*n*，使得没有共同生日的概率小于50%，那么有共同生日的概率就一定大于50%。

如果你随机挑选三个人，就有三对人要检查是否有共同生日。如果有四个人，就有六对人。所以，人群越大，可以形成的对数就越多。我们能否找到一个规则，将人数*m*映射到需要比较的对数*n*？如果我们有了这个规则，我们就可以找到最小的*m*，使得*n*在这个情况下的[方程2.7](ch02.xhtml#ch02equ07)的概率小于50%。

当我们有一组*m*个唯一的对象，比如房间里的人，我们从中选择成对的对象时，我们能选择多少不同的对？换句话说，当我们从*m*个物体中取出两个物体时，有多少种组合？计算从*m*个物体中取*k*个物体的组合数的公式如下：

![image](Images/028equ01.jpg)

有时你会听到这被称为“*m* choose *k*”，对于我们来说，*k* = 2。让我们找到我们需要的比较次数*n*，并使用两两选择的物体组合数来找到至少*n*次比较的*m*。

在Python中，一个简单的循环可以找到我们需要的*n*：

for n in range(300):

if ((364/365)**n < 0.5):

print(n)

break

我们知道*n* = 253。因此，我们需要平均进行253次比较，253对人，才能有超过50%的概率，其中一对共享生日。最后一步是找出至少有253对的*m*人中的多少种两两组合。一点点试探和误差告诉我们这一点：

![image](Images/028equ02.jpg)

我们平均需要 *m* = 23 人，才能有超过 50% 的机会至少有两个人共享一个生日。这一切都要归功于乘法法则。

我们的结果可靠吗，还是只是技巧？一些代码可以告诉我们。首先，让我们通过模拟来验证，随机选择两个人有相同生日的概率是 0.3%：

match = 0

for i in range(100000):

a = np.random.randint(0,364)

b = np.random.randint(0,364)

if (a == b):

match += 1

print("随机匹配的概率 = %0.6f" % (match/100000,))

该代码模拟了 100,000 对随机的人的生日，其中随机整数 [0, 364] 代表一个人的生日。如果这两个人的生日匹配，match 会增加。所有模拟运行结束后，我们打印出概率。运行这段代码后得到了以下结果，这让我们关于 0.3% 机会的推断变得可信：

随机匹配的概率 = 0.003100

那么，多少人能够有超过 50% 的机会有相同的生日呢？在这里，我们有两个循环。第一个是针对房间内的人数（m），第二个是针对该人数的模拟次数（n）。代码如下所示：

for m in range(2,31):

matches = 0

for n in range(100000):

match = 0

b = np.random.randint(0,364,m)

for i in range(m):

for j in range(m):

if (i != j) and (b[i] == b[j]):

match += 1

if (match != 0):

matches += 1

print("%2d %0.6f" % (m, matches/100000))

我们让 m 的范围从 2 到 30 人。对于每组 m 个人，我们进行 100,000 次模拟。对于每次模拟，我们为每个房间中的人选择一个生日（b），然后将每个人与其他每个人进行比较，查看是否有生日匹配。如果有匹配，我们就增加 match。如果至少有一个匹配，我们就增加 matches，并进入下一次模拟。最后，当当前房间人数的所有模拟完成后，我们打印出至少有一个匹配的概率。

如果我们运行代码并绘制输出结果，我们会得到 [图 2-1](ch02.xhtml#ch02fig01)，其中虚线代表 50%。第一个超过虚线的点是 23 个人，正如我们计算的那样。

![image](Images/02fig01.jpg)

*图 2-1：共享生日的概率与房间内人数的关系*

看到模拟结果与数学计算相符，总是令人满意的。

#### 条件概率

假设有一个装有 10 个弹珠的袋子，其中 8 个红色，2 个蓝色。如果我们从袋子中随机挑一个弹珠，挑到蓝色弹珠的机会是 2/10，即 20%。假设我们挑到了一个蓝色弹珠，在欣赏其美丽的蓝色后，我们将其放回袋子，摇晃袋子，再挑出一个弹珠。那么，再次挑到蓝色弹珠的概率是多少呢？再次强调，袋子里还是有 2 个蓝色弹珠和 10 个弹珠，所以概率依然是 20%。

如果事件*A*发生了（在这里指的是我们选择了一个蓝色弹珠，然后把它放回袋子里），并没有影响到未来事件*B*的概率，那么这两个事件就是独立事件。我们第二次选中蓝色弹珠的概率完全不受之前选择了蓝色弹珠这一事实的影响。掷硬币也是如此。如果我们连续四次正面朝上，这与下一次掷出反面的概率没有任何关系，前提是硬币是公平的，也就是说，它没有一面偏重或是两面都是正面（或反面）。

现在，考虑一个替代情境。我们依然有一个袋子，里面有八个红色弹珠和两个蓝色弹珠。我们从袋子里抽取一个弹珠——假设这次是红色的——由于我们喜欢这个颜色，我们把弹珠保留下来并放在一边。现在，我们再从袋子里抽取另一个弹珠。再次选中红色弹珠的概率是多少呢？这里，情况已经发生了变化。现在袋子里有九个弹珠，其中七个是红色的。因此，我们第二次选中红色弹珠的概率现在是9分之7，约为78%。最初选中红色弹珠的概率是10分之8，或80%。事件*A*，即选中并保留一个红色弹珠，改变了第二次事件的概率。两个事件不再是独立的。第一次事件的发生改变了第二次事件的概率。在符号上，我们写作*P**(B*|*A*)，表示事件*B*在事件*A*发生后发生的概率。这是一个*条件概率*，因为它是基于事件*A*发生的条件下的概率。

这就是我们更新乘法规则的地方。[方程 2.5](ch02.xhtml#ch02equ05)中的版本假设这两个事件是独立的，就像是女性和棕色眼睛一样。如果我们遇到的是依赖的情况，那么规则就变成了

![image](Images/02equ08.jpg)

这意味着两个事件同时发生的概率是其中一个事件发生后，另一个事件发生的条件概率与另一个事件的概率的乘积。

回顾我们上面的弹珠例子，我们计算了在已经选中并保持一个红色弹珠之后，再次选中红色弹珠的概率为9分之7，约为78%。这就是*P**(B*|*A*)。对于*P(A*)，我们需要初始选中红色弹珠的概率，我们设定为80%。因此，选中并保持一个红色弹珠，*A*，以及在第二次抽取时选中红色弹珠，*B*，的概率是62%：

![image](Images/031equ01.jpg)

如果两个事件是互斥的，*P**(B*|*A*) = *P*(*A*|*B*) = 0。如果事件*A*和*B*是独立的，那么*P*(*A*|*B*) = *P*(*A*)，并且*P*(*B*|*A*) = *P*(*B*)，因为条件事件是否发生对后续事件没有任何影响。

最后，请注意，通常 *P**(B*|*A*) ≠ *P*(*A*|*B*)，混淆这两个条件概率是一个常见且常常严重的错误。正如我们将在[第三章](ch03.xhtml#ch03)中看到的，贝叶斯定理给出了条件概率之间的正确关系。我们在讨论概率的链式法则时会再次遇到条件概率。

#### 总概率

如果我们的样本空间被划分成不相交的区域，*B[i]*（*B*[1]、*B*[2] 等），并且样本空间的总量被 *B[i]*s 覆盖且 *B[i]*s 之间没有重叠，我们可以通过以下方式计算事件在所有分区上的概率：

![image](Images/031equ02.jpg)

这里 *P**(A*|*B[i]*) 是在给定分区 *B[i]* 的情况下 *A* 的概率，而 *P*(*B[i]*) 是分区 *B[i]* 的概率，表示 *B[i]* 所代表的样本空间的量。从这个角度看，*P**(A*) 是在各分区 *B[i]* 上 *A* 的 *总概率*。让我们来看一个如何使用这个法则的例子。

你有三个城市，Kish、Kesh 和 Kuara，它们的总人口分别为 2,000、1,000 和 3,000。此外，这些城市中蓝眼睛的百分比分别为 12%、3% 和 21%。我们想知道从这些城市中随机选出一个人，拥有蓝眼睛的概率。城市的人口会影响这一点，因为每个城市的蓝眼睛概率不同，而且城市之间的人口也不同。为了求 *P*(blue)，我们使用总概率：

![image](Images/032equ01.jpg)

这里 *P*(blue|Kish) 是在你住在 Kish 的条件下拥有蓝眼睛的概率，*P*(Kish) 是住在 Kish 的概率，依此类推。

我们知道计算总概率所需的必要量。每个城市的蓝眼睛概率如上所示，每个城市的居住概率通过其人口与三个城市的总人口计算得到：

![image](Images/032equ02.jpg)

因此，*P*(blue) 是

![image](Images/032equ03.jpg)

这意味着从这三个城市中随机选出一个居民拥有蓝眼睛的概率为 15%。注意，选择城市的概率之和：*P*(Kish) + *P*(Kesh) + *P*(Kuara) = 1。这是样本空间分区必须满足的条件，即所有城市居民的样本空间必须通过城市的分区覆盖。

### 联合概率和边际概率

两个变量的*联合概率*，*P*(X = x, Y = y)，是指随机变量 *X* 在随机变量 *Y* 为 *y* 的同时取值为 *x* 的概率。我们已经看过一个联合概率的例子。当我们在计算概率时使用“和”时，我们就是在计算联合概率。联合概率是多个条件同时为真的概率，这就是“和”。*边缘概率*是当我们计算一个或多个条件的概率时，不考虑其他条件的值；换句话说，就是计算“和”中随机变量的子集的概率。

在本节中，我们将使用简单的表格来研究联合概率和边缘概率。然后，我们将介绍概率的链式法则。这个法则使我们能够将联合概率分解为较小的联合概率和条件概率的乘积。

#### 联合概率表

根据色盲意识网站 (*[http://www.colourblindawareness.org/](http://www.colourblindawareness.org/)*), 大约 12 名男性中就有 1 名色盲，而 200 名女性中就有 1 名色盲。这个差异来源于色盲基因位于 X 染色体上，女性需要从母亲和父亲那里各继承一个隐性基因，而男性只需从一方继承基因。

假设我们调查了 1,000 人。我们可以统计出男性且色盲、女性且色盲、男性且非色盲、女性且非色盲的人数。我们进行统计并将数据按如下方式排列：

|  | **色盲** | **非色盲** |
| --- | --- | --- |
| **男性** | 42 | 456 | 498 |
| **女性** | 3 | 499 | 502 |
|  | 45 | 955 | 1000 |

这样的表格被称为*列联表*。统计数据位于表格中间的 2 × 2 数字部分。最右边的列是按行的总和，最后一行是按列的总和。最后一行或最后一列的总和位于最后一个单元格，并且必然总和为我们调查的 1,000 人。

我们可以通过将每个单元格除以 1,000（即调查人数），将列联表转换为概率表。这样得到的表格如下：

|  | **色盲** | **非色盲** |
| --- | --- | --- |
| **男性** | 0.042 | 0.456 | 0.498 |
| **女性** | 0.003 | 0.499 | 0.502 |
|  | 0.045 | 0.955 | 1.000 |

该表现在是一个联合概率表。通过它，我们可以查找成为男性且色盲的概率。表示法上，我们写作：

*P*(性别 = 男性, 色盲 = 是) = 0.042

同样地，我们看到

*P*(性别 = 女性, 色盲 = 否) = 0.499

使用联合概率表，我们可以预测在随机抽样的人群中，我们期望测量到什么。例如，如果我们有一个 20,000 人的样本，那么根据我们的表格，我们预计会发现大约 20000(0.042) = 840 名色盲男性和大约 20000(0.003) = 60 名色盲女性。

如果我们想知道无论性别如何，色盲的概率是多少呢？为了做到这一点，我们沿着色盲这一列求和，发现随机选择的人中有4.5%的可能性是色盲。同样，沿行求和给我们一个估计的女性概率为50.2%。我们需要牢记的是，表格是基于仅1000人的样本构建的。如果我们抽样的是10万人，你可能猜测，男性和女性的比例会接近50/50，你是对的。

从联合概率表中计算色盲或女性的概率是计算边际概率。在第一个案例中，我们沿列求和以去除性别的影响，而在第二个案例中，我们沿行求和以去除色盲的影响。

数学上，我们通过对不想要的变量求和，得到边际概率。如果我们有一个两个变量的联合概率表，如上面的例子，我们通过求和得到边际概率：

![image](Images/034equ01.jpg)

使用上表，我们可以写出

![image](Images/034equ02.jpg)

我们在这里对性别进行求和，以去除其影响。现在，让我们探索另一个表格，它包含三个变量。

1912年4月14日夜间，RMS *泰坦尼克号*在从英国驶往纽约的处女航途中沉没于北大西洋。基于在*泰坦尼克号*上的887人样本，我们可以生成[表2-2](ch02.xhtml#ch02tab02)，显示生存、性别和舱位等级三个变量的联合概率。

**表2-2：** *泰坦尼克号*乘客联合概率表

|  |  | **舱位1** | **舱位2** | **舱位3** |
| --- | --- | --- | --- | --- |
| **死亡** | **男性** | 0.087 | 0.103 | 0.334 |
| **女性** | 0.003 | 0.007 | 0.081 |
| **生存** | **男性** | 0.051 | 0.019 | 0.053 |
| **女性** | 0.103 | 0.079 | 0.081 |

让我们使用[表2-2](ch02.xhtml#ch02tab02)来计算一些概率。请注意，我们将使用[表2-2](ch02.xhtml#ch02tab02)中的数值，这些数值精确到小数点后三位。因此，整体数字与我们通过计数计算出的概率会稍有偏差，但这样做可以使表格和方程之间的联系更加具体。

首先，我们可以直接从表格中读取特定的三元组（生存状态、性别、舱位等级）。这里有一个例子：

*P*(死亡, 男性, 舱位3) = 0.334

这意味着，随机选择的乘客是位于三等舱且未生还的男性的概率为33%。那一等舱的男性呢？表格里也有：

*P*(死亡, 男性, 舱位1) = 0.087

这意味着选中的乘客有9%的机会是死于一等舱的男性。我们可以看到，舱位等级和社会阶层差异对生存影响很大。

让我们利用表格计算一些其他的联合概率和边际概率。首先，不幸存的概率是多少？为了找到这个概率，我们需要对性别和舱位求和：

![image](Images/02equ09.jpg)

这里我们引入了性别（*M*/*F*）和舱位等级（1、2、3）的简写符号。

让我们计算给定乘客为男性的情况下不幸存的概率，*P*(死亡|*M*)。为了做到这一点，我们回顾[方程 2.8](ch02.xhtml#ch02equ08)，记住“和”意味着联合概率。我们重新写[方程 2.8](ch02.xhtml#ch02equ08)来解算*P*(*B*|*A*)：

![image](Images/035equ01.jpg)

这有时用来定义条件概率。注意，*P*(A，*B*)表示*P*(*A*且*B*)——两者都是联合概率。使用这种形式，给定乘客是男性的情况下，不幸存的概率是

![image](Images/036equ01.jpg)

其中，*P*(死亡，*M*)是死亡且为男性的联合概率，*P*(*M*)是为男性的概率。

我们在考虑概率时需要小心。*P*(死亡，*M*)并不是指如果乘客是男性时不幸存的概率。实际上，它是指随机选取的乘客为未幸存的男性的概率。我们想要的是*P*(死亡|*M*)，即给定乘客为男性的情况下，不幸存的概率。

为了得到*P*(死亡，*M*)，我们需要对舱位等级求和：

![image](Images/02equ10.jpg)

为了得到*P*(*M*)，我们需要对生存情况和舱位等级求和：

![image](Images/02equ11.jpg)

最终计算*P*(死亡|*M*)：

![image](Images/036equ02.jpg)

这告诉我们，81%的男性乘客没有幸存。

如下所示的类似计算告诉我们，成为女性并幸存的概率：

![image](Images/036equ03.jpg)

我们看到女性比男性更有可能幸存。这是“妇女和儿童优先”这一说法的实际体现。我留给你做一个练习，计算*P*(幸存|*F*)的个别概率。

我们已经计算出了*P*(死亡，*M*)，即未幸存的男性的概率；*P*(*M*)，即为男性的概率；以及*P*(死亡|*M*)，即给定为男性时未幸存的概率。让我们再根据[表格 2-2](ch02.xhtml#ch02tab02)做一次计算。我们来求*P*(死亡或*M*)，即不幸存或为男性的概率。

[方程 2.6](ch02.xhtml#ch02equ06)告诉我们这是概率：

![image](Images/037equ01.jpg)

如果我们查看[方程 2.9](ch02.xhtml#ch02equ09)和[方程 2.11](ch02.xhtml#ch02equ11)，我们可以看到它们有相同的项，这些项正是[方程 2.10](ch02.xhtml#ch02equ10)中求和的项。这就是为什么我们必须从*P*(死亡或*M*)的计算中减去*P*(死亡，*M*)，以避免重复计算。

总结一下：

+   联合概率是指两个或多个随机变量具有特定值的概率。联合概率通常以表格的形式表示。

+   随机变量的边际概率是通过对其他随机变量的所有可能值求和得到的。

乘积法则结合条件概率告诉我们如何在有两个随机变量的情况下，给定条件概率和无条件概率来计算联合概率。接下来我们将展示如何使用概率链式法则来推广这一概念。

#### 概率链式法则

[方程式 2.8](ch02.xhtml#ch02equ08)告诉我们如何通过条件概率来计算两个随机变量的联合概率。运用*概率链式法则*，我们可以扩展[方程式 2.8](ch02.xhtml#ch02equ08)，计算超过两个随机变量的联合概率。

在其通用形式中，*n*个随机变量的联合概率的链式法则如下：

![image](Images/02equ12.jpg)

这里使用⋂表示“和”连接联合概率。[方程式 2.12](ch02.xhtml#ch02equ12)看起来很复杂，但跟随几个例子后，你会发现其实并不难理解。我需要在方程中使用⋂来表示条件概率的联合部分，但在例子中，我会使用逗号，你会很快理解其中的规律。

这是链式法则如何将三个随机变量的联合概率分解开的方式：

![image](Images/038equ01.jpg)

第一行说的是*X*、*Y*和*Z*的概率是*X*在给定*Y*和*Z*下的概率与*Y*和*Z*的概率的乘积。这是[方程式 2.8](ch02.xhtml#ch02equ08)，其中*X*代表*B*，*Y*和*Z*代表*A*。第二行将链式法则应用于*P*(*Y*，*Z*)，得到*P*(*Y*|*Z*)*P*(*Z*)。这个规则可以像链条一样顺序应用，因此得名“链式法则”。

如果有四个随机变量的联合概率呢？我们得到如下结果：

![image](Images/038equ02.jpg)

让我们通过一个使用链式法则的例子来进行讲解。假设我们非常社交，派对上有50个人。其中四个人曾在秋天去过波士顿。我们随机挑选三个人。那么，*这三个人都没有去过波士顿*的概率是多少？

我们将用*A[i]*表示一个没有在秋天去过波士顿的人的事件。因此，我们想要找的是*P*(*A*[3]，*A*[2]，*A*[1])，即三个人都没有在秋天去过波士顿的概率。链式法则让我们将这个概率分解成这样：

![image](Images/038equ04.jpg)

我们可以直观地理解这个方程的右边。看看 *P*(*A*[1])。这是从房间里随机选一个人，且他没有在秋季去过波士顿的概率。四个人去过波士顿，所以46个人没有去，我们看到 *P*(*A*[1]) = 46/50。选定一个人之后，我们需要知道从剩下的49个人中选第二个人的概率，即 *P*(*A*[2]|*A*[1]) = 45/49。此时，剩下的人只有49个，且我们还没选中去过波士顿的四个人。最后，选中了两个人后，房间里剩下48人，其中44人没有在秋季去过波士顿。所以 *P*(*A*[3]|*A*[2], *A*[1]) = 44/48。

我们现在准备回答最初的问题。从房间里随机选出三个人，他们都没有在秋季去过波士顿的概率如下：

![image](Images/038equ03.jpg)

这稍微超过了77%。

我们可以通过模拟三个人的多次抽取来检查我们的计算是否合理。这是我们需要的代码：

nb = 0

N = 100000

for i in range(N):

s = np.random.randint(0,50,3)

fail = False

for t in range(3):

if (s[t] < 4):

fail = True

if (not fail):

nb += 1

print("秋季没有去波士顿 = %0.4f" % (nb/N,))

我们将运行100,000次模拟。每次我们从50个人中选出三个人，且他们都没有在秋季去过波士顿时，我们将递增 nb。我们通过选择三个范围在[0, 50)之间的随机整数来模拟选三个人，并将它们放入 s 中。然后，我们检查这三个人中的每个整数，判断是否有小于四的。如果有，就说明选中了一位去过波士顿的人，我们将 fail 设置为 True。如果这三个整数都不小于四，那么这次模拟就成功了。完成后，我们将输出模拟中，选出三位从未去过波士顿的人所占的比例。

运行这段代码产生了

秋季没有去波士顿 = 0.7780

这个结果足够接近我们计算的值，给了我们信心，说明我们找到了正确的答案。

### 总结

本章介绍了概率的基本原理。我们探讨了概率的基本概念，包括样本空间和随机变量。接着，我们给出了一些人类在概率方面容易出错的例子。之后，我们讨论了概率的基本规则，并附上了例子。这些规则引导我们进入了联合概率和边际概率，最终讲解了概率的链式法则。

下一章将继续我们的概率之旅，从概率分布开始，讲解如何从中抽样，最后讲到贝叶斯定理，它告诉我们如何正确地比较条件概率。
