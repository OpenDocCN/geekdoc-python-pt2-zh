## **1

设置环境**

![image](img/common.jpg)

虽然本书没有传统的数学练习，但如果我们想掌握这些概念，还是需要进行一定的练习。我们有很多机会来进行这些练习，但我们将使用代码，而非纸笔。

本章将帮助你通过配置工作环境来为后续工作做好准备。在整本书中，我将使用 Linux，特别是 Ubuntu 20.04，但我们所做的事情很可能也适用于更新版本的 Ubuntu 以及大多数其他 Linux 发行版。为了完整性，我还包括了 macOS 和 Windows 环境配置的部分。我应该指出，深度学习所期望的操作系统是 Linux，虽然大多数事情也可以在 macOS 上运行。Windows 通常是事后考虑的系统，许多深度学习工具包的移植维护得不好，尽管这一点随着时间的推移正在有所改善。

我们将首先介绍如何安装预期的软件包。接着，我们将快速了解 Python 3.*x* 的 NumPy 库。NumPy 是几乎所有 Python 科学用途的基础，掌握它的基本用法是非常必要的。然后，我将介绍 SciPy。这也是科学所需的工具包，但在这里我们只需使用它的极小一部分。最后，我会谈谈 Scikit-Learn 工具包，简写为 sklearn。这个有价值的工具包实现了许多传统的机器学习模型。

在本书中，我会经常使用运行实例来说明概念。所有代码片段都假设已执行以下行：

import numpy as np

此外，在某些地方，代码会引用本章前面出现的代码片段的输出。代码示例较简短，所以从一个到下一个跟着做应该不会造成负担。不过，我确实建议在完成一个章节时保持一个 Python 会话持续运行，尽管这不是必须的。

### 安装工具包

本节的最终目标是安装以下工具包，*至少*包括所列的版本号：

+   Python 3.8.5

+   NumPy 1.17.4

+   SciPy 1.4.1

+   Matplotlib 3.1.2

+   Scikit-Learn (sklearn) 0.23.2

比这些版本更新的版本几乎肯定也能正常工作。

让我们快速了解一下如何在主要操作系统中安装这些工具包。

#### Linux

在以下内容中，$ 提示符代表命令行，而 >>> 是 Python 提示符。

全新安装的 Ubuntu 20.04 桌面版会免费提供 Python 3.8.5。使用以下代码：

$ cat /etc/os-release

验证操作系统版本并使用 python3 运行 Python，因为仅使用 python 会启动旧版的 Python 2.7。

这些命令安装了 NumPy、SciPy、Matplotlib 和 sklearn：

$ sudo apt-get install python3-pip

$ sudo apt-get install python3-numpy

$ sudo apt-get install python3-scipy

$ sudo pip3 install matplotlib

$ sudo pip3 install scikit-learn

通过启动 Python 3 并导入每个模块：numpy、scipy 和 sklearn 来测试安装情况。然后打印 __version__ 字符串，以确保它符合或超过上述版本要求。例如，参见以下代码。

>>> import numpy; numpy.__version__

'1.17.4'

>>> import scipy; scipy.__version__

'1.4.1'

>>> import matplotlib; matplotlib.__version__

'3.1.2'

>>> import sklearn; sklearn.__version__

'0.23.2'

#### macOS

要在 Macintosh 上安装 Python 3.*x*，请访问 *[`www.python.org/`](https://www.python.org/)*，在 **Downloads** 下选择 **Mac OS X**，然后选择最新的稳定版 Python 3 发布版本。撰写本文时，最新版本是 3.9.2。下载完成后，运行安装程序以安装 Python 3.9.2。

安装完成后，打开终端窗口并通过以下命令验证安装：

$ python3 --version

Python 3.9.2

假设 Python 3 正确安装，现在我们可以使用终端窗口和 pip3 安装库，安装程序为我们配置了这些工具：

$ pip3 install numpy --user

$ pip3 install scipy --user

$ pip3 install matplotlib --user

$ pip3 install scikit-learn --user

最后，我们可以在 Python 3 中检查库的版本。打开终端并输入 **python3** 以启动 Python 控制台，然后导入 numpy、scipy、matplotlib 和 sklearn，打印版本信息，正如我们上面所做的，确认它们符合或超过最低版本要求。

#### Windows

在 Windows 10 上安装 Python 3 和工具包，请按照以下步骤操作：

1.  访问 *[`www.python.org/`](https://www.python.org/)*，点击 **Downloads** 和 **Windows**。

1.  在页面底部，选择 x86-64 可执行安装程序。

1.  运行安装程序，选择默认选项。

1.  选择 **Install for All Users** 和 **Add Python to the Windows PATH**。这一点很重要。

当安装程序完成时，Python 将可从命令提示符使用，因为我们告诉安装程序将 Python 添加到 PATH 环境变量中。因此，打开命令提示符（WINDOWS-R，cmd），输入 python。如果一切顺利，你将看到 Python 启动消息，并进入 >>> 交互式提示符。撰写本文时，安装的版本是 3.8.2。请注意，要在 Windows 退出 Python，使用 CTRL-Z，而不是 CTRL-D。

Python 安装程序还帮我们安装了 pip。我们可以直接在 Windows 命令提示符下使用它来安装所需的库。在命令提示符下，输入以下行来安装 NumPy、SciPy、Matplotlib 和 sklearn 库：

> pip install numpy
> 
> pip install scipy
> 
> pip install matplotlib
> 
> pip install sklearn

对我来说，这安装了 NumPy 1.18.1、SciPy 1.4.1、Matplotlib 3.2.1 和 sklearn 0.22.2，满足上述最低版本要求，所以一切正常。

为了测试，请从命令提示符启动 Python，并导入 numpy、scipy、matplotlib 和 sklearn。这三个模块都应该能顺利加载而不报错。要编写 Python 代码，可以安装任何你喜欢的编辑器，或者简单使用记事本。

在安装好工具包并准备就绪后，让我们快速了解每个库，至少让我们对它们稍微熟悉一些。全书中我们会看到相关的例子，但我建议你查看推荐的文档。值得一读。

### NumPy

我们在上一节中安装了 NumPy。现在我将介绍一些基本的 NumPy 概念和操作。完整的教程可以在 *[`docs.scipy.org/doc/numpy/user/quickstart.html`](https://docs.scipy.org/doc/numpy/user/quickstart.html)* 上找到。

启动 Python。然后在提示符下尝试以下操作：

>>> import numpy as np

>>> np.__version__

'1.16.2'

第一行加载了 NumPy，并为它设置了一个快捷名称 np。使用快捷名称不是必须的，但几乎是普遍的做法。我们接下来将假设使用 np。第二行显示了版本信息，应该至少与上面显示的版本一致。

#### 定义数组

NumPy 主要处理数组，并且非常擅长将列表转换成数组。可以类比 C 语言或 Java 中的数组。NumPy 提供了优势，因为虽然 Python 很优雅，但当用列表模拟数组时，它在科学计算中会显得过于慢。实际的数组要快得多。这里有一个例子，定义了一个数组并检查它的一些属性：

>>> a = np.array([1,2,3,4])

>>> a

array([1, 2, 3, 4])

>>> a.size

4

>>> a.shape

(4,)

>>> a.dtype

dtype('int64')

这个例子定义了一个包含四个元素的列表，并将其传递给 np.array 函数，将其转化为 NumPy 数组。基本的数组属性包括大小和形状。大小为四个元素，形状也为四，作为一个元组，表明 a 是一个一维（1D）数组。之所以形状为四，是因为数组 a 具有四个元素。如果 a 是二维（2D）数组，形状将有两个值，分别对应数组的两个轴。参见下一个例子，数组 b 的形状表明它有两行四列：

>>> b = np.array([[1,2,3,4],[5,6,7,8]])

>>> print(b)

[[1 2 3 4]

[5 6 7 8]]

>>> b.shape

(2, 4)

#### 数据类型

Python 数值数据类型有两种类型：任意大小的整数（尝试 2**1000）或浮点数。然而，NumPy 允许创建多种类型的数组。NumPy 底层是用 C 实现的，因此它支持 C 支持的相同数据类型。前面的例子展示了 np.array 函数接受了给定的列表，并且由于列表的每个元素都是整数，因此创建了一个每个元素都是带符号 64 位整数的数组。表 1-1 列出了 NumPy 支持的数据类型；我们可以让 NumPy 为我们选择数据类型，或者我们可以明确指定数据类型。

**表 1-1:** NumPy 数据类型名称、C 语言等效类型及其范围

| **NumPy 名称** | **等效 C 类型** | **范围** |
| --- | --- | --- |
| float64 | 双精度浮点数 | ±[2.225 × 10^(–308), 1.798 × 10³⁰⁸] |
| float32 | 浮点数 | ±[1.175 × 10^(–38), 3.403 × 10³⁸] |
| int64 | 长整型 | [–2⁶³, 2⁶³–1] |
| uint64 | 无符号长整型 | [0, 2⁶⁴–1] |
| int32 | long | [–2³¹, 2³¹–1] |
| uint32 | 无符号长整型 | [0, 2³²–1] |
| uint8 | 无符号字符 | [0, 255 = 2²–1] |

让我们看一些具有特定数据类型的数组示例：

>>> a = np.array([1,2,3,4], dtype="uint8")

>>> a.dtype

dtype('uint8')

>>> a = np.array([1,2,3,4], dtype="int16")

>>> a = np.array([1,2,3,4], dtype="uint32")

>>> b = np.array([1,2,3,4.0])

>>> b.dtype

dtype('float64')

>>> b = np.array([1,2,3,4.0], dtype="float32")

>>> c = np.array([111,222,333,444], dtype="uint8")

>>> c

array([111, 222,  77, 188], dtype=uint8)

数组 a 的示例使用了整数类型，而数组 b 的示例使用了浮点类型。注意，第一个 b 的例子默认使用了 64 位浮点数。NumPy 这样做是因为输入列表中的一个元素是浮动数（4.0）。

最后一个定义数组 c 的例子看起来像是一个 bug。但实际上不是。NumPy 不会警告我们如果请求的数据类型无法容纳给定的值。在这里，我们有一个 8 位整数，它只能容纳范围在[0, 255]内的值。前两个值，111 和 222，符合要求，但后两个值，333 和 444，太大了。NumPy 悄悄地只保留了这些值的最低 8 位，分别对应 77 和 188。教训是，NumPy 期望你知道自己在数据类型方面在做什么。通常这不是问题，但值得注意。

#### 二维数组

如果一个列表变成了一个 1D 向量，我们可能会怀疑一个由列表组成的列表会变成一个 2D 数组。我们猜对了：

>>> d = np.array([[1,2,3],[4,5,6],[7,8,9]])

>>> d.shape

(3, 3)

>>> d.size

9

>>> d

array([[1, 2, 3],

[4, 5, 6],

[7, 8, 9]])

我们看到三个子列表组成的列表被映射到一个 3×3 的数组（一个矩阵）。NumPy 数组的下标是从零开始的，因此上面引用的 d[1,2]返回的是 6。

#### 零与一

有两个特别有用的 NumPy 函数，分别是 np.zeros 和 np.ones。两者都可以根据给定的形状定义数组。第一个将数组元素初始化为零，而第二个将它们初始化为一。这是从头创建 NumPy 数组的主要方法：

>>> a = np.zeros((3,4), dtype="uint32")

>>> a[0,3] = 42

>>> a[1,1] = 66

>>> a

array([[ 0,  0,  0, 42],

[ 0, 66,  0,  0],

[ 0,  0,  0,  0]], dtype=uint32)

>>> b = 11*np.ones((3,1))

>>> b

array([[11.],

[11.],

[11.]])

第一个参数是一个元组，表示每个维度的大小。如果我们传入一个标量，结果数组就是一个 1D 向量。让我们看看 b 的定义。在这里，我们将 3×1 的数组与一个标量（11）相乘。这导致数组中的每个元素，初始值为 1.0，都被乘以 11。

#### 高级索引

我们在上面的例子中看到的是简单的数组索引，其中我们使用单一的值进行索引。NumPy 支持更复杂的数组索引。我们常用的一种类型是单个索引返回一个完整的子数组。以下是一个例子：

>>> a = np.arange(12).reshape((3,4))

>>> a

array([[ 0,  1,  2,  3],

[ 4,  5,  6,  7],

[ 8,  9, 10, 11]])

>>> a[1]

array([4, 5, 6, 7])

>>> a[1] = [44,55,66,77]

>>> a

array([[ 0,  1,  2,  3],

[44, 55, 66, 77],

[ 8,  9, 10, 11]])

这个例子介绍了 np.arange，它是 NumPy 中与 Python 的 range 函数等效的函数。请注意使用 reshape 方法将包含 12 个元素的向量转换为 3 × 4 的矩阵。同样需要注意的是，a[1] 返回整个子数组，从第一维的第一个索引开始。此语法实际上是 a[1,:]，其中 : 表示该维度的所有元素。这个简写语法也可以用于赋值，如下行所示。

与 Python 列表的切片语法相同，NumPy 也使用类似的语法。继续上述示例，结果如下：

>>> a[:2]

array([[ 0,  1,  2,  3],

[44, 55, 66, 77]])

>>> a[:2,:]

array([[ 0,  1,  2,  3],

[44, 55, 66, 77]])

>>> a[:2,:3]

array([[ 0,  1,  2],

[44, 55, 66]])

>>> b = np.arange(12)

>>> b

array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

>>> b[::2]

array([ 0,  2,  4,  6,  8, 10])

>>> b[::3]

array([0, 3, 6, 9])

>>> b[::-1]

array([11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])

我们看到 a[:2] 返回前两行，并隐含了第二维度的 :，如下行所示。通过第三个命令，我们使用 a[:2,:3] 从二维数组中提取了前两行和前三列。与 b 的例子展示了如何提取每隔一个或每隔三个元素。最后一个例子特别有用：它使用负增量来反转维度。如果增量是 –1，那么就会反转所有值。如果是 –2，就会返回 b 中每隔一个元素的倒序。 

NumPy 使用 : 来表示沿特定维度的所有元素。它还允许使用 ...（省略号）作为“需要多少个 : 就写多少个”的简写。例如，定义一个三维（3D）数组：

>>> a = np.arange(24).reshape((4,3,2))

>>> a

array([[[ 0,  1],

[ 2,  3],

[ 4,  5]],

[[ 6,  7],

[ 8,  9],

[10, 11]],

[[12, 13],

[14, 15],

[16, 17]],

[[18, 19],

[20, 21],

[22, 23]]])

你可以将数组 a 看作是四个 3 × 2 的矩阵集合。要更新其中第二个矩阵，可以使用以下方式：

>>> a[1,:,:] = [[11,22],[33,44],[55,66]]

>>> a

array([[[ 0,  1],

[ 2,  3],

[ 4,  5]],

[[11, 22],

[33, 44],

[55, 66]],

[[12, 13],

[14, 15],

[16, 17]],

[[18, 19],

[20, 21],

[22, 23]]])

在此，我们通过 : 明确指定了维度，并且展示了 NumPy 不挑剔：它知道一个列表的列表与预期的子数组形状匹配，因此相应地更新了数组 a。我们可以通过使用省略号来达到相同效果，接下来展示了这一点。

>>> a[2,...] = [[99,99],[99,99],[99,99]]

>>> a

array([[[ 0,  1],

[ 2,  3],

[ 4,  5]],

[[11, 22],

[33, 44],

[55, 66]],

[[99, 99],

[99, 99],

[99, 99]],

[[18, 19],

[20, 21],

[22, 23]]])

我们现在已更新了第三个 3 × 2 的子数组。

#### 磁盘读写

NumPy 数组可以通过 np.save 和 np.load 进行磁盘读写，示例如下：

>>> a = np.random.randint(0,5,(3,4))

>>> a

array([[4, 2, 1, 3],

[4, 0, 2, 4],

[0, 4, 3, 1]])

>>> np.save("random.npy",a)

>>> b = np.load("random.npy")

>>> b

array([[4, 2, 1, 3],

[4, 0, 2, 4],

[0, 4, 3, 1]])

在这里，我们使用 np.random.randint 创建一个随机的 3 × 4 整数数组，值的范围是 0 到 5。NumPy 提供了广泛的随机数库。我们将数组 a 写入磁盘，命名为 random.npy。扩展名 .npy 是必要的，如果没有提供，它会被自动添加。然后我们使用 np.load 从磁盘加载该数组。

我们将在本书中遇到其他 NumPy 函数。我会在它们首次出现时进行解释。现在让我们快速了解一下 SciPy 库。

### SciPy

SciPy 为 Python 添加了大量功能。它在底层使用 NumPy，因此两者通常一起安装。这里有一个完整的教程：[`docs.scipy.org/doc/scipy/reference/tutorial/index.html`](https://docs.scipy.org/doc/scipy/reference/tutorial/index.html)*。

在本书中，我们将重点介绍 scipy.stats 模块中的函数。启动 Python 并尝试以下操作：

>>> import scipy

>>> scipy.__version__

'1.2.1'

这将加载 SciPy 模块并验证其版本号至少与预期一致。任何较新的 SciPy 版本都应该可以正常工作。

作为一个快速测试，让我们尝试以下操作：

>>> from scipy.stats import ttest_ind

>>> a = np.random.normal(0,1,1000)

>>> b = np.random.normal(0,0.5,1000)

>>> c = np.random.normal(0.1,1,1000)

>>> ttest_ind(a,b)

Ttest_indResult(statistic=-0.027161815649563964, pvalue=0.9783333836992686)

>>> ttest_ind(a,c)

Ttest_indResult(statistic=-2.295584443456226, pvalue=0.021802794508002675)

首先，我们加载 NumPy，然后加载 SciPy 中 stats 模块的 ttest_ind 函数。这个函数接受两组数据，例如来自两个班级的测试成绩，并提出一个问题：这两组数据是否具有相同的平均值？或者更准确地说，它问：我们能多大程度上相信这两组数据来自同一个生成过程？*t 检验*是用来回答这个问题的经典方法。评估其结果的一种方式是查看 *p 值*。你可以将 *p* 值看作是一个概率，表示如果这两组数据来自同一个生成过程，它们会有测量到的平均值差异的概率。接近 1 的概率意味着我们非常有信心这两组数据来自同一个过程。

变量 a、b 和 c 是 1D 数组，其中的值（这里是 1,000）是从高斯曲线中提取出来的，也叫 *正态曲线*。我们稍后会详细介绍它们，但目前要知道的是，这些数字是从一个钟形曲线中抽取的，其中位于中间的值比位于边缘的值更可能被选中。normal 函数的前两个参数分别是平均值和标准差，标准差是衡量钟形曲线如何扩展的一个指标：标准差越大，曲线就越平坦、越宽。

在这个例子中，我们预计 a 和 b 会非常相似，因为它们的平均值都是 0.0，尽管钟形曲线的形状略有不同。然而，c 的平均值为 0.1。我们希望 t 检验能够检测到这一点，并告诉我们可能需要小心，a 和 c 是否真的来自相同的过程。

ttest_ind 函数的输出列出了 *p*-值（pvalue）。正如我们预期的那样，比较 a 和 b 返回的 *p*-值为 0.98，这意味着在假设它们来自相同生成过程的情况下，我们看到这两组数据均值之间的差异的概率大约为 98%。然而，当我们比较 a 和 c 时，得到的 *p*-值为 2.7%（0.027）。这意味着如果 a 和 c 来自相同的生成过程，我们看到它们之间的差异的概率约为 3%。因此，我们得出结论，a 和 c 来自不同的过程。我们可以说，这两组数据之间的差异是 *统计上显著的*。

历史上，*p*-值小于 0.05 被认为是统计显著的。然而，这一阈值是任意的，最近在复制实验（尤其是软科学领域）中的经验表明，需要更严格的阈值。使用 *p*-值为 0.05 意味着你大约每 20 次就会错一次（1/20 = 0.05），这是一个过于宽松的阈值。也就是说，一个接近 0.05 的 *p*-值表明可能存在某种现象，需要更多的调查（以及更大的数据集）。

### Matplotlib

我们将使用 Matplotlib 来生成图表。让我们在这里验证它的 2D 和 3D 绘图能力。首先是一个简单的 2D 示例：

>>> import numpy as np

>>> import matplotlib.pylab as plt

>>> x = np.random.random(100)

>>> plt.plot(x)

>>> plt.show()

这个例子加载了 NumPy，Matplotlib 与它配合使用效果最佳，并生成一个包含 100 个随机值（范围为 0, 1)）的向量 x，这是 np.random.random 的输出。然后我们使用 plt.plot 绘制这个向量，并用 plt.show 显示它。Matplotlib 的输出是交互式的。可以在图表上进行操作，熟悉如何使用绘图窗口。例如，[图 1-1 显示了在 Linux 上绘图窗口的样子。由于绘图是随机的，你将看到一组不同的值，但窗口上的控件将保持不变。

![image](img/01fig01.jpg)

*图 1-1：一个示例的 Matplotlib 绘图窗口*

对于 3D，可以试试这个：

>>> from mpl_toolkits.mplot3d import Axes3D

>>> import matplotlib.pylab as plt

>>> import numpy as np

>>> x = np.random.random(20)

>>> y = np.random.random(20)

>>> z = np.random.random(20)

>>> fig = plt.figure()

>>> ax = fig.add_subplot(111, projection='3d')

>>> ax.scatter(x,y,z)

>>> plt.show()

我们首先加载 3D 坐标轴工具包 Matplotlib 和 NumPy。然后，使用 NumPy 生成三个随机向量，[0, 1)。这些就是我们的 3D 点。使用 `plt.figure` 和 `fig.add_subplot` 设置 3D 投影。`111` 是一种简写，告诉 Matplotlib 我们希望得到 1 × 1 的网格，并且当前的绘图应该放在该网格的索引 1 位置。因此，`111` 表示一个单独的绘图。`projection` 关键字让绘图准备好进行 3D 展示。最后，通过 `ax.scatter` 创建散点图，并使用 `plt.show` 显示出来。与 2D 绘图一样，3D 绘图是交互式的。使用鼠标拖动并按住即可旋转图形。

### Scikit-Learn

本书的目标是讲解深度学习的数学，而非深度学习的实现。然而，偶尔我们会需要看一下简单的神经网络模型。在这些情况下，我们会使用 sklearn，特别是 MLPClassifier 类。此外，sklearn 还包含一些用于评估模型性能和高维数据可视化的有用工具。

作为一个快速示例，让我们构建一个简单的神经网络，用于分类手写数字的 8×8 像素灰度图像。此数据集已内置在 sklearn 中。以下是示例代码：

import numpy as np

from sklearn.datasets import load_digits

from sklearn.neural_network import MLPClassifier

❶ d = load_digits()

digits = d["data"]

labels = d["target"]

N = 200

❷ idx = np.argsort(np.random.random(len(labels)))

x_test, y_test = digits[idx[:N]], labels[idx[:N]]

x_train, y_train = digits[idx[N:]], labels[idx[N:]]

❸ clf = MLPClassifier(hidden_layer_sizes=(128,))

clf.fit(x_train, y_train)

score = clf.score(x_test, y_test)

pred = clf.predict(x_test)

err = np.where(y_test != pred)[0]

print("score      : ", score)

print("errors:")

print("  actual   : ", y_test[err])

print("  predicted: ", pred[err])

我们首先导入 NumPy。然后从 sklearn 导入 `load_digits` 函数，用于返回小数字图像数据集，并导入 MLPClassifier 类，用于训练传统神经网络，即多层感知机（MLP）。接着，我们获取数字数据并提取图像及其关联标签，0 . . . 9 ❶。数字图像存储为 8 × 8 = 64 元素的向量，表示图像的展开形式，即将行按顺序排列。数字数据集包含 1,797 张图像，因此 `digits` 是一个 2D NumPy 数组，包含 1,797 行，每行有 64 列，而 `labels` 是一个包含 1,797 个数字标签的向量。

我们随机打乱图像的顺序，并小心地确保每个标签与对应的数字匹配 ❷，然后提取训练数据和测试数据（x_train, x_test）以及标签（y_train, y_test）。我们将前 200 张数字图像留作测试数据，使用剩余的 1,597 张图像训练模型。这意味着我们每个数字大约有 160 张图像用于训练，每个数字大约有 20 张图像用于测试。

接下来，我们通过创建 MLPClassifier ❸ 的实例来构建模型。我们采用所有默认设置，只指定一个隐藏层的大小，该层包含 128 个节点。输入向量有 64 个元素，因此我们将隐藏层的节点数设为输入的两倍。无需显式指定输出层的大小；sklearn 会根据 y_train 中的标签自动推断。训练模型只需要简单地调用 clf.fit，并传入训练图像向量（x_train）和标签（y_train）。

对于像这样的一个小数据集，训练只需几秒钟。当训练完成时，学习到的权重和偏置会保存在模型 (clf) 中。我们首先获取分数，整体准确率（score），然后是模型在测试集上的实际类别标签预测 (pred)。通过检查实际标签 (y_test) 与预测标签不匹配的地方，任何错误都会被记录在 err 中。最后，我们展示错误的实际类别标签和预测标签。

每次运行这段代码时，我们都会得到不同的数字数据排序，从而生成不同的训练集和测试集。此外，神经网络在训练前会随机初始化。因此，每次运行时我们都会得到不同的结果。第一次运行这段代码时，我的整体得分为 0.97（97% 的准确率）。如果只是猜测，准确率大约为 10%，所以我们可以说模型已经学得相当不错。

### 总结

在本章中，我们学习了如何配置我们的工作环境。接着，我简要介绍了我们的 Python 工具包，并提供了进一步学习的资源。工作环境已经设置好并且顺利运行，下一章将深入探讨概率论。
