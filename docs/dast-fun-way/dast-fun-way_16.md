# 结论

![](image_fi/book_art/chapterart.png)

在本书中，我们考察了多种不同的数据结构，了解它们如何影响使用它们的算法，以及它们是否能帮助我们找到咖啡。我们展示了数据的组织如何导致计算成本的显著减少或算法行为的变化。我们审视了不同表示方式之间的权衡以及它们为何重要。在此过程中，我们尝试为如何思考数据结构提供一个直观的基础。

理解每种数据结构的动机、构造方式、用途和权衡取舍是至关重要的，这样才能在开发高效解决方案时正确使用它们。如果你随便选择一个看起来“足够好”的数据结构，可能会遇到最坏的情况，导致性能差到无法忍受。接下来，我们将回顾前面章节中的一些核心主题，以强调每个计算机科学从业者在选择数据结构时应该问的一些问题。

## 数据结构的影响是什么？

从第二章的二分查找开始，我们看到即使是对数据进行少量的结构化处理，也能大大提高算法的效率。数据中的结构使我们能够高效地访问值、聚合计算，或裁剪搜索空间的区域。就像二分查找的例子一样，这种结构可以简单到仅仅是将数据排序。这个简单的改变让我们能够将最坏情况下的运行时间缩短，并将其与值的数量的关系从线性转变为对数级别。类似地，整理我们的咖啡储藏室也能在不同的方面优化我们的咖啡制作体验——最常见的是减少制作第一杯咖啡所需的时间。

二叉查找树、字典树、四叉树和k-d树向我们展示了如何在搜索过程中进一步促进剪枝。基于树的数据结构提供了一种显式的分支组织，使我们能够通过简单的测试裁剪掉搜索空间中的大区域。我们将数据的边界编码到树的结构和节点本身中。此外，数据的分支性质使我们能够清晰地可视化每一层次我们提出的问题：“考虑到这个节点下方的点的边界，感兴趣的点是否可能在这个子树中？”

即使我们没有主动为当前算法优化数据的组织方式，它的排列也会深刻影响我们算法的行为和效率，正如栈和队列所展示的那样。例如，从栈切换到队列会将搜索从深度优先改为广度优先。在极端情况下，数据的结构要求开发全新的算法方法：图的连接结构驱动了一系列新的算法，用于搜索、排序和执行其他计算。

## 我们需要动态数据结构吗？

动态数据结构显著增强了我们方法的灵活性和适应性。使用这些结构意味着我们不再受限于预分配的内存块，这些内存块可能对当前任务来说太小。相反，我们可以通过指针将内存中的不同位置链接起来，使得我们的数据结构可以根据需要增长或缩小。最重要的是，动态数据结构让我们能够不断增加我们的咖啡记录，并在地理网格单元中存储多个咖啡店的位置。

动态数据结构为计算机科学中一些最激动人心、有趣且强大的算法提供了基础。几乎本书中描述的每一个数据结构都利用了指针（或相关的链接）来组织内存中不同块的数据。我们使用指针将二叉搜索树中的节点连接起来，在网格单元和哈希表桶中创建链表，并表示图的结构。

这种强大与灵活性的代价是，访问数据时会增加额外的复杂性。在数组中，我们可以根据索引查找任何项目。然而，一旦涉及指针，这种直接访问方式就不再适用。我们必须通过内存中的指针链条来查找特定的数据，无论是通过链表的节点、树的节点，还是图中的节点。根据这些指针的排列（链表与搜索树），我们可能会使操作对当前任务的效率更高或更低。我们始终需要理解算法如何使用数据结构。仅仅购买一台花哨的咖啡机是远远不够的；我们需要了解如何使用它。

## 什么是摊销成本？

在考虑是否使用某个数据结构时，重要的是要同时考虑构建数据结构的成本和它带来的节省。对数组进行排序或构建二叉搜索树的成本可能比扫描数据以查找单个值更高。几乎总是情况下，通过扫描每个数据点一次进行搜索，比构建一个辅助数据结构更为高效。然而，当我们进行多次搜索时，数学上的计算就会发生变化。

排序数组、二叉搜索树以及其他数据结构之所以有用，是因为它们减少了*所有*未来搜索的成本。如果我们付出一次性的*N* log[2](*N*)成本来对一个整数数组进行排序，那么我们可以根据需要执行任意次数的log[2](*N*)二叉搜索。我们之所以能节省成本，是因为我们将排序数据的成本摊销到许多未来的搜索中。同样地，在冰箱里按过期日期对牛奶盒进行排序，可以在取用时节省宝贵的几秒钟。

## 我们如何将数据结构适应特定问题？

基本数据结构不仅提供了一组本身有用的工具，还为构建更具适应性和专门化的方法奠定了基础。通过前缀树（trie），我们研究了如何将二叉搜索树的分支结构扩展到更高的分支因子，从而实现对字符串的高效搜索。我们还看到了链表如何提供第二层灵活性，以处理哈希表中的碰撞或网格单元中的多个项。

空间数据结构很好地展示了我们适应、结合和优化数据结构的能力。将网格的空间划分与基于树的结构相结合，给我们带来了四叉树的适应性结构。然而，网格和四叉树在高维空间中都会出现问题。我们看到k-d树如何通过在每个分支沿着单一维度进行划分，帮助空间数据结构适应更高维度，不仅使得该结构能够扩展到更高维度，还提高了其剪枝能力。在考虑新的与咖啡相关的问题时，例如匹配标志或优化我们的冲泡设备的参数时，我们应该重新审视并可能根据问题的具体情况调整我们工具箱中的方法。

## 内存与运行时的权衡是什么？

内存和运行时间的权衡是计算机科学中的经典问题。我们通常可以通过预计算并存储额外的数据显著减少算法的成本。堆允许我们在列表中高效地查找和提取最小（或最大）元素，无论是在搜索算法中还是作为辅助数据结构。其权衡是堆本身的开销。我们使用的额外内存与我们想要存储的数据大小成线性关系。类似地，通过使用额外的内存来构建四叉树或k-d树，我们可以大幅减少未来最近邻搜索的运行时间。

即使在数据结构内部，这种权衡仍然存在。我们可以通过增加哈希表的大小来减少碰撞率。在链表中存储额外的信息使我们能够实现跳表，从而在搜索时获得更好的平均性能。类似地，预计算空间树节点的边界并将其存储在节点中，可能使我们能够更高效地测试是否可以剪枝该节点。

理解这些权衡并将其适应于特定项目的环境是至关重要的。你正在编写的视频游戏是要运行在个人电脑、移动设备，还是数据中心的大型服务器上？低内存环境可能需要与高内存环境不同的方法。我们的咖啡储藏室的大小不仅会影响我们能存储的咖啡总量，还会影响是否值得添加明亮的隔板。在一个大型储藏室中——例如可能将卧室改造成储物区——隔板可能帮助我们更快找到咖啡。而在一个小型储藏室中，比如厨房的橱柜，隔板可能只是占用了宝贵的货架空间。

## 如何调整我们的数据结构？

一些数据结构有影响操作性能的参数。网格在最近邻搜索中的性能高度依赖于网格单元的数量和粒度。类似地，B 树的大小参数*k*使我们能够根据本地内存调整每个节点的大小。这些参数几乎总是依赖于我们使用数据结构的上下文。没有一个完美的设置。

理解数据结构的参数如何影响性能以及它们如何依赖于问题的具体情况非常重要。在某些情况下，我们可以通过分析确定使用哪个参数。例如，我们可以根据运行代码的设备的内存块大小来选择 B 树的大小参数*k*。我们选择*k*的方式是让一个完整的 B 树节点恰好适应内存块，从而使我们能够通过一次访问获取最大量的数据。

有时，我们可能需要在真实数据上通过实证测试不同的参数。一种简单的方法是使用具有一系列参数设置的数据，并查看哪种设置的性能最佳。

## 随机化如何影响预期行为？

在检查二叉搜索树和哈希表时，我们注意到这两种数据结构的最坏情况性能可能会退化为线性时间。如果我们将排序的项插入到二叉搜索树中，或者为数据选择了不良的哈希函数，我们实际上会得到链表。我们的数据结构的性能在所有条件下并不总是最优的，而是依赖于数据本身。有时我们能做的最好的事就是提高预期的（或平均情况）运行时。

理解极端性能的可能性对于选择和调整最佳数据结构至关重要。在选择哈希表的参数时，我们希望选择一个足够大的表大小，以降低冲突的概率，同时避免浪费内存。更为关键的是哈希函数的选择，对于哈希表来说，这要求我们了解键的分布。如果键本身有结构，比如只包含偶数，我们需要选择一个对该结构有鲁棒性的哈希函数。类似地，如果我们正在为一个咖啡爱好者会议组织注册，而这些人的姓氏首字母都是*K*，那么注册表不应该根据他们姓氏的首字母来划分与会者。

我们可以通过随机化数据结构本身来在一定程度上缓解病态坏数据的影响。如果我们总是按排序顺序将数据插入到二叉搜索树中，实际上最终会得到一个链表。跳表提供了一种技术，通过故意在我们的列表节点层级中注入随机性，平均来说，可以实现对数时间复杂度的运行时间。然而，随机化并不是万能的。跳表可能会因运气不佳而选择错误的高度。在最坏的情况下，像链表一样，跳表的性能会退化到与数据大小成线性关系。然而，它们发生这种情况的概率很小，我们可以预期它们在平均情况下会表现良好，即使面对病态坏数据。

## 为什么这很重要

在计算机科学中没有一种完美的数据结构。如果我们能指着某一个数据结构说：“总是使用X”，那该多好，但不幸的是，事情并没有那么简单。所有的数据结构都有其复杂性、性能、内存使用和准确性的权衡。

在本书中，我们考察了不同数据结构的样本，它们的权衡，以及它们如何影响算法。我们的讨论远非详尽无遗；还有很多数据结构专门为特定算法、问题或领域进行了优化。例如，红黑树提供了二叉搜索树的自平衡扩展，而度量树则为高维数据提供了不同的空间划分方法。这两种方法，以及其他成百上千种令人印象深刻的数据结构，都有自己的一套权衡和最佳使用场景。我们仅仅触及了数据结构这一丰富而复杂的世界的表面。

本书旨在鼓励你仔细思考如何存储和组织数据。像特定的编程语言或巧妙的算法一样，数据结构对程序的性能、准确性和复杂度有着实际的影响。所有计算机科学从业者不仅需要理解各个数据结构的具体内容，还要了解这些数据结构在解决问题的更广泛背景中的功能。

尤其是当涉及到咖啡时。
