## 第五章：使用列表组织值

![image](img/common.jpg)

我们已经看到，字符串可以用来处理字符序列。在本章中，我们将学习列表，它们帮助我们处理其他类型值的序列，如整数和浮点数。我们还将学习如何将列表嵌套在列表中，这使得我们可以处理数据的网格。

我们将通过使用列表来解决三个问题：找到一组村庄中最小邻里的大小，判断是否筹集到了足够的资金进行学校旅行，以及计算面包店提供的奖金数量。

### 问题 #11：村庄邻里

在本问题中，我们将找到一组村庄中最小邻里的大小。我们会发现，存储所有邻里大小非常有用。不过，可能会有多达 100 个村庄，单独为每个村庄使用一个变量会很麻烦。我们将看到，列表允许我们将原本是分开的变量聚集到一个集合中。我们还将学习 Python 强大的列表操作，用于修改、查找和排序列表。

这是 DMOJ 问题 `ccc18s1`。

#### 挑战

有 *n* 个村庄，位于一条直路上的不同位置。每个村庄用一个整数表示，表示它在路上的位置。

一个村庄的左邻居是位置最小的下一个村庄；一个村庄的右邻居是位置最大的下一个村庄。一个村庄的 *邻里* 包含该村庄与其左邻居之间空间的一半，加上该村庄与其右邻居之间空间的一半。例如，如果一个村庄位于位置 10，左邻居在位置 6，右邻居在位置 15，那么这个村庄的邻里从位置 8（6 和 10 之间的中点）开始，到位置 12.5（10 和 15 之间的中点）结束。

最左边和最右边的村庄只有一个邻居，因此它们的邻里定义没有意义。在本问题中，我们将忽略这两个村庄的邻里。

邻里的 *大小* 计算方法是：邻里的最右端位置减去邻里的最左端位置。例如，从 8 到 12.5 的邻里，大小为 12.5 – 8 = 4.5。

确定最小邻里的大小。

#### 输入

输入包含以下几行：

+   一行包含整数 *n*，表示村庄的数量。*n* 的值在 3 到 100 之间。

+   *n* 行，每行给出一个村庄的位置。每个位置是一个介于 -1,000,000,000 和 1,000,000,000 之间的整数。位置不必按从左到右的顺序给出；一个村庄的邻居可能出现在这些行中的任何位置。

#### 输出

输出最小邻里的大小。输出时保留一位小数。

### 为什么选择列表？

作为读取输入的一部分，我们需要读取 *n* 个整数（表示村庄位置的整数）。当我们在第三章解决 Data Plan 时，就已经处理过这个问题。在那里，我们使用了一个 `for` 循环，精确地循环了 *n* 次。在这里我们也会这样做。

Data Plan 和 Village Neighborhood 之间有一个关键的区别。在 Data Plan 中，我们读取一个整数，使用它，然后再也不引用它了。我们不需要将其保留。但在 Village Neighborhood 中，单次看到每个整数是不够的。一个村庄的邻里关系取决于它的左邻和右邻。如果没有访问这些邻居，我们就无法计算该村庄的邻里大小。我们需要存储所有村庄的位置以备后用。

以一个例子说明为什么我们需要存储所有村庄位置，考虑这个测试案例：

```py
6

20

50

4

19

15

1
```

这里有六个村庄。为了找出一个村庄的邻里大小，我们需要该村庄的左邻和右邻。

输入中的第一个村庄位于位置 20。那么该村庄的邻里大小是多少？为了回答这个问题，我们需要访问所有村庄的位置，以便找到它的左邻和右邻。通过扫描位置，你可以识别出左邻在位置 19，右邻在位置 50。因此，该村庄的邻里大小为 (20 – 19)/2 + (50 – 20)/2 = 15.5。

输入中的第二个村庄位于位置 50。那么该村庄的邻里大小是多少呢？我们仍然需要查看位置来计算。这个村庄恰好是最右侧的村庄，因此我们忽略该村庄的邻里关系。

输入中的第三个村庄位于位置 4。左邻位于位置 1，右邻位于位置 15，所以该村庄的邻里大小为 (4 – 1)/2 + (15 – 4)/2 = 7。

输入中的第四个村庄位于位置 19。左邻位于位置 15，右邻位于位置 20，所以该村庄的邻里大小为 (19 – 15)/2 + (20 – 19)/2 = 2.5。

唯一剩下需要考虑的村庄位于位置 15。如果你计算它的邻里大小，你应该得到答案 7.5。

比较我们计算的所有邻里大小，我们发现最小的邻里大小——也就是此测试案例的正确答案——是 2.5。

我们需要一种方法来存储所有的村庄位置，以便找到每个村庄的邻居。字符串不行，因为字符串只存储字符，而不存储整数。Python 列表来帮忙！

### 列表

*列表* 是一种 Python 类型，用于存储一系列值。（你有时会看到列表的值被称为 *元素*。）我们用开方括号和闭方括号来界定列表。

我们只能在字符串中存储字符，但我们可以在列表中存储任何类型的值。这个整数列表包含了上一部分的村庄位置。

```py
>>> [20, 50, 4, 19, 15, 1]

[20, 50, 4, 19, 15, 1]
```

这是一个字符串列表：

```py
>>> ['one', 'two', 'hello']

['one', 'two', 'hello']
```

我们甚至可以创建一个值类型不同的列表：

```py
>>> ['hello', 50, 365.25]

['hello', 50, 365.25]
```

你对字符串的很多了解也适用于列表。例如，列表支持`+`操作符进行拼接，支持`*`操作符进行复制：

```py
>>> [1, 2, 3] + [4, 5, 6]

[1, 2, 3, 4, 5, 6]

>>> [1, 2, 3] * 4

[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
```

我们甚至有`in`操作符，它可以告诉我们一个值是否在列表中：

```py
>>> 'one' in ['one', 'two', 'hello']

True

>>> 'n' in ['one', 'two', 'three']

False
```

我们有`len`函数来获取列表的长度：

```py
>>> len(['one', 'two', 'hello'])

3
```

列表是一个序列，我们可以使用`for`循环遍历它的值：

```py
>>> for value in [20, 50, 4, 19, 15, 1]:

...     print(value)

...

20

50

4

19

15

1
```

我们可以像使变量指向字符串、整数和浮动数一样让变量指向列表。让我们让两个变量指向列表，然后将它们拼接起来，生成一个新列表。

```py
>>> lst1 = [1, 2, 3]

>>> lst2 = [4, 5, 6]

>>> lst1 + lst2

[1, 2, 3, 4, 5, 6]
```

虽然我们展示了拼接后的列表，但我们并没有存储它，正如我们通过再次查看列表所看到的那样：

```py
>>> lst1

[1, 2, 3]

>>> lst2

[4, 5, 6]
```

为了让一个变量指向拼接后的列表，我们使用赋值：

```py
>>> lst3 = lst1 + lst2

>>> lst3

[1, 2, 3, 4, 5, 6]
```

当不需要具体说明列表包含什么内容时，可以使用像`lst`、`lst1`和`lst2`这样的名称。

但不要使用`list`本身作为变量名。它已经是一个我们可以用来将序列转换为列表的名称：

```py
>>> list('abcde')

['a', 'b', 'c', 'd', 'e']
```

如果你创建一个名为`list`的变量，你将失去这种有价值的行为，并且会让读者感到困惑，他们会期望`list`不被篡改。

最后，列表支持索引和切片。索引返回一个单一值，而切片返回一个值的列表：

```py
>>> lst = [50, 30, 81, 40]

>>> lst[1]

30

>>> lst[-2]

81

>>> lst[1:3]

[30, 81]
```

如果我们有一个字符串列表，我们可以通过两次索引来访问其中一个字符串的字符，第一次选择字符串，第二次选择字符：

```py
>>> lst = ['one', 'two', 'hello']

>>> lst[2]

'hello'

>>> lst[2][1]

'e'
```

**概念检查**

以下代码会将什么存储到`total`变量中？

```py
lst = [a list of numbers]

total = 0

i = 1

while i <= len(lst):

    total = total + i

    i = i + 1
```

A. 列表的和

B. 列表的和，不包括其第一个值

C. 列表的和，不包括其第一个和最后一个值

D. 这段代码会报错，因为它访问了列表的一个无效索引

E. 以上都不是

答案：E. 这段代码将`1`、`2`、`3`等数字加到列表的长度，直到列表的末尾。它并没有加列表中的数字，也没有索引列表！

### 列表的可变性

字符串是*不可变的*，这意味着它们不能被修改。当看起来我们在修改字符串时（例如，使用字符串拼接），我们实际上是在创建一个新字符串，而不是修改已经存在的字符串。

另一方面，列表是*可变的*，这意味着它们*可以*被修改。

我们可以通过使用索引来观察这个区别。如果我们尝试改变一个字符串的字符，就会得到一个错误：

```py
>>> s = 'hello'

>>> s[0] = 'j'

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

TypeError: 'str' object does not support item assignment
```

错误信息说字符串不支持项赋值，这意味着我们不能改变它们的字符。

但由于列表是可变的，我们可以改变它们的值：

```py
>>> lst = ['h', 'e', 'l', 'l', 'o']

>>> lst

['h', 'e', 'l', 'l', 'o']

 >>> lst[0] = 'j'

>>> lst

['j', 'e', 'l', 'l', 'o']

>>> lst[2] = 'x'

>>> lst

['j', 'e', 'x', 'l', 'o']
```

如果没有对赋值语句的准确理解，可变性可能会导致看似令人困惑的行为。这里有一个例子：

```py
   >>> x = [1, 2, 3, 4, 5]

❶ >>> y = x

   >>> x[0] = 99

   >>> x

   [99, 2, 3, 4, 5]
```

目前没有什么意外。但你可能会对这个感到惊讶：

```py
>>> y

[99, 2, 3, 4, 5]
```

`99`是怎么进到`y`中的呢？

当我们将`x`赋值给`y` ❶时，`y`被设置为引用与`x`相同的列表。赋值语句并不会复制列表。实际上只有一个列表，它恰好有两个名称（或*别名*）指向它。所以，如果我们对该列表进行更改，无论是通过`x`还是`y`来引用它，我们都能看到这个更改。

可变性很有用，因为它直接模拟了我们可能希望在列表中执行的操作。如果我们想更改一个值，我们只需修改它。如果没有可变性，修改一个值是不可能的。我们必须创建一个新的列表，内容与旧列表相同，除了我们希望更改的那个值。这样也是可行的，但它是一个迂回且不太透明的方式来改变一个值。

如果你确实想要一个列表的副本，而不仅仅是另一个名称，你可以使用切片。省略起始和结束索引，这样就会得到整个列表的副本：

```py
>>> x = [1, 2, 3, 4, 5]

>>> y = x[:]

>>> x[0] = 99

>>> x

[99, 2, 3, 4, 5]

>>> y

[1, 2, 3, 4, 5]
```

这次请注意，当`x`列表改变时，`y`列表没有变化。它们是独立的列表。

**概念检查**

以下代码的输出是什么？

```py
lst = ['abc', 'def', 'ghi']

lst[1] = 'wxyz'

print(len(lst))
```

A. `3`

B. `9`

C. `10`

D. `4`

E. 这段代码会产生一个错误

答案：A. 改变列表的值是允许的（因为列表是可变的）。但是，将索引 1 处的值更改为更长的字符串，并不会改变列表有三个值这一事实。

### 学习方法

像字符串一样，列表也有许多有用的方法。我将在下一节中展示一些它们，但首先我想教你如何自行学习方法。

你可以使用 Python 的`dir`函数获取特定类型的方法列表。只需用一个值作为参数调用`dir`，你就会得到该值类型的所有方法。

这是我们用字符串值作为参数调用`dir`时得到的结果：

```py
>>> dir('')

['__add__', '__class__', '__contains__', '__delattr__',

<more stuff with underscores>

'capitalize', 'casefold', 'center', 'count', 'encode',

'endswith', 'expandtabs', 'find', 'format',

'format_map', 'index', 'isalnum', 'isalpha', 'isascii',

'isdecimal', 'isdigit', 'isidentifier', 'islower',

'isnumeric', 'isprintable', 'isspace', 'istitle',

'isupper', 'join', 'ljust', 'lower', 'lstrip',

'maketrans', 'partition', 'replace', 'rfind', 'rindex',

'rjust', 'rpartition', 'rsplit', 'rstrip', 'split',

'splitlines', 'startswith', 'strip', 'swapcase', 'title',

'translate', 'upper', 'zfill']
```

请注意，我们用空字符串调用了`dir`。我们本可以用任何字符串值来调用`dir`；空字符串只是最快打出来的。

忽略顶部带有下划线的名称；这些名称是供 Python 内部使用的，一般对程序员没有兴趣。其余的名称是你可以调用的字符串方法。在那个列表中，你会发现一些你已经知道的字符串方法，比如`isupper`和`count`，以及我们尚未遇到的许多其他方法。

要学习如何使用某个方法，你可以在`help`中调用该方法的名称。这是我们在字符串`count`方法上的帮助信息：

```py
>>> help(''.count)

Help on built-in function count:

count(...) method of builtins.str instance

  ❶ S.count(sub[, start[, end]]) -> int

     Return the number of non-overlapping occurrences of

     substring sub in string S[start:end].  Optional

     arguments start and end are interpreted as in

     slice notation.
```

帮助信息告诉我们如何调用该方法 ❶。

方括号表示可选的参数。如果你只想在字符串的某一部分内统计`sub`的出现次数，可以使用`start`和`end`。

浏览方法列表是值得的，看看是否有方法可以帮助你完成当前的编程任务。即使你之前使用过某个方法，查看帮助也能让你发现你以前不知道的功能！

要查看哪些列表方法可用，请调用`dir([])`。要了解它们，可以调用`help([].xxx)`，其中 xxx 是列表方法的名称。

**概念检查**

这是`center`方法的帮助文档：

```py
>>> help(''.center)

Help on built-in function center:

center(width, fillchar=' ', /) method of builtins.str instance

    Return a centered string of length width.

    Padding is done using the specified fill character

    (default is a space).
```

以下代码生成的字符串是什么？

```py
'cave'.center(8, 'x')
```

A. `'xxcavexx'`

B. `' cave '`

C. `'xxxxcavexxxx'`

D. `' cave '`

答案：A. 我们在调用`center`时，`width`是`8`，`fillchar`是`'x'`。（如果我们只提供一个参数，`fillchar`会使用空格。）因此，生成的字符串的长度将是 8。字符串`'cave'`有四个字符，因此我们需要再加四个字符来达到长度 8。所以 Python 会在字符串的开头和结尾各加两个空格，使得字符串居中。

### 列表方法

现在该在村庄邻里问题上取得进展了。我能想到两个对列表进行操作的方式，这将有助于我们解决它。

首先，向列表添加元素。我们从没有任何村庄位置开始，然后一次从输入中读取一个村庄位置。因此，我们需要一种方法来将每个位置添加到一个增长的列表中：一开始列表什么都没有，然后它会有一个村庄位置，再然后两个，以此类推。

第二，排序一个列表。在读取完所有村庄位置后，我们需要找到最小的邻里。这涉及到查看每个村庄的位置以及它左右邻居的距离。村庄的位置可能是任意顺序，因此通常很难找到某个村庄的邻居。回想一下我们在本章“为什么使用列表？”中的工作。对于每个村庄，我们必须扫描整个列表来找出它的邻居。如果我们能够按位置对村庄进行排序，那就容易多了。那样我们就能确切知道邻居在哪里：它们将恰好位于村庄的左边和右边。

例如，以下是我们按顺序读取的示例村庄：

```py
20 50 4 19 15 1
```

这太乱了！在真实的街道上，它们会按位置顺序排列，像这样：

```py
1 4 15 19 20 50
```

想知道位置为 4 的村庄的邻居吗？只需查看它左边和右边的位置：1 和 15。位置为 15 的村庄的邻居呢？嗖，它们就在那儿——4 和 19。再也不需要到处找了。我们将排序村庄位置的列表，以简化代码。

我们可以使用`append`方法向列表添加元素，并使用`sort`方法对列表进行排序。我们将学习这两种方法，以及其他一些你在继续处理列表时可能会觉得有用的方法，然后我们会回到村庄邻里问题上。

#### 向列表添加元素

`append`方法*追加*到一个列表中，这意味着它会将一个值添加到已经存在的值的末尾。下面是`append`向一个最初为空的列表添加三个村庄位置：

```py
>>> positions = []

>>> positions.append(20)

>>> positions

[20]

>>> positions.append(50)

>>> positions

[20, 50]

>>> positions.append(4)

>>> positions

[20, 50, 4]
```

请注意，我们在使用`append`时并没有使用赋值语句。`append`方法不会返回一个列表；它会修改现有的列表。

在方法改变列表时使用赋值语句是一个常见的错误。犯这个错误会导致列表丢失，像这样：

```py
>>> positions

[20, 50, 4]

>>> positions = positions.append(19)

>>> positions
```

什么都没有！从技术上讲，`positions`现在引用的是一个`None`值；你可以通过`print`查看到这一点：

```py
>>> print(positions)

None
```

`None` 值用于表示没有可用的信息。这里绝对不应该是这种情况——我们希望得到四个村庄的位置！——但是由于一个错误的赋值语句，我们丢失了列表。

如果你的列表丢失了，或者你收到与 `None` 值相关的错误消息，确保你没有使用赋值语句与一个只修改列表的方法一起使用。

`extend` 方法与 `append` 方法相关。当你想将一个列表（而不是单一的值）连接到现有列表的末尾时，可以使用 `extend`。这是一个示例：

```py
>>> lst1 = [1, 2, 3]

>>> lst2 = [4, 5, 6]

>>> lst1.extend(lst2)

>>> lst1

[1, 2, 3, 4, 5, 6]

>>> lst2

[4, 5, 6]
```

如果你想在列表中的某个位置插入元素，而不是插入到末尾，可以使用 `insert` 方法。它接受一个索引和一个值，并将该值插入到指定位置：

```py
>>> lst = [10, 20, 30, 40]

>>> lst.insert(1, 99)

>>> lst

[10, 99, 20, 30, 40]
```

#### 排序列表

`sort` 方法 *排序* 一个列表，将其值按顺序排列。如果我们调用时不传递任何参数，它会按从小到大的顺序排序：

```py
>>> positions = [20, 50, 4, 19, 15, 1]

>>> positions.sort()

>>> positions

[1, 4, 15, 19, 20, 50]
```

如果我们使用 `reverse` 参数并将其设置为 `True`，它会从大到小排序：

```py
>>> positions.sort(reverse=True)

>>> positions

[50, 20, 19, 15, 4, 1]
```

我使用的语法，`reverse=True`，是新的。根据我们在本书中到目前为止调用方法和函数的方式，你可能会期待单独的 `True` 就能工作。但事实并非如此：`sort` 需要完整的 `reverse=True` 参数，原因我将在第六章中解释。

#### 从列表中移除值

`pop` 方法通过索引移除一个值。如果没有提供参数，`pop` 会移除并返回最右边的值。

```py
>>> lst = [50, 30, 81, 40]

>>> lst.pop()

40
```

我们可以将要移除的值的索引作为参数传递给 `pop` 方法。在这里，我们移除并返回索引为 `0` 的值：

```py
>>> lst.pop(0)

50
```

由于 `pop` 会返回值——与 `append` 和 `sort` 等方法不同——将其返回值赋给一个变量是有意义的：

```py
>>> lst

[30, 81]

>>> value = lst.pop()

>>> value

81

>>> lst

[30]
```

`remove` 方法通过值移除，而不是通过索引。传递给它一个值，它会移除该值在列表中的最左侧出现。如果值不存在，`remove` 会产生错误。如下所示，列表中有两个 `50`，因此 `remove(50)` 会执行两次，直到产生错误：

```py
>>> lst = [50, 30, 81, 40, 50]

>>> lst.remove(50)

>>> lst

[30, 81, 40, 50]

>>> lst.remove(50)

>>> lst

[30, 81, 40]

>>> lst.remove(50)

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

ValueError: list.remove(x): x not in list
```

**概念检查**

以下代码运行后，`lst` 的值是什么？

```py
lst = [2, 4, 6, 8]

lst.remove(4)

lst.pop(2)
```

A. `[2, 4]`

B. `[6, 8]`

C. `[2, 6]`

D. `[2, 8]`

E. 这段代码会产生错误

答案：C. `remove` 调用移除了值 `4`，剩下 `[2, 6, 8]`。现在 `pop` 调用移除了索引为 `2` 的值，即值 `8`。这留下了最终的列表 `[2, 6]`。

### 解决问题

假设我们已经成功读取并排序了村庄位置。此时我们的列表将如下所示：

```py
>>> positions = [1, 4, 15, 19, 20, 50]

>>> positions

[1, 4, 15, 19, 20, 50]
```

要找到最小邻里的大小，我们首先要找到索引为 `1` 的村庄的邻里大小。（注意，我们没有从索引 `0` 开始：索引 `0` 处的村庄是最左边的，根据问题描述，我们可以忽略它。）我们可以这样找到该邻里的大小：

```py
>>> left = (positions[1] - positions[0]) / 2

>>> right = (positions[2] - positions[1]) / 2

>>> min_size = left + right

>>> min_size

7.0
```

`left` 变量存储邻里左侧部分的大小，而 `right` 存储右侧部分的大小。然后，我们将它们相加得到邻里的总大小。我们得到的值是 `7.0`。

那就是我们需要超越的值。我们怎么知道其他村庄是否有更小的邻里呢？我们可以使用一个循环来处理这些其他村庄。如果我们找到一个比当前最小邻里还小的邻里，我们就将当前最小邻里更新为这个更小的大小。

我们解决方案的代码在清单 5-1 中。

```py
   n = int(input())

❶ positions = []

❷ for i in range(n):

    ❸ positions.append(int(input()))

❹ positions.sort()

❺ left = (positions[1] - positions[0]) / 2

   right = (positions[2] - positions[1]) / 2

   min_size = left + right

❻ for i in range(2, n - 1):

       left = (positions[i] - positions[i - 1]) / 2

       right = (positions[i + 1] - positions[i]) / 2

       size = left + right

    ❼ if size < min_size:

           min_size = size

   print(min_size)
```

*清单 5-1：解决村庄邻里问题*

我们首先从输入中读取`n`，即村庄的数量。我们还将`positions`设置为空列表❶。

第一个范围`for`循环的每次迭代❷负责读取一个村庄的位置，并将其添加到`positions`列表中。它通过使用`input`读取下一个村庄的位置，使用`int`将其转换为整数，并使用列表方法`append`将该整数添加到列表❸。这一行代码❸等价于以下三行代码：

```py
    position = input()

    position = int(position)

    positions.append(position)
```

在读取了村庄位置之后，我们接着按升序对它们进行排序❹。然后，我们找到索引为`1`的村庄的邻里大小，并使用`min_size`存储❺。

接下来，在第二个循环中，我们遍历其他村庄，这些村庄的邻里大小需要计算❻。这些村庄的索引从`2`开始，到`n - 2`结束。（我们不想考虑索引为`n - 1`的村庄，因为那是最右边的村庄。）因此，我们使用`range`，第一个参数为`2`（即从`2`开始），第二个参数为`n - 1`（即到`n - 2`结束）。

在循环内部，我们计算当前村庄邻里的大小，正如我们为第一个村庄所做的那样。到目前为止我们找到的最小邻里大小由`min_size`表示。当前村庄的邻里是否比我们找到的最小邻里更小？为了回答这个问题，我们使用`if`语句❼。如果当前村庄的邻里比`min_size`小，我们就将`min_size`更新为当前村庄的邻里大小。如果当前村庄的邻里不小于`min_size`，我们就什么也不做，因为这个村庄不会改变最小邻里的大小。

遍历完所有村庄后，`min_size`一定是最小的邻里大小。因此，我们输出`min_size`的值。

该问题描述的“输出”部分要求“保留小数点后正好一位数字”。如果最小的大小是像 6.25 或 8.33333 这样的数值呢？我们是不是应该对这个问题做些什么？

不，按照我们所做的已经很安全了。我们能获得的邻域大小只有类似`3.0`（小数点后有`0`）和`3.5`（小数点后有`.5`）这样的数字。原因如下。当我们计算邻域的左部分时，我们先减去两个整数，然后将得到的整数除以 2。如果除以 2 之前是偶数，那么结果将是`.0`数（没有余数）。如果除以 2 之前是奇数，那么结果将是`.5`数。邻域的右部分也是如此：其大小要么是`.0`，要么是`.5`。因此，将左部分和右部分相加得到总大小，必然会得到一个`.0`或`.5`的数字。

### 避免代码重复：另外两种解决方案

有一点令人失望的是，我们在第二个范围的`for`循环之前和其中都包含了“计算邻域大小”的代码。通常来说，重复的代码意味着我们有可能改善代码的设计。我们希望避免重复代码，因为它增加了我们需要维护的代码量，并且如果重复的代码存在缺陷，修复起来也更加困难。在这里，重复的代码我认为是可以接受的（只有三行），但我们可以讨论两种避免重复的方式。这些是你可以应用于其他类似问题的通用方法。

#### 使用一个巨大值

我们之所以在循环之前计算村庄邻域的大小，是为了让循环能够有一个值来与其他邻域大小进行比较。如果我们没有给`min_size`赋初值就进入循环，当代码尝试将其与当前村庄的大小进行比较时，就会出错。

如果我们在循环之前将`min_size`设置为`0.0`，那么循环将永远找不到更小的值，我们将错误地输出`0.0`，无论测试用例是什么。使用`0.0`会是一个错误！

但是一个非常大的值，至少大到能够覆盖所有可能的邻域大小，*是*可行的。我们只需要让它变得足够大，确保第一次循环时就能找到一个大小不再增大的值，保证我们的伪巨大值不会被输出。

从问题描述中的“输入”部分我们知道，每个位置的范围在-1,000,000,000 到 1,000,000,000 之间。那么我们能拥有的最大邻域就是当一个村庄位于-1,000,000,000，另一个村庄位于 1,000,000,000，并且中间有一个村庄时。这个中间的村庄将拥有一个大小为 1,000,000,000 的邻域。因此，我们可以将`min_size`初始化为`1000000000.0`或更大的值。这个替代方法见列表 5-2。

```py
   n = int(input())

   positions = []

   for i in range(n):

       positions.append(int(input()))

   positions.sort()

   min_size = 1000000000.0

❶ for i in range(1, n - 1):

       left = (positions[i] - positions[i - 1]) / 2

       right = (positions[i + 1] - positions[i]) / 2

       size = left + right

       if size < min_size:

           min_size = size

   print(min_size)
```

*列表 5-2：用一个巨大值解决村庄邻域问题*

小心！现在我们需要从索引`1`开始计算大小❶（而不是从`2`）；否则，我们会忘记包括索引`1`处村庄的邻域。

#### 构建大小列表

另一个避免代码重复的方法是将每个邻里大小存储在一个大小列表中。Python 有一个内建的 `min` 函数，它可以接受一个序列并返回其中的最小值：

```py
>>> min('qwerty')

'e'

>>> min([15.5, 7.0, 2.5, 7.5])

2.5
```

（Python 也有一个 `max` 函数，可以返回序列中的最大值。）

请参见清单 5-3，它展示了如何在邻里大小列表上使用`min`。

```py
n = int(input())

positions = []

for i in range(n):

    positions.append(int(input()))

positions.sort()

sizes = []

for i in range(1, n - 1):

    left = (positions[i] - positions[i - 1]) / 2

    right = (positions[i + 1] - positions[i]) / 2

    size = left + right

    sizes.append(size)

min_size = min(sizes)

print(min_size)
```

*清单 5-3：使用* min 解决村庄邻里问题

随时可以提交这些解答给评审，任选你最喜欢的一个！

在继续之前，你可能想尝试解决“章节练习”中的第 1 题，见第 134 页。

### 问题 #12：学校旅行

许多问题中，输入行会包含多个整数或浮动数字。到现在为止我们避免了这些问题，但它们随处可见！接下来我们将学习如何使用列表处理这类问题的输入。

这是 DMOJ 问题`ecoo17r1p1`。

#### 挑战

学生们希望在年底进行一次学校旅行，但他们需要资金来支付旅行费用。为了筹集资金，他们组织了一次早午餐活动。参加早午餐的学生，第一年级学生支付$12，第二年级学生支付$10，第三年级学生支付$7，第四年级学生支付$5。

在早午餐筹集的所有资金中，50%的资金可以用来支付学校旅行的费用（剩下的 50%用于支付早午餐本身的费用）。

我们知道学校旅行的费用、每年级学生的比例，以及学生的总人数。确定学生们是否需要为学校旅行筹集更多的资金。

#### 输入

输入包括 10 个测试用例，每个测试用例有三行（共 30 行）。以下是每个测试用例的三行：

+   第一行包含学校旅行的费用，单位是美元，整数范围在 50 到 50,000 之间。

+   第二行包含四个数字，分别表示参加早午餐的学生在第一、第二、第三和第四年级的比例。每两个数字之间有一个空格。每个数字介于 0 和 1 之间，它们的和为 1（即 100%）。

+   第三行包含整数 *n*，表示参加早午餐的学生人数。*n* 介于 4 到 2,000 之间。

#### 输出

对于每个测试用例：如果学生们需要为学校旅行筹集更多的钱，输出`YES`；否则，输出`NO`。

#### 一个陷阱

假设有 50 名学生，其中 10%（即 0.1 的比例）是四年级学生。然后我们可以计算出 50 * 0.1 = 5 名四年级学生。

现在假设有 50 名学生，其中 15%（即 0.15 的比例）是四年级学生。如果我们相乘，得到 50 * 0.15 = 7.5 名四年级学生。

拥有 7.5 个学生没有任何意义，而且我还没告诉你在这种情况下应该怎么做。完整的问题描述指出，我们需要将数字向下取整——所以这里我们需要将其取整到 7。这样可能会导致一、二、三、四年级的学生总数与所有学生总数不符。对于没有被计算到的学生，我们需要将他们添加到学生最多的那一年级。可以保证，只有一个年级的学生数最多（不会出现多个年级平分的情况）。

我们首先解决问题时忽略这个限制条件，然后再将这个限制条件纳入进来，提供完整的解决方案。

### 拆分字符串和连接列表

每个测试用例的第二行包含四个比例，像这样：

```py
0.2 0.08 0.4 0.32
```

我们需要一种方法，从字符串中提取出这四个数字以进行进一步处理。我们将学习字符串的`split`方法，来将一个字符串拆分为它的各个部分。同时，我们还将学习字符串的`join`方法，它让我们可以反过来，将一个列表合并成一个单一的字符串。

#### 将字符串拆分为列表

记住，不管输入是什么样的，`input`函数总是返回一个字符串。如果输入应该被解释为整数，我们需要将字符串转换为整数。如果输入应该被解释为浮点数，我们需要将字符串转换为浮点数。如果输入应该被解释为四个浮点数？那么，在转换任何东西之前，我们最好先将它拆分成单独的浮点数！

字符串的`split`方法将字符串拆分为它的各个部分。默认情况下，`split`会以空格为分隔符，这正好适用于我们的四个浮点数：

```py
>>> s = '0.2 0.08 0.4 0.32'

>>> s.split()

['0.2', '0.08', '0.4', '0.32']
```

`split`方法返回一个字符串列表，在此时我们可以独立访问其中的每个值：这里，我保存了`split`返回的列表，然后访问了其中的两个值：

```py
>>> proportions = s.split()

>>> proportions

['0.2', '0.08', '0.4', '0.32']

>>> proportions[1]

'0.08'

>>> proportions[2]

'0.4'
```

现实中的数据通常是以逗号分隔，而不是空格分隔。小菜一碟：我们可以传递一个参数给`split`，告诉它使用什么作为分隔符：

```py
>>> info = 'Toronto,Ontario,Canada'

>>> info.split(',')

['Toronto', 'Ontario', 'Canada']
```

#### 将列表连接成字符串

要实现从列表到字符串的转换，而不是从字符串到列表，我们可以使用字符串的`join`方法。`join`方法调用的字符串将作为列表值之间的分隔符。以下是两个示例：

```py
>>> lst = ['Toronto', 'Ontario', 'Canada']

>>> ','.join(lst)

 'Toronto,Ontario,Canada'

>>> '**'.join(lst)

'Toronto**Ontario**Canada'
```

从技术上讲，`join`可以连接任何序列中的值，不仅仅是列表。这是一个连接字符串中字符的示例：

```py
>>> '*'.join('abcd')

'a*b*c*d'
```

### 修改列表值

当我们对一个由四个部分组成的字符串使用`split`时，我们会得到一个字符串列表：

```py
>>> s = '0.2 0.08 0.4 0.32'

>>> proportions = s.split()

>>> proportions

['0.2', '0.08', '0.4', '0.32']
```

在第一章的《字符串与整数之间的转换》中，我们了解到，看起来像数字的字符串不能用于数值计算。因此，我们需要将这个字符串列表转换为浮点数列表。

我们可以使用`float`将字符串转换为浮点数，像这样：

```py
>>> float('45.6')

45.6
```

那只是一个浮点数。我们如何将整个字符串列表转换为浮点数列表呢？很容易诱惑我们通过以下循环来实现：

```py
>>> for value in proportions:

...     value = float(value)
```

逻辑是，程序应该遍历列表中的每个值并将其转换为浮点数。

可惜，它没有奏效。列表仍然指向字符串：

```py
>>> proportions

['0.2', '0.08', '0.4', '0.32']
```

可能哪里出了问题？`float`没有起作用吗？我们可以通过查看转换后`value`的类型来确认`float`正常工作：

```py
>>> for value in proportions:

...     value = float(value)

...     type(value)

...

<class 'float'>

<class 'float'>

<class 'float'>

<class 'float'>
```

四个浮点数！但列表顽固地保持字符串形式。

这里发生的情况是，我们并没有改变列表中所指向的值。我们改变了变量`value`所指向的内容，但这并没有改变列表仍然指向原来的字符串值。要真正改变列表引用的值，我们需要在列表的索引位置赋予新值。下面是如何做的：

```py
>>> proportions

['0.2', '0.08', '0.4', '0.32']

>>> for i in range(len(proportions)):

...     proportions[i] = float(proportions[i])

...

>>> proportions

[0.2, 0.08, 0.4, 0.32]
```

`for` 循环遍历每个索引，并通过赋值语句修改该索引所指向的值。

### 解决大部分问题

现在我们已经准备好解决问题，只剩下那个特殊情况。

我们将从一个示例开始，突出我们代码需要做的事情。然后我们会进入代码本身。

#### 探索一个测试用例

这个问题的输入包括 10 个测试用例，但我这里只展示一个。如果你从键盘输入这个测试用例，你将看到答案。但程序不会在这里终止，因为它在等待下一个测试用例。如果你使用输入重定向来处理这个测试用例，你仍然会看到答案。但接下来你会遇到一个`EOFError`。EOF 代表“文件结束”；该错误是因为程序试图读取更多输入，而可用的输入已经用尽。一旦你的代码在一个测试用例中正常工作，你可以尝试在输入中添加更多测试用例，以确保它们也能正常工作。当你有了 10 个测试用例后，程序应该能运行到完成。

这是我想要和你一起追踪的测试用例：

```py
504

0.2 0.08 0.4 0.32

125
```

学校旅行的费用是 504 美元，共有 125 名学生参加早午餐。

为了计算早午餐筹集的资金，我们计算每年学生筹集的资金。第一年有 125 * 0.2 = 25 名学生参加，每个学生支付 12 美元。所以，第一年学生筹集了 25 * 12 = 300 美元。我们可以同样计算第二、三、四年学生筹集的资金。有关这部分的更多内容，请参见表 5-1。

**表 5-1:** 学校旅行示例

| **学年** | **该学年的学生数** | **每个学生的费用** | **筹集的资金** |
| --- | --- | --- | --- |
| 第一学年 | 25 | 12 | 300 |
| 第二学年 | 10 | 10 | 100 |
| 第三学年 | 50 | 7 | 350 |
| 第四学年 | 40 | 5 | 200 |

每年学生所筹集的资金通过将该年学生人数乘以该年每个学生的费用来计算；请参见表格最右列。对于所有学生筹集的总资金，我们可以将最右列中的四个数字相加。这样得到 300 + 100 + 350 + 200 = 950 美元。只有 50%的资金可以用于学校旅行。所以剩下的 950 / 2 = 475 美元，仍然不足以支付 504 美元的旅行费用。因此，正确的输出是`YES`，因为还需要筹集更多的钱。

#### 代码

这个部分解决方案将正确处理任何输入，其中将比例乘以学生人数得到一个整数学生人数（例如我们刚才做的测试用例）。请参见清单 5-4 以获取代码。

```py
❶ YEAR_COSTS = [12, 10, 7, 5]

❷ for dataset in range(10):

       trip_cost = int(input())

    ❸ proportions = input().split()

       num_students = int(input())

    ❹ for i in range(len(proportions)):

           proportions[i] = float(proportions[i])

    ❺ students_per_year = []

       for proportion in proportions:

        ❻ students = int(num_students * proportion)

           students_per_year.append(students)

       total_raised = 0

 ❼ for i in range(len(students_per_year)):

           total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]

    ❽ if total_raised / 2 < trip_cost:

           print('YES')

       else:

           print('NO')
```

*清单 5-4：解决大部分学校旅行问题*

首先，我们使用变量`YEAR_COSTS`来表示参加早午餐的费用列表：包括第一、第二、第三和第四年学生的费用 ❶。一旦我们确定了每年学生的人数，就会将这些人数乘以这些费用值来计算筹集到的资金。费用是固定不变的，因此我们永远不会改变该变量指代的内容。对于这样的“常量”变量，Python 的约定是将其名称写成大写字母，正如我在这里所做的那样。

输入包含 10 个测试用例，因此我们循环 10 次 ❷，每次处理一个测试用例。程序的其余部分在这个循环内，因为我们希望重复执行 10 次。

对于每个测试用例，我们读取三行输入。第二行是包含四个比例的那一行，因此我们使用`split`将其拆分为四个字符串的列表 ❸。然后，我们使用`for`循环遍历范围，将每个字符串转换为浮点数 ❹。

利用这些比例，我们的下一个任务是确定每年学生的人数。我们从一个空列表开始 ❺。然后，对于每个比例，我们将总学生人数乘以该比例 ❻，并将结果附加到列表中。注意在❻处，我使用了`int`来保证我们仅添加整数。`int`用于浮点数时，通过向 0 舍入来丢弃小数部分。

现在我们有了两个列表，可以用来计算已筹集的资金。在`students_per_year`中，我们有一个每年学生人数的列表，大致如下所示：

```py
[25, 10, 50, 40]
```

而在`YEAR_COSTS`中，我们有每年学生的早午餐费用：

```py
[12, 10, 7, 5]
```

这些列表中索引为 0 的每个值告诉我们第一年学生的情况，索引为 1 的每个值告诉我们第二年学生的情况，依此类推。这样的列表被称为*平行列表*，因为它们并行工作，以告诉我们每个列表单独无法提供的信息。

我们使用这两个列表来计算总筹款金额，通过将每个学生人数与相应的学生费用相乘，并将所有这些结果相加 ❼。

是否筹集了足够的钱用于学校旅行？为了找出答案，我们使用`if`语句❽。早午餐筹集的一半钱可以用于学校旅行。如果这笔钱少于学校旅行的费用，那么我们需要筹集更多的钱（`YES`）；否则，我们不需要（`NO`）。

我们编写的代码非常通用。唯一能知道有四个年级学生的线索在❶。如果我们想为不同年数的问题解决类似的问题，我们所需要做的就是修改这一行（并提供期望比例的输入）。这就是列表的强大之处：它们帮助我们编写灵活的代码，能够适应我们正在解决问题的变化。

### 如何处理捕获

现在让我们看看为什么我们当前的程序在一些测试用例中会做出错误的处理，以及我们将使用哪些 Python 功能来修复它。

#### 探索一个测试用例

这是我们当前代码错误处理的一个测试用例：

```py
50

0.7 0.1 0.1 0.1

9
```

这次，学校旅行的费用是 50 美元，九个学生参加了早午餐。对于第一年的学生人数，我们当前的程序会计算 9 * 0.7 = 6.3，然后向下四舍五入为 6。必须向下四舍五入是我们需要小心这个测试用例的原因。要查看我们当前的程序在四个年级的表现，请参见表 5-2。

**表 5-2：** 当前程序处理错误的学校旅行示例案例

| **学年** | **该年学生人数** | **每个学生的费用** | **筹集的金额** |
| --- | --- | --- | --- |
| 第一学年 | 6 | 12 | 72 |
| 第二学年 | 0 | 10 | 0 |
| 第三年 | 0 | 7 | 0 |
| 第四学年 | 0 | 5 | 0 |

除第一年外，每年都没有学生，因为 9 * 0.1 = 0.9 向下四舍五入为 0。所以看起来我们筹集的全部金额只有 72 美元。72 美元的一半是 36 美元，无法支付 50 美元的学校旅行费用。我们当前的程序输出`YES`。我们需要筹集更多的钱。

. . . 或者不。我们应该有九个学生在这里，而不是六个！我们损失了三个学生，因为四舍五入。问题描述中指定我们应该将这些学生加入到学生最多的年级，而在本例中是第一年。如果我们这么做，我们会看到我们实际上筹集了 9 * 12 = 108 美元。108 美元的一半是 54 美元，因此实际上我们*不*需要再为 50 美元的学校旅行筹集更多的钱！正确的输出是`NO`。

#### 更多列表操作

为了修复我们的程序，我们需要做两件事：计算因四舍五入而丢失的学生人数，并将这些学生加到学生最多的年级。

##### 求和一个列表

为了确定因四舍五入而丢失的学生人数，我们可以将`students_per_year`列表中的学生人数加起来，然后从总学生人数中减去这个值。Python 的`sum`函数接收一个列表并返回其值的总和：

```py
>>> students_per_year = [6, 0, 0, 0]

>>> sum(students_per_year)

6

>>> students_per_year = [25, 10, 50, 40]

>>> sum(students_per_year)

125
```

#### 查找最大值的索引

Python 的`max`函数接收一个序列并返回其最大值：

```py
>>> students_per_year = [6, 0, 0, 0]

>>> max(students_per_year)

6

>>> students_per_year = [25, 10, 50, 40]

>>> max(students_per_year)

50
```

我们需要的是最大值的索引，而不是最大值本身，这样我们才能增加该索引处的学生数量。给定最大值后，我们可以使用`index`方法找到它的索引。它返回提供值所在的最左边的索引，若值不在列表中，则会产生错误：

```py
>>> students_per_year = [6, 0, 0, 0]

>>> students_per_year.index(6)

0

>>> students_per_year.index(0)

1

>>> students_per_year.index(50)

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

ValueError: 50 is not in list
```

我们将搜索一个我们知道在列表中的值，因此不需要担心出现错误。

#### 解决问题

我们到了！现在我们可以更新我们的部分解决方案，来处理任何有效的测试用例。新程序见列表 5-5。

```py
YEAR_COSTS = [12, 10, 7, 5]

for dataset in range(10):

    trip_cost = int(input())

    proportions = input().split()

    num_students = int(input())

    for i in range(len(proportions)):

        proportions[i] = float(proportions[i])

    students_per_year = []

    for proportion in proportions:

        students = int(num_students * proportion)

        students_per_year.append(students)

 ❶ counted = sum(students_per_year)

    uncounted = num_students - counted

    most = max(students_per_year)

    where = students_per_year.index(most)

 ❷ students_per_year[where] = students_per_year[where] + uncounted

    total_raised = 0

    for i in range(len(students_per_year)):

        total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]

    if total_raised / 2 < trip_cost:

        print('YES')

    else:

        print('NO')
```

*列表 5-5：解决学校旅行问题*

唯一的新代码是从❶开始的五行。我们使用`sum`来计算迄今为止我们已经统计了多少学生，然后从总学生数中减去这一数值，得到未统计学生的数量。接着，我们使用`max`和`index`来识别应当添加未统计学生数量的年份索引。最后，我们将未统计的学生数添加到这个索引上❷。（将`0`加到一个数字上不会改变该数字，因此不必担心当`uncounted`为`0`时需要编写特殊的行为代码。这个代码在这种情况下是安全的。）

这就是这个问题的全部内容。去提交给评审吧！然后再回来——我们即将探索更多一般的列表结构。

在继续之前，你可能想尝试解决“章节练习”中第 5 题，见第 134 页。

### 问题 #13：面包师奖金

在这个问题中，我们将看到列表如何帮助我们处理二维数据。这种数据在实际的程序中经常出现。例如，电子表格中的数据由行和列组成；处理这样的数据需要像我们即将学习的技巧。

这是 DMOJ 问题`ecoo17r3p1`。

#### 挑战

面包师布里有若干特许经营商，每个特许经营商将烘焙商品销售给消费者。布里已经达到了 13 年的营业里程碑，她将通过根据销售额发放奖金来庆祝。这些奖金取决于每天的销售额和每个特许经营商的销售额。奖金的分配方式如下：

+   对于每一天，如果所有特许经营商的总销售额是 13 的倍数，那么那个倍数将作为奖金发放。例如，一个特许经营商当天共售出了 26 件烘焙商品，那么他将获得 26 / 13 = 2 个奖金。

+   对于每个在所有天数中总销售额是 13 的倍数的特许经营商，那个倍数将作为奖金发放。例如，一个特许经营商总共售出了 39 件烘焙商品，则他将获得 39 / 13 = 3 个奖金。

确定总共发放的奖金数。

#### 输入

输入包含 10 个测试用例。每个测试用例包含以下几行：

+   一行包含特许经营商的整数数量*f*和天数*d*，它们之间由空格分隔。*f*的值在 4 到 130 之间，*d*的值在 2 到 4,745 之间。

+   *d* 行，每行包含 *f* 个由空格分隔的整数。每个整数表示一个销售量。这些行中的第一行给出了第一天每个加盟商的销售额，第二行给出了第二天的销售额，依此类推。每个整数在 1 到 13,000 之间。

#### 输出

对于每个测试用例，输出奖励的奖金总数。

### 表格表示

这个问题的数据可以通过表格来表示。我们将从一个示例开始，然后看看如何将表格表示为一个列表。

#### 探索一个测试用例

如果我们有 *d* 天数和 *f* 加盟商，我们可以将数据排成一个有 *d* 行和 *f* 列的表格。

这是一个示例测试用例：

```py
6 4

1 13 2 1 1 8

2 12 10 5 11 4

39 6 13 52 3 3

15 8 6 2 7 14
```

对应这个测试用例的表格在 表 5-3 中。

**表 5-3：** 烘焙商奖金表

|  | **0** | **1** | **2** | **3** | **4** | **5** |
| --- | --- | --- | --- | --- | --- | --- |
| **0** | 1 | 13 | 2 | 1 | 1 | 8 |
| **1** | 2 | 12 | 10 | 5 | 11 | 4 |
| **2** | 39 | 6 | 13 | 52 | 3 | 3 |
| **3** | 15 | 8 | 6 | 2 | 7 | 14 |

我已经给行和列编号，从 0 开始，以便与我们稍后将数据存储到列表中的方式一致。

在这个测试用例中，奖励了多少奖金？首先，让我们看看表格的行，它们对应的是天数。第 0 行的销售总和是 1 + 13 + 2 + 1 + 1 + 8 = 26\. 由于 26 是 13 的倍数，这一行给我们带来了 26 / 13 = 2 个奖金。第 1 行的总和是 44\. 这不是 13 的倍数，所以这一行没有奖金。第 2 行的总和是 116——同样，没有奖金。第 3 行的总和是 52，给我们带来了 52 / 13 = 4 个奖金。

现在让我们看一下与加盟商对应的列。第 0 列的总和是 1 + 2 + 39 + 15 = 57\. 这不是 13 的倍数，所以没有奖金。实际上，唯一给我们带来奖金的列是第 1 列。它的总和是 39，给我们带来了 39 / 13 = 3 个奖金。

奖金总数是 2 + 4 + 3 = 9\. 所以，`9` 是这个测试用例的正确输出。

#### 嵌套列表

到目前为止，我们已经看过了整数、浮点数和字符串的列表。我们还可以创建列表的列表，称为 *嵌套列表*。每个嵌套列表中的值本身就是一个列表。通常会使用类似 `grid` 或 `table` 的变量名来表示一个嵌套列表。这里是一个对应于 表 5-3 的 Python 列表：

```py
>>> grid = [[ 1, 13,  2,  1,  1,  8],

...         [ 2, 12, 10,  5, 11,  4],

...         [39,  6, 13, 52,  3,  3],

...         [15,  8,  6,  2,  7, 14]]
```

每个列表的值对应一行。如果我们索引一次，就能得到一行，它本身就是一个列表：

```py
>>> grid[0]

[1, 13, 2, 1, 1, 8]

>>> grid[2]

[39, 6, 13, 52, 3, 3]
```

如果我们索引两次，就能得到一个单一的值。这里是第 1 行第 2 列的值：

```py
>>> grid[1][2]

10
```

处理列比处理行稍微复杂一些，因为每列的值分布在多个列表中。要访问一列，我们需要从每一行聚合一个值。我们可以通过一个循环来实现，它逐步构建出代表某一列的新列表。在这里，我获取了第 1 列：

```py
   >>> column = []

   >>> for i in range(len(grid)):

❶ ...     column.append(grid[i][1])

   ...

   >>> column

   [13, 12, 6, 8]
```

请注意，第一个索引（行）在变化，而第二个索引（列）保持不变 ❶。这会选出每个值，其列索引相同。

那么，如何计算行和列的和呢？为了求一行的和，我们可以使用 `sum` 函数。这里是第 0 行的和：

```py
>>> sum(grid[0])

26
```

我们也可以使用类似这样的循环：

```py
>>> total = 0

>>> for value in grid[0]:

...     total = total + value

 ...

>>> total

26
```

使用 `sum` 是更简便的选项，因此我们将使用它。

要计算一列的和，我们可以构建一个 `column` 列表并对其使用 `sum`，或者我们可以直接计算而不创建新的列表。下面是对第 1 列的后者方法：

```py
>>> total = 0

>>> for i in range(len(grid)):

...     total = total + grid[i][1]

...

>>> total

39
```

**概念检查**

以下代码的输出是什么？

```py
lst = [[1, 1],

       [2, 3, 4]]

x = 0

for i in range(len(lst)):

    for j in range(len(lst[0])):

        x = x + lst[i][j]

print(x)
```

A. `2`

B. `7`

C. `11`

D. 这段代码会产生错误（使用了无效的索引）

答案：B. 变量 `i` 遍历值 0 和 1（因为 `lst` 的长度是 2）；变量 `j` 也遍历值 0 和 1（因为 `lst[0]` 的长度是 2）。因此，列表中求和的值是那些索引为 0 或 1 的项，特别是这不包括位于 `lst[1][2]` 的 `4`。

**概念检查**

以下代码包含两个 `print` 调用。输出是什么？

```py
lst = [[5, 10], [15, 20]]

x = lst[0]

x[0] = 99

print(lst)

lst = [[5, 10], [15, 20]]

y = lst[0]

y = y + [99]

print(lst)
```

A.

[[99, 10], [15, 20]]

[[5, 10], [15, 20]]

B.

[[99, 10], [15, 20]]

[[5, 10, 99], [15, 20]]

C.

[[5, 10], [15, 20]]

[[5, 10], [15, 20]]

D.

[[5, 10], [15, 20]]

[[5, 10, 99], [15, 20]]

答案：A. `x` 指的是 `lst` 的第一行；它是引用 `lst[0]` 的另一种方式。因此，当我们执行 `x[0] = 99` 时，这一改变也会反映在通过 `lst` 查看列表时。

接下来，`y` 也指向 `lst` 的第一行。但然后我们将一个新列表赋值给 `y`——而是那个列表，而不是 `lst` 的第一行，才会在末尾附加 `99`。

### 解决问题

我们解决此问题的代码见清单 5-6。

```py
for dataset in range(10):

 ❶ lst = input().split()

    franchisees = int(lst[0])

    days = int(lst[1])

    grid = []

 ❷ for i in range(days):

        row = input().split()

     ❸ for j in range(franchisees):

            row[j] = int(row[j])

     ❹ grid.append(row)

    bonuses = 0

 ❺ for row in grid:

     ❻ total = sum(row)

        if total % 13 == 0:

            bonuses = bonuses + total // 13

 ❼ for col_index in range(franchisees):

        total = 0

     ❽ for row_index in range(days):

            total = total + grid[row_index][col_index]

        if total % 13 == 0:

            bonuses = bonuses + total // 13

    print(bonuses)
```

*清单 5-6: 解决面包师奖金问题*

与“学校旅行”类似，输入包含 10 个测试用例，因此我们将所有代码放在一个循环中，这个循环执行 10 次。

对于每个测试用例，我们读取输入的第一行并调用 `split` 将其拆分为一个列表 ❶。该列表将包含两个值——特许经营者的数量和天数——我们将它们转换为整数并赋值给适当命名的变量。

`grid` 变量开始时是一个空列表。它最终会指向一个行列表，每行是给定日期的销售数据。

我们使用 `for` 循环遍历每一天 ❷。然后，我们读取输入中的一行并调用 `split` 将其拆分为一个销售值列表。这些值现在是字符串类型，因此我们使用嵌套循环将它们全部转换为整数 ❸。接着，我们将该行添加到网格 ❹ 中。

我们现在已经读取了输入并存储了网格。接下来是计算奖金总数。我们分两步进行：首先是按行计算奖金，然后是按列计算奖金。

为了从行中找到奖金，我们在 `grid` 上使用 `for` 循环❺。与任何在列表上的 `for` 循环一样，它会一次给我们一个值。在这里，每个值都是一个列表，所以 `row` 在每次迭代时指代一个不同的列表。`sum` 函数适用于任何数字列表，因此我们在这里使用它来计算当前行❻的值总和。如果总和能被 13 整除，我们就加上奖金数。

我们不能像处理行一样遍历列表的列，因此我们必须依靠通过索引来循环。我们通过使用 `for` 循环遍历列的索引❼来实现这一点。使用 `sum` 来求当前列的和并不可行，因此我们需要一个嵌套循环。这个嵌套循环会遍历行❽，把目标列中的每个值加起来。然后我们检查该总和是否能被 13 整除，如果能，就加上奖励。

我们通过打印总奖金数来结束。

判断时间！如果你提交我们的代码，你应该看到所有测试用例都通过了。

### 小结

在本章中，我们学习了列表，它帮助我们处理我们选择的任何类型的集合。数字列表、字符串列表、列表的列表：Python 支持我们需要的任何类型。我们还学习了列表方法，以及为什么排序列表可以让处理列表中的值变得更加容易。

与字符串不同，列表是可变的，这意味着我们可以更改它们的内容。这帮助我们更容易地操作列表，但我们必须小心修改我们想要修改的列表。

我们已经进入学习的阶段，现在可以编写包含多行代码的程序。我们可以通过 `if` 语句和循环来控制程序的行为。我们可以使用字符串和列表来存储和操作信息。我们可以编写程序来解决具有挑战性的问题。这样的程序可能变得难以设计和阅读。幸运的是，我们有一个工具可以帮助我们组织程序，以保持复杂度在可控范围内，我们将在下一章学习这个工具。完成以下的一些练习可能会加深你对编写大量代码的困难的理解。然后你就可以准备继续学习了！

### 本章练习

这里有一些练习供你尝试。

1.  DMOJ 问题 `ccc07j3`，交易还是不交易计算器

1.  DMOJ 问题 `coci17c1p1`，凯撒

1.  DMOJ 问题 `coci18c2p1`，Preokret

1.  DMOJ 问题 `ccc00s2`，喋喋不休的溪流（看看 Python 的 `round` 函数。）

1.  DMOJ 问题 `ecoo18r1p1`，柳树的疯狂之旅

1.  DMOJ 问题 `ecoo19r1p1`，免费 T 恤

1.  DMOJ 问题 `dmopc14c7p2`，潮汐

1.  DMOJ 问题 `wac3p3`，韦斯利玩 DDR

1.  DMOJ 问题 `ecoo18r1p2`，Rue 的戒指（如果你在这里使用 f-strings，你需要一种方法来包含 `{` 和 `}` 符号本身。你可以通过 `{{` 来包含 `{`，通过 `}}` 来包含 `}`。）

1.  DMOJ 问题 `coci19c5p1`，Emacs

1.  DMOJ 问题 `coci20c2p1`，Crtanje（你需要支持从 –100 到 100 的行。但当 Python 列表从索引 0 开始时，我们如何支持负索引的行呢？这里有一个小技巧：每次需要访问行 `x` 时，使用索引 `x + 100`。这样就将行号从 –100 到 100 转换为 0 到 200。此外，关于字符串的一个小烦恼：`\` 是一个特殊字符，所以如果你想要一个 `\` 字符，必须使用 `'\\'` 而不是 `'\'`。）

1.  DMOJ 问题 `dmopc19c5p2`，Charlie 的疯狂征服（你需要小心索引和游戏规则！）

### 备注

Village Neighborhood 最初来自 2018 年加拿大计算机竞赛，高级组。School Trip 最初来自 2017 年安大略省教育计算组织编程竞赛，第一轮。Baker Bonus 最初来自 2017 年安大略省教育计算组织编程竞赛，第三轮。
