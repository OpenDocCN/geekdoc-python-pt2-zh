## 5

使用列表组织值

![image](img/common.jpg)

我们已经看到，可以使用字符串处理字符序列。在本章中，我们将学习列表，它帮助我们处理其他类型值的序列，如整数和浮点数。我们还将学习如何将列表嵌套在列表中，这使得我们可以处理数据的网格。

我们将通过列表解决三个问题：找到一组村庄中最小的邻域，确定是否筹集到了足够的资金进行学校旅行，以及计算面包店提供的奖金数量。

### 问题 #11：村庄邻域

在这个问题中，我们要找到一组村庄中最小的邻域大小。我们会发现将所有邻域大小存储起来会很有帮助。虽然我们可能最多有 100 个村庄，但为每个村庄使用单独的变量会非常麻烦。我们会看到，列表可以将本来应该是独立变量的数据聚合成一个集合。我们还将学习 Python 强大的列表操作，用于修改、查找和排序列表。

这是 DMOJ 问题 ccc18s1。

#### 挑战

有 *n* 个村庄位于直路上的不同位置。每个村庄由一个整数表示，指示其在道路上的位置。

一个村庄的左邻居是位置最接近且较小的村庄；右邻居是位置最接近且较大的村庄。一个村庄的*邻域*包括该村庄与其左邻居之间的空间的一半，加上该村庄与其右邻居之间的空间的一半。例如，如果一个村庄位于位置 10，左邻居位于位置 6，右邻居位于位置 15，则该村庄的邻域从位置 8（6 和 10 之间的一半）开始，到位置 12.5（10 和 15 之间的一半）结束。

最左和最右的村庄只有一个邻居，因此它们的邻域定义没有意义。在这个问题中，我们将忽略这两个村庄的邻域。

*邻域*的*大小*是通过计算邻域的最右位置减去邻域的最左位置来得出的。例如，从 8 到 12.5 的邻域大小为 12.5 – 8 = 4.5。

确定最小邻域的大小。

#### 输入

输入包含以下几行：

+   一行包含整数 *n*，表示村庄的数量。*n* 的范围是 3 到 100。

+   *n* 行，每行给出一个村庄的位置。每个位置是介于 -1,000,000,000 和 1,000,000,000 之间的整数。位置不必按从左到右的顺序排列；一个村庄的邻居可能位于这些行中的任何地方。

#### 输出

输出最小邻域的大小。保留一位小数。

### 为什么使用列表？

作为读取输入的一部分，我们需要读取 *n* 个整数（表示村庄位置的整数）。在解决第三章的数据规划问题时，我们已经处理过一次。那里，我们使用了一个范围循环，循环了 *n* 次。我们在这里也会这样做。

数据规划与村庄邻域之间有一个至关重要的区别。在数据规划中，我们读取一个整数，使用它，然后不再引用它。我们不需要将它保留下来。但在村庄邻域中，光是看到每个整数一次是不够的。一个村庄的邻域依赖于它的左邻居和右邻居。如果没有这些邻居，我们无法计算该村庄邻域的大小。因此，我们需要存储所有村庄位置，以便后续使用。

为了说明为什么我们需要存储所有村庄位置，考虑这个测试用例：

6

20

50

4

19

15

1

这里有六个村庄。为了找到一个村庄的邻域大小，我们需要该村庄的左邻居和右邻居。

输入中的第一个村庄位于位置 20。这个村庄的邻域大小是多少？要回答这个问题，我们需要访问所有村庄位置，以便找到它的左邻居和右邻居。通过扫描这些位置，你可以发现左邻居在位置 19，右邻居在位置 50。因此，该村庄的邻域大小是 (20 – 19)/2 + (50 – 20)/2 = 15.5。

输入中的第二个村庄位于位置 50。这个村庄的邻域大小是多少？我们仍然需要查看位置来计算它。这个村庄恰好是最右边的一个，所以我们忽略这个村庄的邻域。

输入中的第三个村庄位于位置 4。左邻居在位置 1，右邻居在位置 15，所以该村庄邻域的大小为 (4 – 1)/2 + (15 – 4)/2 = 7。

输入中的第四个村庄位于位置 19。左邻居在位置 15，右邻居在位置 20，所以该村庄的邻域大小是 (19 – 15)/2 + (20 – 19)/2 = 2.5。

我们需要考虑的唯一剩下的村庄位于位置 15。如果你计算它的邻域大小，你应该得到 7.5 的答案。

比较我们计算的所有邻域大小，我们可以看到最小值——也是此测试用例的正确答案——是 2.5。

我们需要一种方式来存储所有的村庄位置，以便找到每个村庄的邻居。字符串不适用，因为字符串存储的是字符，而不是整数。Python 列表来帮忙！

### 列表

*列表* 是一种存储值序列的 Python 类型。（你有时会看到列表中的值被称为 *元素*。）我们使用方括号来表示列表的开始和结束。

我们只能在字符串中存储字符，但我们可以在列表中存储任何类型的值。这个整数列表保存了前面部分的村庄位置。

>>> [20, 50, 4, 19, 15, 1]

[20, 50, 4, 19, 15, 1]

这是一个字符串列表：

>>> ['one', 'two', 'hello']

['one', 'two', 'hello']

我们甚至可以创建一个值类型不同的列表：

>>> ['hello', 50, 365.25]

['hello', 50, 365.25]

你学到的很多关于字符串的内容也适用于列表。例如，列表支持 + 运算符进行连接，支持 * 运算符进行复制：

>>> [1, 2, 3] + [4, 5, 6]

[1, 2, 3, 4, 5, 6]

>>> [1, 2, 3] * 4

[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]

我们甚至有 `in` 运算符，它告诉我们一个值是否在列表中：

>>> 'one' in ['one', 'two', 'hello']

真

>>> 'n' in ['one', 'two', 'three']

False

我们有 `len` 函数来获取列表的长度：

>>> len(['one', 'two', 'hello'])

3

列表是一个序列，我们可以使用 for 循环遍历它的值：

>>> for value in [20, 50, 4, 19, 15, 1]:

...     print(value)

...

20

50

4

19

15

1

我们可以像让变量指向字符串、整数和浮点数一样让它们指向列表。让我们让两个变量指向列表，然后将它们连接起来生成一个新的列表。

>>> lst1 = [1, 2, 3]

>>> lst2 = [4, 5, 6]

>>> lst1 + lst2

[1, 2, 3, 4, 5, 6]

当我们显示连接后的列表时，我们并没有将其存储下来，正如我们通过再次查看列表所看到的：

>>> lst1

[1, 2, 3]

>>> lst2

[4, 5, 6]

要让变量指向连接后的列表，我们使用赋值：

>>> lst3 = lst1 + lst2

>>> lst3

[1, 2, 3, 4, 5, 6]

像 lst、lst1 和 lst2 这样的名称可以在不需要明确说明列表内容时使用。

但不要将 list 本身作为变量名。它已经是一个可以用来将序列转换为列表的名称：

>>> list('abcde')

['a', 'b', 'c', 'd', 'e']

如果你创建一个名为 list 的变量，你将失去这个有价值的行为，并且会混淆读者，他们会期望 list 不被篡改。

最后，列表支持索引和切片。索引返回单个值，而切片返回一组值：

>>> lst = [50, 30, 81, 40]

>>> lst[1]

30

>>> lst[-2]

81

>>> lst[1:3]

[30, 81]

如果我们有一个字符串列表，我们可以通过双重索引来访问其中某个字符串的字符，首先选择一个字符串，然后选择其中的一个字符：

>>> lst = ['one', 'two', 'hello']

>>> lst[2]

'hello'

>>> lst[2][1]

'e'

**概念检查**

以下代码会把什么存储在 total 变量中？

lst = [一组数字]

total = 0

i = 1

while i <= len(lst):

total = total + i

i = i + 1

A. 列表的总和

B. 列表的总和，不包括其第一个值

C. 列表的总和，不包括其第一个和最后一个值

D. 这段代码会导致错误，因为它访问了列表的无效索引

E. 以上都不是

答案：E. 这段代码将数字 1、2、3 等加到列表的长度上，并没有对列表进行加法或索引操作！

### 列表的可变性

字符串是*不可变的*，这意味着它们不能被修改。当看起来我们在改变一个字符串时（例如使用字符串拼接），我们实际上是在创建一个新字符串，而不是修改已存在的字符串。

另一方面，列表是*可变的*，这意味着它们*可以*被修改。

我们可以通过索引来观察这个区别。如果我们尝试改变字符串中的某个字符，我们会得到一个错误：

>>> s = 'hello'

>>> s[0] = 'j'

回溯（最近的调用最后）：

文件 "<stdin>"，第 1 行，位于 <module>

TypeError: 'str' 对象不支持项赋值

错误信息显示字符串不支持项赋值，这意味着我们不能更改它们的字符。

但由于列表是可变的，我们可以更改它们的值：

>>> lst = ['h', 'e', 'l', 'l', 'o']

>>> lst

['h', 'e', 'l', 'l', 'o']

>>> lst[0] = 'j'

>>> lst

['j', 'e', 'l', 'l', 'o']

>>> lst[2] = 'x'

>>> lst

['j', 'e', 'x', 'l', 'o']

如果没有对赋值语句的准确理解，可变性可能导致看似令人困惑的行为。这里有一个例子：

>>> x = [1, 2, 3, 4, 5]

❶ >>> y = x

>>> x[0] = 99

>>> x

[99, 2, 3, 4, 5]

目前没有什么意外。但你可能会被这个惊讶：

>>> y

[99, 2, 3, 4, 5]

99 是怎么进入 y 的？

当我们将 x 赋值给 y ❶时，y 被设置为引用与 x 相同的列表。赋值语句并没有复制列表。只有一个列表，恰好有两个名称（或*别名*）指向它。因此，如果我们对该列表进行更改，无论是通过 x 还是 y 来引用，我们都会看到这个变化。

可变性很有用，因为它直接模拟了我们可能想对列表中的值做的操作。如果我们想更改某个值，我们只需要更改它。如果没有可变性，改变某个值就不可能。我们必须创建一个新的列表，这个新列表与旧列表相同，除了我们想要更改的值。这样是可行的，但它是一种曲折且不够直观的方式来更改一个值。

如果你确实想要一个列表的副本，而不仅仅是它的另一个名称，你可以使用切片。省略起始和结束索引，这样会得到整个列表的副本：

>>> x = [1, 2, 3, 4, 5]

>>> y = x[:]

>>> x[0] = 99

>>> x

[99, 2, 3, 4, 5]

>>> y

[1, 2, 3, 4, 5]

这次观察到，当 x 列表发生变化时，y 列表并没有变化。它们是独立的列表。

**概念检查**

以下代码的输出是什么？

lst = ['abc', 'def', 'ghi']

lst[1] = 'wxyz'

print(len(lst))

A. 3

B. 9

C. 10

D. 4

E. 这段代码会产生错误

答案：A. 改变列表的值是允许的（因为列表是可变的）。但是将索引 1 处的值更改为一个更长的字符串并不会改变列表包含三个值这一事实。

### 学习方法

和字符串一样，列表也有许多有用的方法。我将在下一节中展示其中的一些，但首先我想向你展示如何自己学习这些方法。

你可以使用 Python 的 dir 函数来获取特定类型的方法列表。只需用一个值作为参数调用 dir，你将获得该值类型的所有方法。

当我们使用字符串值作为参数调用 dir 时，得到的结果是：

>>> dir('')

['__add__', '__class__', '__contains__', '__delattr__',

<更多带下划线的内容>

'capitalize', 'casefold', 'center', 'count', 'encode',

'endswith', 'expandtabs', 'find', 'format',

'format_map', 'index', 'isalnum', 'isalpha', 'isascii',

'isdecimal', 'isdigit', 'isidentifier', 'islower',

'isnumeric', 'isprintable', 'isspace', 'istitle',

'isupper', 'join', 'ljust', 'lower', 'lstrip',

'maketrans', 'partition', 'replace', 'rfind', 'rindex',

'rjust', 'rpartition', 'rsplit', 'rstrip', 'split',

'splitlines', 'startswith', 'strip', 'swapcase', 'title',

'translate', 'upper', 'zfill']

注意我们使用空字符串调用了 dir。我们本可以使用任何字符串值调用 dir；空字符串只是最快输入的方式。

忽略顶部带下划线的名称；这些名称是 Python 内部使用的，程序员通常不需要关心。其余的名称是你可以调用的字符串方法。在这个列表中，你会找到你已经知道的字符串方法，比如 isupper 和 count，以及许多我们还没有遇到过的方法。

要了解如何使用某个方法，你可以在调用 help 时使用该方法的名称。以下是我们在字符串 count 方法上的帮助文档：

>>> help(''.count)

内置函数 count 的帮助文档：

builtins.str 实例的 count(...) 方法

❶ S.count(sub[, start[, end]]) -> int

返回不重叠出现的次数

字符串 S[start:end] 中的子字符串 sub。可选项。

参数 start 和 end 的解释与切片表示法相同。

切片表示法。

帮助文档告诉我们如何调用方法 ❶。

方括号表示可选参数。如果你只想计算子字符串 sub 在字符串片段中的出现次数，可以使用 start 和 end 参数。

浏览方法列表是很有价值的，可以检查是否有方法可以帮助你完成当前的编程任务。即使你以前使用过某个方法，查看帮助文档也可以让你发现你不知道的功能！

要查看列表方法有哪些，可以调用 dir([])。要了解它们，调用 help([].xxx)，其中 xxx 是列表方法的名称。

**概念检查**

这是字符串 center 方法的帮助文档：

>>> help(''.center)

内置函数 center 的帮助文档：

builtins.str 实例的 center(width, fillchar=' ', /) 方法

返回一个指定宽度的居中字符串。

填充是使用指定的填充字符完成的。

（默认是空格）。

以下代码生成的字符串是什么？

'cave'.center(8, 'x')

A. 'xxcavexx'

B. ' cave '

C. 'xxxxcavexxxx'

D. ' cave '

答案：A. 我们调用了 center 方法，宽度为 8，填充字符为 'x'。（如果我们只提供了一个参数，填充字符就会使用空格。）因此，生成的字符串长度将为 8。字符串 'cave' 有四个字符，所以我们需要四个额外的字符才能达到长度 8。Python 因此在字符串的前后各添加了两个空格来居中字符串。

### 列表方法

现在是时候在村庄邻里问题上取得进展了。我能想到两种操作，可以帮助我们解决这个问题。

首先，向列表中添加内容。我们将从没有任何村庄位置的列表开始，并从输入中逐一读取它们。因此，我们需要一种方法将每个位置添加到正在增长的列表中：首先列表是空的，然后它会包含一个村庄位置，接着是两个，依此类推。

第二，排序列表。一旦我们读取了村庄位置，我们需要找到最小的邻里。这涉及到查看每个村庄位置及其左右邻居的距离。村庄的位置可能是无序的，因此通常很难找到某个特定村庄的邻居。回想一下我们在本章“为什么使用列表？”部分做的工作。对于每个村庄，我们必须扫描整个列表来找到它的邻居。如果我们能将村庄按位置排序，那就简单多了。那时我们就能准确知道邻居的位置：它们就在某个村庄的左边和右边。

例如，以下是我们按顺序读取的示例村庄：

20 50 4 19 15 1

这可真乱七八糟！在真实的街道上，它们会按位置顺序排列，如下所示：

1 4 15 19 20 50

想要找到位置为 4 的村庄的邻居吗？只需查看它的左边和右边：分别是 1 和 15。位置为 15 的村庄邻居呢？嗖，邻居就在那儿——4 和 19。不再需要到处寻找了。我们将排序村庄位置列表，以简化代码。

我们可以使用 append 方法向列表添加内容，使用 sort 方法对列表进行排序。我们将学习这两种方法，以及其他一些在继续处理列表时可能会发现有用的方法，然后我们将回过头来解决村庄邻里问题。

#### 向列表添加内容

append 方法会*附加*一个值到列表中，这意味着它会将一个值添加到已存在的值的末尾。下面是将三个村庄位置添加到一个最初为空的列表中的例子：

>>> positions = []

>>> positions.append(20)

>>> positions

[20]

>>> positions.append(50)

>>> positions

[20, 50]

>>> positions.append(4)

>>> positions

[20, 50, 4]

请注意，我们在使用 append 方法时没有使用赋值语句。append 方法不会返回一个新的列表；它会修改现有的列表。

使用会更改列表的函数时，使用赋值语句是一个常见的错误。犯这个错误会导致列表丢失，如下所示：

>>> positions

[20, 50, 4]

>>> positions = positions.append(19)

>>> positions

没有值！从技术上讲，`positions` 现在指向一个 `None` 值；你可以通过 `print` 来查看：

>>> print(positions)

None

`None` 值用于表示没有可用信息。在这里完全没有预期——我们希望得到四个村庄的位置！——但是我们通过一个错误的赋值语句丢失了列表。

如果你的列表消失了，或者遇到与 `None` 值相关的错误信息，请确保你没有在方法中使用赋值语句，这些方法只是修改列表内容。

`extend` 方法与 `append` 相关。每当你想把一个列表（而不是单个值）连接到现有列表的末尾时，就使用 `extend`。以下是一个示例：

>>> lst1 = [1, 2, 3]

>>> lst2 = [4, 5, 6]

>>> lst1.extend(lst2)

>>> lst1

[1, 2, 3, 4, 5, 6]

>>> lst2

[4, 5, 6]

如果你想在列表的某个位置插入元素，可以使用 `insert` 方法。它接受一个索引和一个值，并将该值插入到指定的索引位置：

>>> lst = [10, 20, 30, 40]

>>> lst.insert(1, 99)

>>> lst

[10, 99, 20, 30, 40]

#### 排序列表

`sort` 方法*排序*列表，将其中的值按顺序排列。如果我们不传递任何参数，它会从最小值到最大值排序：

>>> positions = [20, 50, 4, 19, 15, 1]

>>> positions.sort()

>>> positions

[1, 4, 15, 19, 20, 50]

如果我们使用 `reverse=True` 参数来调用它，它会从最大值排序到最小值：

>>> positions.sort(reverse=True)

>>> positions

[50, 20, 19, 15, 4, 1]

我使用的语法 `reverse=True` 是新的。根据我们目前在书中的方法和函数调用方式，你可能会期望 `True` 自己工作。但不是这样：`sort` 需要完整的 `reverse=True` 参数，原因我会在第六章中解释。

#### 从列表中移除值

`pop` 方法通过索引移除值。如果没有提供参数，`pop` 会移除并返回最右侧的值。

>>> lst = [50, 30, 81, 40]

>>> lst.pop()

40

我们可以将要移除值的索引作为参数传递给 `pop` 方法。这里，我们移除并返回索引为 0 的值：

>>> lst.pop(0)

50

由于 `pop` 会返回某个值——不同于像 `append` 和 `sort` 这样的函数——因此将其返回值赋给变量是有意义的：

>>> lst

[30, 81]

>>> value = lst.pop()

>>> value

81

>>> lst

[30]

`remove` 方法通过值来移除，而不是通过索引。传递给它要移除的值，它会移除列表中最左侧出现的该值。如果该值不存在，`remove` 会产生错误。在以下示例中，列表中有两个 50，因此 `remove(50)` 会执行两次，直到产生错误：

>>> lst = [50, 30, 81, 40, 50]

>>> lst.remove(50)

>>> lst

[30, 81, 40, 50]

>>> lst.remove(50)

>>> lst

[30, 81, 40]

>>> lst.remove(50)

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

ValueError: list.remove(x): x not in list

**概念检查**

以下代码执行后，`lst` 的值是什么？

lst = [2, 4, 6, 8]

lst.remove(4)

lst.pop(2)

A. [2, 4]

B. [6, 8]

C. [2, 6]

D. [2, 8]

E. 这段代码产生错误

答案：C. remove 调用移除了值 4，剩下[2, 6, 8]。然后 pop 调用移除了索引 2 处的值 8。最终剩下的列表是[2, 6]。

### 解决问题

假设我们已经成功读取并排序了村庄位置。此时，我们的列表应如下所示：

>>> positions = [1, 4, 15, 19, 20, 50]

>>> positions

[1, 4, 15, 19, 20, 50]

为了找到最小邻里的大小，我们首先找到索引 1 处村庄的邻里大小。（注意我们没有从索引 0 开始：索引 0 处的村庄是最左边的村庄，根据题目描述，我们可以忽略它。）我们可以这样找到该邻里大小：

>>> left = (positions[1] - positions[0]) / 2

>>> right = (positions[2] - positions[1]) / 2

>>> min_size = left + right

>>> min_size

7.0

left 变量存储了邻里左侧部分的大小，right 存储了右侧部分的大小。然后我们将它们加在一起，得到邻里的总大小。我们得到的值是 7.0。

那是我们需要超越的目标。我们如何知道是否有其他村庄的邻里更小呢？我们可以使用循环来处理其他村庄。如果我们找到一个比当前最小邻里还小的邻里，就更新当前最小值为那个更小的值。

我们解决方案的代码位于列表 5-1。

n = int(input())

❶ positions = []

❷ for i in range(n):

❸ positions.append(int(input()))

❹ positions.sort()

❺ left = (positions[1] - positions[0]) / 2

right = (positions[2] - positions[1]) / 2

min_size = left + right

❻ for i in range(2, n - 1):

left = (positions[i] - positions[i - 1]) / 2

right = (positions[i + 1] - positions[i]) / 2

size = left + right

❼ if size < min_size:

min_size = size

print(min_size)

*列表 5-1：解决村庄邻里问题*

我们首先通过输入读取 n，表示村庄的数量。我们还将 positions 设置为指向一个空列表 ❶。

第一轮 range 循环的每次迭代 ❷ 都负责读取一个村庄位置，并将其附加到 positions 列表中。它通过使用 input 读取下一个村庄位置，使用 int 将其转换为整数，并使用 list 方法 append 将该整数附加到列表 ❸。这一行 ❸ 等价于下面三行：

position = input()

position = int(position)

positions.append(position)

在读取了村庄位置后，我们接下来按升序对其进行排序 ❹。然后，我们找到索引 1 处村庄的邻里大小，并使用 min_size ❺保存它。

接下来，在第二个循环中，我们遍历每个其他需要计算邻里大小的村庄 ❻。这些村庄从索引 2 开始，到索引 n - 2 结束。（我们不考虑索引 n - 1 处的村庄，因为那是最右边的村庄。）因此，我们使用 range，第一参数为 2（即从 2 开始），第二参数为 n - 1（即到 n - 2 结束）。

在循环内部，我们计算当前村庄邻域的大小，正如我们为第一个村庄所做的那样。我们迄今为止找到的最小邻域大小被 min_size 所表示。当前村庄的邻域是否比我们目前找到的最小邻域更小？为了回答这个问题，我们使用一个 if 语句 ❼。如果当前村庄的邻域小于 min_size，我们就将 min_size 更新为该邻域的大小。如果当前村庄的邻域不小于 min_size，那么我们什么也不做，因为这个村庄不会改变最小邻域的大小。

经过所有村庄的遍历后，min_size 必须是最小的邻域大小。因此，我们输出 min_size 的值。

这个问题描述中的“输出”部分规定了“输出时小数点后恰好保留一位”。如果最小的大小是 6.25 或 8.33333 之类的数字呢？我们是不是应该对这个情况做点什么？

不，我们的操作是安全的。我们能得到的邻域大小只有像 3.0（小数点后有 0）和 3.5（小数点后有 .5）这样的数字。原因如下。当我们计算邻域的左边部分时，我们会减去两个整数并将结果除以 2。如果我们在除以 2 之前有一个偶数整数，那么除法结果会是一个 .0 的数字（没有余数）。如果我们在除以 2 之前有一个奇数整数，那么除法结果会是一个 .5 的数字。邻域的右边部分也一样：大小会是 .0 或 .5 的数字。因此，将左边和右边的部分相加得到总大小，最终结果必定是 .0 或 .5 的数字。

### 避免代码重复：另外两种解决方案

有点令人失望的是，我们在循环之前和第二个范围的 for 循环中都包含了“计算邻域大小”的代码。通常，重复的代码意味着我们可以改善代码的设计。我们希望避免重复代码，因为它增加了我们必须维护的代码量，并且如果重复的代码有问题，修复起来会更加困难。在这里，我认为重复的代码是可以接受的（只有三行），但我们来讨论两种避免重复代码的方法。这些是通用方法，你可以将它们应用到其他类似的问题中。

#### 使用超大尺寸

我们在循环之前计算村庄邻域的大小，唯一的原因是为了让循环可以将其他邻域大小与其进行比较。如果我们在没有 min_size 值的情况下进入循环，那么当代码尝试将其与当前村庄的大小进行比较时，就会报错。

如果我们在循环之前将 min_size 设置为 0.0，那么循环将永远找不到更小的大小，无论测试用例如何，我们都会错误地输出 0.0。使用 0.0 会是一个 bug！

但是一个巨大的值，至少和每个可能的邻里大小一样大，*会*起作用。我们只需要让它足够大，以确保循环的第一次迭代能找到一个不更大的大小，从而保证我们的伪巨大值永远不会被输出。

从这个问题描述中的“输入”部分，我们知道每个位置的值介于–1,000,000,000 和 1,000,000,000 之间。我们能遇到的最大邻里大小发生在村庄位置为–1,000,000,000，另一个在 1,000,000,000，且有一个村庄在它们之间。位于中间的村庄将有一个邻里大小为 1,000,000,000。我们因此可以从 1000000000.0 或更大的值开始设定 min_size。这个替代方法见列表 5-2。

n = int(input())

positions = []

for i in range(n):

positions.append(int(input()))

positions.sort()

min_size = 1000000000.0

❶ for i in range(1, n - 1):

left = (positions[i] - positions[i - 1]) / 2

right = (positions[i + 1] - positions[i]) / 2

size = left + right

if size < min_size:

min_size = size

print(min_size)

*列表 5-2：使用一个巨大值解决村庄邻里问题*

小心！我们现在需要从索引 1 开始计算大小❶（而不是 2）；否则我们会忘记包括索引 1 处村庄的邻里。

#### 构建大小列表

另一种避免代码重复的方法是将每个邻里大小存储在一个大小列表中。Python 有一个内建的 min 函数，它接受一个序列并返回其最小值：

>>> min('qwerty')

'e'

>>> min([15.5, 7.0, 2.5, 7.5])

2.5

（Python 还有一个 max 函数，返回一个序列的最大值。）

请参见列表 5-3，该解决方案使用 min 对邻里大小列表进行处理。

n = int(input())

positions = []

for i in range(n):

positions.append(int(input()))

positions.sort()

sizes = []

for i in range(1, n - 1):

left = (positions[i] - positions[i - 1]) / 2

right = (positions[i + 1] - positions[i]) / 2

size = left + right

sizes.append(size)

min_size = min(sizes)

print(min_size)

*列表 5-3：使用* min 解决村庄邻里问题

随时将这些解决方案提交给评测系统，选择你最喜欢的一种！

在继续之前，你可能想尝试解决“章节练习”中的第 1 题，见第 134 页。

### 问题 #12：学校旅行

你将遇到的许多问题都包含每行有多个整数或浮点数的输入。我们到现在为止已经避免了这些问题，但它们无处不在！接下来我们将学习如何使用列表来处理这些类型的问题输入。

这是 DMOJ 问题 eco17r1p1。

#### 挑战

学生们希望在年末去学校旅行，但他们需要钱来支付费用。为了筹集资金，他们组织了一次早午餐活动。参加早午餐的费用为：大一学生 12 美元，大二学生 10 美元，大三学生 7 美元，大四学生 5 美元。

所有在早午餐中筹集的资金中，50%可以用于支付学校旅行费用（另 50%用于支付早午餐本身）。  

我们知道学校旅行的费用、每年级学生的比例以及学生的总人数。请判断学生们是否需要筹集更多的钱来支付学校旅行的费用。  

#### 输入  

输入包含 10 个测试案例，每个测试案例有三行（共 30 行）。每个测试案例的三行如下：  

+   第一行包含学校旅行的费用（以美元为单位）；它是一个介于 50 和 50,000 之间的整数。  

+   第二行包含四个数字，表示参加早午餐的学生分别在第一年、第二年、第三年和第四年中的比例。每对数字之间有一个空格。每个数字在 0 和 1 之间，它们的总和为 1（即 100%）。  

+   第三行包含一个整数*n*，表示参加早午餐的学生人数。*n*的范围是 4 到 2000 之间。  

#### 输出  

对于每个测试案例：如果学生需要为学校旅行筹集更多的钱，输出 YES；否则，输出 NO。  

#### 一个特殊情况  

假设有 50 名学生，其中 10%（即比例为 0.1）的学生是四年级的。那么我们可以计算出 50 * 0.1 = 5 名四年级学生。

现在假设有 50 名学生，其中 15%（即比例为 0.15）的学生是四年级的。如果我们相乘，就得到 50 * 0.15 = 7.5 名四年级学生。  

7.5 名学生是没有意义的，我也没有告诉你我们应该如何处理这种情况。完整的问题描述中规定我们需要向下取整——所以我们在这里会向下取整为 7。这可能导致第一年、第二年、第三年和第四年学生的总和不等于学生总数。对于未被计算在内的学生，我们需要将他们分配到人数最多的年级。保证有且只有一个年级会有最多的学生（不会出现多个年级平分秋色的情况）。  

我们将首先忽略这个特殊情况来解决问题。然后，我们将考虑这个特殊情况，给出完整的解决方案。  

### 字符串分割和列表连接  

每个测试案例的第二行包含四个比例，如下所示：  

0.2 0.08 0.4 0.32  

我们需要一种方法来提取这四个数字以便进一步处理。我们将学习字符串的 split 方法，用于将字符串分割成多个部分。顺便提一下，我们还将学习字符串的 join 方法，它允许我们将一个列表合并成一个单一的字符串。  

#### 将字符串分割成列表  

记住，无论输入的样子如何，input 函数始终返回一个字符串。如果输入应该解释为整数，我们需要将字符串转换为整数。如果输入应该解释为浮点数，我们需要将字符串转换为浮点数。如果输入应该被解释为四个浮点数？那么我们最好先将其分割成单独的浮点数，然后再进行转换！

字符串的 split 方法将字符串分割成它的各个部分的列表。默认情况下，split 会在空格处进行分割，这正是我们需要的四个浮点数：

>>> s = '0.2 0.08 0.4 0.32'

>>> s.split()

['0.2', '0.08', '0.4', '0.32']

split 方法返回一个字符串列表，此时我们可以独立访问每一个字符串。这里，我保存了 split 返回的列表，然后访问其中的两个值：

>>> proportions = s.split()

>>> proportions

['0.2', '0.08', '0.4', '0.32']

>>> proportions[1]

'0.08'

>>> proportions[2]

'0.4'

在实际情况中，数据通常是用逗号分隔的，而不是空格分隔的。非常简单：我们可以通过给 split 函数传递一个参数，告诉它使用什么作为分隔符：

>>> info = 'Toronto,Ontario,Canada'

>>> info.split(',')

['Toronto', 'Ontario', 'Canada']

#### 将列表连接成字符串

要反过来，从列表转换为字符串，而不是从字符串转换为列表，我们可以使用字符串的 join 方法。调用 join 的字符串将作为分隔符，连接列表中的各个值。这里有两个示例：

>>> lst = ['Toronto', 'Ontario', 'Canada']

>>> ','.join(lst)

'Toronto,Ontario,Canada'

>>> '**'.join(lst)

'Toronto**Ontario**Canada'

从技术上讲，join 可以将任何顺序中的值连接起来，而不仅仅是连接列表中的值。以下是一个从字符串中连接字符的示例：

>>> '*'.join('abcd')

'a*b*c*d'

### 更改列表值

当我们在包含四个部分的字符串上使用 split 时，会得到一个字符串列表：

>>> s = '0.2 0.08 0.4 0.32'

>>> proportions = s.split()

>>> proportions

['0.2', '0.08', '0.4', '0.32']

在第一章《字符串与整数转换》中，我们学到了看起来像数字的字符串不能直接用于数值计算。因此，我们需要将这个字符串列表转换为浮点数列表。

我们可以使用 float 将字符串转换为浮点数，如下所示：

>>> float('45.6')

45.6

这只是一个浮点数。我们如何将整个字符串列表转换为浮点数列表呢？我们很容易就会想要通过以下循环来实现这一点：

>>> for value in proportions:

...     value = float(value)

其逻辑是，这应该遍历列表中的每个值并将其转换为浮点数。

可惜，它不起作用。列表仍然引用的是字符串：

>>> proportions

['0.2', '0.08', '0.4', '0.32']

出了什么问题？是 float 无法工作吗？我们可以通过查看转换后的值的类型来看到，float 完全正常工作：

>>> for value in proportions:

...     value = float(value)

...     type(value)

...

<class 'float'>

<class 'float'>

<class 'float'>

<class 'float'>

四个浮动数！但是列表顽固地仍然是字符串类型。

这里发生的事情是，我们没有改变列表中引用的值。我们只是在改变变量值所指向的内容，但这并没有改变列表仍然引用旧的字符串值的事实。为了实际更改列表引用的值，我们需要在列表的索引位置分配新值。以下是方法：

>>> proportions

['0.2', '0.08', '0.4', '0.32']

>>> for i in range(len(proportions)):

...     proportions[i] = float(proportions[i])

...

>>> proportions

[0.2, 0.08, 0.4, 0.32]

for 循环遍历每个索引，并通过赋值语句改变该索引所指向的内容。

### 解决大部分问题

现在我们准备好解决问题，唯一的问题就是陷阱。

我们将通过一个示例来说明我们的代码需要做什么。然后我们将进入代码本身。

#### 探索一个测试用例

这个问题的输入由 10 个测试用例组成，但这里我只会展示其中一个。如果你从键盘输入这个测试用例，你将看到答案。但程序不会在此终止，因为它正在等待下一个测试用例。如果你使用输入重定向来运行这个测试用例，你也会看到答案。但接着你会遇到 EOFError 错误。EOF 代表“文件结束”；这个错误是因为程序尝试读取更多输入数据，但没有更多数据可读。当你的代码能够处理一个测试用例时，你可以尝试添加更多测试用例，确保它们也能正常工作。最终，输入 10 个测试用例时，程序应该能够运行完成。

这是我想和你一起跟踪的测试用例：

504

0.2 0.08 0.4 0.32

125

学校旅行费用为 504 美元，有 125 名学生参加早午餐。

为了确定在早午餐中筹集了多少钱，我们需要计算每年学生所筹集的资金。有 125 名学生中的 20%是第一年学生，即 125 * 0.2 = 25 人，他们每人支付 12 美元参加早午餐。所以，一年级学生筹集了 25 * 12 = 300 美元。我们可以用同样的方法计算二年级、三年级和四年级学生所筹集的资金。有关详细计算，请参见表 5-1。

**表 5-1：** 学校旅行示例

| **年份** | **该年学生人数** | **每位学生费用** | **筹集的资金** |
| --- | --- | --- | --- |
| 一年级 | 25 | 12 | 300 |
| 二年级 | 10 | 10 | 100 |
| 三年级 | 50 | 7 | 350 |
| 四年级 | 40 | 5 | 200 |

每年学生所筹集的资金是通过将该年学生人数与每位学生的费用相乘得到的；请参见表格最右列。所有学生所筹集的总金额可以通过将这一列中的四个数字相加得到。计算结果为 300 + 100 + 350 + 200 = 950 美元。只有其中 50%的资金可以用于学校旅行。因此，我们剩下 950 / 2 = 475 美元，无法支付 504 美元的旅行费用。所以，正确的输出应该是 YES，因为需要筹集更多资金。

#### 代码

这个部分的解决方案将正确处理任何输入，其中将比例与学生人数相乘得到的是整数（比如我们刚才做的测试用例）。请参见 列表 5-4 获取代码。

❶ YEAR_COSTS = [12, 10, 7, 5]

❷ for dataset in range(10):

trip_cost = int(input())

❸ proportions = input().split()

num_students = int(input())

❹ for i in range(len(proportions)):

proportions[i] = float(proportions[i])

❺ students_per_year = []

for proportion in proportions:

❻ students = int(num_students * proportion)

students_per_year.append(students)

total_raised = 0

❼ for i in range(len(students_per_year)):

total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]

❽ if total_raised / 2 < trip_cost:

print('YES')

else:

print('NO')

*列表 5-4: 解决大部分学校旅行问题*

一开始，我们使用变量 YEAR_COSTS 来表示一份列出了学生参加午餐费用的列表：第一年、第二年、第三年和第四年学生的费用 ❶。一旦确定了每年学生的人数，我们将乘以这些费用来确定筹集的资金。费用是固定的，所以我们永远不会改变这个变量的值。对于这种“常量”变量，Python 的约定是将其名称写成大写字母，正如我在这里所做的。

输入包含 10 个测试用例，所以我们循环 10 次 ❷，每次处理一个测试用例。程序的其余部分都在这个循环内，因为我们要将所有内容重复执行 10 次。

对于每个测试用例，我们读取三行输入。第二行包含四个比例，因此我们使用 split 将其拆分成四个字符串的列表 ❸。我们使用一个范围 for 循环将每个字符串转换为浮点数 ❹。

使用这些比例，接下来的任务是确定每年学生的人数。我们从一个空列表 ❺ 开始。然后，对于每个比例，我们将总学生人数乘以该比例 ❻，并将其添加到列表中。请注意，在 ❻ 处，我使用了 int 来确保我们只添加整数。当用于浮点数时，int 会通过向零舍入来去掉小数部分。

现在我们有了计算筹集资金所需的两个列表。在 students_per_year 中，我们有每年学生人数的列表，它大概是这样的：

[25, 10, 50, 40]

在 YEAR_COSTS 中，我们有每年学生的午餐费用：

[12, 10, 7, 5]

这些列表中索引为 0 的每个值告诉我们第一年学生的情况，索引为 1 的每个值告诉我们第二年学生的情况，以此类推。这样的列表被称为 *并行列表*，因为它们并行工作，提供的信息比单独使用任何一个都要多。

我们使用这两个列表来计算筹集的总金额，通过将每个学生的人数乘以每个学生的对应费用，并将所有结果加起来 ❼。

是否为学校旅行筹集了足够的资金？为了确定这一点，我们使用了 if 语句 ❽。早午餐筹集的资金的一半可以用于学校旅行。如果这个金额少于学校旅行的费用，那么我们需要筹集更多资金（YES）；否则，不需要（NO）。

我们编写的代码是非常通用的。唯一的线索是❶，表明有四个年级的学生。如果我们想为不同年级数的类似问题提供解决方案，只需要更改那一行（并提供包含预期比例的输入）。这就是列表的强大之处：它们帮助我们编写灵活的代码，能够适应我们解决问题时的变化。

### 如何处理异常

现在让我们看看为什么我们的当前程序会在某些测试用例中出错，以及我们将使用的 Python 特性来修复它。

#### 探索一个测试用例

这是一个当前代码处理错误的测试用例：

50

0.7 0.1 0.1 0.1

9

这次，学校旅行费用为 50 美元，共有 9 名学生参加了早午餐。对于大一的学生人数，当前程序会计算 9 * 0.7 = 6.3，然后向下取整为 6。由于我们必须向下取整，这也是我们需要小心这个测试用例的原因。要查看我们当前程序对于所有四年级的计算结果，请参见表 5-2。

**表 5-2：** 一个来自学校旅行的示例案例，当前程序计算错误

| **年级** | **年级学生数** | **每个学生费用** | **筹集资金** |
| --- | --- | --- | --- |
| 大一 | 6 | 12 | 72 |
| 大二 | 0 | 10 | 0 |
| 大三 | 0 | 7 | 0 |
| 大四 | 0 | 5 | 0 |

除了大一以外的每个年级都有 0 名学生，因为 9 * 0.1 = 0.9 向下取整为 0。所以看起来我们只筹集了 72 美元。72 美元的一半是 36 美元，不足以支付 50 美元的学校旅行费用。我们的当前程序输出 YES。我们需要筹集更多的资金。

. . . 或者不修复。我们这里应该有 9 名学生，而不是 6 名！我们由于向下取整失去了 3 名学生。问题描述中规定，我们应该将这些学生加到人数最多的年级，这里是大一。如果我们这样做，就会看到我们实际上筹集了 9 * 12 = 108 美元。108 美元的一半是 54 美元，因此实际上我们不需要再为 50 美元的学校旅行筹集更多资金！正确的输出是 NO。

#### 更多列表操作

为了修复我们的程序，我们需要做两件事：找出由于四舍五入丢失的学生人数，并将这些学生添加到人数最多的年级。

##### 求和列表

为了确定由于四舍五入丢失的学生人数，我们可以将 students_per_year 列表中的学生数加起来，然后从总学生数中减去这个值。Python 的 sum 函数接受一个列表并返回其值的总和：

>>> students_per_year = [6, 0, 0, 0]

>>> sum(students_per_year)

6

>>> students_per_year = [25, 10, 50, 40]

>>> sum(students_per_year)

125

#### 查找最大值的索引

Python 的 max 函数接受一个序列并返回其最大值：

>>> students_per_year = [6, 0, 0, 0]

>>> max(students_per_year)

6

>>> students_per_year = [25, 10, 50, 40]

>>> max(students_per_year)

50

我们需要最大值的索引，而不是最大值本身，以便我们可以增加该索引处的学生人数。给定最大值，我们可以使用`index`方法找到它的索引。它返回提供值所在的最左边的索引，或者如果该值不在列表中，则会生成错误：

>>> students_per_year = [6, 0, 0, 0]

>>> students_per_year.index(6)

0

>>> students_per_year.index(0)

1

>>> students_per_year.index(50)

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

ValueError: 50 is not in list

我们将寻找一个我们知道在列表中的值，因此不必担心会发生错误。

#### 解决问题

我们到了！现在我们可以更新我们的部分解决方案以处理任何有效的测试用例。新程序在列表 5-5 中。

YEAR_COSTS = [12, 10, 7, 5]

for dataset in range(10):

trip_cost = int(input())

proportions = input().split()

num_students = int(input())

for i in range(len(proportions)):

proportions[i] = float(proportions[i])

students_per_year = []

for proportion in proportions:

students = int(num_students * proportion)

students_per_year.append(students)

❶ counted = sum(students_per_year)

uncounted = num_students - counted

most = max(students_per_year)

where = students_per_year.index(most)

❷ students_per_year[where] = students_per_year[where] + uncounted

total_raised = 0

for i in range(len(students_per_year)):

total_raised = total_raised + students_per_year[i] * YEAR_COSTS[i]

if total_raised / 2 < trip_cost:

print('YES')

else:

print('NO')

*列表 5-5：解决学校旅行问题*

唯一的新代码是从❶开始的五行。我们使用`sum`计算目前为止已计数的学生数，然后从学生总数中减去这些，得到未计数的学生数。然后，我们使用`max`和`index`来找出应该将未计数学生加到的年份索引。最后，我们将未计数的学生加到该索引❷处。（将 0 加到数字上不会改变该数字，因此不必担心编码特殊行为来处理未计数为 0 的情况。该代码在这种情况下是安全的。）

这个问题就解决了。现在提交给评测系统吧！然后再回来——我们将进一步探索更一般的列表结构。

在继续之前，您可以尝试解决《章节练习》中第 5 题，位于第 134 页。

### 问题 #13：面包师奖金

在这个问题中，我们将看到如何使用列表来处理二维数据。这类数据在实际程序中非常常见。例如，电子表格形式的数据由行和列组成；处理这种数据需要像我们即将学习的技术。

这是 DMOJ 问题 eco17r3p1。

#### 挑战

面包师布里有多个特许经营商，每个特许经营商将烘焙商品出售给消费者。作为开业 13 周年的庆祝活动，面包师布里将根据销售额发放奖金。奖金的多少取决于每天的销售额和每个特许经营商的销售额。奖金的分配规则如下：

+   对于每一天，如果所有特许经营商的总销售额是 13 的倍数，那么这个倍数将作为奖金发放。例如，一个特许经营商一天售出 26 个烘焙商品，将为总奖金增加 26 / 13 = 2 个奖金。

+   对于每个特许经营商，如果其所有天数的总销售额是 13 的倍数，那么这个倍数将作为奖金发放。例如，某个特许经营商总共售出了 39 个烘焙商品，将为总奖金增加 39 / 13 = 3 个奖金。

确定奖励的奖金总数。

#### 输入

输入包含 10 个测试用例。每个测试用例包含以下行：

+   一行包含特许经营商数量 *f* 和天数 *d*，它们由空格分隔。*f* 的值在 4 到 130 之间，*d* 的值在 2 到 4,745 之间。

+   *d* 行，每行包含 *f* 个以空格分隔的整数。每个整数表示一个特许经营商的销售量。这些行中的第一行表示第一天每个特许经营商的销售额，第二行表示第二天的销售额，依此类推。每个整数的值在 1 到 13,000 之间。

#### 输出

对于每个测试用例，输出总共发放的奖金数量。

### 表格表示

本问题的数据可以通过表格进行可视化。我们将从一个示例开始，然后看看如何将表格表示为列表。

#### 探索测试用例

如果我们有 *d* 天和 *f* 个特许经营商，我们可以将数据布局为一个有 *d* 行和 *f* 列的表格。

这是一个示例测试用例：

6 4

1 13 2 1 1 8

2 12 10 5 11 4

39 6 13 52 3 3

15 8 6 2 7 14

该测试用例对应的表格在 表 5-3 中。

**表 5-3：** 面包师奖金表

|  | **0** | **1** | **2** | **3** | **4** | **5** |
| --- | --- | --- | --- | --- | --- | --- |
| **0** | 1 | 13 | 2 | 1 | 1 | 8 |
| **1** | 2 | 12 | 10 | 5 | 11 | 4 |
| **2** | 39 | 6 | 13 | 52 | 3 | 3 |
| **3** | 15 | 8 | 6 | 2 | 7 | 14 |

我已经给行和列编号，从 0 开始，以便与我们稍后如何将这些数据存储到列表中的方式一致。

这个测试用例中发放了多少奖金？首先，让我们来看一下表格的行，这些行对应于天数。第 0 行的销售总和是 1 + 13 + 2 + 1 + 1 + 8 = 26。因为 26 是 13 的倍数，所以这一行给我们带来了 26 / 13 = 2 个奖金。第 1 行的总和是 44。这个总和不是 13 的倍数，因此没有奖金。第 2 行的总和是 116——同样没有奖金。第 3 行的总和是 52，带来了 52 / 13 = 4 个奖金。

现在让我们来看一下对应于特许经营商的列。第 0 列的总和是 1 + 2 + 39 + 15 = 57。这个总和不是 13 的倍数，因此没有奖金。事实上，唯一一个给我们带来奖金的列是第 1 列。它的总和是 39，带来了 39 / 13 = 3 个奖金。

奖金总数是 2 + 4 + 3 = 9。所以，9 是这个测试案例的正确输出。

#### 嵌套列表

到目前为止，我们已经看到整数、浮点数和字符串的列表。我们还可以创建列表的列表，称为*嵌套列表*。这样的列表中的每个值本身就是一个列表。通常我们使用像 grid 或 table 这样的变量名来指代嵌套列表。下面是一个与表 5-3 对应的 Python 列表：

>>> grid = [[ 1, 13, 2, 1, 1, 8],

...         [ 2, 12, 10, 5, 11, 4],

...         [39, 6, 13, 52, 3, 3],

...         [15, 8, 6, 2, 7, 14]]

每个列表值对应一个行。如果我们只索引一次，我们得到的是一行，它本身是一个列表：

>>> grid[0]

[1, 13, 2, 1, 1, 8]

>>> grid[2]

[39, 6, 13, 52, 3, 3]

如果我们索引两次，我们就能得到一个单一的值。这里是第 1 行，第 2 列的值：

>>> grid[1][2]

10

与处理行相比，处理列稍微复杂一些，因为每一列跨越多个列表。为了访问某一列，我们需要从每一行中汇总一个值。我们可以通过循环实现这一点，逐步构建一个表示列的新列表。在这里，我获得了第 1 列：

>>> column = []

>>> for i in range(len(grid)):

❶ ...         column.append(grid[i][1])

...

>>> column

[13, 12, 6, 8]

注意，第一个索引（行）是变化的，但第二个索引（列）是不变的 ❶。这可以挑选出每个具有相同列索引的值。

那么，如何求行和列的总和呢？我们可以使用 sum 函数来求行的总和。这里是第 0 行的总和：

>>> sum(grid[0])

26

我们也可以使用一个循环，像这样：

>>> total = 0

>>> for value in grid[0]:

...     total = total + value

...

>>> total

26

使用 sum 是更简单的选择，所以我们将使用它。

要求列的总和，我们可以构建一个列列表并使用 sum 来计算，或者我们可以直接计算而不创建新列表。下面是对第 1 列的后者方法：

>>> total = 0

>>> for i in range(len(grid)):

...     total = total + grid[i][1]

...

>>> total

39

**概念检查**

以下代码的输出是什么？

lst = [[1, 1],

[2, 3, 4]]

x = 0

for i in range(len(lst)):

for j in range(len(lst[0])):

x = x + lst[i][j]

print(x)

A. 2

B. 7

C. 11

D. 这段代码会产生错误（它使用了无效的索引）

答案：B. 变量 i 遍历值 0 和 1（因为 lst 的长度是 2）；变量 j 也遍历值 0 和 1（因为 lst[0]的长度是 2）。因此，求和的列表值是每个索引为 0 或 1 的项，特别地，这不包括 lst[1][2]中的 4。

**概念检查**

以下代码包含两个打印调用。输出是什么？

lst = [[5, 10], [15, 20]]

x = lst[0]

x[0] = 99

print(lst)

lst = [[5, 10], [15, 20]]

y = lst[0]

y = y + [99]

print(lst)

A.

[[99, 10], [15, 20]]

[[5, 10], [15, 20]]

B.

[[99, 10], [15, 20]]

[[5, 10, 99], [15, 20]]

C.

[[5, 10], [15, 20]]

[[5, 10], [15, 20]]

D.

[[5, 10], [15, 20]]

[[5, 10, 99], [15, 20]]

答案：A. x 指的是 lst 的第一行；它是引用 lst[0] 的另一种方式。因此，当我们执行 x[0] = 99 时，修改也会反映在通过 lst 查看列表时。

接下来，y 也指的是 lst 的第一行。但我们给 y 赋了一个新的列表——正是这个列表，而不是 lst 的第一行，追加了 99。

### 解题过程

我们解决这个问题的代码在清单 5-6 中。

for dataset in range(10):

❶ lst = input().split()

franchisees = int(lst[0])

days = int(lst[1])

grid = []

❷ for i in range(days):

row = input().split()

❸ for j in range(franchisees):

row[j] = int(row[j])

❹ grid.append(row)

bonuses = 0

❺ for row in grid:

❻ total = sum(row)

if total % 13 == 0:

bonuses = bonuses + total // 13

❼ for col_index in range(franchisees):

total = 0

❽ for row_index in range(days):

total = total + grid[row_index][col_index]

if total % 13 == 0:

bonuses = bonuses + total // 13

print(bonuses)

*清单 5-6：解决烘焙者奖金问题*

和“学校旅行”一样，输入包含 10 个测试用例，因此我们将所有代码放入一个循环中，该循环执行 10 次。

对于每个测试用例，我们读取输入的第一行，并调用 split 将其拆分成一个列表 ❶。这个列表包含两个值——特许经营商的数量和天数——我们将它们转换为整数，并赋值给适当命名的变量。

grid 变量最初是一个空列表。它最终将引用一个包含行的列表，其中每一行是某天的销售数据。

我们使用 range 循环一次循环每一天 ❷。然后我们从输入中读取一行，并调用 split 将其拆分成一个包含单个销售值的列表。这些值现在是字符串，所以我们使用嵌套循环将它们全部转换为整数 ❸。然后，我们将这一行添加到我们的网格 ❹。

我们现在已经读取了输入并存储了网格。接下来是计算奖金的总数。我们分两步进行：第一步是计算来自行的奖金，第二步是计算来自列的奖金。

为了找到来自行的奖金，我们在 grid 上使用 for 循环 ❺。和任何列表上的 for 循环一样，它会一次返回一个值。这里，每个值都是一个列表，所以每次迭代时，row 都指向一个不同的列表。sum 函数可以对任何数字列表进行求和，因此我们在这里用它来加总当前行中的值 ❻。如果总和能被 13 整除，我们就增加奖金数量。

我们不能像遍历行那样遍历列表的列，因此我们必须通过索引进行循环。我们通过使用一个 range 循环遍历列的索引 ❼ 来实现这一点。使用 sum 函数不能直接求和当前列，因此我们需要一个嵌套循环。这个嵌套循环遍历行 ❽，并累加所需列中的每个值。然后我们检查总和是否能被 13 整除，如果能，我们就加上相应的奖金。

最后，我们打印出奖金的总数。

判断时间！如果你提交我们的代码，你应该会看到所有测试用例通过。

### 总结

在本章中，我们学习了列表，它帮助我们处理任何类型的集合。数字列表、字符串列表、列表的列表：Python 支持我们所需要的任何类型。我们还学习了列表方法，并了解了为什么对列表进行排序可以使处理列表中的值变得更加容易。

与字符串不同，列表是可变的，这意味着我们可以改变它们的内容。这使得我们更容易操作列表，但我们必须小心修改我们认为正在修改的列表。

我们的学习已经到了一个阶段，能够编写多行代码的程序。我们可以使用 if 语句和循环来控制程序的执行。我们可以使用字符串和列表来存储和处理信息。我们可以编写程序来解决具有挑战性的问题。这样的程序可能变得难以设计和阅读。幸运的是，我们可以使用一种工具帮助我们组织程序，以保持其复杂度在可控范围内，而我们将在下一章学习该工具。完成以下一些练习可能会加深你对编写大量代码难度的理解。然后你就可以继续前进了！

### 本章练习

这里有一些练习供你尝试。

1.  DMOJ 问题 ccc07j3， Deal or No Deal 计算器

1.  DMOJ 问题 coci17c1p1，Cezar

1.  DMOJ 问题 coci18c2p1，Preokret

1.  DMOJ 问题 ccc00s2，喋喋不休的小溪（查看 Python 的 round 函数。）

1.  DMOJ 问题 ecoo18r1p1，柳树的狂野之旅

1.  DMOJ 问题 ecoo19r1p1，免费衬衫

1.  DMOJ 问题 dmopc14c7p2，潮汐

1.  DMOJ 问题 wac3p3，韦斯利玩 DDR

1.  DMOJ 问题 ecoo18r1p2，露丝的戒指（如果你在这里使用 f-strings，你需要一种方法来包含 { 和 } 符号本身。你可以通过使用 {{ 来包含 {，通过使用 }} 来包含 }。）

1.  DMOJ 问题 coci19c5p1，Emacs

1.  DMOJ 问题 coci20c2p1，Crtanje（你需要支持从 -100 到 100 的行。那么，当 Python 列表的索引从 0 开始时，我们如何支持负索引的行呢？这里有个技巧：每次需要访问第 x 行时，使用索引 x + 100。这样可以将行号从 -100 到 100 移动到 0 到 200 的范围。此外，关于字符串的一个小困扰是：\ 是特殊字符，因此如果你想要一个 \ 字符，你需要使用 '\\' 而不是 '\'。）

1.  DMOJ 问题 dmopc19c5p2，查理的疯狂征服（你需要小心处理索引和游戏规则！）

### 备注

《Village Neighborhood》最初来自 2018 年加拿大计算机竞赛高级组。《School Trip》最初来自 2017 年安大略省教育计算组织编程竞赛第 1 轮。《Baker Bonus》最初来自 2017 年安大略省教育计算组织编程竞赛第 3 轮。
