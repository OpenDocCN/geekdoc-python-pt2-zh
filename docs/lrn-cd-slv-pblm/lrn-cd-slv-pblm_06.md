## 6

使用函数设计程序

![image](img/common.jpg)

在编写大型程序时，组织我们的代码成更小的逻辑单元是很重要的，每个单元都为整体目标做出贡献。这样，我们就可以独立思考每个单元，而不必担心其他单元在做什么。然后，我们再将这些单元组合在一起。这些单元被称为*函数*。

在本章中，我们将使用函数来分解并解决两个问题：计算两人纸牌游戏的得分和判断动作人物的盒子是否可以整齐地组织。

### 问题 #14：纸牌游戏

在这个问题中，我们将实现一个两人纸牌游戏。作为思考问题的一部分，我们会发现相同的逻辑片段会多次出现。我们将学习如何将这些代码打包成 Python 函数，以避免代码重复并增强代码的清晰性。

这是 DMOJ 问题 ccc99s1。

#### 挑战

两个玩家，A 和 B，正在进行一场纸牌游戏。（你不需要了解纸牌或纸牌游戏即可理解这个问题。）

游戏从一副 52 张的纸牌开始。玩家 A 从牌堆中拿一张卡片，然后玩家 B 拿一张卡片，然后是玩家 A，再是玩家 B，直到牌堆中没有卡片为止。

牌堆中有 13 种类型的卡片。这些类型如下：二、三、四、五、六、七、八、九、十、杰克、皇后、国王、王牌。每种类型的卡片都有四张。例如，牌堆中有四张二，四张三，以此类推，一直到四张王牌。（这就是为什么牌堆中有 52 张卡片的原因：13 种类型乘以每种类型的 4 张卡片。）

一个*高牌*是指杰克、皇后、国王或王牌。当玩家拿到高牌时，他们可能会得分。以下是得分的规则：

+   如果玩家拿到一张杰克，并且此后牌堆中至少还剩下一张卡片，而接下来的一张卡片不是高牌，那么该玩家得 1 分。

+   如果玩家拿到一张皇后，并且此后牌堆中至少还剩两张卡片，而接下来的两张卡片都不是高牌，那么该玩家得 2 分。

+   如果玩家拿到一张国王，并且此后牌堆中至少还剩三张卡片，而接下来的三张卡片都不是高牌，那么该玩家得 3 分。

+   如果玩家拿到一张王牌，并且此后牌堆中至少剩下四张卡片，而接下来的四张卡片都不是高牌，那么该玩家得 4 分。

我们需要在每次玩家得分时输出信息，并且在游戏结束时输出每个玩家的总得分。

#### 输入

输入由 52 行组成。每行包含牌堆中一张卡片的类型。这些行的顺序与卡片从牌堆中被拿出的顺序一致；也就是说，第一行是从牌堆中拿出的第一张卡片，第二行是第二张卡片，依此类推。

#### 输出

每当玩家得分时，输出以下内容：

玩家 p 得分 q 分。

其中 p 是玩家 A 或 B，q 是他们刚刚得分的分数。

当游戏结束时，输出以下两行：

玩家 A：m 分。

玩家 B：n 分。

其中 m 是玩家 A 的总得分，n 是玩家 B 的总得分。

### 探索一个测试用例

如果你仔细思考如何解决这个问题，你可能会想是否现在就可以解决它，而不需要学任何新的东西。事实上，我们可以！我们状态很好。我们可以使用列表来表示牌堆。我们知道如何使用列表的 append 方法向牌堆中添加一张牌。我们可以访问列表中的值来查找高牌。我们甚至有 f-strings 来帮助我们输出玩家和得分信息。

不过，在深入讨论之前，我们先看一个小例子。这样做将突出我们缺少 Python 中的一个关键特性，这个特性将使得我们更容易组织解决方案并解决这个问题。

如果我们用一副 52 张牌来做例子，可能会花费整年时间，因此我们使用一个包含 10 张牌的较小例子。这个例子不是完整的测试用例，因此我们写的程序不能在它上面工作，但足够让我们理解游戏的机制以及我们解决方案需要做什么。以下是测试用例：

皇后

三

七

国王

九

杰克

八

国王

杰克

四

玩家 A 拿到了第一张牌，这是一张皇后牌。皇后是高牌，玩家 A 在这里可能得 2 分。首先，我们确认皇后之后，牌堆中至少还有两张牌。接下来，我们需要检查这两张牌，希望它们之间没有高牌。接下来的两张牌不是高牌——它们是三和七——因此玩家 A 得了 2 分。

玩家 B 现在拿到第二张牌，这是一张三。三不是高牌，因此玩家 B 没有得分。

玩家 A 现在拿到了七。没有得分。

玩家 B 现在拿到国王，因此玩家 B 有可能得 3 分。国王之后牌堆中至少还有三张牌。我们需要检查这三张牌，希望它们之间没有高牌。遗憾的是，这三张牌中有一张高牌——杰克——因此玩家 B 没有得分。

玩家 A 现在拿到了九。没有得分。

玩家 B 现在拿到第一张杰克牌。杰克之后牌堆中至少还有一张牌。我们需要检查这张牌，希望它不是高牌。好消息是：它不是高牌——它是一张八——因此玩家 B 得 1 分。

只剩下最后一分，由玩家 A 在他们从牌堆中拿到倒数第二张牌（杰克）时得到。

因此，这是该测试用例的输出：

玩家 A 得分 2 分。

玩家 B 得分 1 分。

玩家 A 得分 1 分。

玩家 A：3 分。

玩家 B：1 分。

注意，每次玩家拿到一张高牌时，我们需要检查两件事：第一，牌堆中剩余的牌数量是否足够；第二，这些牌中是否没有高牌。我们可以通过使用一个变量来跟踪已取出的牌的数量，来解决第一个问题。第二个问题则更为复杂。我们需要一些代码来检查一组牌中是否有高牌。更糟糕的是，如果不小心，我们可能会把非常相似的代码重复四次：一次检查杰克后的牌，一次检查皇后后的两张牌，一次检查国王后的三张牌，最后一次检查王牌后的四张牌。如果我们稍后发现逻辑上的问题，我们必须在最多四个不同的地方修复它。

是否有一种 Python 特性，可以让我们只写一次“没有高牌”的逻辑，并调用四次？有的。它叫做*函数*，它就是一个执行小任务的命名代码块。函数对于我们代码的组织和清晰性至关重要。所有程序员都在使用函数。没有它们，编写像游戏和文字处理器这样的庞大软件系统将变得不可行。让我们学习如何使用函数。

### 定义和调用函数

我们已经学会了如何调用 Python 提供的内置函数。例如，我们曾使用过 input 函数来读取输入。下面是一个没有参数的 input 函数调用：

>>> s = input()

你好

>>> s

'你好'

我们还使用了 Python 的 print 函数来输出文本。以下是带有一个参数的 print 函数调用：

>>> print('well, well')

well, well

Python 内置的函数是通用的，设计用于在各种场景下使用。当我们希望一个函数来解决特定问题时，我们必须自己定义它。

#### 无参数的函数

要*定义*或创建一个函数，我们使用 Python 的 def 关键字。以下是一个输出三行的函数定义：

>>> def intro():

...     print('*********')

...     print('*欢迎*')

...     print('*********')

...

函数定义的结构类似于 if 语句或循环。def 后面的名字是我们正在定义的函数的名称；在这里，我们定义了一个名为 intro 的函数。函数名称后面跟着一对空括号 ()。稍后我们会看到，我们可以在括号中传递信息，以将参数传递给函数。这个 intro 函数不接受任何参数，所以括号是空的。括号后面是一个冒号；就像 if 语句或循环一样，缺少冒号会导致语法错误。在接下来的几行中，我们提供了一段缩进的代码块，每次调用该函数时都会执行。

当你定义 intro 函数时，你可能会期待看到以下输出：

*********

*欢迎*

*********

但是不行：到目前为止，我们只是定义了函数，还没有调用它。定义函数没有可观察的效果；它只是将函数存储在计算机的内存中，以便我们稍后可以调用它。我们像调用任何 Python 内建函数一样调用我们自己的函数。由于这个 intro 函数不接受任何参数，我们在调用时使用一对空括号：

>>> intro()

*********

*WELCOME*

*********

你可以根据需要调用这个函数任意多次。它会在我们需要时提供。

#### 带有参数的函数

我们的 intro 函数并不灵活，因为每次调用它时都做相同的事情。我们可以修改函数，以便能够传递参数，而我们传递的参数可以影响函数的行为。这里是一个新的 intro 函数版本，它允许我们传递一个参数：

>>> def intro2(message):

...     line_length = len(message) + 2

...     print('*' * line_length)

...     print(f'*{message}*')

...     print('*' * line_length)

...

要调用此函数，我们提供一个字符串参数：

>>> intro2('HELLO')

*******

*HELLO*

*******

>>> intro2('WIN')

*****

*WIN*

*****

我们不能在没有参数的情况下调用这个 intro2 函数——如果我们尝试，系统会报错：

>>> intro2()

回溯（最近的调用最后）：

文件 "<stdin>"，第 1 行，在 <module> 中

TypeError: intro2() 缺少 1 个必需的位置参数：'message'

错误提醒我们没有为 message 提供参数。message 是一个函数的*参数*。当我们调用 intro2 时，Python 首先让 message 引用我们的参数所引用的内容；也就是说，message 成为我们参数的别名。

我们可以创建具有多个参数的函数。这里有一个函数，接受两个参数：一个是要打印的消息，另一个是打印的次数：

>>> def intro3(message, num_times):

...     for i in range(num_times):

...         print(message)

...

要调用这个函数，我们提供两个参数。Python 从左到右工作，将第一个参数赋给第一个参数位置，将第二个参数赋给第二个参数位置。在以下调用中，'high' 被赋值给 message 参数，5 被赋值给 num_times 参数：

>>> intro3('high', 5)

high

high

high

high

high

请确保提供正确数量的参数。对于 intro3，我们需要两个参数。其他任何情况都会报错：

>>> intro3()

回溯（最近的调用最后）：

文件 "<stdin>"，第 1 行，在 <module> 中

TypeError: intro3() 缺少 2 个必需的位置参数：'message'

和 'num_times'

>>> intro3('high')

回溯（最近的调用最后）：

文件 "<stdin>"，第 1 行，在 <module> 中

TypeError: intro3() 缺少 1 个必需的位置参数：'num_times'

我们还必须确保提供正确类型的值。错误的类型不会阻止我们调用函数，但它们会在函数内部引发错误：

>>> intro3('high', 'low')

回溯（最近的调用最后）：

文件 "<stdin>"，第 1 行，在 <module> 中

文件 "<stdin>"，第 2 行，在 intro3 中

TypeError: 'str' 对象不能作为整数解释

这个 TypeError 错误发生是因为 intro3 使用了针对 num_times 变量的 range 循环。如果我们为 num_times 提供的参数不是整数，那么 range 循环会失败。

#### 关键字参数

调用函数时，可以覆盖参数与参数值之间的左到右对应关系。为了实现这一点，我们可以随意使用参数的名称顺序。使用参数名称的参数被称为*关键字参数*。这就是它的工作原理：

>>> def intro3(message, num_times):

...     对于 i 在 range(num_times) 中:

...         打印(message)

...

>>> intro3(message='high', num_times=3)

high

high

high

>>> intro3(num_times=3, message='high')

high

high

high

每次函数调用使用两个关键字参数。关键字参数写作参数名、等号及其对应的参数值。

你甚至可以先使用常规参数，再使用关键字参数：

>>> intro3('high', num_times=3)

high

high

high

但是一旦你使用了关键字参数，就不能再回到常规参数了：

>>> intro3(message='high', 3)

文件 "<stdin>"，第 1 行

SyntaxError: 位置参数位于关键字参数后面

在《第五章 排序一个列表》中，我们在调用 sort 方法时使用了一个 reverse 关键字参数。Python 设计者决定 reverse 只能作为关键字参数使用，这意味着无法在不使用关键字参数的情况下填充它的值。Python 也允许我们对函数使用这种方式，但本书中不需要这种控制。

#### 局部变量

参数名称像常规变量一样工作，但它们是*局部的*，仅在定义它们的函数中存在。也就是说，函数参数在函数外部不存在：

>>> def intro2(message):

...     line_length = len(message) + 2

...     打印('*' * line_length)

...     打印(f'*{message}*')

...     打印('*' * line_length)

...

>>> intro2('hello')

*******

*hello*

*******

>>> message

错误追踪（最近的调用最后）：

文件 "<stdin>"，第 1 行，在 <module> 中

NameError: 未定义名称 'message'

那么那个 line_length 变量呢——它也是局部的吗？它是的：

>>> line_length

错误追踪（最近的调用最后）：

文件 "<stdin>"，第 1 行，在 <module> 中

NameError: 未定义名称 'line_length'

如果你有一个变量，并且调用了一个使用相同名称参数或局部变量的函数，会发生什么？你的值会丢失吗？我们来看一下：

>>> line_length = 999

>>> intro2('hello')

*******

*hello*

*******

>>> line_length

999

呼——它仍然是 999，就像我们离开时一样。局部变量在函数调用时创建，并在函数终止时销毁，且不会影响其他具有相同名称的变量。

一个函数可以访问函数外部创建的变量。然而，不建议依赖这种做法，因为这样函数就不是自包含的，而是期望某些变量已经存在。在本书中，我们将编写只使用局部变量的函数。所有函数需要的信息都会通过参数传递给函数。

#### 可变参数

由于参数是其对应实参的别名，它可以用来改变可变值。这里是一个函数，用于从列表 lst 中移除所有出现的某个值：

>>> def remove_all(lst, value):

...         while value in lst:

...         lst.remove(value)

...

>>> lst = [5, 10, 20, 5, 45, 5, 9]

>>> remove_all(lst, 5)

>>> lst

[10, 20, 45, 9]

注意我们通过使用变量将列表传递给 remove_all。如果你直接用列表值（而不是引用列表的变量）调用这个函数，它将不会完成任何有用的操作：

>>> remove_all([5, 10, 20, 5, 45, 5, 9], 5)

这个函数移除了列表中的所有 5，但由于我们没有使用变量，我们再也无法引用这个列表。

**概念检查**

以下代码的输出是什么？

def mystery(s, lst):

s = s.upper()

lst = lst + [2]

s = 'a'

lst = [1]

mystery(s, lst)

print(s, lst)

A. a [1]

B. a [1, 2]

C. A [1]

D. A [1, 2]

答案：A。当调用 mystery 函数时，它的 s 参数会指向 s 实参指向的内容，即 'a' 字符串。同样，它的 lst 参数会指向 lst 实参指向的内容，即 [1] 列表。在 mystery 函数内部，s 和 lst 是局部变量。

现在我们来研究一下函数本身的两个语句。

首先，s = s.upper()。这使得局部变量 s 指向 'A'（大写）。但它没有改变函数外部的 s 指向的内容，外部的 s 仍然指向 'a'（小写）。

其次，lst = lst + [2]。使用 + 运算符与列表操作会创建一个新列表（它不会改变现有的列表！），因此这使得局部变量 lst 指向新的列表：[1, 2]。但同样，它并没有改变外部 lst 指向的内容，它仍然是 [1]。

怎么回事——不是说过函数可以改变一个可变参数吗？是的，但为了让这种情况发生，你确实需要改变值本身，而不是局部变量指向的内容。比较之前的程序和下面的程序，后者的输出不同：

def mystery(s, lst):

s.upper()  # upper 创建一个新字符串

lst.append(2)  # append 改变了列表

s = 'a'

lst = [1]

mystery(s, lst)

print(s, lst)

#### 返回值

让我们回到卡牌游戏问题。我们的目标是定义一个函数，告诉我们在一副牌中是否没有高牌。我们将这个函数命名为 no_high。虽然我们还没有编写 no_high 函数，但我们可以先说明我们希望实现的目标。以下是我们的目标：

>>> no_high(['two', 'six'])

True

>>> no_high(['eight'])

True

>>> no_high(['two', 'jack', 'four'])

False

>>> no_high(['queen', 'king', 'three', 'queen'])

False

我们希望前两次调用返回 True，因为在那些卡片列表中没有高牌。而我们希望第三次和第四次调用返回 False，因为在那些卡片列表中至少有一张高牌。

我们如何定义一个函数，返回这些 True 和 False 值呢？这就是函数谜题的最后一块拼图。

要从函数返回一个值，我们使用 Python 的 return 关键字。一旦执行到 return，函数执行就会立即终止，并且指定的值会返回给调用者。

这是我们如何编写 no_high 函数的方式：

>>> def no_high(lst):

...     if 'jack' in lst:

...         return False

...     if 'queen' in lst:

...         return False

...     if 'king' in lst:

...         return False

...     if 'ace' in lst:

...         return False

...     return True

...

我们首先检查列表中是否有任何 'jack' 卡片。如果有，那么我们知道列表中包含一个或多个高牌，因此我们立即返回 False。

如果我们还在这里，那么我们知道没有 jack。但仍可能有其他高牌，所以我们需要检查它们。其余的 if 语句分别检查 queen、king 和 ace，如果它们中的任何一个存在于列表中，则返回 False。

如果我们没有遇到这四个 return 语句，那么列表中就没有高牌。在这种情况下，我们返回 True。

A. 没有给定值的 return 本身会返回 None。这个特性在你编写一个没有返回有用结果的函数时非常有用，可以让你在到达函数代码的底部之前终止函数。

如果在循环中遇到 return，函数仍会立即终止，不论它嵌套得多深。下面是一个例子，展示了 return 如何让我们跳出一个嵌套循环：

>>> def func():

...     for i in range(10):

...         for j in range(10):

...             print(i, j)

...             if j == 4:

...                 return

...

>>> func()

0 0

0 1

0 2

0 3

0 4

return 就像是超级 break！有些人不喜欢在循环中使用 return，原因和他们不喜欢 break 是一样的：它可能会掩盖循环的目的和逻辑。我在循环中使用 return 是为了方便。与可以随处出现的 break 不同，return 只能在函数内部使用，并且与其他代码分开。如果我们保持函数的简洁，那么在循环中使用 return 可以帮助我们编写清晰的代码，而不会干扰周围的代码。

**概念检查**

以下版本的 no_high 函数是否正确？也就是说，它是否在列表中至少有一张高牌时返回 True，否则返回 False？

def no_high(lst):

for card in lst:

if card in ['jack', 'queen', 'king', 'ace']:

return False

else:

return True

A. 是的

B. 不是；例如，它返回错误的值，对于 ['two', 'three'] 来说就是如此。

C. 不是；例如，它返回错误的值，对于 ['jack'] 来说就是如此。

D. 不是；例如，它返回错误的值，对于 ['jack', 'two'] 来说就是如此。

E. 不对；例如，它对 ['two', 'jack'] 返回错误的值

答案：E. if-else 语句使得循环总是在第一次迭代时终止。如果第一张牌是高牌，函数就终止并返回 False；如果第一张牌不是高牌，函数就终止并返回 True。它不会检查其他任何牌！这就是它在 ['two', 'jack'] 上失败的原因：第一张牌不是高牌，因此函数返回 True。返回 True 告诉我们列表中没有高牌。但这错了：里面有一张杰克！函数做错了，应该返回 False。

### 函数文档

现在我们很清楚 no_high 函数的作用，以及如何调用它。但如果几个月后，旧代码的目的不容易记起来怎么办？如果我们积累了大量自己的函数，导致很难记住每个函数的作用又该怎么办？

对于我们编写的每个函数，我们都会添加文档，说明每个参数的含义以及函数返回的内容。这种文档叫做*文档字符串*，即“documentation string”。文档字符串应该从函数代码块的第一行开始编写。下面是 no_high 函数，带有文档字符串：

>>> def no_high(lst):

...     """

...     lst 是一个字符串列表，表示扑克牌。

...

...     如果 lst 中没有高牌，则返回 True，否则返回 False。

...     """

...     如果 'jack' 在 lst 中：

...         return False

...     如果 'queen' 在 lst 中：

...         return False

...     如果 'king' 在 lst 中：

...         return False

...     如果 'ace' 在 lst 中：

...         return False

...     return True

...

文档字符串以三个双引号（"""）开始和结束。像单引号（'）或双引号（"）一样，三个双引号可以用来开始和结束任何字符串。使用三个引号创建的字符串叫做*三引号字符串*。（三单引号也可以，但 Python 的约定是使用三个双引号。）它们的优势是允许我们通过在每行后按下 ENTER 键来添加多行文本；而使用 ' 或 " 创建的字符串不能像这样跨越多行。我们使用三引号字符串作为文档字符串，以便可以包括任意数量的行。

这里的文档字符串告诉我们 lst 是什么：它是一个表示扑克牌的字符串列表。它还告诉我们函数返回 True 或 False 值，并说明每个返回值的含义。这些信息足够让别人可以调用函数，而无需查看它的代码。只要有人知道一个函数的作用，他们就可以直接使用它。我们一直在使用 Python 函数，甚至从来没有看过它们的代码。print 是如何工作的？input 是如何工作的？我们不知道！但这并不重要：我们知道这些函数做什么，所以我们只需专注于调用它们。

对于具有多个参数的函数，文档字符串应命名每个参数并给出其预期类型。以下是 remove_all 函数，来自本章“可变参数”部分，具有合适的文档字符串：

>>> def remove_all(lst, value):

...     """

...     lst 是一个列表。

...     value 是一个值。

...

...     移除 lst 中所有的 value 出现的地方。

...     """

...     while value in lst:

...         lst.remove(value)

...

请注意，这个文档字符串没有谈论返回任何内容。这是因为这个函数不返回任何有用的东西！它从 lst 中移除元素，这正是文档字符串所描述的。

### 解决问题

我们刚刚学习了定义和调用函数的基础知识。在本书的剩余部分，每当我们面临一个大问题时，我们就能够将其解决方案分解为更小的任务，每个任务将由一个函数解决。

让我们在 Card Game 的解决方案中使用我们的 no_high 函数。代码在 Listing 6-1 中。

❶ NUM_CARDS = 52

❷ 定义 no_high(lst)：

"""

lst 是一个字符串列表，表示牌。

如果 lst 中没有高牌，返回 True，否则返回 False。

"""

如果'lst'中有'jack'：

返回 False

如果'lst'中有'queen'：

返回 False

如果'lst'中有'king'：

返回 False

如果'lst'中有'ace'：

返回 False

返回 True

❸ deck = []

❹ 对 i 在 range(NUM_CARDS)中：

deck.append(input())

score_a = 0

score_b = 0

player = 'A'

❺ 对 i 在 range(NUM_CARDS)中：

card = deck[i]

points = 0

❻ remaining = NUM_CARDS - i - 1

❼ 如果 card == 'jack' and remaining >= 1 and no_high(deck[i+1:i+2]):

points = 1

elif card == 'queen' and remaining >= 2 and no_high(deck[i+1:i+3]):

points = 2

elif card == 'king' and remaining >= 3 and no_high(deck[i+1:i+4]):

points = 3

elif card == 'ace' and remaining >= 4 and no_high(deck[i+1:i+5]):

points = 4

❽ 如果 points > 0：

print(f'玩家{player}得分 {points} 分。')

❾ 如果 player == 'A'：

score_a = score_a + points

player = 'B'

否则：

score_b = score_b + points

player = 'A'

print(f'玩家 A: {score_a} 分。')

print(f'玩家 B: {score_b} 分。')

*Listing 6-1: 解决 Card Game*

我引入了常量 NUM_CARDS 来表示 52 ❶。我们将在代码中多次使用它，记住 NUM_CARDS 的含义比记住 52 的含义要容易。

接下来我们定义 no_high 函数，包括文档字符串，这是我们已经深入讨论过的 ❷。我们通常将函数放在程序的顶部，这样函数就可以被后续的代码调用。

程序的主要部分从创建一个列表开始，该列表将保存牌组中的牌 ❸。然后我们从输入中读取牌，将每张牌附加到牌组中。你会注意到，牌从未被字面上移除或从牌组中取出（牌组在整个程序执行过程中保持不变）。我们本可以那样做，但我选择跟踪我们在牌组中的位置，这样我们就知道下一张被移除的牌是哪张。

还有三个其他关键变量需要维护：`score_a`，玩家 A 当前的总得分；`score_b`，玩家 B 当前的总得分；以及 `player`，当前玩家的名字。

我们的下一步任务是查看牌组中的每张卡片并给予玩家得分。常规的 for 循环允许我们查看当前卡片。但这还不够：如果当前卡片是高牌，我们还需要查看后面的卡片。为了实现这一点，我们使用了 range for 循环 ❺。

在每次循环迭代中，我们会根据玩家从牌组中抽取的卡片来确定他们获得的得分。每条得分规则依赖于牌组中剩余卡片的数量。`remaining` 变量 ❻ 告诉我们剩余卡片的数量。当 i 为 0 时，剩余卡片的数量是 51，因为我们刚刚抽取了第一张卡片。当 i 为 1 时，剩余卡片的数量是 50，因为我们刚刚抽取了第二张卡片。一般来说，剩余卡片数量的表达式是总卡片数减去 i 再减去 1。

现在我们有四个测试，每个测试对应一种得分方式❼。每个测试都会检查当前卡片和剩余卡片的数量。如果这两个条件都为真，就会调用我们的 `no_high` 函数，并传递包含适当数量卡片的牌组切片。例如，如果当前卡片是“杰克”并且至少剩下 1 张卡片，我们就会将长度为 1 的列表传递给 `no_high` ❼。如果 `no_high` 返回 True，那么该切片中就没有高牌，因此当前玩家会得分。`points` 变量决定将要奖励的得分；它在每次循环迭代时从 0 开始，根据情况设置为 1、2、3 或 4。

如果玩家得分了 ❽，我们会输出一条消息，指示得分的玩家及他们得的分数。

当前迭代中剩下的任务是将得分加到当前玩家的得分中，并轮到另一个玩家。我们通过一个 if-else 语句 ❾ 来完成这两个任务。（如果本次迭代的 `points` 是 0，那么就会把一个无害的 0 加到玩家的得分中。没有必要明确测试和避免这种情况。）

最后的两个 `print` 调用会输出每个玩家的总得分。

就这样：通过使用函数来组织我们的代码并使其更易于阅读，我们解决了这个问题。可以随意将我们的代码提交给评审，你应该能看到所有测试用例都通过了。

### 问题 #15：动作人物

为了解决纸牌游戏问题，我们首先通过一个示例，并且这个示例突出了在哪些地方使用函数可能是有用的。现在，我们将使用函数来解决另一个问题，但我们会通过更系统的方法来发现所需的函数。

这是 Timus 问题 2144。这是书中唯一来自 Timus 评测系统的问题。要找到该问题，请访问 *[`acm.timus.ru/`](https://acm.timus.ru/)*，点击 **Problem set**，点击 **Volume 12**，然后找到问题 2144（在评测系统中称为 Cleaning the Room）。

#### 挑战

Lena 有 *n* 个未打开的动作人物盒子。这些盒子不能被打开（否则动作人物的价值会丧失），因此盒子中的动作人物顺序不能改变。此外，盒子也不能旋转（否则动作人物会朝错的方向）。

每个动作人物都有一个高度。例如，其中一个盒子可能包含三个动作人物，按从左到右的顺序，它们的高度分别是 4、5 和 7。当我提到动作人物盒子时，我总是按从左到右的顺序列出它们的高度。

Lena 想要 *整理盒子*，这意味着要将盒子排列，使得盒子中的动作人物高度从左到右逐渐增加或保持不变。

是否能够整理这些盒子取决于盒子中动作人物的高度。例如，如果第一个盒子有高度分别为 4、5 和 7 的动作人物，而第二个盒子有高度分别为 1 和 2 的动作人物，那么她可以通过将第二个盒子放在前面来整理这些盒子。但如果我们保持第一个盒子的顺序不变，并将第二个盒子的动作人物高度改为 6 和 8，那么就无法整理这些盒子。

判断 Lena 是否能整理这些盒子。

#### 输入

输入包含以下几行：

+   一行包含整数 *n*，表示盒子的数量。*n* 的值在 1 到 100 之间。

+   *n* 行，每行代表一个盒子。每行开始是一个整数 *k*，表示该盒子中的动作人物数量。*k* 的值在 1 到 100 之间。（因为 *k* 至少为 1，所以我们不需要担心空盒子的情况。）接下来是 *k* 个整数，表示该盒子中动作人物的高度，按从左到右的顺序排列。每对整数之间有一个空格。

#### 输出

如果 Lena 能够整理这些盒子，则输出 YES；否则，输出 NO。

### 盒子的表示

这个问题由多个小问题组成，每个问题我们可以通过编写一个函数来解决。首先让我们看看如何在 Python 中表示这些盒子，然后我们将设计所需的函数。

在 第五章中，当我们解决 Baker Bonus 问题时，我们学到了列表可以包含其他列表作为其值。这使得我们可以将列表嵌套在其他列表中。我们可以使用这种结构来表示动作人物的盒子。例如，这里有一个表示两个盒子的列表：

>>> boxes = [[4, 5, 7], [1, 2]]

第一个盒子有三个动作人物，第二个盒子有两个。我们可以单独访问每个盒子：

>>> boxes[0]

[4, 5, 7]

>>> boxes[1]

[1, 2]

我们将从输入中读取框的内容，并将这些信息放入一个嵌套列表，就像我展示的那样。然后，我们将使用这个嵌套列表来判断这些框是否能够被组织。

### 自顶向下设计

我们将使用一种称为 *自顶向下设计* 的程序设计方法来解决这个问题。自顶向下设计将一个大问题分解为几个较小的问题。这样做很有用，因为每个较小的问题都更容易解决。然后，我们可以将这些子问题的解决方案组合起来，解决原始问题。

#### 执行自顶向下设计

下面是自顶向下设计的工作原理。我们首先编写一个不完整的 Python 程序，捕捉解决方案中的主要任务。其中一些任务不需要很多代码，因此我们可以直接解决它们。其他任务则需要更多的工作，我们会将每个任务转化为一个函数，并在需要时调用它。我们也可能通过编写一点代码 *并* 调用一个函数来解决某个任务。然而，这些函数还不存在，我们必须先编写它们！

为了编写所需的函数，我们对该函数的任务重复执行相同的过程。也就是说，我们首先写下该函数的任务。如果我们可以直接为某个任务编写代码，就立即写；否则，我们调用另一个函数（稍后编写）来处理这个任务。

我们一直这样做，直到不再需要编写任何函数。到那时，我们就有了问题的解决方案。

它被称为自顶向下设计，因为我们从问题的顶层或最高层开始，逐步向下穿过问题的核心，直到每个任务都已完全用代码实现。接下来我们将使用这种方法来解决动作人物的问题。

#### 顶层

在开始设计之前，我们专注于需要解决的主要任务。

我们肯定需要读取输入数据，所以这是我们的第一个任务。

现在，假设我们已经读取了输入数据。我们应该做什么来判断这些框是否可以被组织起来？一个重要的步骤是检查每个框本身，确保其中的动作人物高度是有序的。例如，假设我们有一个框 [18, 20, 4]。这个框的高度顺序错乱，意味着我们没有机会组织所有的框。我们甚至不能组织这个框！

所以，这是我们的第二个任务：判断每个框本身是否将动作人物按顺序排列。如果任何一个框的动作人物顺序不对，那我们就知道这些框不能组织。如果所有框都没有问题，那么我们就有更多的检查任务。

如果每个框本身都没问题，接下来的问题是我们是否能组织所有的框。这里一个重要的观察是，从现在起，我们只关心每个框左右两侧的动作人物。框内这些动作人物之间的顺序已经不再重要。

这里是一个例子，我们有三个框：

[[9, 13, 14, 17, 25],

[32, 33, 34, 36],

[1, 6]]

第一个盒子以一个高度为 9 的人物模型开始，以一个高度为 25 的人物模型结束。放置在此盒子左侧的人物模型必须高度为 9 或更小；例如，我们可以将第三个盒子放置在此盒子左侧。放置在此盒子右侧的人物模型必须高度为 25 或更大；例如，我们可以将第二个盒子放置在此盒子右侧。高度为 13、14 和 17 的人物模型并不会改变任何事情；它们可以不在这里。

那么这是我们的第三个任务：忽略除了盒子两端的人物模型之外的所有人物模型。

紧接着第三个任务，我们将得到一个看起来像这样的列表：

[[9, 25]，

[32, 36]，

[1, 6]]

如果我们首先对这些盒子进行排序，就更容易判断我们是否能整理这些盒子，像这样：

[[1, 6]，

[9, 25]，

[32, 36]]

现在，清楚地看到一个盒子的邻近盒子应该是什么样子。（我们在解决第五章中的村庄邻里问题时采用了类似的方法。）因此，我们的第四个任务是排序这些盒子。

我们的第五个也是最后一个任务是确定这些已排序的盒子是否已整理好。如果人物模型的高度从左到右排序，那么这些盒子就是整理好的。高度为 1、6、9、25、32 和 36 的人物模型已按适当顺序排序，因此前面的盒子可以整理好。但考虑这个例子：

[[1, 6]，

[9, 50]，

[32, 36]]

由于第二个盒子里的那个巨大人物模型，这些盒子无法被整理。第二个盒子占用了高度 9 到 50；第三个盒子不能放在第二个盒子的右边，因为它的高度太小。

我们现在已经完成了问题的处理，并决定了五个主要任务：

1.  读取输入。

1.  检查所有盒子是否正常。

1.  获取一个仅包含每个盒子左侧和右侧人物模型高度的新盒子列表。

1.  对这些新盒子进行排序。

1.  确定这些已排序的盒子是否已整理好。

你可能会想知道为什么我们有“读取输入”任务，却没有“写入输出”任务。对于这个问题，写入输出仅涉及按需输出 YES 或 NO；没有什么复杂的。因此，我们会在知道答案的第一时间输出 YES 或 NO，所以输出会与其他任务交替进行。基于这些原因，我决定不将其作为主要任务。在你独立进行自顶向下设计时，如果你后来意识到漏掉了一个任务，不必担心。你只需要添加它并继续设计即可。

这是我们可以在代码中捕捉所需任务的方式：

❶ # 主程序

# TODO: 读取输入

# TODO: 检查所有盒子是否正常

# TODO: 获取一个仅包含左侧和右侧高度的新盒子列表

# TODO: 排序盒子

# TODO: 确定盒子是否已整理好

我将其称为主程序❶。我们编写的任何函数都应包含在此注释之前。

每个任务目前都仅作为注释书写。TODO 标记用于突出显示这些任务，我们需要将其从英语转换为 Python。一旦完成某个任务，我们会移除其 TODO。这样，我们就能追踪哪些任务已完成，哪些还没有。让我们开始吧！

#### 任务 1: 读取输入

我们需要读取包含 *n*（盒子数量）的那一行，然后读取盒子。读取一个整数可以在一行中完成，所以我们直接读取 *n*。而读取盒子则是一个定义良好的任务，需几行代码来解决，因此我们通过一个函数来实现这个任务；我们将其命名为 read_boxes。以下是主程序的当前状态：

# 主程序

❶ # 读取输入

n = int(input())

boxes = read_boxes(n)

# TODO: 检查所有盒子是否合格

# TODO: 获取一个仅包含左右高度的新盒子列表

# TODO: 对盒子进行排序

# TODO: 确定盒子是否已经组织好

我已从注释 ❶ 中移除了 TODO，因为从主程序的角度来看，我们已经解决了这个任务。当然，我们仍然需要编写 read_boxes 函数，接下来就写这个函数吧。

read_boxes 函数接受一个整数 n 作为参数，并读取并返回 n 个盒子。以下是代码：

def read_boxes(n):

"""

n 是要读取的盒子数量。

从输入中读取盒子，并将其作为返回值

盒子列表；每个盒子是一个动作人物高度的列表。

"""

boxes = []

❶ for i in range(n):

box = input().split()

❷ box.pop(0)

for i in range(len(box)):

box[i] = int(box[i])

boxes.append(box)

return boxes

我们需要读取 n 个盒子，因此我们循环 n 次 ❶。每次循环时，我们读取当前行并将其拆分为各个动作人物的高度。该行以一个整数开始，表示该行中高度的数量，因此在继续之前，我们将该值从列表中删除（它位于索引 0） ❷。然后，我们将每个高度转换为整数，并将当前盒子添加到盒子列表中。最后，我们返回盒子列表。

我们没有将 read_boxes 的任何部分推迟到尚未编写的函数，因此这个任务完成了！我们会在 # 主程序 注释之前，包括这个函数和我们编写的其他函数。

#### 任务 2: 检查所有盒子是否合格

每个盒子是否都按从最矮到最高的顺序排列？这是一个好问题，但我们不能通过一两行代码来回答。我们将依赖一个新函数 all_boxes_ok 来告诉我们。如果该函数返回 False，则至少有一个盒子的高度不正确，因此我们无法组织这些盒子。在这种情况下，我们应该输出 NO。如果 all_boxes_ok 返回 True，则我们应继续进行剩下的任务，以确定这些盒子是否可以组织。让我们在程序中也加入这一段 if-else 逻辑。以下是我们得到的结果：

# 主程序

# 读取输入

n = int(input())

boxes = read_boxes(n)

# 检查所有盒子是否合格

❶ if not all_boxes_ok(boxes):

print('NO')

else:

# TODO: 获取一个只包含左侧和右侧高度的新盒子列表

# TODO: 对盒子进行排序

# TODO: 确定盒子是否已排序

现在我们需要编写我们正在调用的 all_boxes_ok 函数❶。我们可以检查每个盒子，判断它是否有序。如果不是，我们立即返回 False。如果是有序的，则检查下一个盒子。如果我们检查了每个盒子，它们都按顺序排列，那么返回 True。

啊哈，所以我们需要能够检查一个单独的盒子！听起来像是另一个函数。我们叫它 box_ok。

这是我们对 all_boxes_ok 的实现：

def all_boxes_ok(boxes):

"""

boxes 是一个盒子的列表；每个盒子是一个动作人物高度的列表。

如果 boxes 中的每个盒子都有按顺序排列的动作人物，则返回 True

如果高度是非递减的顺序，返回 True，否则返回 False。

"""

for box in boxes:

if not box_ok(box):

return False

return True

我在注释中使用了“非递减”而不是“递增”这个词，因为动作人物的高度是允许相等的。例如，盒子[4, 4, 4]是完全可以的；如果声称这个盒子是“递增的”，那就是不正确的。

我们已经将部分 all_boxes_ok 任务推给了 box_ok，所以接下来编写这个函数。开始：

def box_ok(box):

"""

box 是给定盒子中动作人物的高度列表。

如果盒子中的高度是非递减顺序，则返回 True，

否则返回 False。

"""

for i in range(len(box)):

if box[i] > box[i + 1]:

return False

return True

如果任何一个高度大于其右边的高度，我们返回 False，因为这些高度不是按顺序排列的。如果通过了 for 循环，那就说明没有高度违规，返回 True。

使用自顶向下设计的一个好处是，我们可以将代码分解成小块，封装成函数，然后可以单独进行测试。例如，输入 box_ok 的代码到 Python shell 中。然后我们可以进行测试：

>>> box_ok([4, 5, 6])

我们希望这里返回 True，因为盒子从小到大的高度是有序的。我们肯定不希望得到的是我们实际得到的结果：

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

File "<stdin>", line 9, in box_ok

IndexError: 列表索引超出范围

错误从来不有趣，而且当我们不得不在一页又一页的代码中翻找时，它们就更加不有趣了。但在这里，我们知道错误仅限于这个小函数，所以我们找错误的工作量大大减少。问题在于，我们最终会将最右边的高度与它右边的高度进行比较——当然，后者是不存在的！所以我们需要提前一轮停止，比较倒数第二个高度和最后一个高度。下面是更新后的代码：

def box_ok(box):

"""

box 是给定盒子中动作人物的高度列表。

如果盒子中的高度是非递减顺序，则返回 True，

否则返回 False。

"""

❶ for i in range(len(box) - 1):

if box[i] > box[i + 1]:

return False

return True

唯一的变化是在调用 range ❶ 处。如果你测试这个版本的函数，你会看到它按要求工作。任务 2 完成！

#### 任务 3：获取一个只包含左边和右边高度的新盒子列表

现在我们已经掌握了自顶向下设计的方法。在这个任务中，我们需要一种方法，从包含所有动作人偶的盒子转换成只包含最左边和最右边动作人偶的盒子。我将最左边和最右边的动作人偶称为盒子的 *端点*。

一种方法是创建一个只包含端点的新盒子列表，这也是我这里要做的。你也可以考虑从原始盒子中实际移除高度，尽管那样稍微复杂一些。

我将这个任务的函数命名为 boxes_endpoints。以下是主程序的核心部分，更新后调用了该函数：

# 主程序

# 读取输入

n = int(input())

boxes = read_boxes(n)

# 检查所有盒子是否都正常

如果所有盒子都没问题（boxes）:

print('NO')

否则：

# 获取一个新的盒子列表，只有左边和右边的高度

❶ endpoints = boxes_endpoints(boxes)

# TODO：排序盒子

# TODO：确定盒子是否已经组织好

当我们用一个盒子列表 ❶ 调用 boxes_endpoints 时，我们期望得到一个只包含盒子端点的新列表。这是满足该描述的 boxes_endpoints 代码：

定义 boxes_endpoints(boxes):

"""

boxes 是一个盒子列表；每个盒子是一个动作人偶高度的列表。

返回一个列表，其中每个值都是一个包含两个值的列表：

盒子中最左边和最右边动作人偶的高度。

"""

❶ endpoints = []

对于每个 box 在 boxes 中：

❷ endpoints.append([box[0], box[-1]])

返回 endpoints

我们创建了一个新列表 ❶，用于存储每个盒子的端点。然后我们遍历这些盒子。对于每个盒子，我们使用索引来查找盒子中的最左边和最右边的高度，并将它们添加到端点列表 ❷ 中。最后，我们返回端点列表。

等一下：如果有一个盒子里面只有一个动作人偶，会发生什么？我们的 boxes_endpoints 函数会怎么处理它？根据它的文档字符串，它会返回一个包含两个值的列表。因此，这里最好也能发生这种情况；否则，函数就没有履行它的承诺。让我们测试一下。输入 boxes_endpoints 函数到 Python shell，并尝试用一个包含一个动作人偶的盒子列表来测试：

>>> boxes_endpoints([[2]])

[[2, 2]]

成功！最左边的高度是 2，最右边的高度是 2，因此我们得到了一个包含两个 2 的列表。在这种情况下，我们的函数工作正常，因为当盒子只有一个值时，box[0] 和 box[-1] 都指向相同的值。（不用担心空盒子的可能性，问题描述中已禁止空盒子。）

#### 任务 4：排序盒子

到此，我们已经有了一个端点列表——类似于这样：

>>> endpoints = [[9, 25], [32, 36], [1, 6]]

>>> endpoints

[[9, 25], [32, 36], [1, 6]]

我们想要对它们进行排序。我们需要另一个函数吗？比如说 sort_endpoints 函数？

这次不行！列表的排序方法正好符合我们的需求：

>>> endpoints.sort()

>>> endpoints

[[1, 6], [9, 25], [32, 36]]

当对一个包含两个值的列表调用排序时，排序是根据第一个值进行的。（如果第一个值相等，则根据第二个值进一步排序。）

我们可以立即通过调用排序来更新程序的主程序，解决另一个 TODO。更新后的代码如下：

# 主程序

# 读取输入

n = int(input())

boxes = read_boxes(n)

# 检查所有盒子是否正常

如果 not all_boxes_ok(boxes):

print('NO')

否则：

# 获取一个只包含左侧和右侧高度的新盒子列表

endpoints = boxes_endpoints(boxes)

# 排序盒子

endpoints.sort()

# TODO: 判断盒子是否有序

我们快完成了，只剩下一个 TODO。

#### 任务 5：判断盒子是否有序

我们的最终任务是检查端点。它们可能已经有序，如下所示：

[[1, 6],

[9, 25],

[32, 36]]

或者它们可能没有按顺序排列，如下所示：

[[1, 6],

[9, 50],

[32, 36]]

在前一种情况下，我们应该打印 YES；在后一种情况下，我们应该打印 NO。我们需要一个函数来判断端点是否有序。更新程序的主程序部分，最终我们得到如下代码：

# 主程序

# 读取输入

n = int(input())

boxes = read_boxes(n)

# 检查所有盒子是否正常

如果 not all_boxes_ok(boxes):

print('NO')

否则：

# 获取一个只包含左侧和右侧高度的新盒子列表

endpoints = boxes_endpoints(boxes)

# 排序盒子

endpoints.sort()

# 判断盒子是否有序

❶ 如果 all_endpoints_ok(endpoints):

print('YES')

否则：

print('NO')

在我们和问题的完整解决方案之间，只有一个 `all_endpoints_ok` 函数。它接受一个列表，每个值是一个端点的列表，并且如果端点有序则返回 True，否则返回 False。

让我们通过一个例子来了解如何实现这个函数。这里是我们将使用的端点列表：

[[1, 6],

[9, 25],

[32, 36]]

第一个盒子的右端点是高度 6。那么第二个盒子必须具有高度为 6 或更高的左端点。如果没有，我们就返回 False，表示端点没有按顺序排列。但是这里是没问题的，因为第二个盒子的左端点是高度 9。

现在我们用 25 这个值来重复检查，它是第二个盒子的右端点。第三个盒子的左端点是 32，所以我们又可以继续，因为 32 至少是 25。

一般来说，如果某个盒子的左端点小于上一个盒子的右端点，我们就返回 False。否则，如果所有的检查都通过，我们就返回 True。

这是代码：

def all_endpoints_ok(endpoints):

"""

endpoints 是一个列表，每个值都是一个包含两个值的列表：

盒子中最左边和最右边动作人物的高度。

❶ 需要：端点按动作人物高度排序。

如果端点来自可以

按顺序排列，若未按顺序排列，则返回 False。

"""

❷ maximum = endpoints[0][1]

for i in range(1, len(endpoints)):

如果 endpoints[i][0] < maximum:

返回 False

❸ maximum = endpoints[i][1]

返回 True

我在文档字符串中添加了一些信息，提醒我们调用该函数时需要什么❶。特别是，我们必须记得在调用该函数之前先对 endpoints 进行排序。否则，函数可能返回错误的值。

endpoints 的每个值是一个包含两个值的列表：索引 0 是最左边（最小）的身高，索引 1 是最右边（最大）的身高。代码使用 maximum 变量来跟踪盒子的最大身高。在 for 循环之前，它引用的是第一个盒子的最大身高❷。该循环将下一个盒子的最小身高与最大身高进行比较。如果下一个盒子的最小值过小，则返回 False，因为这两个盒子无法正确排列。每次迭代的最后一步是更新 maximum，使其引用下一个盒子的最大身高❸。

#### 综合全部

在完成了所有任务的代码编写后，包括作为设计的一部分产生的函数，我们准备将其全部汇总成完整的解决方案。是否保留主程序中的注释由你决定。我保留了它们，但实际上这可能会是过度注释代码的情况，因为函数名本身已经足够传达代码的功能。完整代码请参考 Listing 6-2。

def read_boxes(n):

"""

n 是要读取的盒子数量。

从输入中读取盒子，并以列表的形式返回它们。

盒子列表；每个盒子是一个动作人物身高的列表。

"""

boxes = []

对于 i 从 0 到 n - 1:

box = input().split()

box.pop(0)

对于 i 从 0 到 len(box) - 1:

box[i] = int(box[i])

boxes.append(box)

返回 boxes

def box_ok(box):

"""

box 是给定盒子中的动作人物身高列表。

如果 box 中的身高是非递减顺序，则返回 True，

否则返回 False。

"""

对于 i 从 0 到 len(box) - 2:

如果 box[i] > box[i + 1]:

返回 False

返回 True

def all_boxes_ok(boxes):

"""

boxes 是一个盒子列表；每个盒子是一个动作人物身高的列表。

如果每个箱子中的动作人物身高都是按非递减顺序排列的，返回 True。

如果身高按非递减顺序排列，则返回 True，否则返回 False。

"""

对于每个箱子中的盒子：

如果 box_ok(box) 为 False：

返回 False

返回 True

def boxes_endpoints(boxes):

"""

boxes 是一个盒子列表；每个盒子是一个动作人物身高的列表。

返回一个列表，每个值都是一个包含两个值的列表：

盒子中的最左边和最右边的动作人物身高。

"""

endpoints = []

对于每个盒子中的盒子：

endpoints.append([box[0], box[-1]])

返回 endpoints

def all_endpoints_ok(endpoints):

"""

endpoints 是一个列表，每个值都是一个包含两个值的列表：

盒子中的最左边和最右边的动作人物身高。

要求：endpoints 按动作人物身高排序。

如果 endpoints 中的每个值来自可以按顺序排列的盒子，返回 True。

排序后返回 True，否则返回 False。

"""

maximum = endpoints[0][1]

对于 i 从 1 到 len(endpoints) - 1:

如果 endpoints[i][0] < maximum:

返回 False

maximum = endpoints[i][1]

返回 True

# 主程序

# 读取输入

n = int(input())

boxes = read_boxes(n)

# 检查所有盒子是否都 OK

如果 not all_boxes_ok(boxes):

打印('NO')

否则：

# 获取一个新的只包含左右高度的盒子列表

endpoints = boxes_endpoints(boxes)

# 对盒子进行排序

endpoints.sort()

# 判断盒子是否已整理好

如果 all_endpoints_ok(endpoints)：

打印('YES')

否则：

打印('NO')

*列表 6-2：解决动作人物问题*

这是到目前为止我们在书中编写的最大程序。但看看程序的主体是多么简洁：它主要是函数调用，只有少量的 if-else 逻辑将它们串联起来。

我们这里每个函数只调用了一次。对比一下我们在 no_high Card Game 函数中调用了四次的情况。即使一个函数只调用一次，它依然有助于使代码更具组织性和可读性。

该提交是时候提交给 Timus 评测系统了。你应该能看到所有的测试用例都通过了。

**概念检查**

在任务 2 中，我们编写了函数 box_ok 来判断一个盒子的高度是否按顺序排列。它使用了 range for 循环。以下的 while 循环版本的 box_ok 正确吗？

def box_ok(box):

"""

box 是一个包含给定盒子中动作人物高度的列表。

如果 box 中的高度是非递减顺序，则返回 True，

否则返回 False。

"""

ok = True

i = 0

当 i < len(box) - 1 且 ok 为真时：

如果 box[i] > box[i + 1]：

ok = False

i = i + 1

返回 ok

A. 是的

B. 否；它可能会导致 IndexError

C. 否；它不会引发错误，但可能返回错误的值

答案：A。这与我们之前使用 range for 循环的版本等价。ok 变量最开始为 True，意味着我们检查过的所有高度都是正常的（因为我们还没有检查任何一个！）。只要符合条件，while 循环就会继续进行。

因为有更多的盒子需要检查，并且没有高度违反规则。如果某个动作人物的高度不符合顺序，则 ok 被设置为 False，从而终止循环。如果所有动作人物的高度都符合顺序，那么 ok 的值从不会从 True 改变为 False。因此，当我们在函数底部返回 ok 时，如果所有动作人物的高度都符合顺序，就返回 True，否则返回 False。

### 总结

在本章中，我们学习了函数的概念。函数是一个自包含的代码块，用来解决更大问题中的一个小部分。我们学习了如何向函数传递信息（通过参数）并获取信息（通过返回值）。

为了确定首先需要编写哪些函数，我们可以使用自顶向下设计。自顶向下设计帮助我们将一个大问题的解决方案分解为多个小任务；对于每个任务，如果能直接解决就直接解决，如果不能，则为其编写函数。如果一个任务太复杂，我们可以对其进行进一步的自顶向下设计。

在下一章中，我们将学习如何使用我们选择的文件，而不是使用标准输入和标准输出。随着我们不断拓宽知识的边界，我们将在那一章和本书的其余部分发现许多函数的应用。通过练习以下一些习题，来增强你使用函数的信心。

### 章节练习

这里有一些习题供你尝试。对于每个习题，使用自顶向下设计来识别一个或多个函数，帮助你组织代码。每个函数都要包括一个文档字符串！

1.  DMOJ 问题 ccc13s1，从 1987 年到 2013 年

1.  DMOJ 问题 ccc18j3，我们到了吗？

1.  DMOJ 问题 ecoo12r1p2，解码 DNA

1.  DMOJ 问题 crci07p1，平台

1.  DMOJ 问题 coci13c2p2，Misa

1.  重新访问第五章的一些习题，并通过使用函数来改进你的解决方案。我特别建议重新访问 DMOJ 问题 coci18c2p1（Preokret）和 DMOJ 问题 ccc00s2（喋喋不休的小溪）。

### 注释

卡片游戏最初来源于 1999 年加拿大计算机竞赛。动作人物最初来源于 2019 年乌拉尔学校编程竞赛。

许多现代编程语言，包括 Python，都支持两种不同的编程范式。一种是基于函数的；这就是我们在本章中学习的内容。另一种是基于*对象*的，并且引出了一个叫做*面向对象编程（OOP）*的范式。OOP 涉及定义新类型并为这些类型编写方法。在本书中，我们将使用 Python 类型（例如整数和字符串），但不会进一步讨论 OOP。若想了解 OOP 的入门知识以及 OOP 在实践中的案例研究，我推荐 Eric Matthes 编写的《*Python Crash Course*》第二版（No Starch Press, 2019）。
