## 9

设计完全搜索算法

![image](Images/common.jpg)

*算法* 是解决问题的步骤序列。对于本书中的每个问题，我们通过编写 Python 代码的形式来解决它。我们将在本章中重点讨论算法设计。当面对一个新问题时，有时很难知道该怎么做才能解决它。我们应该编写什么算法？幸运的是，我们不需要每次都从零开始。计算机科学家和程序员已经确定了几种通用算法类型，而且其中至少有一种可以用来解决我们的问题。

一种算法叫做 *完全搜索* 算法；它涉及尝试所有候选解决方案并选择最好的。例如，如果问题要求我们找到最大值，我们会尝试所有解决方案并选择最大的；如果问题要求我们找到最小值，我们会尝试所有解决方案并选择最小的。完全搜索算法也被称为 *暴力破解* 算法，但我会避免使用这个术语。的确，计算机在不断地检查一个又一个解决方案，但作为算法设计者，我们做的并不算是暴力破解。

我们使用完全搜索算法解决了 [第 5 章](ch05.xhtml#ch05)中的《村庄邻里》问题。我们被要求找到最小的邻里大小，我们通过查看每个邻里并记住最小的那个来解决这个问题。在本章中，我们将使用完全搜索算法解决其他问题。我们将看到，确定究竟搜索什么可能需要相当的创意。

我们将通过完全搜索解决两个问题：确定解雇哪名救生员，以及识别满足滑雪训练营要求的最低成本。然后我们将看到第三个问题，统计符合特定观察条件的奶牛三元组，这需要我们进一步探索。

### 问题 #21：救生员

在这个问题中，我们需要确定解雇哪名救生员，以便在解雇后最大化游泳池的时间覆盖率。我们将分别尝试解雇每一名救生员并观察结果——这就是一个完全搜索算法！

这是 USACO 2018 年 1 月的铜奖竞赛问题《救生员》。

#### 挑战

农场主约翰为他的奶牛购买了一个游泳池。这个游泳池从时间 0 开放到时间 1000。

农场主约翰雇佣了 *n* 名救生员来监视游泳池。每名救生员监视游泳池的时间是一个给定的时间区间。例如，一名救生员可能从时间 2 开始，到时间 7 结束。我会用 2–7 来表示这样的区间。一个区间所覆盖的时间单位数是结束时间减去开始时间。例如，时间区间为 2–7 的救生员覆盖了 7 – 2 = 5 个时间单位。这些时间单位分别是从时间 2 到 3、从 3 到 4、从 4 到 5、从 5 到 6 和从 6 到 7。

不幸的是，农场主约翰只有足够的钱支付 *n* – 1 名救生员的工资，而不是 *n* 名救生员，所以他必须解雇一名救生员。

确定解雇一个救生员后，仍然能覆盖的最大时间单位数。

#### 输入

从名为 *lifeguards.in* 的文件中读取输入。

输入由以下几行组成：

+   一行包含 *n*，即被雇佣的救生员数量。*n* 介于 1 和 100 之间。

+   *n* 行，每行对应一个救生员。每行给出救生员的开始时间、一个空格和结束时间。开始时间和结束时间都是介于 0 和 1,000 之间的整数，并且都是唯一的。

#### 输出

将输出写入名为 *lifeguards.out* 的文件。

输出可以由 *n* – 1 个救生员覆盖的最大时间单位数。

每个测试用例的解题时间限制是四秒。

### 探索一个测试用例

让我们通过一个测试用例来探索为什么完整搜索算法对于这个问题是有意义的。以下是这个测试用例：

4

5 8

10 15

17 25

9 20

你可能尝试用来解决这个问题的一个简单规则是解雇时间间隔最短的救生员。这看起来直观合理，因为这个救生员似乎对覆盖游泳池的贡献最小。

这个规则能给我们一个正确的算法吗？让我们来看看。它告诉我们解雇 5–8 的救生员，因为这个救生员的时间间隔最短。这样剩下的三个救生员的时间间隔分别是 10–15、17–25 和 9–20。这三个剩余的救生员正好覆盖了 9–25 的时间段，其中 25 – 9 = 16 个时间单位。16 是正确答案吗？

不幸的是，不对。事实证明我们应该解雇 10–15 的救生员。如果我们这么做，剩下的三个救生员的时间间隔将是 5–8、17–25 和 9–20。这三个剩余的救生员覆盖了 5–8 和 9–25 的时间段。（小心：它们并没有覆盖 8 到 9 之间的时间。）这两个时间段分别覆盖了 8 – 5 = 3 个时间单位和 25 – 9 = 16 个时间单位，总共覆盖了 19 个时间单位。

正确答案是 19，而不是 16。解雇时间间隔最短的救生员并没有成功。

想出一个总是有效的简单规则来解决这个问题并不容易。不过不用担心：通过完整搜索算法，我们可以完全避免这个要求。

这里是我们的完整搜索算法用来解决测试用例的过程：

1.  首先，算法会忽略第一个救生员，并计算剩下三个救生员覆盖的时间单位数。它得到的答案是 16。它会记住 16 作为新的目标得分。

1.  接下来，算法会忽略第二个救生员，并计算剩下三个救生员覆盖的时间单位数。它得到的答案是 19。由于 19 大于 16，它会记住 19 作为新的目标得分。

1.  接下来，算法会忽略第三个救生员，并计算剩下三个救生员覆盖的时间单位数。它得到的答案是 14。目标得分依然是 19。

1.  最后，它将忽略第四个救生员，并确定其余三个救生员所覆盖的时间单位数。最终得到的答案是 16。仍然需要超过的分数是 19。

在考虑了解雇每个救生员的后果之后，算法得出 19 是正确的答案。因为我们已经尝试了所有的选项，所以没有比这更好的答案了！我们对所有可能的解进行了完全搜索。

### 解决问题

使用完全搜索时，通常从为特定候选解编写一个解决问题的函数开始会比较有帮助。然后我们可以多次调用该函数，每次使用一个候选解。

#### 解雇一个救生员

我们写一个函数来确定当某个特定的救生员被解雇时，所覆盖的时间单位数。[Listing 9-1](ch09.xhtml#ch09ex01)展示了代码。

def num_covered(intervals, fired):

"""

intervals 是一个救生员时间间隔的列表；

每个时间间隔是一个 [start, end] 列表。

fired 是要解雇的救生员的索引。

返回所有救生员所覆盖的时间单位数

除了被解雇的救生员。

"""

❶ covered = set()

for i in range(len(intervals)):

if i != fired:

interval = intervals[i]

❷ for j in range(interval[0], interval[1]):

❸ covered.add(j)

return len(covered)

*Listing 9-1: 解决某个特定救生员被解雇时的问题*

第一个参数是一个救生员时间间隔的列表；第二个参数是要解雇的救生员的索引。将代码输入到 Python Shell 中。以下是该函数的两个示例调用：

>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 0)

16

>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 1)

19

这些调用确认，如果解雇救生员 0，我们可以覆盖 16 个时间单位；如果解雇救生员 1，我们可以覆盖 19 个时间单位。

现在让我们理解这个函数是如何操作的。我们首先创建一个集合来保存已覆盖的时间单位 ❶。每当一个时间单位被覆盖时，代码将该时间单位的开始时间添加到集合中。例如，如果从 0 到 1 的时间单位被覆盖，代码会将 0 添加到集合中；如果从 4 到 5 的时间单位被覆盖，它将把 4 添加到集合中。

我们遍历救生员的时间间隔。如果某个救生员没有被解雇，那么我们会遍历该救生员的时间间隔 ❷ 来考虑每个覆盖的时间单位。我们将这些时间单位添加到集合中 ❸，正如之前所承诺的那样。回想一下，集合不保留重复的值；如果我们多次尝试添加相同的时间单位也不需要担心。我们已经遍历了所有未解雇的救生员，并将它们所覆盖的所有时间单位添加到集合中。因此，我们只需返回集合中值的数量。

#### 主程序

我们程序的主要部分在[Listing 9-2](ch09.xhtml#ch09ex02)中。它使用num_covered函数来确定开除每个救生员时能够覆盖的时间单位数。确保在这段代码之前输入我们的num_covered函数([Listing 9-1](ch09.xhtml#ch09ex01))，以便完整地解决问题。

input_file = open('lifeguards.in', 'r')

output_file = open('lifeguards.out', 'w')

n = int(input_file.readline())

intervals = []

for i in range(n):

❶ interval = input_file.readline().split()

interval[0] = int(interval[0])

interval[1] = int(interval[1])

intervals.append(interval)

max_covered = 0

❷ for fired in range(n):

❸ result = num_covered(intervals, fired)

if result > max_covered:

max_covered = result

output_file.write(str(max_covered) + '\n')

input_file.close()

output_file.close()

*Listing 9-2: 主程序*

我们这里处理的是文件，而不是标准输入和标准输出。

程序首先读取救生员的数量，然后使用for循环读取每个救生员的时间区间。我们从输入❶读取每个时间区间，将它的每个部分转换为整数，并将其作为一个包含两个值的列表追加到我们的区间列表中。

我们使用max_covered变量来追踪能够覆盖的最大时间单位数。

现在，我们使用for循环❷逐个开除每个救生员。我们调用num_covered ❸来确定开除一个救生员后能够覆盖的时间单位数。每当我们能够覆盖更多的时间单位时，就更新max_covered。

当那个循环完成时，我们将已经检查了每个救生员的开除情况能够覆盖的时间单位数，并记住了其中的最大值。我们输出这个最大值来解决问题。

欢迎将我们的代码提交给USACO评审。对于Python代码，评审为每个测试用例设定了四秒的时间限制，但我们的解决方案应该不会接近这个限制。例如，我刚才运行了这段代码，每个测试用例的完成时间都不超过130毫秒。

#### 我们程序的效率

我们代码运行如此之快的原因是因为救生员数量非常少——最多只有100个。如果救生员的数量很多，那么我们的代码就无法在时间限制内解决问题。如果有几百个救生员，我们应该没问题。如果有3000或4000个救生员，可能还能勉强通过。但是超过这个数量，我们的代码就会变得太慢。例如，如果有5000个救生员，我们可能就无法在规定时间内完成了。我们需要设计一个新的算法，可能是利用比完全搜索更快的方法。

你可能认为5,000是一个庞大的救生员数量，认为我们的算法无法处理这么高的数字也没关系。但事实并非如此！回想一下[第8章](ch08.xhtml#ch08)中的电子邮件地址问题。那里，我们需要处理多达100,000个电子邮件地址。再想想同一章中的城市和州问题。那里，我们需要处理多达200,000个城市。相比之下，5,000个救生员并不算多。

完全搜索解决方案通常适用于少量输入。大规模测试用例往往是完全搜索解决方案失败的地方。

我们的救生员问题的完全搜索解决方案在处理大规模测试用例时效果不佳，原因是它做了大量重复的工作。假设我们在处理一个有5,000个救生员的测试用例。我们解雇救生员0，并调用num_covered来确定剩余救生员覆盖的时间单位数。然后，我们解雇救生员1，再次调用num_covered。这次num_covered所做的工作与上次类似。毕竟，情况并没有发生太大变化。唯一的变化是救生员0回来了，而救生员1被解雇了。其他4,998个救生员和之前一样！但是num_covered并不知道这一点。它又重新计算了所有救生员的工作。当我们解雇救生员2、救生员3，依此类推时，同样的情况会发生。每次，num_covered都从头开始做所有工作，而没有学习之前做过的事情。

记住，虽然有用，完全搜索算法也有局限性。面对一个新的问题，我们想要解决时，完全搜索算法是一个有用的起点，即使最终证明它效率太低。因为设计该算法的过程可能加深我们对问题的理解，并激发新的解决思路。

在下一部分，我们将看到另一个可以使用完全搜索的问题。

**概念检查**

以下版本的num_covered是否正确？

def num_covered(intervals, fired):

"""

intervals是一个救生员时间段的列表；

每个时间段是一个[start, end]的列表。

fired是要解雇的救生员的索引。

返回所有救生员覆盖的时间单位数

除了被解雇的那个。

"""

covered = set()

intervals.pop(fired)

for interval in intervals:

for j in range(interval[0], interval[1]):

covered.add(j)

return len(covered)

A. 是的

B. 不

答案：B。这个函数从救生员列表中删除被解雇的救生员。这是不允许的，因为文档字符串没有说明该函数会修改列表。使用这个版本的函数时，我们的程序将在许多测试用例中失败，因为救生员信息会随着时间丢失。例如，当我们测试开除救生员0时，救生员0被从列表中删除。后来我们测试开除救生员1时，救生员0不幸仍然被删除！如果你想使用一个删除被解雇救生员的函数版本，你需要操作列表的副本，而不是原始列表。

### 问题 #22: 滑雪场

有时，问题描述会明确说明在完全搜索解决方案中应该搜索什么。例如，在救生员问题中，我们被要求开除一名救生员，因此尝试开除每个救生员是合理的。而其他时候，我们需要更具创造性地确定应该搜索什么。当你阅读下一个问题时，思考一下在完全搜索解决方案中你会搜索什么。

这是USACO 2014年1月的青铜奖竞赛问题：滑雪课程设计。

#### 挑战

农场主约翰的农场上有*n*座山丘，每座山丘的高度在0到100之间。他希望将农场注册为滑雪训练营。

只有当最高和最低山丘的高度差不超过17时，农场才能注册为滑雪训练营。因此，农场主约翰可能需要增加一些山丘的高度并降低其他山丘的高度。他只能以整数的方式更改山丘的高度。

改变山丘高度*x*单位的费用是*x*²。例如，将山丘从高度1改为高度4的费用是(4 - 1)² = 9。

确定农场主约翰需要支付的最小金额，以便他能将农场注册为滑雪训练营。

#### 输入

从名为*skidesign.in*的文件中读取输入。

输入包括以下几行：

+   一行包含整数*n*，表示农场上的山丘数量。*n*的范围是1到1000。

+   *n*行，每行给出一座山丘的高度。每个高度是0到100之间的整数。

#### 输出

将输出写入名为*skidesign.out*的文件。

输出农场主约翰需要支付的最小金额，用于改变山丘的高度。

每个测试用例的时间限制是四秒。

### 探索一个测试用例

让我们看看是否可以将从救生员问题中学到的知识应用到这个问题中。在解决救生员问题时，我们分别开除了每个救生员，以找出我们应该开除的救生员。解决滑雪场问题时，也许我们可以对每个山丘做类似的处理？例如，也许我们可以将每个山丘的高度作为允许高度范围的低端？

我们将尝试使用以下测试用例：

4

23

40

16

2

这四座山丘的最小高度为2，最大高度为40。40与2的差为38，大于17。农场主约翰将不得不支付费用来修复这些山丘！

第一座山的高度是23。如果我们使用23作为范围的低端，那么高端就是23 + 17 = 40。我们需要计算将所有山调整到23–40范围内的成本。有两座山超出了这个范围，它们的高度分别为16和2。将它们调整到高度23的成本是(23 – 16)² + (23 – 2)² = 490。490是需要超越的成本。

第二座山的高度是40。这个范围的高端是40 + 17 = 57，所以我们希望将所有的山都调整到40–57的范围内。其他三座山超出了这个范围，因此它们每座都会增加总成本。这个总成本是(40 – 23)² + (40 – 16)² + (40 – 2)² = 2,309。这个值大于490，即当前的最小成本，因此490仍然是需要超越的成本。（记住，在这个问题中，我们的目标是*最小化*农夫约翰的成本，而在救生员问题中，我们的目标是*最大化*覆盖范围。）

第三座山的高度是16，这给我们提供了范围16–33。范围外有两座山，分别是高度为40和2的山。因此，这个范围的总成本是(40 – 33)² + (16 – 2)² = 245。新的超越成本是245！

第四座山的高度是2，这给我们提供了范围2–19。如果你计算这个范围的成本，你应该得到457的成本。

使用该算法得到的最小成本是245。245就是答案吗？我们完成了吗？

不，不行！事实证明，最小成本是221。我们获得这个最小成本的两个范围是12–29和13–30。没有任何一座山的高度是12。同样，也没有任何一座山的高度是13。因此，我们不能将山的高度作为范围的可能低端。

想一想一个正确的完整搜索算法会是什么样子，确保不会漏掉任何范围。

这里有一个保证能得到正确答案的计划。我们首先计算范围0–17的成本。然后我们计算范围1–18的成本。接着是2–19，3–20，4–21，依此类推。我们逐一测试每个可能的范围，并记下得到的最小成本。我们测试的范围与山的高度无关。由于我们正在测试所有可能的范围，因此没有任何方法能让我们错过找到最佳范围。

我们应该测试哪些范围？我们要测试到多高？应该测试50–67的范围吗？是的。那71–88的范围呢？也是的。那115–132呢？不！不是这个。

我们将检查的最终范围是100–117。原因与问题描述中的保证有关，即任何一座山的高度最多为100。

假设我们计算范围101–118的成本。即使不知道这些山丘的高度，我们也可以确定这些山丘不在这个范围内。毕竟，山丘的最大高度是100，而我们的范围从101开始。现在将我们的范围从101–118滑动到100–117。这个100–117的范围比101–118的范围成本更低！这是因为100比101更接近这些山丘。例如，考虑一个高度为80的山丘。将这个山丘的高度提升到101需要的成本是21² = 441，而提升到100只需要20² = 400。这表明101–118不能是最优的范围，没必要尝试它。

类似的逻辑解释了为什么尝试更高的范围（例如102–119、103–120等）是没有意义的。我们总是可以将这些范围滑动下来，使其成本更低。

总结一下，我们将测试恰好101个范围：0–17，1–18，2–19，以此类推，一直到100–117。我们会记住最优的成本。让我们开始吧！

### 求解问题

我们将分两步来解决这个问题，就像解决《救生员》问题时一样。我们将从一个函数开始，用来确定单个范围的成本。然后，我们将写一个主程序，每次调用这个函数，处理每个范围。

#### 确定单一范围的成本

[列表 9-3](ch09.xhtml#ch09ex03)给出了确定给定范围成本的函数代码。

MAX_DIFFERENCE = 17

MAX_HEIGHT = 100

def cost_for_range(heights, low, high):

"""

heights是一个山丘高度的列表。

low是给定范围下限的整数。

high是给定范围上限的整数。

返回将所有山丘的高度更改为

介于low和high之间。

"""

cost = 0

❶ for height in heights:

❷ if height < low:

❸ cost = cost + (low - height) ** 2

❹ elif height > high:

❺ cost = cost + (height - high) ** 2

返回成本

*列表 9-3：求解一个特定范围*

我已包含两个常量，我们稍后会用到。MAX_DIFFERENCE常量记录了最高和最低山丘高度之间允许的最大差异。MAX_HEIGHT常量记录了山丘的最大高度。

现在让我们来看看cost_for_range函数。它接受一个山丘高度的列表和一个由其下限和上限指定的目标范围。它返回将所有山丘高度更改为所需范围的成本。我鼓励你将这个函数的代码输入到Python shell中，在继续之前先试一下。

该函数循环遍历每个山的高度❶，将成本累加到将该山调整到期望范围的过程中。我们需要考虑两种情况。首先，当前山的高度可能低于low❷。表达式low - height给我们提供了需要添加到这座山的高度量，我们将该结果平方以得到成本❸。其次，当前山的高度可能高于high❹。表达式height - high给我们提供了需要从这座山减去的高度量，我们同样将该结果平方以得到成本❺。注意，如果高度已经在low-high范围内，我们不会做任何事情。遍历完所有高度后，我们返回总成本。

#### 主程序

我们程序的主要部分在[列表 9-4](ch09.xhtml#ch09ex04)中。它使用cost_for_range函数来确定每个范围的成本。为了完整地解决这个问题，请确保在这段代码之前输入我们的cost_for_range函数（[列表 9-3](ch09.xhtml#ch09ex03)）。

input_file = open('skidesign.in', 'r')

output_file = open('skidesign.out', 'w')

n = int(input_file.readline())

heights = []

对于i从0到n的范围：

heights.append(int(input_file.readline()))

❶ min_cost = cost_for_range(heights, 0, MAX_DIFFERENCE)

❷ 对于low从1到MAX_HEIGHT + 1的范围：

result = cost_for_range(heights, low, low + MAX_DIFFERENCE)

如果结果 < 最小成本：

min_cost = result

output_file.write(str(min_cost) + '\n')

input_file.close()

output_file.close()

*列表 9-4：主程序*

我们首先读取山的数量，然后将每个高度读入heights列表。

我们使用min_cost变量来记住到目前为止发现的最小成本。我们将min_cost设置为范围0–17的成本❶。然后，在一个范围的for循环中❷，我们尝试其他每个范围的成本，每当找到更小的成本时就更新min_cost。完成这个循环后，我们输出找到的最小成本。

现在是时候将我们的代码提交给评审了。我们的完全搜索解决方案应该能在时间限制内很好地解决问题。

在下一个问题中，我们将看到一个例子，其中简单的完全搜索解决方案效率不足。

**概念检查**

这是对[列表 9-4](ch09.xhtml#ch09ex04)中代码的建议更改。看这一行：

对于low从1到MAX_HEIGHT + 1的范围：

并将其更改为以下内容：

对于low从1到MAX_HEIGHT - MAX_DIFFERENCE + 1的范围：

代码仍然正确吗？

A. 是的

B. 不

答案：A。代码现在检查的最后一个范围是83–100，所以我们必须证明我们不再检查的范围——84–101、85–102等——是无关紧要的。

考虑范围84–101。如果我们能证明范围83–100至少和84–101一样好，那么我们就没有理由检查范围84–101。

范围84–101包括了高度101。但这是没有意义的：最高的山丘只有100，所以101的高度几乎可以忽略不计。我们可以去掉101而不影响范围。如果我们去掉它，剩下的范围就是84–100。啊哈——但是100–84仅为16，而我们允许的差值是17。所以我们可以将范围向左延伸一个单位，得到83–100的范围。显然，像这样扩大范围不会让范围变得更糟。它甚至可能让范围变得更好，因为它现在离任何高度为83或更低的山丘更近了。

我们从范围84–101开始，并展示了84–100范围至少是一样好的。我们可以对85–102、86–103等范围做出相同的论证。没有必要再往更高的范围去！

在继续之前，你可能想尝试解决《章节练习》中第1题和第2题，详见[第263页](ch09.xhtml#ch09lev1sec14)。

### 问题 #23：奶牛棒球

为了结束这一章，我选择了一个问题，在这个问题中我们需要提升我们的算法设计技能，超越完全搜索。阅读这个问题时，请注意输入其实不多。通常这意味着完全搜索算法的有效性。但这次不一样，因为这样的算法需要在这个输入中进行大量的搜索。困难的关键在于嵌套循环太多。为什么嵌套循环在这里会给我们带来问题？我们该怎么做呢？继续阅读！

这是USACO 2013年12月青铜级比赛问题——奶牛棒球。

#### 挑战

农夫约翰有*n*只奶牛。它们排成一排，每只奶牛都有一个不同的位置。它们正在开心地玩着投接棒球的游戏。

农夫约翰正在观察这些滑稽的行为。他发现奶牛*x*将球扔给其右边的某只奶牛*y*，然后奶牛*y*又将球扔给其右边的某只奶牛*z*。他还知道第二次投掷的距离至少是第一次投掷的距离，最多是第一次投掷距离的两倍。（例如，如果第一次投掷的距离是5，那么第二次投掷的距离至少是5，最多是10。）

确定满足农夫约翰观察的奶牛三元组(*x*, *y*, *z*)的数量。

#### 输入

从名为*baseball.in*的文件中读取输入。

输入包含以下几行：

+   一行包含*n*，即奶牛的数量。*n*的值介于3到1,000之间。

+   *n*行，每行给出一只奶牛的位置。所有位置都是唯一的，且每个位置的数值介于1和100,000,000之间。

#### 输出

将输出写入名为*baseball.out*的文件。

输出满足农夫约翰观察的奶牛三元组的数量。

每个测试用例的时间限制为四秒。

### 使用三个嵌套循环

我们可以使用三个嵌套的循环来考虑所有可能的三元组。我们将先查看代码，然后讨论它的效率。

#### 代码

在《第3章的“嵌套”》中，我们学会了如何使用两个嵌套循环遍历所有的值对。这样做的代码如下所示：

>>> lst = [1, 9]

>>> for num1 in lst:

...     for num2 in lst:

...         print(num1, num2)

...

1 1

1 9

9 1

9 9

我们可以通过类似的方法，使用三个嵌套的循环遍历所有的三元组，如下所示：

>>> for num1 in lst:

...     for num2 in lst:

...         for num3 in lst:

...             print(num1, num2, num3)

...

1 1 1

1 1 9

1 9 1

1 9 9

9 1 1

9 1 9

9 9 1

9 9 9

使用这样三个嵌套的循环为我们解决“牛棒球”问题提供了一个起点。对于每一组三元组，我们可以检查它是否符合 Farmer John 的观察结果。请参见 [Listing 9-5](ch09.xhtml#ch09ex05) 获取代码。

input_file = open('baseball.in', 'r')

output_file = open('baseball.out', 'w')

n = int(input_file.readline())

positions = []

for i in range(n):

❶ positions.append(int(input_file.readline()))

total = 0

❷ for position1 in positions:

❸ for position2 in positions:

first_two_diff = position2 - position1

❹ if first_two_diff > 0:

low = position2 + first_two_diff

high = position2 + first_two_diff * 2

❺ for position3 in positions:

if position3 >= low and position3 <= high:

total = total + 1

output_file.write(str(total) + '\n')

input_file.close()

output_file.close()

*Listing 9-5: 使用三个嵌套* for *循环*

我们将所有牛的位置读取到 positions 列表中 ❶。然后我们使用 for 循环 ❷ 遍历列表中的所有位置。对于每一个位置，我们使用嵌套的 for 循环 ❸ 遍历列表中的所有位置。在这一点上，position1 和 position2 分别表示列表中的两个位置。我们需要一个第三个嵌套循环，是的，但现在还不需要。我们首先需要计算 position1 和 position2 之间的差异，因为这告诉我们将要查找的 position3 的范围。

我们从问题描述中要求 position2 在 position1 的右侧。如果它是 ❹，那么我们计算 position3 的范围的低端和高端，并分别用 low 和 high 存储它们。例如，如果 position1 是 1 且 position2 是 6，那么我们将计算 6 + 5 = 11 为低端，6 + 5 * 2 = 16 为高端。然后我们通过第三个嵌套的 for 循环 ❺ 遍历列表，寻找介于 low 和 high 之间的位置。对于每个这样的 position3，我们将总数加 1。

在完成三个嵌套的循环后，我们计算了三元组的总数。最后，我们将该数字输出到输出文件中。

让我们在一个小的测试用例上运行我们的程序，确保没有发生奇怪的事情。代码如下：

7

16

14

23

18

1

6

11

该测试用例的正确答案是 11。满足条件的 11 个三元组如下：

+   14, 16, 18

+   14, 18, 23

+   1, 6, 16

+   1, 6, 14

+   1, 6, 11

+   1, 11, 23

+   6, 14, 23

+   6, 11, 16

+   6, 11, 18

+   11, 16, 23

+   11, 14, 18

好消息：我们的程序在这个测试用例中输出了11！它之所以这样做，是因为它最终找到了每一个满足条件的三元组。例如，在某个时刻，position1 会是 14，position2 会是 16，position3 会是 18。这个三元组满足距离要求，因此我们的程序会将其计入总数。不要担心，后面当 position1 是 18，position2 是 16，position3 是 14 时会发生什么。我们绝对不想计入这个三元组，因为这些投掷并没有投向正确的方向。不过没关系：if 语句 ❹ 会阻止这些三元组被处理。

我们的程序是正确的。但正如你在提交给评测系统时会看到的，它的效率不够高。对于这个问题以及许多竞赛编程问题，前几个测试用例是小的——只有几头牛、几个救生员或几个滑雪坡。我们的程序应该能够在规定时间内解决这些问题。而剩下的测试用例则会将我们的程序推向可接受输入的极限。我们的程序无法在规定时间内解决这些问题。它太慢了。

#### 我们程序的效率

为了理解为什么我们的程序如此缓慢，考虑它必须遍历的三元组数量会有所帮助。回想一下我们刚刚研究的测试用例，它有七头牛。我们的程序会检查多少个三元组？首先，对于第一头牛，有七个选择：16、14、23，等等。第二头牛也有七个选择，第三头牛也有七个选择。将这些数相乘，我们可以看到我们的程序会检查 7 * 7 * 7 = 343 个三元组。

如果我们有八头牛而不是七头牛呢？那我们的程序将会检查 8 * 8 * 8 = 512 个三元组。

我们可以给出一个适用于任意数量牛的三元组数量表达式。我们用 *n* 表示牛的数量；它可以是 7、8、50、1000 等，具体取决于测试用例。然后我们可以说，程序检查的三元组数量是 *n* * *n* * *n*，即 *n*³。

我们可以将任何数量的牛代入 *n* 来确定我们检查的三元组数量。例如，我们可以验证七头牛的三元组数量是 7³ = 343，八头牛的三元组数量是 8³ = 512。这些数字——343 和 512——很小。任何计算机都需要不到几毫秒的时间来检查这么多三元组。作为保守的参考，你可以认为一个 Python 程序每秒能够检查或执行约 500 万次操作。这个问题的时间限制是每个测试用例 4 秒，所以我们能检查大约 20,000,000 个三元组。

让我们用更大的数字替代 *n*，看看会发生什么。对于 50 头牛，我们有 50³ = 125,000 个三元组。没什么大不了的：检查 125,000 个东西对于今天的计算机来说很容易。对于 100 头牛，我们有 100³ = 1,000,000 个三元组。同样没问题。我们可以在不到一秒的时间内检查一百万个东西。对于 200 头牛，我们有 200³ = 8,000,000 个三元组。我们在四秒内仍然能处理，但我希望你开始有点担心了。三元组的数量上升得相当快，而我们现在仅仅是 200 头牛。记住，我们需要支持最多 1,000 头牛。

对于 400 头牛，我们有 400³ = 64,000,000 个三元组。这对于我们在四秒内处理来说太多了。更糟糕的是，让我们试试 1,000 头牛，这是我们能得到的最大值。对于 1,000 头牛，我们有 1,000³ = 1,000,000,000 个三元组。那就是十亿。没戏了。在四秒内，我们根本不可能检查这么多三元组。我们需要让程序更高效。

### 首先排序

排序在这里是有帮助的。让我们先看看如何使用排序，然后讨论我们得到的解决方案的效率。

#### 代码

我们的牛的位置可以是任何顺序——问题描述中并没有保证它们是排序的。不幸的是，这导致我们的程序检查了许多不可能满足要求的三元组。例如，检查三元组 18、16、14 是没有意义的，因为这些数字不是按递增顺序排列的。如果我们在一开始就对牛的位置进行排序，那么就可以避免检查这些不按顺序的三元组。

排序还有另一个好处。假设 position1 指的是某个牛的位置，position2 指的是另一个牛的位置。对于这一对位置，我们知道我们关心的 position3 的最小值和最大值。我们可以利用位置已排序这一事实，减少我们需要检查的值的数量。在继续之前，想一想为什么会这样。我们如何利用排序的事实来检查更少的值？

当你准备好时，可以参考 [清单 9-6](ch09.xhtml#ch09ex06)，查看我们使用排序的代码。

input_file = open('baseball.in', 'r')

output_file = open('baseball.out', 'w')

n = int(input_file.readline())

positions = []

for i in range(n):

positions.append(int(input_file.readline()))

❶ positions.sort()

total = 0

❷ 对于 i 在 range(n) 之间的每个值，执行：

❸ 对于 j 在 i + 1 到 n 之间的每个值，执行：

first_two_diff = positions[j] - positions[i]

low = positions[j] + first_two_diff

high = positions[j] + first_two_diff * 2

left = j + 1

❹ 当 left < n 且 positions[left] < low 时，执行：

left = left + 1

right = left

❺ 当 right < n 且 positions[right] <= high 时，执行：

right = right + 1

❻ total = total + right - left

output_file.write(str(total) + '\n')

input_file.close()

output_file.close()

*清单 9-6：使用排序*

在我们开始寻找三元组之前，我们先对 positions 进行排序 ❶。

我们的第一个循环使用循环变量 i 遍历所有位置 ❷。这次是一个范围 `for` 循环，而不是传统的 `for` 循环，这样我们就可以跟踪当前的位置索引。这很有用，因为我们可以将 i + 1 的值作为第二个循环 ❸ 的起始索引。这样，第二个循环就再也不会浪费时间去查看第一个位置左边的那些位置。

接下来，我们计算第三个位置的值范围的上下边界。

我们可以不再在每次找到合适的第三个位置时将 total 加 1，而是可以找到合适位置的左右边界，然后一次性将 total 增加。我们之所以能这样做，是因为位置列表已经排序。我们通过 `while` 循环找到每个边界。第一个 `while` 循环找到左边界 ❹。只要位置小于低值，它就会继续进行。完成后，left 就是第一个位置大于或等于低值的索引。第二个 `while` 循环找到右边界 ❺。只要位置小于等于高值，它就会继续进行。完成后，right 就是第一个位置大于高值的右侧索引。从 left 到 right 之间（不包括 right）的每个位置都可以作为与 i 和 j 索引位置组成三元组的第三个位置。我们通过将 right - left 加到 total 中来考虑这些位置 ❻。

这个程序中的两个 `while` 循环相当棘手。为了确保我们完全理解它们的工作原理，让我们通过一个示例来进行推演。我们将使用以下位置列表；这些位置与我们在前一部分使用的列表相同，只不过是已排序的：

[1, 6, 11, 14, 16, 18, 23]

假设 i 是 1，j 是 2，这样预期三元组中的两个位置就是 6 和 11。那么，对于第三个位置，我们寻找的是大于或等于 16 并且小于或等于 21 的位置。第一个 `while` 循环会将 left 设置为 4，即第一个位置大于或等于 16 的索引。第二个 `while` 循环会将 right 设置为 6，即第一个位置大于 21 的索引。将 left 从 right 中减去，我们得到 6 - 4 = 2，这意味着有两个三元组包含了位置 6 和 11。在继续之前，我建议你自己验证一下这些 `while` 循环在“特殊”情况下也能正常工作，比如当没有合适的第三个位置或只有一个合适的第三个位置时。

在这一部分，我们已经取得了显著进展。我们这里的代码显然比我们在[列表 9-5](ch09.xhtml#ch09ex05)中给出的代码更高效。然而，它仍然不够高效。如果你提交给评测系统，你会看到它并没有比我们上次得到的结果好多少。它仍然会在大部分测试用例中超时。

#### 我们程序的效率

我们程序的问题在于，找到第三个位置仍然可能需要很长时间。这些 `while` 循环仍然存在一些低效之处。我可以用一个新的位置列表来演示这一点，具体来说，就是从 1 到 32 的位置。

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,

17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]

让我们专注于当 i 为 0 且 j 为 7 时，这些是位置 1 和 8。对于第三个位置，我们寻找的是大于或等于 15 且小于或等于 22 的位置。为了找到 15，第一个 while 循环从右向左逐个位置扫描。它扫描 9，然后是 10，再是 11，再是 12，再是 13，再是 14，最后是 15。然后第二个 while 循环接管，逐个位置扫描，直到找到 23。

每个 while 循环实现了所谓的*线性搜索*。线性搜索是一种逐个搜索集合中每个值的技术。这是一个繁琐的过程，需要扫描所有这些值！并且有很多其他的 i 和 j 值也会导致类似的工作量。例如，试着追踪当 i 为 0 且 j 为 8，或者当 i 为 1 且 j 为 11 时会发生什么。

我们如何改进这个方法呢？我们如何避免扫描整个列表，寻找合适的左索引和右索引？

假设我给你一本书，里面有一千个已排序的整数，每行一个整数。我让你找到第一个大于或等于 300 的整数。你会一个一个地查看这些数字吗？你会先看 1，然后是 3，再是 4，接着是 7？还是说你会直接翻到书的中间？可能更快！也许你在那里找到数字 450。由于 450 大于 300，你现在知道这个数字位于书的前半部分。它不可能在后半部分，因为后半部分的数字都比 450 还大。通过只检查一个数字，你就将工作量减少了一半！现在，你可以在书的前半部分重复这个过程，翻到书的开始和中间之间的一半。你可能会在那里找到数字 200。现在你知道 300 在后面的某个位置，位于书的四分之一部分。你可以重复这个过程，直到找到 300——而且很快就能找到。这种技术——反复将问题一分为二——称为*二分查找*。它非常迅速。它彻底击败了逐个搜索的线性搜索技术。Python 提供了一个二分查找函数，它将为 Cow Baseball 做最后的修饰。但是，这个函数在一个叫做*模块*的东西里面；我们需要先讨论它们。

### Python 模块

*模块*是一个自包含的 Python 代码集合。一个模块通常包含多个函数，我们可以调用这些函数。

Python附带了各种各样的模块，我们可以用来为程序添加功能。有用于处理随机数、日期和时间、统计数据、电子邮件、网页、音频文件等等的模块。要覆盖所有这些内容，可能需要一本单独的书！如果Python没有提供你需要的模块，甚至还有可以下载的模块。

本节我将重点介绍一个模块——random模块。我们将用它来学习模块的相关知识。接下来，我们就可以为下一节的二分查找模块做好准备。

你是否曾经想过人们是如何制作那些让事情随机发生的电脑游戏的？也许是一个抽卡的游戏，一个掷骰子的游戏，或者是敌人不可预测地生成的游戏。关键在于使用随机数。Python通过其random模块为我们提供了生成随机数的功能。

在使用模块中的内容之前，我们必须先*导入*它。一个方法是使用import关键字导入整个模块，如下所示：

>>> import random

那里面有什么？为了找出答案，你可以使用dir(random)：

>>> dir(random)

[忽略的内容

'betavariate', 'choice', 'choices', 'expovariate',

'gammavariate', 'gauss', 'getrandbits', 'getstate',

'lognormvariate', 'normalvariate', 'paretovariate',

'randint', 'random', 'randrange', 'sample', 'seed',

'setstate', 'shuffle', 'triangular', 'uniform',

'vonmisesvariate', 'weibullvariate']

random模块提供的一个函数是randint。我们传入一个范围的下限和上限，Python会返回该范围内的一个随机整数（包括两个端点）。

但我们不能像调用普通函数一样直接调用它。如果尝试这样做，我们会得到一个错误：

>>> randint(2, 10)

最近的调用栈（追踪）：

文件 "<stdin>"，第 1 行，在 <module> 中

NameError: name 'randint' is not defined

我们需要告诉Python，randint函数位于random模块中。为此，我们需要在randint前加上模块名和一个点，如下所示：

>>> random.randint(2, 10)

7

>>> random.randint(2, 10)

10

>>> random.randint(2, 10)

6

要获取randint函数的帮助，你可以输入help(random.randint)：

>>> help(random.randint)

获取模块random中方法randint的帮助：

randint(a, b) 方法来自random.Random实例

返回范围[a, b]内的随机整数，包括两个端点。

random模块中的另一个有用函数是choice。我们传入一个序列，它会随机返回其中的一个值：

>>> random.choice(['win', 'lose'])

'lose'

>>> random.choice(['win', 'lose'])

'lose'

>>> random.choice(['win', 'lose'])

'win'

如果我们经常使用模块中的少数几个函数，每次都输入模块名和点号会变得很麻烦。还有另一种导入这些函数的方法，可以让我们像调用其他非模块函数一样调用它们。下面是如何仅导入randint函数的方式：

>>> from random import randint

现在我们可以直接调用randint，而无需在前面加上random.：

>>> randint(2, 10)

10

如果我们需要randint和choice，可以同时导入它们：

>>> from random import randint, choice

本书中我们不会这样做，但我们可以创建自己的模块，包含我们喜欢的任何函数。例如，如果我们设计了一些与玩游戏相关的Python函数，我们可以将它们全部放在一个名为*game_functions.py*的文件中。然后，我们可以使用`import game_functions`导入该模块，之后访问其中的函数。

本书中我们编写的Python程序并不打算作为模块导入。原因是它们一开始就会读取输入。而模块不应该这样做。模块应该等待其函数被调用后才执行任何操作。random模块就是一个行为良好的模块：只有当我们请求它时，它才开始给我们提供随机的内容。

### bisect模块

现在我们准备开始尝试二分查找了。在[Listing 9-6](ch09.xhtml#ch09ex06)中，我们有两个while循环。它们运行得很慢，所以我们希望去除它们。为此，我们将用二分查找函数替换每个while循环：第一个while循环使用bisect_left，第二个while循环使用bisect_right。

这两个函数都在bisect模块中。我们来导入它们：

>>> from bisect import bisect_left, bisect_right

首先让我们讨论一下bisect_left。我们通过提供一个从小到大的排序列表和一个值x来调用它。它会返回列表中第一个大于或等于x的值的索引。

如果该值在列表中，我们将得到它最左侧出现的位置的索引：

>>> bisect_left([10, 50, 80, 80, 100], 10)

0

>>> bisect_left([10, 50, 80, 80, 100], 80)

2

如果该值不在列表中，那么返回的是第一个大于该值的元素的索引：

>>> bisect_left([10, 50, 80, 80, 100], 15)

1

>>> bisect_left([10, 50, 80, 80, 100], 81)

4

如果我们搜索一个比列表中所有值都大的元素，返回的将是列表的长度：

>>> bisect_left([10, 50, 80, 80, 100], 986)

5

让我们在前面章节中“排序优先”的七个位置列表上使用bisect_left。我们将找到大于或等于16的最左侧位置的索引：

>>> positions = [1, 6, 11, 14, 16, 18, 23]

>>> bisect_left(positions, 16)

4

完美：这正是我们需要的，能够替换[Listing 9-6](ch09.xhtml#ch09ex06)中第一个while循环的功能。

为了替换第二个while循环，我们将使用bisect_right而不是bisect_left。我们调用bisect_right的方式和调用bisect_left一样：提供一个排序好的列表和一个值x。不同之处在于，bisect_right返回的是第一个大于x的值的索引，而不是大于或等于x的索引。

让我们比较一下bisect_left和bisect_right。对于一个在列表中的值，bisect_right返回的索引大于bisect_left返回的索引：

>>> bisect_left([10, 50, 80, 80, 100], 10)

0

>>> bisect_right([10, 50, 80, 80, 100], 10)

1

>>> bisect_left([10, 50, 80, 80, 100], 80)

2

>>> bisect_right([10, 50, 80, 80, 100], 80)

4

对于不在列表中的值，`bisect_left` 和 `bisect_right` 返回相同的索引：

>>> bisect_left([10, 50, 80, 80, 100], 15)

1

>>> bisect_right([10, 50, 80, 80, 100], 15)

1

>>> bisect_left([10, 50, 80, 80, 100], 81)

4

>>> bisect_right([10, 50, 80, 80, 100], 81)

4

>>> bisect_left([10, 50, 80, 80, 100], 986)

5

>>> bisect_right([10, 50, 80, 80, 100], 986)

5

让我们在本章前面“排序”部分使用 `bisect_right` 来操作我们七个位置的列表。我们将找到第一个大于 21 的位置的索引：

>>> positions = [1, 6, 11, 14, 16, 18, 23]

>>> bisect_right(positions, 21)

6

就这样：这就是我们可以用来替换 [列表 9-6](ch09.xhtml#ch09ex06) 中第二个 while 循环的方法。

二分查找的惊人速度，用这些小例子很难体现出来。是时候实际操作一下了。我们将搜索一百万次，找到一个长度为 1000000 的列表中最右边的值。运行这段代码时别移开眼睛，你可能会错过它。

>>> lst = list(range(1, 1000001))

>>> for i in range(1000000):

...     where = bisect_left(lst, 1000000)

...

在我的计算机上，这大约需要一秒钟。你可能会想，如果将二分查找替换为调用列表的 `index` 方法会怎么样。如果你尝试，代码会运行几个小时才完成。因为 `index` 方法像 `in` 运算符一样，进行的是线性查找。（关于这一点，请参见 [第 8 章](ch08.xhtml#ch08) 中的“查找列表的效率”）它无法保证列表已经排序，因此无法执行快速的二分查找。它必须逐个比较每个值，才能找到我们要搜索的值。如果你有一个排序好的列表，二分查找无敌。

### 解决问题

我们已经准备好使用二分查找来解决“牛仔棒球”问题了。见 [列表 9-7](ch09.xhtml#ch09ex07) 了解代码。

❶ from bisect import bisect_left, bisect_right

input_file = open('baseball.in', 'r')

output_file = open('baseball.out', 'w')

n = int(input_file.readline())

positions = []

for i in range(n):

positions.append(int(input_file.readline()))

positions.sort()

total = 0

for i in range(n):

for j in range(i + 1, n):

first_two_diff = positions[j] - positions[i]

low = positions[j] + first_two_diff

high = positions[j] + first_two_diff * 2

❷ left = bisect_left(positions, low)

❸ right = bisect_right(positions, high)

total = total + right - left

output_file.write(str(total) + '\n')

input_file.close()

output_file.close()

*列表 9-7：使用二分查找*

首先，我们从 bisect 模块导入 `bisect_left` 和 `bisect_right` 函数，以便可以调用它们 ❶。与 [列表 9-6](ch09.xhtml#ch09ex06) 相比的唯一不同之处是，现在我们使用 `bisect_left` ❷ 和 `bisect_right` ❸ 代替了 while 循环。

如果你现在将我们的代码提交给评测系统，应该能在时间限制内通过所有测试用例。

我们在这一部分遵循的路径典型地体现了解决难题所需要的过程。我们可能从一个正确但效率过低的完整搜索解决方案开始，这种方案无法满足裁判的时间限制。然后，我们进行改进，逐步摆脱完整搜索，朝着更加精细的解决方案迈进。

**概念检查**

假设我们从[清单 9-7](ch09.xhtml#ch09ex07)开始，并将 bisect_left 替换为 bisect_right。也就是说，我们将这一行：

right = bisect_right(positions, high)

然后我们将其修改为以下内容：

right = bisect_left(positions, high)

程序是否仍然产生正确的答案？

A. 它总是产生正确答案，就像之前一样。

B. 它有时能产生正确答案，取决于测试用例。

C. 它从未产生正确答案。

答案：B。有些测试用例修改后的代码确实能产生正确答案。以下是一个例子：

3

2

4

9

正确答案是 0，这也是我们的程序所产生的结果。

不过要小心，因为也有其他测试用例，修改后的代码会产生错误答案。这里有一个例子：

3

2

4

8

正确答案是 1，但我们的程序产生了 0。当 i 为 0 且 j 为 1 时，程序应当将 left 设置为 2，将 right 设置为 3。不幸的是，使用 bisect_left 会导致 right 被设置为 2，因为索引 2 位置是大于或等于 8 的最左位置。

根据这个反例，你可能会惊讶地发现，*确实*有一种方法可以使用 bisect_left 替代 bisect_right。为了做到这一点，我们需要修改 bisect_left 调用中搜索的内容。如果你感兴趣，可以试试看！

### 总结

在本章中，我们学习了完整搜索算法，这是一种通过搜索所有选项来找到最佳方案的算法。为了确定我们应该解雇哪个救生员，我们尝试解雇每个救生员并选择最佳的一个。为了确定修复滑雪山丘的最小成本，我们尝试所有有效的范围并选择最好的一个。为了确定相关的牛三元组数量，我们检查每个三元组，并将符合要求的三元组添加到结果中。

有时，完整搜索算法本身就足够高效。我们用简单的完整搜索代码解决了“救生员”和“滑雪山丘”问题。然而，在其他情况下，我们需要提高完整搜索算法的效率。我们在解决“牛棒球”问题时就是这样，通过用更快速的二分查找替代完整搜索的 while 循环来提高效率。

程序员和计算机科学家如何讨论算法的效率？你如何知道一个算法是否足够高效？你能避免实现那些太慢的算法吗？[第10章](ch10.xhtml#ch10)将为你揭晓答案。

### 章节练习

这里有一些练习供你尝试。对于每一个，使用完整搜索。如果你的解决方案效率不够高，想想如何在保持正确答案的前提下提高效率。

对于每个练习，请仔细检查问题的来源判定器：有些问题来自DMOJ判定器，有些来自USACO判定器。

1.  USACO 2019年1月铜奖竞赛问题《壳游戏》

1.  USACO 2016年美国公开赛铜奖竞赛问题《钻石收藏家》

1.  DMOJ问题coci20c1p1，《Patkice》

1.  DMOJ问题ccc09j2，《老渔洞》

1.  DMOJ问题ecoo16r1p2，《Spindie》

1.  DMOJ问题cco96p2，《SafeBreaker》

1.  USACO 2019年12月铜奖竞赛问题《我在哪里》

1.  USACO 2016年1月铜奖竞赛问题《愤怒的奶牛》

1.  USACO 2016年12月银奖竞赛问题《数干草堆》

1.  DMOJ问题crci06p3，《萤火虫》

### 注释

《救生员》最初来自USACO 2018年1月铜奖竞赛，《滑雪山丘》最初来自USACO 2014年1月铜奖竞赛，《奶牛棒球》最初来自USACO 2013年12月铜奖竞赛。

除了完全搜索算法，还有其他类型的算法，如*贪心算法*和*动态规划算法*。如果一个问题不能通过完全搜索解决，那么值得思考它是否可以通过这些其他类型的算法解决。

如果你有兴趣通过Python学习更多算法方面的内容，我推荐Magnus Lie Hetland的《Python算法》（第二版，Apress，2014）。

我还写了一本关于算法设计的书：《算法思维：基于问题的入门》（No Starch Press，2021）。它采用了与本书相同的基于问题的格式，因此，它的风格和节奏对你来说应该很熟悉。然而，它使用的是C编程语言，而不是Python编程语言，所以为了最大化利用这本书，你可能需要提前学习一些C语言。

在本章中，我们调用了预先存在的Python函数来执行二分查找。如果我们愿意，我们也可以编写自己的二分查找代码，而不依赖于这些函数。将列表一分为二，直到找到我们想要的值，这个思路很直观，但实现这段代码却出奇的复杂。同样令人惊讶的是，可以通过二分查找的变体来解决广泛的问题。我之前提到的书《算法思维》中，包含了关于二分查找及其应用的整整一章内容。
