## 第九章：使用完全搜索设计算法

![image](img/common.jpg)

*算法*是解决问题的一系列步骤。本书中的每个问题我们都是通过编写 Python 代码形式的算法来解决的。在本章中，我们将专注于算法设计。当面对一个新问题时，有时很难知道该做什么来解决它。我们应该编写什么样的算法呢？幸运的是，我们不必每次都从头开始。计算机科学家和程序员已经确定了几种通用的算法类型，至少有一种可能能够解决我们的问题。

一种算法被称为*完全搜索*算法；它涉及尝试所有候选解并选择最优解。例如，如果问题要求我们找到最大值，我们就尝试所有解并选择最大的；如果问题要求我们找到最小值，我们就尝试所有解并选择最小的。完全搜索算法也被称为*暴力算法*，但我将避免使用这个术语。确实，计算机正在全力处理，逐一检查每个解，但作为算法设计师，我们所做的并没有暴力的成分。

我们使用了完全搜索算法来解决第五章中的“村庄邻里”问题。我们的任务是找到最小的邻里大小，我们通过查看每个邻里并记住最小的那个来实现这一目标。在本章中，我们将使用完全搜索算法来解决其他问题。我们将看到，确定具体要搜索什么，可能需要相当的巧妙构思。

我们将通过完全搜索来解决两个问题：确定解雇哪个救生员和识别满足滑雪训练营要求的最低成本。接着我们将看到一个第三个问题，计算满足给定观察条件的奶牛三元组，这个问题要求我们更进一步。

### 问题#21：救生员

在这个问题中，我们需要确定解雇哪个救生员，以使我们能获得最大覆盖时间的游泳池。我们将分别尝试解雇每个救生员并观察结果——这就是一个完全搜索算法！

这是 USACO 2018 年 1 月铜奖比赛中的问题：救生员。

#### 挑战

农夫约翰为他的奶牛购买了一个游泳池。该游泳池的开放时间为从时间 0 到时间 1000。

农夫约翰雇佣了*n*个救生员来监控游泳池。每个救生员在一个给定的时间段内监控池塘。例如，一个救生员可能从时间 2 开始，到时间 7 结束。我将把这个时间段表示为 2-7。一个时间段所覆盖的时间单位数是结束时间减去开始时间。例如，时间段为 2-7 的救生员覆盖了 7-2=5 个时间单位。那些时间单位分别是从时间 2 到 3，3 到 4，4 到 5，5 到 6，以及 6 到 7。

不幸的是，农夫约翰只有足够的钱支付*n* – 1 个救生员的薪水，而不是*n*个救生员，因此他必须解雇一个救生员。

确定在解雇一名救生员后，仍然可以覆盖的最大时间单位数。

#### 输入

从名为 *lifeguards.in* 的文件中读取输入。

输入由以下几行组成：

+   一行包含 *n*，表示被雇佣的救生员数量。*n* 的范围在 1 到 100 之间。

+   *n* 行，每行一个救生员。每行给出救生员的开始时间、一个空格和结束时间。开始和结束时间都是介于 0 到 1000 之间的整数，且各不相同。

#### 输出

将输出写入名为 *lifeguards.out* 的文件中。

输出 *n* – 1 名救生员能够覆盖的最大时间单位数。

每个测试用例的解答时间限制为四秒。

### 探索一个测试用例

让我们探索一个测试用例，帮助说明为什么完整搜索算法对于这个问题是合理的。以下是测试用例：

```py
4

5 8

10 15

17 25

9 20
```

你可以尝试使用的一个简单规则是解雇时间间隔最短的救生员。这在直觉上有些道理，因为似乎那个救生员对覆盖泳池的贡献最小。

这个规则给出的算法正确吗？让我们来看看。它告诉我们解雇第 5–8 名救生员，因为那名救生员的时间间隔最短。这样剩下的三个救生员的时间间隔是 10–15、17–25 和 9–20。这三个剩余的救生员恰好覆盖了 9–25 的区间，包含 25 – 9 = 16 个时间单位。那么 16 是正确答案吗？

不幸的是，不是的。事实上，我们应该解雇的是 10–15 名救生员。如果我们这么做，那么剩下的三个救生员的时间区间将是 5–8、17–25 和 9–20。这三个剩余的救生员覆盖了 5–8 和 9–25 的区间。（小心：它们不覆盖从 8 到 9 这一单位时间。）这两个区间分别覆盖 8 – 5 = 3 个时间单位，和 25 – 9 = 16 个时间单位，总共是 19 个时间单位。

正确答案是 19，而不是 16。解雇时间间隔最短的救生员并没有奏效。

设计一个始终有效的简单规则来解决这个问题并不容易。不过我们不需要担心：通过完整搜索算法，我们可以完全绕过这一要求。

下面是我们的完整搜索算法如何解决测试用例的过程：

1.  首先，它将忽略第一个救生员，确定其余三个救生员所覆盖的时间单位数。它将得到一个 16 的答案，并将其记住为需要超越的分数。

1.  接下来，它将忽略第二个救生员，确定其余三个救生员所覆盖的时间单位数。它将得到一个 19 的答案。由于 19 大于 16，它会将 19 记住为超越的分数。

1.  接下来，它将忽略第三个救生员，确定其余三个救生员所覆盖的时间单位数。它将得到一个 14 的答案，超越的分数依然是 19。

1.  最后，它将忽略第四个救生员，并确定其余三个救生员所覆盖的时间单位数量。它将得到 16 的答案。要打破的分数仍然是 19。

在考虑了解雇每个救生员的后果之后，算法得出结论，19 是正确答案。因为我们尝试了所有的选项，所以没有比这更好的答案了！我们进行了完整的解决方案搜索。

### 解决问题

为了使用完整搜索，通常有助于首先编写一个函数，解决某个特定候选解决方案的问题。然后，我们可以多次调用该函数，每次使用一个候选解决方案。

#### 解雇一个救生员

让我们编写一个函数来确定解雇某个特定救生员时所覆盖的时间单位数。列表 9-1 展示了代码。

```py
def num_covered(intervals, fired):

    """

    intervals is a list of lifeguard intervals;

    each interval is a [start, end] list.

    fired is the index of the lifeguard to fire.

    Return the number of time units covered by all lifeguards

    except the one fired.

    """

 ❶ covered = set()

    for i in range(len(intervals)):

        if i != fired:

            interval = intervals[i]

         ❷ for j in range(interval[0], interval[1]):

             ❸ covered.add(j)

    return len(covered)
```

*列表 9-1：解雇某个特定救生员时的解决方案*

第一个参数是救生员时间间隔的列表；第二个参数是被解雇的救生员的索引。将代码输入 Python shell。以下是两个函数调用的示例：

```py
>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 0)

16

 >>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 1)

19
```

这些调用确认，如果我们解雇救生员 0，我们可以覆盖 16 个时间单位；如果我们解雇救生员 1，我们可以覆盖 19 个时间单位。

现在，让我们理解这个函数是如何操作的。我们首先创建一个集合，用来存储覆盖的时间单位❶。每当有时间单位被覆盖时，代码会将该时间单位的起始时间添加到集合中。例如，如果从 0 到 1 的时间单位被覆盖，代码会将`0`添加到集合中；如果从 4 到 5 的时间单位被覆盖，它将添加`4`到集合中。

我们遍历救生员时间间隔。如果某个救生员没有被解雇，那么我们会遍历该救生员的时间间隔❷，考虑每一个被覆盖的时间单位。我们将这些时间单位添加到集合中❸，如承诺的那样。回想一下，集合不会保留重复的值；如果我们尝试多次添加相同的时间单位，也不用担心。我们已经遍历了所有没有被解雇的救生员，并将所有覆盖的时间单位添加到了集合中。因此，我们只需返回集合中的值的数量。

#### 主程序

我们程序的主要部分在列表 9-2 中。它使用`num_covered`函数来确定分别解雇每个救生员时所覆盖的时间单位数。请确保在这段代码之前输入我们的`num_covered`函数(列表 9-1)，以便完整解决这个问题。

```py
input_file = open('lifeguards.in', 'r')

output_file = open('lifeguards.out', 'w')

n = int(input_file.readline())

intervals = []

for i in range(n):

 ❶ interval = input_file.readline().split()

    interval[0] = int(interval[0])

    interval[1] = int(interval[1])

    intervals.append(interval)

   max_covered = 0

❷ for fired in range(n):

    ❸ result = num_covered(intervals, fired)

       if result > max_covered:

          max_covered = result

   output_file.write(str(max_covered) + '\n')

   input_file.close()

   output_file.close()
```

*列表 9-2：主程序*

我们在这里处理的是文件，而不是标准输入和标准输出。

程序开始时读取救生员的数量，然后使用`for`循环读取每个救生员的时间间隔。我们从输入❶中读取每个时间间隔，将其各个组成部分转换为整数，并将其作为一个包含两个值的列表附加到我们的时间间隔列表中。

我们使用`max_covered`变量来跟踪可以覆盖的最大时间单位数。

现在，我们通过一个 `for` 循环 ❷ 分别开火每个救生员。我们调用 `num_covered` ❸ 来确定一个救生员开火后能覆盖的时间单位数。每当我们能够覆盖更多的时间单位时，就会更新 `max_covered`。

当那个循环完成时，我们将检查每个救生员的开火所能覆盖的时间单位，并记住其中的最大值。我们输出这个最大值来解决问题。

随时可以将我们的代码提交给 USACO 判定器。对于 Python 代码，判定器每个测试用例的时间限制是四秒，但我们的解决方案应该不会接近这个限制。例如，我刚刚运行了这段代码，每个测试用例的执行时间都不超过 130 毫秒。

#### 我们程序的效率

我们的代码之所以如此快速，是因为救生员的数量非常少——最多只有 100 名。如果救生员的数量很多，那么我们的代码就无法在时间限制内解决问题。如果只有几百名救生员，应该没问题。如果有 3,000 或 4,000 名救生员，我们也许还能勉强完成。再多的话，代码就太慢了。例如，如果有 5,000 名救生员，我们可能无法按时完成。我们需要设计一种新算法，可能是采用比完全搜索更快的方法。

你可能认为 5,000 名救生员是一个非常庞大的数字，既然我们的算法无法处理这么多，也没关系。但其实不然！回想一下第八章中的电子邮件地址问题。那时，我们要处理最多 100,000 个电子邮件地址。再想想同一章中的城市和州问题。那时，我们需要处理最多 200,000 个城市。相比之下，5,000 名救生员其实并不算多。

完全搜索的解决方案通常在输入量较小的情况下效果良好。然而，大规模的测试用例往往是完全搜索解决方案失效的地方。

我们的完全搜索解决方案之所以在大规模测试用例下对救生员问题不太适用，是因为它做了大量重复的工作。假设我们正在解决一个包含 5,000 名救生员的测试用例。我们会开火救生员 `0` 并调用 `num_covered` 来确定其余救生员所能覆盖的时间单位数。然后，我们开火救生员 `1` 并再次调用 `num_covered`。这次 `num_covered` 所做的事情和之前调用时差不多。毕竟，情况没有发生太大变化。唯一的不同是救生员 0 回来了，救生员 1 被开火了。其余的 4,998 名救生员和之前一样！但是 `num_covered` 并不知道这一点。它会重新计算所有救生员。每次我们开火救生员 2、3 等等时，`num_covered` 都会从头开始做所有工作，完全没有记住它之前做了什么。

请记住，尽管完全搜索算法有其用处，但它们也有局限性。对于我们想要解决的新问题，完全搜索算法是一个有用的起点，即使它最终证明效率太低。这是因为设计该算法的过程可能会加深我们对问题的理解，并激发出新的解决思路。

在接下来的部分，我们将看到另一个可以使用完全搜索的方法来解决的问题。

**概念检查**

以下版本的 `num_covered` 是否正确？

```py
def num_covered(intervals, fired):

    """

    intervals is a list of lifeguard intervals;

    each interval is a [start, end] list.

    fired is the index of the lifeguard to fire.

    Return the number of time units covered by all lifeguards

    except the one fired.

    """

    covered = set()

    intervals.pop(fired)

    for interval in intervals:

        for j in range(interval[0], interval[1]):

            covered.add(j)

    return len(covered)
```

A. 是

B. 否

答案：B. 这个函数将被解雇的救生员从救生员列表中移除。这样是不允许的，因为文档字符串中没有说明该函数会修改列表。使用这个版本的函数时，我们的程序会在多个测试用例中失败，因为救生员信息会随着时间丢失。例如，当我们测试解雇救生员 0 时，救生员 0 会从列表中被移除。之后，当我们测试解雇救生员 1 时，遗憾的是救生员 0 已经消失了！如果你想使用一个版本的函数，其中被解雇的救生员会从列表中移除，你需要操作列表的副本，而不是原始列表。

### 问题#22：滑雪山丘

有时候，问题描述会明确指出我们应该在完全搜索的解决方案中搜索什么。例如，在救生员问题中，我们被要求解雇一名救生员，所以尝试解雇每一名救生员是有意义的。而其他时候，我们需要更有创意地确定应该搜索什么内容。当你阅读下一个问题时，想一想在完全搜索的解决方案中，你会搜索什么。

这是 USACO 2014 年 1 月的铜奖比赛题目：滑雪道设计。

#### 挑战

农民约翰的农场上有 *n* 座山丘，每座山丘的高度在 0 到 100 之间。他希望将他的农场注册为滑雪训练营。

只有当最高山丘和最低山丘之间的高度差不超过 17 时，一块农场才能注册为滑雪训练营。因此，农民约翰可能需要增加一些山丘的高度并减少其他山丘的高度。他只能以整数值改变山丘的高度。

改变一座山丘的高度* x *单位的成本是 *x*²。例如，将一座山丘从高度 1 改为高度 4 的成本是(4 – 1)² = 9。

确定农民约翰需要支付的最小金额，以改变山丘的高度，从而能够将他的农场注册为滑雪训练营。

#### 输入

从名为*skidesign.in*的文件中读取输入。

输入包括以下几行：

+   包含整数 *n* 的一行，表示农场上的山丘数量。*n* 的值介于 1 和 1000 之间。

+   *n* 行，每行给出一座山丘的高度。每个高度是介于 0 和 100 之间的整数。

#### 输出

将输出写入名为*skidesign.out*的文件。

输出农民约翰需要支付的最小金额，以改变山丘的高度。

每个测试用例的时间限制为四秒。

### 探索一个测试用例

让我们看看能否将从 Lifeguards 中学到的内容应用到这个问题中。为了解决 Lifeguards 问题，我们分别试图解雇每个救生员，找出应该解雇的救生员。要解决滑雪山丘问题，也许我们能对每个山丘做类似的处理？例如，也许我们可以将每个山丘的高度作为允许高度范围的低端？

我们将使用以下测试用例进行尝试：

```py
4

23

40

16

2
```

这四个山丘中的最小高度是 2，最大高度是 40。40 和 2 之间的差是 38，大于 17。Farmer John 需要支付费用来修正这些山丘！

第一个山丘的高度是 23。如果我们将 23 作为范围的低端，那么高端就是 23 + 17 = 40。我们需要计算将所有山丘都带入范围 23–40 的成本。有两个山丘不在这个范围内，分别是高度为 16 和 2 的山丘。将它们提升到高度 23 的成本是 (23 – 16)² + (23 – 2)² = 490。490 的成本仍然是需要打破的成本。

第二个山丘的高度是 40。这个范围的高端是 40 + 17 = 57，因此我们需要将所有山丘都包含在 40–57 的范围内。其他三个山丘不在这个范围内，因此每个山丘都会增加总成本。这个总成本是 (40 – 23)² + (40 – 16)² + (40 – 2)² = 2,309。这个值大于 490，我们当前的最小成本，所以 490 仍然是要打破的成本。（记住，在这个问题中，我们的目标是*最小化* Farmer John 的成本，而在 Lifeguards 中，我们的目标是*最大化*覆盖率。）

第三个山丘的高度是 16，这给我们提供了范围 16–33。有两个山丘不在这个范围内，分别是高度为 40 和 2 的山丘。因此，这个范围的总成本是 (40 – 33)² + (16 – 2)² = 245。新的最小成本是 245！

第四个山丘的高度是 2，这给我们提供了范围 2–19。如果你计算这个范围的成本，你应该得到 457 的成本。

我们使用这个算法得到的最小成本是 245。245 是答案吗？我们完成了吗？

不对，完全不对！结果显示，最小成本是 221。我们有两个范围可以得到这个最小成本：12–29 和 13–30。没有一个山丘的高度是 12。同样，也没有一个山丘的高度是 13。因此，我们不能将山丘的高度作为范围的可能低端。

想想看，一个正确的完整搜索算法应该是什么样子，能够保证不会漏掉任何范围。

这里有一个计划，保证能帮我们得到正确的答案。我们从计算范围 0–17 的成本开始。然后我们计算范围 1–18 的成本。接着是 2–19。然后是 3–20，再是 4–21，依此类推。我们逐个测试每个可能的范围，并记住我们得到的最小成本。我们测试的范围与山丘的高度无关。由于我们测试了所有可能的范围，因此不可能错过找到最优解。

我们应该测试哪些范围？要测试多高的范围？我们应该测试范围 50–67 吗？是的。那范围 71–88 呢？再次是的。那 115–132 呢？不！不是那个。

我们要检查的最后一个区间是 100–117。原因在于问题描述中有一个保证，即任何山丘的高度最多为 100。

假设我们算出了区间 101–118 的成本。即使不知道山丘的高度，我们也能确定这个区间内没有任何山丘。毕竟山丘的最大高度是 100，而我们的区间从 101 开始。现在将我们的区间从 101–118 滑动到 100–117。这个 100–117 区间的成本比 101–118 低！这是因为 100 比 101 离山丘更近。例如，考虑一座高度为 80 的山丘。将这座山丘的高度提高到 101，需要花费 21² = 441，但将其提高到 100 只需要 20² = 400。由此可见，101–118 不能是最优的区间，尝试它是没有意义的。

类似的逻辑也解释了为什么尝试更高的区间，比如 102–119、103–120 等，毫无意义。我们总是可以将这些区间滑动下来，从而减少其成本。

总结来说，我们将测试正好 101 个区间：0–17、1–18、2–19，以此类推，一直到 100–117。我们会记住最优区间的成本。让我们开始吧！

### 解决问题

我们将分两步来解决问题，就像解决 Lifeguards 问题时那样。我们首先写一个函数来计算单个区间的成本。然后编写一个主程序，为每个区间调用该函数一次。

#### 计算一个区间的成本

清单 9-3 给出了计算给定区间成本的函数代码。

```py
MAX_DIFFERENCE = 17

MAX_HEIGHT = 100

def cost_for_range(heights, low, high):

    """

    heights is a list of hill heights.

    low is an integer giving the low end of the range.

    high is an integer giving the high end of a range.

    Return the cost of changing all heights of hills to be

    between low and high.

    """

    cost = 0

 ❶ for height in heights:

     ❷ if height < low:

         ❸ cost = cost + (low - height) ** 2

     ❹ elif height > high:

         ❺ cost = cost + (height - high) ** 2

    return cost
```

*清单 9-3：求解某一特定区间*

我已经包含了我们稍后会用到的两个常量。`MAX_DIFFERENCE` 常量记录了最高山丘和最低山丘之间允许的最大高度差。`MAX_HEIGHT` 常量记录了山丘的最大高度。

现在让我们来看看 `cost_for_range` 函数。它接受一个山丘高度的列表和一个由低端和高端指定的目标区间。它返回将山丘高度调整到目标区间所需的成本。我建议你在 Python 解释器中输入这个函数的代码，以便在继续之前进行测试。

该函数遍历每个山丘的高度 ❶，计算将该山丘调整到目标区间所需的成本。我们需要考虑两种情况。首先，当前山丘的高度可能低于 `low`，即超出了下限 ❷。表达式 `low - height` 给出我们需要为这座山丘增加的高度，我们将这个结果平方来得到成本 ❸。其次，当前山丘的高度可能高于 `high`，即超出了上限 ❹。表达式 `height - high` 给出我们需要为这座山丘减少的高度，我们将这个结果平方来得到成本 ❺。请注意，如果山丘的高度已经在低高区间内，我们不会做任何操作。遍历完所有山丘后，我们返回总成本。

#### 主程序

我们程序的主要部分在 清单 9-4 中。它使用 `cost_for_range` 函数来确定每个范围的成本。确保在这段代码之前输入我们的 `cost_for_range` 函数（清单 9-3），以便完整解决问题。

```py
   input_file = open('skidesign.in', 'r')

   output_file = open('skidesign.out', 'w')

   n = int(input_file.readline())

   heights = []

   for i in range(n):

       heights.append(int(input_file.readline()))

❶ min_cost = cost_for_range(heights, 0, MAX_DIFFERENCE)

❷ for low in range(1, MAX_HEIGHT + 1):

       result = cost_for_range(heights, low, low + MAX_DIFFERENCE)

       if result < min_cost:

           min_cost = result

   output_file.write(str(min_cost) + '\n')

   input_file.close()

   output_file.close()
```

*清单 9-4：主程序*

我们首先读取山丘的数量，然后将每个高度读入 `heights` 列表中。

我们使用 `min_cost` 变量来记录迄今为止发现的最小成本。我们将 `min_cost` 设置为范围 0–17 的成本 ❶。然后，在一个范围 `for` 循环 ❷ 中，我们尝试其他范围的成本，每当找到更小的成本时，就更新 `min_cost`。当这个循环结束时，我们输出我们找到的最小成本。

现在是时候将我们的代码提交给评审了。我们的完全搜索解决方案应当能够在时间限制内良好地解决问题。

在下一个问题中，我们将看到一个示例，其中直接的完全搜索解决方案效率不足。

**概念检查**

这是对 清单 9-4 中代码的提议更改。请看这一行：

```py
for low in range(1, MAX_HEIGHT + 1):
```

并将其更改为以下内容：

```py
for low in range(1, MAX_HEIGHT - MAX_DIFFERENCE + 1):
```

代码仍然正确吗？

A. 是

B. 否

答案：A。代码现在检查的最后一个范围是 83–100，所以我们必须证明我们不再检查的范围——84–101、85–102 等——并不重要。

考虑范围 84–101。如果我们可以证明范围 83–100 至少与 84–101 一样好，那么我们就没有理由检查范围 84–101。

范围 84–101 包括高度 101。但是，这毫无意义：最高的山丘高度是 100，所以 101 的高度就不需要存在了。我们可以去掉 101，而不会使范围变差。如果去掉它，剩下的范围是 84–100。哈——但 100–84 只有 16，而我们允许的差值是 17。所以我们可以将范围从左边扩展一个单位，得到 83–100 的范围。显然，这样扩大范围不会让范围变差，甚至可能使范围更好，因为它现在距离任何高度为 83 或更低的山丘更近了。

我们从范围 84–101 开始，并证明范围 83–100 至少与之同样有效。我们可以对范围 85–102、86–103 等做相同的推理。没有必要去考虑比 83–100 更大的范围！

在继续之前，你可以尝试解决“章节练习”中的第 1 和第 2 题，见 第 263 页。

### 问题 #23：牛球赛

为了结束这一章，我选择了一个我们需要提升算法设计技能的题目，超越完全搜索的范畴。当你阅读这个问题时，请注意输入并不多。这通常意味着完全搜索算法的有效性。但这一次并非如此，因为这种算法需要在输入中进行大量搜索。困难的关键在于有太多嵌套循环。为什么嵌套循环在这里会给我们带来麻烦？我们能做些什么呢？继续阅读！

这是 USACO 2013 年 12 月铜级竞赛题目“牛球赛”。

#### 挑战

农场主约翰有 *n* 只牛。它们排成一排，每只牛处在一个独特的位置。它们正在玩传球棒球的游戏。

农场主约翰正在观察这些牛的举动。他观察到牛 *x* 将球投给其右侧的牛 *y*，然后牛 *y* 又将球投给其右侧的牛 *z*。他还知道，第二次投球的距离至少是第一次投球的距离，并且最多是第一次投球距离的两倍。（例如，如果第一次投球的距离是 5，那么第二次投球的距离至少是 5，最多是 10。）

确定满足农场主约翰观察条件的 (*x*, *y*, *z*) 牛三元组的数量。

#### 输入

从名为 *baseball.in* 的文件中读取输入。

输入包含以下几行：

+   一行包含 *n*，即牛的数量。*n* 的值在 3 到 1,000 之间。

+   *n* 行，每行给出一只牛的位置。所有位置都是唯一的，且每个位置都在 1 到 100,000,000 之间。

#### 输出

将输出写入名为 *baseball.out* 的文件。

输出满足农场主约翰观察条件的牛三元组的数量。

每个测试用例的时间限制为四秒。

### 使用三重嵌套循环

我们可以使用三重嵌套循环来考虑所有可能的三元组。我们先来看一下代码，然后再讨论其效率。

#### 代码

在 第三章中的“嵌套”一节里，我们学到了如何使用两重嵌套循环遍历所有的值对。这样做的代码如下所示：

```py
>>> lst = [1, 9]

>>> for num1 in lst:

...     for num2 in lst:

...         print(num1, num2)

...

1 1

1 9

9 1

9 9
```

我们可以通过使用三重嵌套循环，类似于这样遍历所有的三元组：

```py
>>> for num1 in lst:

...     for num2 in lst:

...         for num3 in lst:

...             print(num1, num2, num3)

...

1 1 1

1 1 9

1 9 1

1 9 9

9 1 1

9 1 9

9 9 1

9 9 9
```

使用三重嵌套循环的方式为我们解决牛棒球问题提供了一个起点。对于每个三元组，我们可以检查它是否符合农场主约翰的观察条件。具体代码见 列表 9-5。

```py
   input_file = open('baseball.in', 'r')

   output_file = open('baseball.out', 'w')

   n = int(input_file.readline())

   positions = []

   for i in range(n):

    ❶ positions.append(int(input_file.readline()))

   total = 0

❷ for position1 in positions:

    ❸ for position2 in positions:

           first_two_diff = position2 - position1

        ❹ if first_two_diff > 0:

               low = position2 + first_two_diff

               high = position2 + first_two_diff * 2

            ❺ for position3 in positions:

                   if position3 >= low and position3 <= high:

                       total = total + 1

   output_file.write(str(total) + '\n')

   input_file.close()

   output_file.close()
```

*列表 9-5：使用三重*for*循环*

我们将所有牛的位置读取到 `positions` 列表❶中。然后，我们用一个 `for` 循环❷遍历列表中的所有位置。对于这些位置中的每一个，我们用一个嵌套的 `for` 循环❸遍历列表中的所有位置。此时，`position1` 和 `position2` 分别代表列表中的两个位置。我们需要一个第三个嵌套循环，没错，但还不急。我们首先需要计算 `position1` 和 `position2` 之间的差值，因为这决定了我们要查找的 `position3` 的范围。

根据题目描述，我们要求 `position2` 在 `position1` 的右侧。如果满足这一条件❹，我们就计算 `position3` 的范围，分别用 `low` 和 `high` 来存储。例如，如果 `position1` 是 1，`position2` 是 6，那么我们会计算 6 + 5 = 11 作为 `low`，并计算 6 + 5 * 2 = 16 作为 `high`。接着，我们用第三个嵌套的 `for` 循环❺遍历列表，寻找位于 `low` 和 `high` 之间的位置。对于每一个符合条件的 `position3`，我们就将总数加 1。

跟随三个嵌套的循环，我们计算出了三元组的总数。最后，我们将这个数字输出到输出文件。

让我们在一个小的测试用例上运行程序，确保没有出现奇怪的情况。测试用例如下：

```py
7

16

14

23

18

1

6

11
```

这个测试用例的正确答案是 11。满足条件的 11 个三元组如下：

+   14, 16, 18

+   14, 18, 23

+   1, 6, 16

+   1, 6, 14

+   1, 6, 11

+   1, 11, 23

+   6, 14, 23

+   6, 11, 16

+   6, 11, 18

+   11, 16, 23

+   11, 14, 18

好消息：我们的程序对于这个测试用例输出了`11`！它之所以能够输出这个结果，是因为程序最终找到了每个满足条件的三元组。例如，在某个时刻，`position1`会是`14`，`position2`会是`16`，`position3`会是`18`。这个三元组满足距离要求，因此程序会将其计入总数。不要担心，当`position1`是`18`，`position2`是`16`，`position3`是`14`时会发生什么。我们肯定不希望将那个三元组计入，因为这些投掷并没有朝着正确的方向进行。不过没关系：`if`语句❹会防止这些三元组被处理。

我们的程序是正确的。但正如你在提交给判题系统后看到的，它的效率不够高。对于这个问题以及许多竞争编程问题，前几个测试用例都比较小——只有几只牛、几位救生员或几座滑雪山。我们的程序应该能够在规定时间内解决这些问题。剩下的测试用例则测试我们的程序是否能处理接近最大输入量的情况。我们的程序无法在规定时间内解决这些问题，速度太慢了。

#### 我们程序的效率

为了理解为什么我们的程序如此缓慢，我们可以考虑一下它必须检查的三元组数量。回想一下我们刚才研究过的测试用例，那里有 7 只牛。我们的程序将检查多少个三元组呢？对于第一只牛，有七个选择：16、14、23 等等。第二只牛也有七个选择，第三只牛也有七个选择。将这些数相乘，我们可以得出程序检查了 7 * 7 * 7 = 343 个三元组。

如果我们有 8 只牛，而不是 7 只呢？那么程序将检查 8 * 8 * 8 = 512 个三元组。

我们可以给出一个表达式，来表示适用于任意数量牛的三元组数。假设牛的数量是*n*；它可以是 7、8、50、1000 等等，具体取决于测试用例。然后我们可以说，程序检查的三元组数量是*n* * *n* * *n*，即*n*³。

我们可以替换任意数量的牛为*n*来确定我们检查的三元组数量。例如，我们可以验证 7 只牛的三元组数量是 7³ = 343，而 8 只牛的三元组数量是 8³ = 512。这些数字——343 和 512——是微不足道的。任何计算机检查这些三元组都不会超过几毫秒。作为保守估计，你可以认为一个 Python 程序每秒钟大约能够检查或处理 500 万项任务。这个问题的时间限制是每个测试用例 4 秒，因此我们大约能检查 2000 万个三元组。

让我们用更大的数字代替*n*，看看会发生什么。对于 50 头牛，我们有 50³ = 125,000 个三元组。没问题：检查 125,000 个东西对今天的计算机来说不算什么。对于 100 头牛，我们有 100³ = 1,000,000 个三元组。同样，没问题。我们可以在不到一秒钟的时间内检查一百万个东西。对于 200 头牛，我们有 200³ = 8,000,000 个三元组。我们在四秒钟内还行，但我希望你已经开始有些担心了。三元组的数量增长得相当快，而我们只考虑了 200 头牛。记住，我们需要支持最多 1,000 头牛。

对于 400 头牛，我们有 400³ = 64,000,000 个三元组。这个数量太多，四秒钟内处理不过来。更糟的是，让我们试试 1,000 头牛，这是我们可能遇到的最大值。对于 1,000 头牛，我们有 1,000³ = 1,000,000,000 个三元组。那就是十亿。不行。我们永远不可能在四秒钟内检查这么多三元组。我们需要让程序更加高效。

### 先排序

排序在这里很有帮助。让我们看看如何使用排序，并讨论我们最终解法的效率。

#### 代码

我们的牛的位置可以按任何顺序排列——从问题描述中并没有保证它们是排序的。不幸的是，这导致我们的程序会检查许多根本不可能满足要求的三元组。例如，检查三元组 18、16、14 是没有意义的，因为这些数字不是按递增顺序排列的。如果我们一开始就对牛的位置进行排序，那么就可以避免检查这些不按顺序的三元组。

排序还有另一个好处。假设`position1`表示某个牛的位置，`position2`表示另一个牛的位置。对于这对位置，我们知道我们关心的`position3`的最小值和最大值。我们可以利用位置已排序的事实来减少我们需要检查的值的数量。在继续之前，想一想为什么会这样。我们如何利用位置已经排序这一事实，来查看更少的值呢？

准备好后，查看 Listing 9-6，其中有使用排序的代码。

```py
   input_file = open('baseball.in', 'r')

   output_file = open('baseball.out', 'w')

   n = int(input_file.readline())

   positions = []

   for i in range(n):

       positions.append(int(input_file.readline()))

❶ positions.sort()

   total = 0

❷ for i in range(n):

    ❸ for j in range(i + 1, n):

           first_two_diff = positions[j] - positions[i]

           low = positions[j] + first_two_diff

           high = positions[j] + first_two_diff * 2

           left = j + 1

        ❹ while left < n and positions[left] < low:

               left = left + 1

           right = left

        ❺ while right < n and positions[right] <= high:

               right = right + 1

        ❻ total = total + right - left

   output_file.write(str(total) + '\n')

   input_file.close()

   output_file.close()
```

*Listing 9-6: 使用排序*

在我们开始查找三元组之前，先对位置进行排序❶。

我们的第一个循环使用循环变量`i` ❷遍历所有位置。这次是一个范围`for`循环，而不是一个普通的`for`循环，这样我们就能跟踪当前的索引。这样做很有用，因为我们可以使用`i + 1`的值作为第二个循环的起始索引❸。这样，第二个循环就不会浪费时间查看第一个位置左边的那些位置。

接下来，我们计算第三个位置的值范围的低端和高端。

我们可以通过找到适合的第三个位置的左右边界来增加`total`，而不是每次找到合适的第三个位置时就将`total`加 1。我们之所以能够这样做，是因为位置列表已经排序。我们通过`while`循环找到每个边界。第一个`while`循环找到左边界❹。它会一直执行，直到位置大于等于`low`。当它完成时，`left`将是第一个大于或等于`low`的索引。第二个`while`循环找到右边界❺。它会一直执行，直到位置小于等于`high`。当它完成时，`right`将是第一个大于`high`的索引。从`left`到`right`之间的每个位置（不包括`right`）都可以作为包含索引`i`和`j`的三元组中的第三个位置。我们通过`right - left`将这些位置加到`total`中❻。

本程序中的两个`while`循环相当复杂。让我们通过一个例子来确保我们完全理解它们的作用。我们将使用以下位置列表；这些位置与我们在前一节中使用的相同，只是经过了排序：

```py
[1, 6, 11, 14, 16, 18, 23]
```

假设`i`为`1`，`j`为`2`，那么预期三元组中的两个位置分别是`6`和`11`。因此，第三个位置应该是大于或等于`16`且小于或等于`21`的索引。第一个`while`循环将`left`设置为`4`，即第一个大于或等于`16`的位置的索引。第二个`while`循环将`right`设置为`6`，即第一个大于`21`的位置的索引。从`right`中减去`left`，得到 6 – 4 = 2，这意味着有两个三元组涉及到位置`6`和`11`。在继续之前，我建议你验证一下这些`while`循环在“特殊”情况下是否能够正常工作，比如没有合适的第三个位置，或者只有一个合适的第三个位置时。

在这一节中我们取得了显著进展。我们的代码无疑比我们在清单 9-5 中的代码更高效。然而，它仍然不够高效。如果你将其提交给评测系统，你会发现它并没有比上次更进一步。它仍然会在大多数测试用例上超时。

#### 我们程序的效率

我们程序中的问题是找到第三个位置仍然需要很长时间。这些`while`循环仍然存在一些低效之处。我可以通过一个新的位置列表来演示这一点，即位置从 1 到 32 的列表。

```py
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,

 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
```

让我们关注当`i`为`0`，`j`为`7`时；这分别是位置`1`和位置`8`。对于第三个位置，我们需要寻找大于或等于 15 且小于或等于 22 的位置。为了找到`15`，第一个`while`循环从右向左扫描，一次一个位置。它依次扫描`9`，然后是`10`，然后是`11`，然后是`12`，然后是`13`，然后是`14`，最后找到`15`。然后第二个`while`循环接管，进行类似的大量扫描，一次一个位置，一直扫描到找到`23`。

每个`while`循环实现了我们所说的*线性搜索*。线性搜索是一种逐个查找集合中每个值的技术。这是一项繁重的工作，得逐一扫描所有这些值！而且对于不同的`i`和`j`值，工作量也差不多。例如，试着追踪一下当`i`为`0`，`j`为`8`，或者当`i`为`1`，`j`为`11`时会发生什么。

我们如何改进这个方法呢？如何避免扫描一大段列表，寻找合适的`left`和`right`索引？

假设我给你一本有一千个排序整数的书，每行一个整数。我让你找出第一个大于或等于 300 的整数。你会逐个查看这些数字吗？会先看`1`，然后是`3`，然后是`4`，然后是`7`吗？路还很长——接下来你会看`8`，然后是`12`，然后是`17`？大概不会吧！如果你直接翻到书的中间会快得多。也许你在中间找到了数字`450`。既然`450`大于`300`，你就知道数字在书的前半部分。它不可能在后半部分，因为那里的数字比`450`还要大。你通过检查一个数字就减少了一半的工作量！你现在可以在书的前半部分重复这个过程，从书的开头和中间翻找。你可能在那找到数字`200`。现在你知道`300`在后面的某一页，可能是在书的第二四分之一部分。你可以继续重复这个过程，直到找到`300`——而且这不会花太多时间。这个技巧——反复将问题一分为二——就叫做*二分查找*。它惊人地快速，比逐个查找的线性搜索方法要快得多。Python 有一个二分查找函数，它将为牛仔棒球项目画上圆满的句号。不过，这个函数在一个叫做*模块*的东西里；我们需要先讨论模块。

### Python 模块

一个*模块*是一个自包含的 Python 代码集合。一个模块通常包含几个我们可以调用的函数。

Python 提供了各种各样的模块，可以用来为我们的程序添加功能。有处理随机数、日期和时间、统计、电子邮件、网页、音频文件等的模块，种类繁多，甚至可以专门写一本书来讲解它们！如果 Python 中没有你需要的模块，你还可以下载额外的模块。

本节我将专注于一个模块——`random`模块。我们将使用它来了解模块的使用方法。然后，我们就能为下一节中的二分查找模块做好准备。

你是否曾经想过，人们是如何制作那些包含随机事件的计算机游戏的？也许这是一个抽卡的游戏，或者是一个掷骰子的游戏，或者是敌人随机生成的游戏。关键在于使用随机数。Python 通过其`random`模块为我们提供了随机数生成的功能。

在我们使用模块中的内容之前，我们必须*导入*它。导入整个模块的一种方法是使用`import`关键字，像这样：

```py
>>> import random
```

里面有什么？要查找，可以使用`dir(random)`：

```py
>>> dir(random)

[stuff to ignore

'betavariate', 'choice', 'choices', 'expovariate',

'gammavariate', 'gauss', 'getrandbits', 'getstate',

'lognormvariate', 'normalvariate', 'paretovariate',

'randint', 'random', 'randrange', 'sample', 'seed',

'setstate', 'shuffle', 'triangular', 'uniform',

'vonmisesvariate', 'weibullvariate']
```

`random`模块提供的一个函数是`randint`。我们传递给它一个范围的低端和高端，Python 会返回该范围内的一个随机整数（包括两个端点）。

然而，我们不能像普通函数那样直接调用它。如果尝试这样做，会出现错误：

```py
>>> randint(2, 10)

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

NameError: name 'randint' is not defined
```

我们需要告诉 Python，`randint`函数位于`random`模块中。为此，我们需要在`randint`前加上模块名和一个点，像这样：

```py
>>> random.randint(2, 10)

7

>>> random.randint(2, 10)

10

>>> random.randint(2, 10)

6
```

要获取有关`randint`函数的帮助，可以输入`help(random.randint)`：

```py
>>> help(random.randint)

Help on method randint in module random:

randint(a, b) method of random.Random instance

    Return random integer in range [a, b], including both end points.
```

`random`模块中另一个有用的函数是`choice`。我们传递给它一个序列，它会随机返回其中的一个值：

```py
>>> random.choice(['win', 'lose'])

'lose'

>>> random.choice(['win', 'lose'])

'lose'

>>> random.choice(['win', 'lose'])

'win'
```

如果我们经常使用模块中的少量函数，输入模块名和点每次都显得很麻烦。还有另一种导入这些函数的方法，可以让我们像调用任何其他非模块函数一样调用它们。以下是我们只导入`randint`函数的方式：

```py
>>> from random import randint
```

现在我们可以直接调用`randint`，而不需要加上`random.`：

```py
>>> randint(2, 10)

10
```

如果我们需要`randint`和`choice`，我们可以同时导入它们：

```py
>>> from random import randint, choice
```

本书中我们不会这么做，但我们可以创建自己的模块，包含我们喜欢的任何函数。例如，如果我们设计了一些与玩游戏相关的 Python 函数，我们可以将它们都放在一个名为*game_functions.py*的文件中。然后，我们可以使用`import game_functions`导入该模块，并访问其中的函数。

本书中我们编写的 Python 程序并不是为了作为模块被导入的。原因是它们在开始运行时就会读取输入，而模块不应该这样做。一个模块应该等待函数被调用之后再执行任何操作。`random`模块是一个表现良好的模块：它只有在我们请求时才开始给我们提供随机内容。

### bisect 模块

现在我们准备好进行二分查找的练习了。在示例 9-6 中，我们有两个`while`循环。它们比较慢，所以我们想要去掉它们。为此，我们将用一个二分查找函数来替换每个循环：第一个`while`循环用`bisect_left`，第二个用`bisect_right`。

这两个函数都在`bisect`模块中。让我们导入它们：

```py
>>> from bisect import bisect_left, bisect_right
```

让我们先讨论`bisect_left`。我们通过提供一个从小到大排序的列表和一个值`x`来调用它。它返回列表中第一个大于或等于`x`的左侧值的索引。

如果值在列表中，我们会得到它最左侧出现位置的索引：

```py
>>> bisect_left([10, 50, 80, 80, 100], 10)

0

>>> bisect_left([10, 50, 80, 80, 100], 80)

2
```

如果值不在列表中，我们会得到第一个大于该值的索引：

```py
>>> bisect_left([10, 50, 80, 80, 100], 15)

1

>>> bisect_left([10, 50, 80, 80, 100], 81)

4
```

如果我们查找的值大于列表中的所有值，我们将得到列表的长度：

```py
>>> bisect_left([10, 50, 80, 80, 100], 986)

5
```

让我们在本章前面“首先排序”的七个位置的列表上使用`bisect_left`。我们将找到第一个大于或等于 16 的左侧位置的索引：

```py
>>> positions = [1, 6, 11, 14, 16, 18, 23]

>>> bisect_left(positions, 16)

4
```

完美：这正是我们需要的，用来替换清单 9-6 中第一个`while`循环的内容。

为了替换第二个`while`循环，我们将使用`bisect_right`而不是`bisect_left`。我们像调用`bisect_left`一样调用`bisect_right`：传入一个排序好的列表和一个值`x`。它不会返回列表中左侧第一个大于或等于`x`的值的索引，而是返回第一个大于`x`的值的索引。

让我们比较一下`bisect_left`和`bisect_right`。对于在列表中的值，`bisect_right`返回的索引大于`bisect_left`返回的索引：

```py
>>> bisect_left([10, 50, 80, 80, 100], 10)

0

>>> bisect_right([10, 50, 80, 80, 100], 10)

1

>>> bisect_left([10, 50, 80, 80, 100], 80)

2

 >>> bisect_right([10, 50, 80, 80, 100], 80)

4
```

对于不在列表中的值，`bisect_left`和`bisect_right`返回相同的索引：

```py
>>> bisect_left([10, 50, 80, 80, 100], 15)

1

>>> bisect_right([10, 50, 80, 80, 100], 15)

1

>>> bisect_left([10, 50, 80, 80, 100], 81)

4

>>> bisect_right([10, 50, 80, 80, 100], 81)

4

>>> bisect_left([10, 50, 80, 80, 100], 986)

5

>>> bisect_right([10, 50, 80, 80, 100], 986)

5
```

让我们在本章前面“首先排序”的七个位置的列表上使用`bisect_right`。我们将找到第一个大于 21 的左侧位置的索引：

```py
>>> positions = [1, 6, 11, 14, 16, 18, 23]

>>> bisect_right(positions, 21)

6
```

就是这样：这正是我们可以用来替换清单 9-6 中第二个`while`循环的内容。

二分查找的惊人速度，通过这些小示例是难以体会的。是时候展示真正的速度了。我们将在长度为`1000000`的列表中，进行一百万次查找，寻找最右侧的值。运行这段代码时不要移开眼睛，你可能错过它。

```py
>>> lst = list(range(1, 1000001))

>>> for i in range(1000000):

...     where = bisect_left(lst, 1000000)

...
```

在我的电脑上，这大约需要一秒钟。你可能会想，如果用列表的`index`方法代替二分查找会发生什么。如果你尝试这样做，你将真的等上好几个小时才等到代码运行完成。这是因为`index`像`in`操作符一样，进行的是线性搜索（有关此更多内容，请参见第八章中的“搜索列表的效率”）。它没有保证列表是排序的，因此无法执行快速的二分查找。它必须逐个比对每个值，找到与我们要查找的值相等的项。如果你有一个排序好的列表，并且想要在其中查找值，二分查找是无法阻挡的。

### 解决问题

我们准备好使用二分查找解决牛棒球问题了。查看清单 9-7 以获取代码。

```py
❶ from bisect import bisect_left, bisect_right

   input_file = open('baseball.in', 'r')

   output_file = open('baseball.out', 'w')

   n = int(input_file.readline())

   positions = []

   for i in range(n):

       positions.append(int(input_file.readline()))

   positions.sort()

   total = 0

   for i in range(n):

       for j in range(i + 1, n):

           first_two_diff = positions[j] - positions[i]

           low = positions[j] + first_two_diff

           high = positions[j] + first_two_diff * 2

        ❷ left = bisect_left(positions, low)

        ❸ right = bisect_right(positions, high)

           total = total + right - left

   output_file.write(str(total) + '\n')

   input_file.close()

   output_file.close()
```

*清单 9-7：使用二分查找*

首先，我们从`bisect`模块中导入`bisect_left`和`bisect_right`函数，以便可以调用它们❶。与清单 9-6 相比，唯一的不同之处是我们现在使用`bisect_left`❷和`bisect_right`❸，而不再使用`while`循环。

如果你现在将我们的代码提交给评测系统，你应该能够在时间限制内通过所有测试用例。

本节中的思路弧线是解决难题时常见的思路。我们可能从一个正确但效率较低的完全搜索解决方案开始，然而，这个方案也过于慢，无法满足评测系统的时间限制。然后我们进行改进，最终抛弃完全搜索，转向更精细的方法。

**概念检查**

假设我们从清单 9-7 开始，并用`bisect_left`替代`bisect_right`。也就是说，我们修改这一行：

```py
        right = bisect_right(positions, high)
```

然后我们将其改为以下内容：

```py
        right = bisect_left(positions, high)
```

程序仍然能产生正确的答案吗？

A. 它始终产生正确的答案，就像之前一样。

B. 它有时产生正确答案，具体取决于测试用例。

C. 它从不产生正确的答案。

答案：B。有些测试用例中，修改后的代码确实会产生正确的答案。以下是一个例子：

```py
3

2

4

9
```

正确的答案是 0，这也是我们程序产生的结果。

但要小心，因为还有其他一些测试用例，修改后的代码会产生错误的答案。以下是一个反例：

```py
3

2

4

8
```

正确答案是 1，但我们程序产生了`0`。当`i`是`0`并且`j`是`1`时，程序应该将`left`设置为`2`，并将`right`设置为`3`。不幸的是，使用`bisect_left`会导致`right`被设置为`2`，因为索引 2 的位置是大于或等于`8`的最左侧位置。

看到这个反例，你可能会惊讶地发现，其实*是有*一种方法可以使用`bisect_left`而不是`bisect_right`。为了做到这一点，我们需要改变在调用`bisect_left`时要搜索的内容。如果你感兴趣，不妨试试看！

### 总结

在本章中，我们学习了完全搜索算法，这些算法通过遍历所有选项来找到最佳解。为了确定我们应该解雇的救生员，我们尝试解雇每一个救生员并选择最合适的一个。为了确定修复滑雪坡的最低成本，我们尝试所有有效的区间并选择最佳的一个。为了确定相关的牛的三元组数量，我们检查每一个三元组并添加符合要求的三元组。

有时候，完全搜索算法本身就足够高效。我们用简单的完全搜索代码解决了救生员和滑雪坡的问题。然而，有时我们需要让完全搜索算法更加高效。我们在解决牛棒球问题时就做到了这一点，通过将完全搜索的`while`循环替换为更快速的二分查找。

程序员和计算机科学家如何讨论效率？你怎么知道一个算法是否足够高效？如何避免实现那些太慢的算法？第十章 等待着你。

### 章节练习

这里有一些练习供你尝试。对于每个练习，使用完全搜索。如果你的解决方案效率不够高，思考如何在保证正确答案的前提下提高效率。

对于每个练习，务必核实问题来源的判题系统：有些是在 DMOJ 判题系统上，其他则是在 USACO 判题系统上。

1.  USACO 2019 年 1 月青铜奖竞赛问题 Shell Game

1.  USACO 2016 年美国公开赛青铜奖竞赛问题 Diamond Collector

1.  DMOJ 问题 `coci20c1p1`，Patkice

1.  DMOJ 问题 `ccc09j2`，Old Fishin’ Hole

1.  DMOJ 问题 `ecoo16r1p2`，Spindie

1.  DMOJ 问题 `cco96p2`，SafeBreaker

1.  USACO 2019 年 12 月青铜奖竞赛问题 Where Am I

1.  USACO 2016 年 1 月青铜奖竞赛问题 Angry Cows

1.  USACO 2016 年 12 月银奖竞赛问题 Counting Haybales

1.  DMOJ 问题 `crci06p3`，Firefly

### 注意事项

Lifeguards 最初来自 USACO 2018 年 1 月的青铜奖竞赛。Ski Hills 最初来自 USACO 2014 年 1 月的青铜奖竞赛。Cow Baseball 最初来自 USACO 2013 年 12 月的青铜奖竞赛。

除了完全搜索外，还有其他类型的算法，如 *贪心算法* 和 *动态规划算法*。如果一个问题不能通过完全搜索解决，那么值得思考是否可以使用这些其他类型的算法来解决。

如果你有兴趣了解更多使用 Python 进行的算法相关内容，我推荐 Magnus Lie Hetland 编写的《*Python Algorithms*》第二版（Apress，2014）。

我还写了一本关于算法设计的书：《*Algorithmic Thinking: A Problem-Based Introduction*》（No Starch Press，2021）。它采用与本书相同的问题导向格式，因此它的风格和节奏你应该会很熟悉。然而，它使用的是 C 编程语言，而不是 Python 编程语言，因此为了更好地理解这本书，你可能需要先学习一些 C 语言。

在本章中，我们调用了预先存在的 Python 函数来执行二分查找。如果愿意，我们可以编写自己的二分查找代码，而不是依赖这些函数。将列表一分为二，直到找到我们想要的值，这个思路是直观的，但实现这一功能的代码出乎意料地复杂。同样令人惊讶的是，使用二分查找的变种可以解决的广泛问题。我之前提到的书籍《*Algorithmic Thinking*》中有一整章专门讲解二分查找及其应用。
