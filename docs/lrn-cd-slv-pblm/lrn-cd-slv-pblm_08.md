## 8

使用集合和字典组织值

![image](img/common.jpg)

当我们需要存储一系列值时，比如动作人物的身高或文章中的单词，Python 列表非常有用。列表使我们能够轻松地保持值的顺序，并根据索引访问某个值。然而，正如我们在本章中将看到的，列表并不适合一些操作，包括检查某个特定值是否在集合中以及在值对之间建立关联。

在本章中，我们将学习 Python 集合和字典，这两种存储值集合的替代方式。我们将看到，当我们需要查找特定值且不关心它们的顺序时，集合是首选工具；而当我们需要处理值对时，字典则是最佳选择。

我们将通过这三种新的集合解决问题：确定唯一电子邮件地址的数量、查找一组单词中共同的单词，以及确定特殊的城市和州的配对数量。

### 问题 #18：电子邮件地址

在这个问题中，我们将存储一组电子邮件地址。我们不关心每个电子邮件地址出现的次数，也不关心电子邮件地址的顺序。这些宽松的存储要求意味着我们可以用集合代替列表——集合是 Python 中一种比列表更高效的类型。我们将学习关于集合的所有内容。

这是 DMOJ 问题 ecoo19r2p1。

#### 挑战

你知道吗，写某人的 Gmail 地址有很多种方式？

我们可以在某人的 Gmail 地址中加入一个加号（+）符号和一个字符串，在@符号前，这样他们就会收到我们发送到新地址的任何邮件。也就是说，就 Gmail 地址而言，所有从加号（+）符号开始到@符号前的字符都会被忽略。例如，我告诉大家我的 Gmail 地址是* daniel.zingaro@gmail.com*，但这只是其中一种写法。如果你发送邮件到* daniel.zingaro+book@gmail.com* 或* daniel.zingaro+hi.there@gmail.com*，我也会收到。（选一个你喜欢的。打个招呼吧！）

在 Gmail 地址中，@符号前的点也会被忽略。例如，如果你将邮件发送到* danielzingaro@gmail.com*（没有点），* daniel..zingaro@gmail.com*（两个点连在一起），* da.nielz.in.gar.o..@gmail.com*（混乱的点），* daniel.zin.garo+blah@gmail.com*，等等，我都会收到。

最后一点：地址中的大小写差异会被忽略。我希望你此时不会朝我发射一阵子弹，但我会收到任何你发到* Daniel.Zingaro@gmail.com*、*DAnIELZIngARO+Flurry@gmAIL.COM*等地址的邮件。

在这个问题中，我们提供了电子邮件地址，我们需要确定其中有多少个是唯一的。这个问题中电子邮件地址的规则与 Gmail 中讨论的规则相同：从 + 符号到 @ 符号前的字符会被忽略，@ 符号前的点会被忽略，整个地址的大小写会被忽略。

#### 输入

输入包含 10 个测试用例。每个测试用例包含以下几行：

+   一行包含整数 *n*，表示电子邮件地址的数量。*n* 介于 1 和 100,000 之间。

+   *n* 行，每行包含一个电子邮件地址。每个电子邮件地址至少包含一个 @ 符号前的字符，后跟 @ 符号本身，再后面是至少一个 @ 符号后的字符。@ 符号前的字符可以是字母、数字、点和加号。@ 符号后的字符可以是字母、数字和点。

#### 输出

对于每个测试用例，输出唯一电子邮件地址的数量。

解决测试用例的时间限制为 30 秒。

### 使用列表

你已经完成了本书的七章内容。在每一章中，我都提出了一个问题，然后教你新的 Python 特性，以便你能够解决这个问题。因此，你可能会期望我在解决电子邮件地址问题之前，教你一些新的 Python 知识。

你可能会对此提出异议：难道我们已经拥有了所需的内容吗？毕竟，我们可以编写一个函数来接受电子邮件地址并返回清理后的版本，没有 + 相关内容，没有 @ 符号前的点，且全部小写。我们还可以维护一个清理后的电子邮件地址列表。对于我们看到的每个电子邮件地址，我们可以清理它并检查它是否已经在清理后的电子邮件地址列表中。如果没有，我们就添加它；如果有，我们就什么也不做（因为它已经被计数了）。一旦我们遍历了所有电子邮件地址，列表的长度将给出唯一电子邮件地址的数量。

是的。我们可能已经拥有了所需的内容。让我们尝试解决这个问题。

#### 清理电子邮件地址

考虑电子邮件地址 *DAnIELZIngARO+Flurry@gmAIL.COM*。我们将清理这个电子邮件地址，使其变为 *danielzingaro@gmail.com*。没有 +Flurry，没有 @ 符号前的点，而且全部小写。我们可以将清理后的版本视为真实的电子邮件地址。任何表示相同真实电子邮件地址的其他电子邮件地址，在清理后也会匹配 *danielzingaro@gmail.com*。

清理电子邮件地址是一个小而独立的任务，因此让我们为此编写一个函数。这个清理函数将接受一个代表电子邮件地址的字符串，清理它，并返回清理后的电子邮件地址。我们将执行三个清理步骤：从 + 符号到 @ 符号前的字符需要删除，@ 符号前的点需要删除，以及将字符转换为小写。这个函数的代码在清单 8-1 中。

def clean(address):

"""

address 是一个字符串，表示电子邮件地址。

返回清理后的地址。

"""

# 去除从'+'到@符号前的所有内容

❶ plus_index = address.find('+')

if plus_index != -1:

❷ at_index = address.find('@')

address = address[:plus_index] + address[at_index:]

# 去除@符号前的点

at_index = address.find('@')

before_at = ''

i = 0

while i < at_index:

❸ if address[i] != '.':

before_at = before_at + address[i]

i = i + 1

❹ cleaned = before_at + address[at_index:]

# 转换为小写

❺ cleaned = cleaned.lower()

return cleaned

*清单 8-1：清理电子邮件地址*

第一步是去除从+符号到@符号之前的所有字符。字符串的 find 方法在这里非常有用。它返回参数最左边出现的位置索引，如果找不到则返回-1：

>>> 'abc+def'.find('+')

3

>>> 'abcdef'.find('+')

-1

我使用 find 方法来确定最左边的+符号的索引 ❶。如果没有+符号，那么这一操作就不需要做了。但是，如果有的话，我们会找到@符号的索引 ❷，并去掉从+符号到@符号之前的所有字符。

第二步是去掉@符号前面的任何点。为此，我使用一个新的字符串 before_at，用来累积@符号前的部分。每个@符号前不是点的字符都会被添加到 before_at 中 ❸。

before_at 字符串不包括@符号或其后的任何字符。我们不想丢失电子邮件地址的这部分，所以我使用一个新变量 cleaned，来表示整个电子邮件地址 ❹。

第三步是将整个电子邮件地址转换为小写 ❺。完成后，电子邮件地址就被清理好了，可以返回它。

让我们稍微测试一下。将我们的 clean 函数代码输入到 Python Shell 中。这里是该函数清理几个电子邮件地址的例子：

>>> clean('daniel.zingaro+book@gmail.com')

'danielzingaro@gmail.com'

>>> clean('da.nielz.in.gar.o..@gmail.com')

'danielzingaro@gmail.com'

>>> clean('DAnIELZIngARO+Flurry@gmAIL.COM')

'danielzingaro@gmail.com'

>>> clean('a.b.c@d.e.f')

'abc@d.e.f'

如果电子邮件地址已经是干净的，clean 函数会直接返回它：

>>> clean('danielzingaro@gmail.com')

'danielzingaro@gmail.com'

#### 主程序

我们可以使用我们的 clean 函数来清理任何电子邮件地址。现在的策略是维护一个清理过的电子邮件地址列表。只有在该清理后的电子邮件地址尚未添加时，我们才会将其加入此列表。通过这种方式，我们可以避免添加重复的清理过的电子邮件地址。

我们程序的主要部分在清单 8-2 中。请确保在这段代码之前输入我们的 clean 函数代码（清单 8-1），这样可以完整解决问题。

# 主程序

for dataset in range(10):

n = int(input())

❶ addresses = []

for i in range(n):

address = input()

address = clean(address)

❷ if not address in addresses:

addresses.append(address)

❸ print(len(addresses))

*清单 8-2：主程序，使用列表*

我们有 10 个测试用例需要处理，因此我们将程序的其余部分用一个循环包围，循环执行 10 次。

对于每个测试用例，我们读取电子邮件地址的数量，并从一个空的干净电子邮件地址列表开始❶。

然后我们使用一个内部的循环遍历每个电子邮件地址。我们读取每个电子邮件地址并进行清理。然后，如果我们之前没有见过这个干净的电子邮件地址❷，我们就将它添加到我们的干净电子邮件地址列表中。

当内部循环结束时，我们将构建出一个包含所有干净电子邮件地址的列表。该列表中没有重复项。那么，唯一电子邮件地址的数量就是该列表的长度，因此我们将输出这个结果❸。

不错吧？几乎就像我们在学习了第六章的函数后就可以解决这个问题。或者，实际上，在我们学习了第五章的列表后也能解决。

差一点，但还是不完全对。因为如果你提交给评测系统，你应该会注意到事情并没有按计划进行。

问题的第一个迹象是，评测系统显示结果需要一些时间。例如，我在这里等待了 1 分钟才看到我的结果。对比我们之前解决的其他问题，反馈速度非常快。

问题的第二个迹象是，当结果显示出来时，我们并没有获得该问题的满分！我得到了 5 分中的 3.25 分。你可能会得到稍多或稍少的分数，但不应该得到满分 5 分。

我们失去分数的原因不是因为程序有错误。我们的程序是正确的。无论测试用例如何，它都会输出正确的唯一电子邮件地址数量。

那么，如果我们的程序是正确的，问题出在哪里呢？

问题是我们的程序太慢了。评测系统通过在每个测试用例前标记 TLE 来告诉我们这一点。TLE 代表“超时”（Time Limit Exceeded）。对于这个问题，评测系统为每批 10 个测试用例分配了 30 秒时间。如果我们的程序花费的时间超过 30 秒，评测系统会终止程序，并且该批次中剩余的测试用例将不再运行。

这可能是你收到的第一次超时错误，尽管你可能在完成前面的章节练习时也曾遇到过。

收到这个错误时，首先要检查的是你的程序是否陷入了无限循环。如果是的话，程序将永远不会结束，不管时间限制如何。当分配的时间到期时，评测系统会终止程序。

如果没有无限循环，那么问题的可能原因就是我们程序的*效率*。当程序员谈论效率时，他们指的是程序运行的时间。运行更快（花费更少时间）的程序比运行更慢（花费更多时间）的程序更高效。为了在时间限制内解决测试用例，我们需要提高程序的效率。

### 搜索列表的效率

向 Python 列表中添加元素非常快速。无论列表中只有几个值，还是有成千上万个值，追加操作所花费的时间几乎是一样的。

然而，使用 `in` 操作符是另一回事。我们的程序使用 `in` 操作符来判断一个干净的电子邮件地址是否已经在我们清洁的电子邮件地址列表中。一个测试用例可能有多达 100,000 个电子邮件地址。那么，在最坏的情况下，我们的程序可能会使用 `in` 操作符查找 100,000 次。事实证明，当在一个包含大量值的列表上使用 `in` 时，它非常慢，这最终会影响程序的效率。为了确定一个值是否在列表中，`in` 会从头到尾逐个检查列表中的每个值。它会一直这样查找，直到找到所需的值，或者没有值可以继续检查。`in` 需要查找的值越多，它的速度就越慢。

让我们感受一下随着列表长度增加，`in` 操作符的速度是如何变慢的。我们将使用一个函数，该函数接受一个列表和一个值，并使用 `in` 操作符在列表中查找该值。它会查找 50,000 次；如果我们只查找一次，那就太快了，我们无法看到发生了什么。

该函数位于 列表 8-3。将它的代码输入到 Python shell 中。

def search(collection, value):

"""

在集合中多次搜索值。

"""

for i in range(50000):

found = value in collection

*列表 8-3：多次搜索集合中的值*

让我们创建一个包含 1 到 5,000 的整数列表，并搜索 5000。通过搜索列表中的最右侧值，我们让 `in` 操作符在这个列表上尽可能花费时间。不要担心我们用整数列表而不是电子邮件地址列表来探索这个问题。效率是类似的，而且数字比电子邮件地址要容易生成得多！

开始：

>>> search(list(range(1, 5001)), 5000)

在我的笔记本上，这大约需要 3 秒钟。我们不需要精确的时间，只是想大致了解随着列表长度增加，发生了什么。

现在让我们创建一个包含 1 到 10,000 的整数列表，并搜索 10000：

>>> search(list(range(1, 10001)), 10000)

在我的笔记本上，这大约花了 6 秒。到目前为止的总结是，对于一个长度为 5000 的列表，花费了 3 秒钟；将列表长度加倍到 10000，所花时间也加倍，变成了 6 秒。

长度为 20000 的列表？试试看：

>>> search(list(range(1, 20001)), 20000)

这在我的笔记本上大约花了 12 秒。

时间再次翻倍了。试试在一个长度为 50,000 的列表上。你会等上一段时间。我刚刚在我的笔记本上运行了这个：

>>> search(list(range(1, 50001)), 50000)

这花了 30 多秒。记住，我们的搜索函数会查找列表 50,000 次。所以，它花了 30 秒钟在一个长度为 50,000 的列表上总共查找 50,000 次。

我们可能有一个需要如此多查找的测试案例。例如，假设我们每次都向列表中添加 100,000 个唯一的电子邮件地址。如果我们添加到一半，列表就会有 50,000 个值；从那时起，剩下的 50,000 次查找都会发生在至少包含 50,000 个值的列表中。

这仅仅是 10 个测试案例中的一个！我们需要在 30 秒内完成所有 10 个测试案例。如果一个测试案例就需要大约 30 秒，我们就没有机会了。

查找列表的速度实在是太慢了。Python 列表类型不适合用来做这个。我们需要一个更适合此任务的类型。我们需要 Python 集合。你简直不敢相信，查找集合是多么迅速。

### 集合

*集合* 是 Python 中一种存储值集合的类型，其中不允许有重复值。我们使用开闭大括号来定义集合。

与列表不同，集合可能不会保持你指定的值的顺序。以下是一个整数集合：

>>> {13, 15, 30, 45, 61}

{45, 13, 15, 61, 30}

注意 Python 打乱了值的顺序。你可能在你的电脑上看到不同的顺序。关键点是，你不能依赖于任何特定的顺序。如果顺序对你很重要，集合就不是你该使用的类型。

如果我们尝试包含多个相同的值，只有一个会被保留：

>>> {1, 1, 3, 2, 3, 1, 3, 3, 3}

{1, 2, 3}

如果两个集合包含完全相同的值，即使我们以不同的顺序写它们，它们也是相等的：

>>> {1, 2, 3} == {1, 2, 3}

True

>>> {1, 1, 3, 2, 3, 1, 3, 3, 3} == {1, 2, 3}

True

>>> {1, 2} == {1, 2, 3}

False

我们可以像这样创建一个字符串集合：

>>> {'abc@d.e.f', 'danielzingaro@gmail.com'}

{'abc@d.e.f', 'danielzingaro@gmail.com'}

我们不能创建一个包含列表的集合：

>>> {[1, 2], [3, 4]}

回溯（最近的调用最后）：

文件 "<stdin>"，第 1 行，在 <module> 中

TypeError: 无法哈希的类型: 'list'

集合中的值必须是不可变的，这解释了为什么我们不能将列表放入集合中。这个限制与 Python 如何在集合中查找值有关。当 Python 向集合添加一个值时，它会使用该值本身来确定存储的位置。之后，Python 可以通过查看该值应该存放的位置来找到这个值。如果集合中的值可能会改变，那么 Python 可能会在错误的位置查找，导致找不到这个值。

虽然我们不能创建一个包含列表的集合，但创建一个包含集合的列表是没有问题的：

>>> lst = [{1, 2, 3}, {4, 5, 6}]

>>> lst

[{1, 2, 3}, {4, 5, 6}]

>>> len(lst)

2

>>> lst[0]

{1, 2, 3}

你可以使用 len 函数来确定集合中值的数量：

>>> len({2, 4, 6, 8})

4

你也可以遍历集合中的值：

>>> for value in {2, 4, 6, 8}:

...     print('I found', value)

...

我找到了 8

我找到了 2

我找到了 4

我找到了 6

但是，你不能对集合进行索引或切片操作。集合中的值没有索引。

要创建一个空集合，你可能会想使用一对空的大括号，即 {}。但由于 Python 语法的不一致性，这样做不起作用：

>>> type({2, 4, 6, 8})

<class 'set'>

>>> {}

{}

>>> type({})

<class 'dict'>

使用 {} 给我们带来了错误的类型：字典（dict），而不是集合。我们稍后将在本章讨论字典。

要创建一个空集合，我们使用 set()，像这样：

>>> set()

set()

>>> type(set())

<class 'set'>

### 集合方法

集合是可变的，因此我们可以添加和移除值。我们可以使用方法执行这些任务。

你可以使用 dir(set()) 获取集合方法的列表。你还可以通过使用 help 获取关于特定集合方法的帮助，方法类似于我们获取字符串或列表方法帮助的方式。例如，要了解 add 方法，可以输入 help(set().add)。

add 方法是用来向集合中添加一个值的。它类似于列表中的 append：

>>> s = set()

>>> s

set()

>>> s.add(2)

>>> s

{2}

>>> s.add(4)

>>> s

{2, 4}

>>> s.add(6)

>>> s

{2, 4, 6}

>>> s.add(8)

>>> s

{8, 2, 4, 6}

>>> s.add(8)

>>> s

{8, 2, 4, 6}

要移除一个值，我们使用 remove 方法：

>>> s.remove(4)

>>> s

{8, 2, 6}

>>> s.remove(8)

>>> s

{2, 6}

>>> s = {2, 6}

>>> s.remove(8)

Traceback (most recent call last):

文件 "<stdin>"，第 1 行，在 <module>

KeyError: 8

**概念检查**

使用 help 来了解集合的 update 和 intersection 方法。

以下代码的 print 调用会输出什么？

s1 = {1, 3, 5, 7, 9}

s2 = {1, 2, 4, 6, 8, 10}

s3 = {1, 4, 9, 16, 25}

s1.update(s2)

s1.intersection(s3)

print(s1)

A. {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

B. {1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

C. {1, 4, 9}

D. {1, 4, 9, 16, 25}

E. {1}

答案：A。update 方法将集合 s2 中缺失的内容添加到集合 s1 中。调用 update 后，s1 就变成了集合 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}。

现在来看交集的调用。两个集合的交集是由两个集合中都包含的值组成的集合。这里，s1 和 s3 的交集是 {1, 4, 9}。然而，交集方法*不会*修改集合；它会生成一个新的集合！因此，它对 s1 没有影响。

### 搜索集合的效率

回到解决电子邮件地址的问题。

我们在清理后的电子邮件地址中关心顺序吗？不！我们关心的只是电子邮件地址是否已经存在。

我们是否需要在清理后的电子邮件地址中允许重复项？再次不需要！事实上，我们希望明确避免存储重复的电子邮件地址。

顺序不重要，且不允许重复项。这是建议使用集合作为合适类型的两个要素。

我们在尝试使用列表时遇到障碍，因为搜索列表的速度太慢。使用集合会对我们有所改善，因为我们可以比搜索列表更快地搜索集合。

我们已经使用 Listing 8-3 中的搜索函数搜索过列表。但这个函数并不特定需要列表！它使用 in 运算符，而 in 运算符可以在列表和集合中使用。所以我们可以直接使用这个函数来搜索集合。

从列表 8-3 中的搜索功能进入 Python shell。在你的电脑上跟着做，体验一下在长列表和大集合中搜索的区别：

>>> search(list(range(1, 50001)), 50000)

❶ >>> search(set(range(1, 50001)), 50000)

在❶处，我使用 set 来生成一个整数集合，而不是列表。

在我的笔记本电脑上，搜索列表大约需要 30 秒。而搜索集合则非常快速，几乎是瞬间完成。

集合是不可阻挡的。不要在列表上尝试这个，但我们来试试，在一个 50 万个元素的集合中搜索：

>>> search(set(range(1, 500001)), 500000)

哇！轻松搞定。

Python 管理列表的方式使我们可以随时使用任何索引。Python 不能随意改变值的顺序：第一个值必须在索引 0，第二个值在索引 1，以此类推。但是对于集合，Python 可以以它想要的任何方式存储它，因为它不承诺为我们保持顺序。而正是这种增加的灵活性使得 Python 能够在集合中优化搜索的速度。

出于类似的原因，一些在大列表上非常慢的操作，在大集合上却非常快。例如，从列表中删除一个值非常慢，因为 Python 必须调整该值右边每个值的索引。相比之下，从集合中删除一个值非常快：因为没有需要更新的索引！

### 解决问题

我们已经有一个函数来清理电子邮件地址（列表 8-1），我们将在集合解决方案中使用它。至于主程序，列表 8-2 已经为我们提供了大部分解决方案。我们只需要用集合代替列表。

新的主程序在列表 8-4 中。要完整解决这个问题，请在这段代码前包含列表 8-1。

# 主程序

for dataset in range(10):

n = int(input())

❶ addresses = set()

for i in range(n):

address = input()

address = clean(address)

❷ addresses.add(address)

print(len(addresses))

*列表 8-4：主程序，使用集合*

注意，我们现在使用的是一个电子邮件地址的集合❶，而不是列表。清理每个电子邮件地址后，我们通过集合的 add 方法❷将其添加到集合中。

在列表 8-2 中，我们使用了 in 操作符来检查一个电子邮件地址是否已经在列表中，以防止添加重复项。在我们的集合解决方案中，没有相应的 in 检查。那它去哪儿了？似乎我们在将每个电子邮件地址添加到集合时，并没有确保它还不在集合中。

使用集合时，我们可以省略 in 检查，因为集合永远不会包含重复项。add 方法会为我们处理 in 检查，确保不会添加重复项。你可以认为 add 方法在执行自己的 in 检查。这里没有时间上的顾虑，因为搜索集合非常快速。

如果你将这个解法提交给评审，你应该能在时间限制内顺利通过所有测试用例。

正如你在这里看到的，选择合适的 Python 类型可能意味着解决方案是满意的，还是不满意的。在你开始写代码之前，问问自己哪些操作你会频繁执行，哪些 Python 类型最适合这些操作。

在继续之前，你可能想尝试解决“章节练习”中的第 1 题和第 2 题，详情见 第 236 页。

### 问题 #19: 常见单词

在这个问题中，我们需要将单词与它们出现的次数关联起来。由于集合无法完成这一任务，所以我们不使用集合。相反，我们将学习并使用 Python 字典。

这是 DMOJ 问题 cco99p2。

#### 挑战

我们给定 *m* 个单词。这些单词不一定是不同的；例如，单词 brook 可能出现多次。我们还给定一个整数 *k*。

我们的任务是找出 *k*th 最常见的单词。一个单词 *w* 是 *k*th 最常见单词，当且仅当有恰好 *k* – 1 个不同的单词出现得比 *w* 更频繁。根据数据集，*k*th 最常见的单词可能是没有单词、一个单词或多个单词。

让我们明确一下*k*th 最常见单词的定义。如果*k* = 1，那么我们要求的是恰好有 0 个单词出现得更频繁的单词，也就是说，我们要求的是出现最频繁的单词。如果*k* = 2，那么我们要求的是恰好有 1 个单词出现得更频繁的单词。如果*k* = 3，那么我们要求的是恰好有两个不同单词出现得更频繁的单词，以此类推。

#### 输入

输入包含一行，给出测试用例的数量，后面是每个测试用例的行。每个测试用例包含以下几行：

+   一行包含整数 *m*（测试用例中的单词数）和 *k*（查询的常见单词顺序），二者由空格分隔。*m* 的范围是 0 到 1000，*k* 至少为 1。

+   *m* 行，每行给出一个单词。每个单词最多由 20 个字符组成，且所有字符均为小写字母。

#### 输出

对于每个测试用例，输出以下内容：

+   一行包含以下内容：

    第 p 个最常见单词：

    其中 p 是第 1 个，如果 *k* 是 1；第 2 个，如果 *k* 是 2；第 3 个，如果 *k* 是 3；第 4 个，如果 *k* 是 4，依此类推。

+   每个 *k*th 最常见单词一行。如果没有这样的单词，则没有输出行。

+   一行空白行。

解决测试用例的时间限制是 1 秒。

### 探索一个测试用例

让我们通过一个测试用例来开始。这将帮助我们更好地理解问题，并激励我们使用一种新的 Python 类型。

假设我们对所有单词中最常见的单词感兴趣。这意味着 *k* 是 1。这里是测试用例：

1

14 1

storm

cut

magma

cut

brook

gully

gully

storm

cliff

cut

blast

brook

cut

gully

最常出现的单词是 cut。cut 出现了四次，没有其他单词出现这么多次。因此，正确的输出是：

第一个最常见的词：

cut

❶

注意末尾需要有一个空行 ❶。

那么，如果 *k* 为 2，我们该怎么办？我们可以通过再次扫描单词并统计出现次数来回答这个问题，但还有一种不同的方式来组织单词，这会让我们的任务变得更加轻松。与其列出单词，不如将每个单词与其出现次数关联起来。请参见表 8-1。

**表 8-1：** 单词和出现次数

| **单词** | **出现次数** |
| --- | --- |
| cut | 4 |
| gully | 3 |
| storm | 2 |
| brook | 2 |
| magma | 1 |
| cliff | 1 |
| blast | 1 |

我已经根据单词的出现次数对它们进行了排序。查看第一行，我们可以确认 cut 是 *k* = 1 时要输出的单词。查看第二行，我们看到 gully 是 *k* = 2 时要输出的单词。gully 是唯一一个恰好有一个出现次数更多的单词。

现在考虑 *k* = 3。这次，有 *两个* 单词需要输出，storm 和 brook，因为它们的出现次数相同。每个单词恰好有两个出现次数更多的单词。这表明我们有时需要输出多个单词。

也有可能我们需要输出零个单词！例如，考虑 *k* = 4。在这种情况下，没有单词的出现次数恰好有三个比它更多的单词。看一下表格，你可能会问为什么我们不输出 magma 当 *k* = 4。我们不输出 magma，因为 magma 恰好有四个单词（而不是三个单词）出现次数更多。

当 *k* = 5 时，我们有三个单词需要输出：magma、cliff 和 blast。在继续之前，请自行验证，对于其他任何 *k* 的值，都没有单词需要输出——对于 *k* = 6，*k* = 7，*k* = 8，*k* = 9，*k* = 100 等等，都没有单词。

表 8-1 为我们简化了问题。接下来，我们将学习如何在 Python 中组织这样的信息。

### 字典

*字典* 是一种 Python 类型，用于存储从一组元素（称为 *键*）到另一组元素（称为 *值*）的映射。

我们使用开括号和闭括号来限定字典。这些符号与我们用来表示集合的符号相同，但 Python 能够通过大括号中的内容区分集合和字典。对于集合，我们列出的是值；对于字典，我们列出的是键:值对。

这是一个将一些字符串映射到数字的字典：

>>> {'cut':4, 'gully':3}

{'cut': 4, 'gully': 3}

在这个字典中，键是 'cut' 和 'gully'，值分别是 4 和 3。键 'cut' 映射到值 4，键 'gully' 映射到值 3。

基于我们对集合的了解，你可能会想知道字典是否会按照我们输入的顺序来保持这些键值对。例如，你可能会想知道是否会发生以下情况：

>>> {'cut':4, 'gully':3}

{'gully': 3, 'cut': 4}

从 Python 3.7 开始，答案是“否”：字典会保持你添加键值对的顺序。在 Python 的早期版本中，字典并不保留顺序，因此你可以按某种顺序添加键值对，但取出来时可能是另一个顺序。不过，编写不依赖于 Python 3.7 行为的代码仍然是个好主意，因为未来仍有可能使用较旧版本的 Python。

字典如果包含相同的键值对，无论我们以何种顺序书写，都是相等的：

>>> {'cut':4, 'gully':3} == {'cut':4, 'gully':3}

真

>>> {'cut':4, 'gully':3} == {'gully': 3, 'cut': 4}

真

>>> {'cut':4, 'gully':3} == {'gully': 3, 'cut': 10}

假

>>> {'cut':4, 'gully':3} == {'cut': 4}

假

字典的键必须是唯一的。如果你尝试多次包含相同的键，那么只会保留一个涉及该键的键值对：

>>> {'风暴': 1, '风暴': 2}

{'风暴': 2}

相反，重复的值是可以的：

>>> {'风暴': 2, '小溪': 2}

{'风暴': 2, '小溪': 2}

键必须是不可变值，如数字和字符串。值可以是不可变的或可变的。这意味着我们不能使用列表作为键，但可以将列表作为值：

>>> {['风暴', '小溪']: 2}

回溯（最近一次调用最先发生）：

文件 "<stdin>"，第 1 行，模块内：

TypeError: 不可哈希的类型：'列表'

>>> {2: ['风暴', '小溪']}

{2: ['风暴', '小溪']}

len 函数返回字典中键值对的数量：

>>> len({'cut':4, 'gully':3})

2

>>> len({2: ['风暴', '小溪']})

1

要创建一个空字典，我们使用{}。这也是为什么我们不得不使用那种二流的 set()语法来创建集合——字典拥有更漂亮的语法：

>>> {}

{}

>>> type({})

<class 'dict'>

类型叫做 dict，而不是字典。

在 Python 的资源和代码中，你会看到“字典”和“dict”可以互换使用，但在本书中，我会坚持使用“字典”这个术语。

**概念检查**

以下哪项最适合用字典而不是列表或集合？

A. 人们完成比赛的顺序

B. 食谱所需的配料

C. 各国及其首都的名称

D. 50 个随机整数

答案：C。这是唯一一个包含键值映射的选项。这里，键可以是国家，值可以是它们的首都。

**概念检查**

以下字典中，忽略键后，值的类型是什么？

{'MLB': {'蓝鸟': [1992, 1993],

'金莺': [1966, 1970, 1983]},

'NFL': {'爱国者': ['太多']}}

A. 整数

B. 字符串

C. 列表

D. 字典

E. 上述多个选项

答案：D。字典中每个键的值本身就是一个字典。例如，键'MLB'映射到一个字典；该字典有两个键值对。

### 索引字典

我们可以使用方括号查找一个键映射到的值。这类似于如何索引列表，不过是用键作为有效的“索引”：

>>> d = {'cut':4, 'gully':3}

>>> d

{'cut': 4, 'gully': 3}

>>> d['cut']

4

>>> d['gully']

3

使用不存在的键是错误的：

>>> d['storm']

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

KeyError: 'storm'

我们可以通过先使用 in 检查一个键是否在字典中来防止这个错误。当在字典上使用 in 操作符时，它只检查键，而不检查值。以下是如何在尝试查找键的值之前检查一个键是否存在：

>>> if 'cut' in d:

...     print(d['cut'])

...

4

>>> if 'storm' in d:

...     print(d['storm'])

...

索引和使用 in 操作符对字典进行操作都是非常快速的操作。无论字典中有多少键，都不需要搜索任何列表。

有时使用 get 方法比通过索引查找键的值更方便。即使键不存在，get 方法也永远不会产生错误：

>>> print(d.get('cut'))

4

>>> print(d.get('storm'))

None

如果键存在，get 会返回其值。否则，它返回 None，表示该键不存在。

除了查找键的值，我们还可以使用方括号向字典添加键，或更改键所映射的值。以下是一些代码，展示如何做到这一点，从一个空字典开始：

>>> d = {}

>>> d['gully'] = 1

>>> d

{'gully': 1}

>>> d['cut'] = 1

>>> d

{'gully': 1, 'cut': 1}

>>> d['cut'] = 4

>>> d

{'gully': 1, 'cut': 4}

>>> d['gully'] = d['gully'] + 1

>>> d

{'gully': 2, 'cut': 4}

>>> d['gully'] = d['gully'] + 1

>>> d

{'gully': 3, 'cut': 4}

**概念检查**

使用 help({}.get) 来了解字典的 get 方法。

以下代码的输出是什么？

d = {3: 4}

d[5] = d.get(4, 8)

d[4] = d.get(3, 9)

print(d)

A. {3: 4, 5: 8, 4: 9}

B. {3: 4, 5: 8, 4: 4}

C. {3: 4, 5: 4, 4: 3}

D. 由 get 引起的错误

答案：B. 第一次调用 get 返回 8，因为键 4 在字典中不存在。该行因此添加了键 5 和值 8。

第二次调用 get 返回 4：键 3 已经在字典中，因此第二个参数 9 被忽略。该行因此添加了键 4 和值 4。

### 遍历字典

如果我们对字典使用 for 循环，得到的是字典的键：

>>> d = {'cut': 4, 'gully': 3, 'storm': 2, 'brook': 2}

>>> for word in d:

...     print('a key is', word)

...

一个键被切割

一个键是 gully

一个键是 storm

一个键是 brook

我们也可能希望访问与每个键相关联的值，我们可以通过使用每个键作为字典中的索引来做到这一点。以下是一个循环，访问键及其值：

>>> for word in d:

...     print('key', word, 'has value', d[word])

...

key cut 的值为 4

key gully 的值为 3

key storm 的值为 2

key brook 的值为 2

字典有方法可以让我们访问键、值或两者。

keys 方法给我们键，values 方法给我们值：

>>> d.keys()

dict_keys(['cut', 'gully', 'storm', 'brook'])

>>> d.values()

dict_values([4, 3, 2, 2])

这些不是列表，但我们可以将它们传递给 list 来进行转换：

>>> keys = list(d.keys())

>>> keys

['cut', 'gully', 'storm', 'brook']

>>> values = list(d.values())

>>> values

[4, 3, 2, 2]

使用列表形式的键，我们可以对键进行排序，然后按排序顺序遍历它们：

>>> keys.sort()

>>> keys

['brook', 'cut', 'gully', 'storm']

>>> for word in keys:

...     print('key', word, 'has value', d[word])

...

key brook 的值是 2

key cut 的值是 4

key gully 的值是 3

key storm 的值是 2

我们也可以遍历值：

>>> for num in d.values():

...     print('number', num)

...

数字 4

数字 3

数字 2

数字 2

遍历键通常比遍历值更受欢迎。因为从键到值很容易。但正如我们在下一个小节中将看到的，从值回到键则没有那么简单。

这里有一个相关的最终方法是 items。它让我们可以同时访问键和值：

>>> pairs = list(d.items())

>>> pairs

[('cut', 4), ('gully', 3), ('storm', 2), ('brook', 2)]

这为我们提供了另一种遍历字典键:值对的方式：

>>> for pair in pairs:

...     print('key', pair[0], 'has value', pair[1])

...

key cut 的值是 4

key gully 的值是 3

key storm 的值是 2

key brook 的值是 2

仔细查看 pairs 的值：

>>> pairs

[('cut', 4), ('gully', 3), ('storm', 2), ('brook', 2)]

这里有点问题：每个内部值周围都是括号，而不是方括号。事实证明，这*不是*一个列表的列表，而是一个元组的列表：

>>> type(pairs[0])

<class 'tuple'>

元组与列表类似，它们存储一个值的序列。元组和列表之间最重要的区别是，元组是不可变的。你可以遍历它们、索引它们和切片它们，但不能修改它们。如果你试图修改元组，就会报错：

>>> pairs[0][0] = 'river'

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

TypeError: 'tuple' 对象不支持项赋值

你可以使用括号创建自己的元组。对于一个只有单个值的元组，我们需要一个结尾的逗号。对于多个值的元组，则不需要：

>>> (4,)

(4,)

>>> (4, 5)

(4, 5)

>>> (4, 5, 6)

(4, 5, 6)

元组有方法——但只有少数几个，因为不允许改变元组的那些方法。如果你感兴趣，我鼓励你了解更多关于元组的内容，但在本书中我们不会再使用元组了。

### 反转字典

我们接近于能够使用字典解决常见单词问题了。计划如下：我们维护一个字典，将单词映射到它们出现的次数。每当处理一个单词时，我们检查该单词是否已经在字典中。如果不在，我们就以 1 为值将其加入字典。如果已经在字典中，我们则将其值加 1。

这里有一个例子，展示如何添加两个单词，一个是我们之前见过的，另一个是我们没见过的：

>>> d = {'storm': 1, 'cut': 1, 'magma': 1}

>>> word = 'cut'  # 'cut' 已经在字典中

>>> if not word in d:

...     d[word] = 1

... else:

...     d[word] = d[word] + 1

...

>>> d

{'storm': 1, 'cut': 2, 'magma': 1}

>>> word = 'brook'  # 'brook' 不在字典中

>>> if not word in d:

...     d[word] = 1

... else:

...     d[word] = d[word] + 1

...

>>> d

{'storm': 1, 'cut': 2, 'magma': 1, 'brook': 1}

字典使得从键到值的映射变得容易。例如，给定键 'brook'，我们可以轻松查找值 1：

>>> d['brook']

1

参照表 8-1，这就像从左列的单词到右列的出现次数。但是，这并不能直接告诉我们有多少个单词具有特定的出现次数。我们真正需要做的是从右列到左列转换，从出现次数到单词。这样我们就能按照出现次数从多到少排序，找到我们需要的单词。

也就是说，我们需要将这种字典转换为：

{'storm': 2, 'cut': 4, 'magma': 1, 'brook': 2,

'gully': 3, 'cliff': 1, 'blast': 1}

转换为这种形式，即*倒转字典*：

{2: ['storm', 'brook'], 4: ['cut'], 1: ['magma', 'cliff', 'blast'],

3: ['gully']}

原始字典将字符串映射到数字。倒转的字典将数字映射到字符串。嗯，不完全是：倒转的字典将数字映射到*字符串列表*。记住，在字典中，每个键只能出现一次。在倒转的字典中，我们需要将每个键映射到多个值，因此我们将所有这些值存储在一个列表中。

要倒转一个字典，每个键变成一个值，每个值变成一个键。如果一个键还没有出现在倒转字典中，我们为它的值创建一个列表。如果该键已经存在于倒转字典中，那么我们将它的值添加到该列表中。

现在我们可以编写一个函数来返回字典的倒转版本。请参见示例 8-5 获取代码。

def invert_dictionary(d):

"""

d 是一个将字符串映射到数字的字典。

返回 d 的倒转字典。

"""

inverted = {}

❶ for key in d:

❷ num = d[key]

if not num in inverted:

❸ inverted[num] = [key]

else:

❹ inverted[num].append(key)

return inverted

*示例 8-5：倒转字典*

我们使用一个 for 循环遍历字典 d ❶，它为我们提供每个键。我们索引 d 来获取这个键映射到的值 ❷。然后我们将这个键值对添加到倒转字典中。如果 num 还不是倒转字典中的键，那么我们添加它并将其映射到 d 中的关联键 ❸。如果 num 已经是倒转字典中的键，那么它的值已经是一个列表。因此，我们可以使用 append 方法将 d 中的键作为另一个值添加到列表中 ❹。

将我们的 `invert_dictionary` 函数的代码输入到 Python shell 中。让我们试试看：

>>> d = {'a': 1, 'b': 1, 'c': 1}

>>> invert_dictionary(d)

{1: ['a', 'b', 'c']}

>>> d = {'storm': 2, 'cut': 4, 'magma': 1, 'brook': 2,

...      'gully': 3, 'cliff': 1, 'blast': 1}

>>> invert_dictionary(d)

{2: ['storm', 'brook'], 4: ['cut'], 1: ['magma', 'cliff', 'blast'],

3: ['gully']}

现在我们准备通过反转字典来解决常见单词问题。

### 解决问题

如果你想通过自顶向下的设计来多做一些练习，可以在继续之前尝试独立解决这个问题。为了节省空间，我在这里不逐步跟进自顶向下的设计，而是直接给出完整的解决方案，然后我们再讨论每个函数及其用途。

#### 代码

解决方案见 Listing 8-6。

def invert_dictionary(d):

"""

d 是一个将字符串映射到数字的字典。

返回反转后的字典 d。

"""

inverted = {}

for key in d:

num = d[key]

如果 num 不在 inverted 中：

inverted[num] = [key]

else:

inverted[num].append(key)

return inverted

❶ def with_suffix(num):

"""

num 是一个大于或等于 1 的整数。

返回带有后缀的数字字符串；例如 '5th'。

"""

❷ s = str(num)

❸ 如果 s[-1] == '1' 且 s[-2:] != '11':

return s + 'st'

elif s[-1] == '2' 且 s[-2:] != '12':

return s + 'nd'

elif s[-1] == '3' 且 s[-2:] != '13':

return s + 'rd'

else:

return s + 'th'

❹ def most_common_words(num_to_words, k):

"""

num_to_words 是一个将出现次数映射到单词的字典。

单词列表。

k 是一个大于或等于 1 的整数。

返回 num_to_words 中第 k 个最常见的单词的列表。

"""

nums = list(num_to_words.keys())

nums.sort(reverse=True)

total = 0

i = 0

done = False

❺ while i < len(nums) 且 done 为假：

num = nums[i]

❻ 如果 total + len(num_to_words[num]) >= k:

done = True

else:

total = total + len(num_to_words[num])

i = i + 1

❼ 如果 total == k - 1 且 i < len(nums):

return num_to_words[nums[i]]

else:

return []

❽ n = int(input())

for dataset in range(n):

lst = input().split()

m = int(lst[0])

k = int(lst[1])

word_to_num = {}

for i in range(m):

word = input()

如果 word 不在 word_to_num 中：

word_to_num[word] = 1

else:

word_to_num[word] = word_to_num[word] + 1

❾ num_to_words = invert_dictionary(word_to_num)

ordinal = with_suffix(k)

words = most_common_words(num_to_words, k)

print(f'{ordinal} most common word(s):')

for word in words:

print(word)

print()

*Listing 8-6: 解决常见单词问题*

第一个函数是 invert_dictionary。我们在本章“反转字典”部分已经讨论过它。接下来我们将逐一讲解程序中的其他部分。

#### 添加后缀

with_suffix 函数 ❶ 接收一个数字，并返回一个带有正确后缀的字符串。我们需要这个函数，因为有个麻烦的要求需要将 *k* 与后缀一起输出。例如，如果 *k* = 1，那么我们就必须在输出中生成这一行：

1st 最常见的单词：

如果 *k* = 2，我们必须在输出中生成这一行：

2nd 最常见的单词：

依此类推。我们的`with_suffix`函数确保我们为数字添加正确的后缀。我们首先将数字转换为字符串❷，以便我们可以轻松访问它的每一位数字。然后我们使用一系列的测试来确定后缀是 st、nd、rd 还是 th。例如，如果最后一位数字是 1，但最后两位数字不是 11❸，那么正确的后缀是 st。这样我们就得到了 1st、21st 和 31st，但不是 11st（那将是错误的）。

#### 查找第 k 个最常见的单词

`most_common_words`函数❹就是实际查找我们需要的单词的函数。它接受一个反转字典（将出现次数映射到单词列表）和一个整数 k，并返回一个包含第 k 个最常见单词的列表。

为了看它是如何工作的，让我们看看一个示例反转字典。我已经按从最多到最少出现次数的顺序整理了它的键，因为这是`most_common_words`函数遍历键的顺序。以下是字典：

{4: ['cut'],

3: ['gully'],

2: ['storm', 'brook'],

1: ['magma', 'cliff', 'blast']}

假设 k 是 3。因此，恰好有两个单词必须比我们返回的单词更常见。我们需要的单词并没有由第一个字典键提供。这个键只给了我们一个单词（cut），所以它不能是第三个最常见的单词。同样，第二个字典键也没有提供我们需要的单词。这个键给了我们另外一个单词（gully）。到现在为止，我们已经处理了两个单词，但仍未找到第三个最常见的单词。然而，第三个字典键提供了我们需要的单词。该键给了我们两个单词；这两个单词（storm 和 brook）都有恰好两个比它们出现次数更多的单词，因此这些就是 k 为 3 时的单词。

如果 k 是 4 会怎么样呢？这时，必须有恰好三个词比我们返回的词更常见。候选词仍然是来自第三个键（storm 和 brook），但是只有两个词比这两个词更常见。因此，当 k=4 时，*没有*可以返回的词。

总结来说，我们需要累计当遍历键时看到的单词，直到找到可能包含我们所需单词的键。如果恰好有 k - 1 个单词更常见，那么我们就找到了第 k 个最常见的单词；否则，我们没有找到，因此没有单词可以输出。

现在让我们一起看一下代码本身。我们首先获取字典的键并按从大到小排序。然后我们按这个倒排序的顺序遍历键❺。done 变量告诉我们是否已经查看了 k 个或更多的单词。一旦我们查看了❻个单词，我们就退出循环。

当循环结束后，我们检查是否有第 k 个单词。如果恰好有 k - 1 个单词出现得更频繁，并且我们没有遍历到键的末尾❼，那么我们确实有单词可以返回。否则，没有单词可以返回，所以我们返回空列表。

#### 主程序

现在我们进入程序的主要部分❽。我们构建了字典 word_to_num，它将每个单词映射到其出现次数。接着我们构建了反向字典 num_to_words❾，它将每个出现次数映射到相关的单词列表。请注意，这些字典的名称传达了映射的方向：word_to_num 是从单词到数字，num_to_words 是从数字到单词。

剩余的代码调用了其他辅助函数，并输出适当的单词。

这样，你就准备好提交给评测系统了。做得好：这是你用字典解决的第一个问题。每当你需要在两种类型的值之间映射时，想一想是否可以使用字典来组织这些信息。如果可以，这通常意味着你已经走在了高效解决方案的道路上！

### 问题 #20：城市与州

这是另一个我们能够使用字典的问题。在阅读问题描述时，思考我们可以将什么作为键，什么可以作为值。

这是 USACO 2016 年 12 月银奖竞赛问题“城市与州”。

#### 挑战

美国被划分为称为*州*的地理区域，每个州包含一个或多个城市。每个州都有一个由两个字符组成的缩写。例如，宾夕法尼亚州的缩写是 PA，南卡罗来纳州的缩写是 SC。我们将所有城市名和州缩写写成大写。

考虑城市对 SCRANTON PA 和 PARKER SC。这个城市对是*特殊的*，因为每个城市的前两个字符给出了另一个城市所在州的缩写。也就是说，SCRANTON 的前两个字符给出了 SC（PARKER 的州），而 PARKER 的前两个字符给出了 PA（SCRANTON 的州）。

如果一对城市满足以下条件，并且不在同一个州，则该对城市是*特殊的*。

确定提供输入中的特殊城市对的数量。

#### 输入

从名为*citystate.in*的文件中读取输入。

输入由以下几行组成：

+   一行包含*n*，表示城市的数量。*n*的范围是 1 到 200,000 之间。

+   *n*行，每行对应一个城市。每行包含一个城市名（大写），一个空格，以及该城市所在州的缩写（大写）。每个城市的名称长度在 2 到 10 个字符之间；每个州的缩写恰好由两个字符组成。同一城市名可以出现在多个州，但不会在同一个州中出现两次。本问题中的城市名或州名是符合这些要求的任何字符串；它们可能不是实际的美国城市或州名。

#### 输出

将输出写入名为*citystate.out*的文件。

输出特殊城市对的数量。

每个测试案例的时间限制是四秒。

### 探索测试案例

也许你在想，你可以用列表来解决这个问题。这是一个不错的思路！如果你感兴趣，我建议你在继续之前先尝试一下。策略是使用两个嵌套的循环来考虑每一对城市，并检查每一对是否特殊。使用这种方法也是可能得出正确解的。

一个正确的解决方案，没错，但也是一个缓慢的解决方案。城市的列表可能非常庞大——最多可达 200,000 个——任何涉及搜索列表以匹配城市的方案注定会太慢。让我们通过一个测试案例来探讨一下字典如何能提供帮助。

这是我们的测试案例：

12

SCRANTON PA

曼尼斯蒂 MI

纳舒厄 NH

帕克 SC

拉斐特 CO

瓦绍格尔 WA

米德尔伯勒 MA

麦迪逊 MI

米尔福德 MA

中托 MA

科温顿 LA

莱克伍德 CO

第一个城市是 SCRANTON PA。为了找到涉及该城市的特殊城市对，我们需要找到其他名称以 PA 开头且州为 SC 的城市。唯一符合这个描述的城市是帕克 SC。

注意，SCRANTON PA 只有一个条件我们需要关心，那就是它的名字以 SC 开头，且它的州是 PA。它本可以叫做 SCMERWIN PA，SCSHOCK PA 或者 SCHRUTE PA，依然会与帕克 SC 形成特殊对。

让我们把城市名称的前两个字符加上城市所在的州称为*组合*。例如，SCRANTON PA 的组合是 SCPA，帕克 SC 的组合是 PASC。

与其寻找特殊的城市对，我们现在可以看看特殊的组合对。让我们尝试一下。

有两个城市属于 MAMI 组合。它们恰好是曼尼斯蒂 MI 和麦迪逊 MI，但我们关心的是它们的数量是两个。MAMI 城市以 MA 开头，且位于 MI 州。为了计算涉及 MAMI 城市的特殊城市对，我们需要知道那些以 MI 开头并且位于 MA 州的城市数量。也就是说，我们需要知道 MIMA 城市的数量。共有三个 MIMA 城市。它们恰好是米德尔伯勒 MA、米尔福德 MA 和中托 MA，但我们关心的是它们的数量是三个。那么——我们有两个 MAMI 城市和三个 MIMA 城市。因此，这些组合的总特殊城市对数量是 2 * 3 = 6，因为对于每一个 MAMI 城市，我们都有三个 MIMA 城市的选择。

如果你还不相信，这里是这几个组合的六个特殊城市对：

+   曼尼斯蒂 MI 和米德尔伯勒 MA

+   曼尼斯蒂 MI 和米尔福德 MA

+   曼尼斯蒂 MI 和中托 MA

+   麦迪逊 MI 和米德尔伯勒 MA

+   麦迪逊 MI 和米尔福德 MA

+   麦迪逊 MI 和中托 MA

如果我们能将组合——SCPA, PASC, MAMI, MIMA 等——映射到出现次数，我们就可以循环这些组合来找出特殊城市对的数量。字典是存储这种映射的完美工具。

这是我们希望为测试案例创建的字典：

{'SCPA': 1, 'MAMI': 2, 'NANH': 1, 'PASC': 1, 'LACO': 2,

'MIMA': 3, 'COLA': 1}

有了这个字典，我们可以计算出特殊城市对的数量。让我们一步步地看一下这个过程。

第一个关键字是 'SCPA'，它的值是 1。要找到涉及 'SCPA' 的特殊城市对，我们需要查找 'PASC' 的值。这个值也是 1。我们将两个值相乘，得到 1 * 1 = 1 对涉及这些组合的特殊城市对。我们需要对字典中每个其他的关键字执行相同的操作。

下一个关键字是 'MAMI'，它的值是 2。要找到涉及 'MAMI' 的特殊城市对，我们需要查找 'MIMA' 的值。这个值是 3。我们将两个值相乘，得到 2 * 3 = 6 对涉及这些组合的特殊城市对。加上之前找到的 1 对，现在总共有 7 对。

下一个关键字是 'NANH'，它的值是 1。要找到涉及 'NANH' 的特殊城市对，我们需要查找 'NHNA' 的值。但 'NHNA' 不是字典中的一个关键字！因此没有涉及这些组合的特殊城市对。我们仍然有总共 7 对。

请特别注意接下来的这一条。下一个关键字是 'PASC'，它的值是 1。要找到涉及 'PASC' 的特殊城市对，我们需要查找 'SCPA' 的值。这个值也是 1。我们将两个值相乘，得到 1 * 1 = 1 对涉及这些组合的特殊城市对。但是等等：我们已经在处理 'SCPA' 关键字时考虑过了这一对。如果我们在这里加 1，就会导致重复计算这一对。事实上，通过处理每个关键字，我们会重复计算 *每一* 对特殊城市对。不过不用担心：当我们准备打印最终答案时，我们会做出调整。让我们把这 1 加进去。加上之前找到的 7 对，现在总共有 8 对。

下一个关键字是 'LACO'，它的值是 2。'COLA' 的值是 1，乘积 2 * 1 = 2，表示涉及这些组合的特殊城市对有 2 对。加上之前找到的 8 对，现在总共有 10 对。

还有两个关键字需要处理，'MIMA' 和 'COLA'。第一个让我们将 6 加到总数中；第二个让我们将 2 加上。加上之前找到的 10 对，现在总共有 18 对。

记住，我们已经重复计算了每一对特殊城市对。因此，我们并没有 18 对独特的特殊城市对。实际上，我们只有 18 / 2 = 9 对特殊城市对。我们只需要除以 2，就能消除重复计数。

如果你将我们刚才讲解的字典与测试用例中的城市进行比较，你会注意到字典中缺少了一个城市——WASHOUGAL WA！它的组合是 WAWA，但字典中没有 'WAWA' 这个关键字。我们没有考虑到这个城市，我们需要理解为什么。

WASHOUGAL WA 的前两个字符是 WA。这意味着 WASHOUGAL WA 成为特殊城市对的一部分的唯一方式是找到另一个州为 WA 的城市。请注意，WASHOUGAL WA 也位于 WA 州。然而，问题指定特殊城市对中的两个城市必须来自不同的州。因此，无法找到包含 WASHOUGAL WA 的特殊城市对。为了确保我们不会意外地计数虚假的特殊城市对，我们甚至不将 WASHOUGAL WA 包含在字典中。

### 解决问题

我们准备好了！我们可以使用字典为城市和州问题提供简洁、快速的解决方案。代码在 清单 8-7 中。

input_file = open('citystate.in', 'r')

output_file = open('citystate.out', 'w')

n = int(input_file.readline())

❶ combo_to_num = {}

for i in range(n):

lst = input_file.readline().split()

❷ city = lst[0][:2]

state = lst[1]

❸ if city != state:

combo = city + state

if not combo in combo_to_num:

combo_to_num[combo] = 1

else:

combo_to_num[combo] = combo_to_num[combo] + 1

total = 0

❹ for combo in combo_to_num:

❺ other_combo = combo[2:] + combo[:2]

if other_combo in combo_to_num:

❻ total = total + combo_to_num[combo] * combo_to_num[other_combo]

❼ output_file.write(str(total // 2) + '\n')

input_file.close()

output_file.close()

*清单 8-7：解决城市和州的问题*

这是一个 USACO 问题，我们需要使用文件而不是标准输入和标准输出。

我们将构建的字典叫做 combo_to_num ❶。它将四个字符的组合（例如 'SCPA'）映射到具有该组合的城市数量。

对于输入中的每个城市，我们使用变量来表示城市名称的前两个字符 ❷ 和其州名。然后，如果这些值不相同 ❸，我们将它们组合并将组合添加到字典中。如果该组合尚未在字典中，我们将其添加，值为 1；如果已经存在，我们将其值增加 1。

字典现在已经构建完成。我们遍历其键 ❹。对于每个键，我们构造需要查找的另一个组合，以便找到包含此键的特殊城市对。如果键是 'SCPA'，例如，那么我们希望另一个组合是 'PASC'。为此，我们取键的最右边两个字符，再跟上最左边的两个字符 ❺。如果另一个组合也在字典中，那么我们将两个键的值相乘，并将结果加到总数中 ❻。

现在我们需要做的就是将特殊城市对的总数输出到输出文件。如前一节所述，我们需要将总数除以 2 ❼ 来消除因处理字典中的每个键而导致的重复计数。

就这样：这是一个使用字典适当部署来解决问题的例子。随时可以提交我们的代码！

### 摘要

在这一章中，我们学习了 Python 的集合和字典。集合是一种没有顺序且没有重复元素的值集合。字典是一种由键：值对组成的集合。正如我们在本章的题目中看到的，有时候这些集合比列表更合适。例如，相比于在列表上执行相同的操作，判断某个值是否存在于集合中要快得多。如果我们不关心值的顺序，或者希望消除重复项，那么我们应该认真考虑使用集合。

类似地，字典使得通过键来查找对应的值变得容易。如果我们需要维持一个从键到值的映射，那么我们应该认真考虑使用字典。

通过引入集合和字典，你现在有更多的灵活性来存储你的值。然而，这种灵活性意味着你需要做出选择。不要再默认使用列表了！使用不同类型的数据结构之间的差异，可能会决定你能否解决问题。

我们已经达到了一个重要的里程碑，因为我们已经涵盖了本书中我要教授的绝大部分 Python 内容。这并不意味着你的 Python 学习之旅就此完成。Python 还有很多知识点是本书中没有涉及的。然而，这意味着我们已经达到了一个阶段，我们可以利用我们的 Python 技能解决各种各样的问题——无论是在竞争性编程中，还是其他方面。

在本书的下一章中，我们将转变方向：从学习新的 Python 特性转向提升我们的问题解决能力。我们将专注于一种特定类型的问题，解决这些问题的方式是通过搜索所有候选解来完成。

### 章节练习

以下是一些你可以尝试的练习。对于每个练习，使用集合或字典。有时候，集合或字典可以帮助你写出更快速的代码；有时候，它们也能帮助你写出更有组织且更易读的代码。

1.  DMOJ 问题 crci06p1，Bard

1.  DMOJ 问题 dmopc19c5p1，显眼的神秘清单

1.  DMOJ 问题 coci15c2p1，Marko

1.  DMOJ 问题 ccc06s2，加密文本的攻击

1.  DMOJ 问题 dmopc19c3p1，众数查找

1.  DMOJ 问题 coci14c2p2，Utrka（试着用三种不同的方式来解决这个问题：使用字典、使用集合和使用列表！）

1.  DMOJ 问题 coci17c2p2，ZigZag（提示：维护两个字典。第一个将每个起始字母映射到其单词列表；第二个将每个起始字母映射到下一个将要输出的单词的索引。通过这种方式，我们可以循环遍历每个字母的单词，而不需要显式更新出现次数或修改列表。）

### 备注

Email Addresses 最初来自 2019 年安大略省教育计算组织编程竞赛第 2 轮。Common Words 最初来自 1999 年加拿大计算奥林匹克竞赛。Cities and States 最初来自 2016 年美国计算奥林匹克银奖竞赛。

如果你想深入了解 Python，我推荐由 Eric Matthes 所著的*Python Crash Course*（第二版，No Starch Press，2019）。当你准备好提升自己的技能时，你可能会喜欢阅读由 Brett Slatkin 所著的*Effective Python*（第二版，Addison-Wesley Professional，2020），它提供了一系列技巧，帮助你编写更好的 Python 代码。
