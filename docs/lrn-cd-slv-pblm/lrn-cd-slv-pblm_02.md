## 做出决策

![image](img/common.jpg)

大多数我们日常使用的程序会根据其执行过程中发生的事情表现得不同。例如，当文字处理软件问我们是否保存工作时，它会根据我们的回答做出决策：如果我们回答“是”，它就保存工作；如果回答“否”，它就不保存工作。在这一章中，我们将学习`if`语句，它让我们的程序能够做出决策。

我们将解决两个问题：确定篮球比赛的结果和确定一个电话号码是否属于推销员。

### 问题 #3：获胜队伍

在这个问题中，我们需要输出一个根据篮球比赛结果不同而变化的消息。为此，我们将学习所有关于`if`语句的内容。我们还将学习如何在程序中存储和操作真假值。

这是 DMOJ 问题`ccc19j1`。

#### 挑战

在篮球比赛中，有三种方式得分：三分球、两分球和一分罚球。

你刚刚观看了苹果队和香蕉队之间的篮球比赛，并记录了每支队伍成功的三分球、两分球和一分罚球数。请判断比赛是由苹果队获胜、香蕉队获胜还是平局。

#### 输入

有六行输入。前三行给出苹果队的得分，后面三行给出香蕉队的得分。

+   第一行给出苹果队成功投中的三分球数。

+   第二行给出苹果队成功投中的两分球数。

+   第三行给出苹果队成功投中的一分罚球数。

+   第四行给出香蕉队成功投中的三分球数。

+   第五行给出香蕉队成功投中的两分球数。

+   第六行给出香蕉队成功投中的一分罚球数。

每个数字是 0 到 100 之间的整数。

#### 输出

输出是一个单一字符。

+   如果苹果队得分高于香蕉队，输出`A`（*A*代表苹果队）。

+   如果香蕉队得分高于苹果队，输出`B`（*B*代表香蕉队）。

+   如果苹果队和香蕉队得分相同，输出`T`（*T*代表平局）。

### 条件执行

我们可以利用第一章学到的知识在这里取得很大进展。我们可以使用`input`和`int`读取输入中的六个整数。我们可以使用变量保存这些值。我们可以将成功的三分球数乘以 3，将成功的两分球数乘以 2。我们可以使用`print`输出`A`、`B`或`T`。

我们还没有学习的是，如何让程序根据比赛结果做出决策。我可以通过两个测试用例演示我们为什么需要这个。

首先，考虑这个测试用例：

```py
5

1

3

1

1

1
```

苹果队得分为 5 * 3 + 1 * 2 + 3 = 20 分，香蕉队得分为 1 * 3 + 1 * 2 + 1 = 6 分。苹果队赢得了比赛，所以这是正确的输出：

```py
A
```

其次，考虑这个测试用例，其中苹果队和香蕉队的得分已被交换：

```py
1

1

1

5

1

3
```

这一次，香蕉队赢得了比赛，因此这是正确的输出：

```py
B
```

我们的程序必须能够比较苹果队和香蕉队的总得分，并利用这个比较结果来决定输出 `A`、`B` 或 `T`。

我们可以使用 Python 的`if`语句来做这些决定。一个*条件*是一个真假表达式，`if`语句利用条件来决定做什么。`if`语句导致*条件执行*，这个名字的由来是程序的执行受到条件的影响。

我们将首先了解一种新类型，允许我们表示真假值，以及如何构建这种类型的表达式。然后，我们将使用这些表达式编写 `if` 语句。

### 布尔类型

将一个表达式传递给 Python 的`type`函数，它会告诉你该表达式值的类型：

```py
>>> type(14)

<class 'int'>

>>> type(9.5)

<class 'float'>

 >>> type('hello')

<class 'str'>

>>> type(12 + 15)

<class 'int'>
```

我们还没有遇到的 Python 类型是布尔（`bool`）类型。与整数、字符串和浮点数不同，它们有数十亿个可能的值，布尔类型只有两个值：`True` 和 `False`。这正是我们用来表示条件结果的值。

```py
>>> True

True

>>> False

False

>>> type(True)

<class 'bool'>

>>> type(False)

<class 'bool'>
```

我们能用这些值做什么呢？对于数字，我们有像 `+` 和 `-` 这样的数学运算符，允许我们将值组合成更复杂的表达式。我们需要一组新的运算符来处理布尔值。

### 关系运算符

`5` 是否大于 `2`？`4` 是否小于 `1`？我们可以使用 Python 的*关系运算符*来进行这些比较。它们返回 `True` 或 `False`，因此用于编写*布尔表达式*。

`>`运算符接受两个操作数，如果第一个大于第二个则返回`True`，否则返回`False`：

```py
>>> 5 > 2

True

>>> 9 > 10

False
```

同样，我们有 `<` 运算符表示小于：

```py
>>> 4 < 1

False

>>> -2 < 0

True
```

`>=` 表示大于或等于，`<=` 表示小于或等于：

```py
>>> 4 >= 2

True

>>> 4 >= 4

 True

>>> 4 >= 5

False

>>> 8 <= 6

False
```

为了判断相等，我们使用`==`运算符。那是两个等号，而不是一个。记住，一个等号（`=`）用于赋值语句；它与检查相等无关。

```py
>>> 5 == 5

True

>>> 15 == 10

False
```

对于不等式，我们使用 `!=` 运算符。如果操作数不相等，它返回 `True`，如果相等，它返回 `False`：

```py
>>> 5 != 5

False

>>> 15 != 10

True
```

真实程序不会评估我们已经知道其值的表达式。我们不需要 Python 告诉我们 `15` 不等于 `10`。更常见的是，我们在这些表达式中使用变量。例如，`number != 10` 是一个表达式，它的值取决于 `number` 代表的内容。

关系运算符也适用于字符串。在检查相等性时，大小写是重要的：

```py
>>> 'hello' == 'hello'

True

>>> 'Hello' == 'hello'

False
```

一个字符串比另一个字符串小，如果它在字母顺序中排在前面：

```py
>>> 'brave' < 'cave'

True

>>> 'cave' < 'cavern'

True

>>> 'orange' < 'apple'

False
```

但是当同时涉及大小写字母时，事情可能会变得出人意料：

```py
>>> 'apple' < 'Banana'

False
```

很奇怪吧？这与字符在计算机中存储的方式有关。通常，大写字母按字母顺序排在小写字母之前。看看这个：

```py
>>> '10' < '4'

True
```

如果这些是数字，那么结果将是`False`。但是字符串是逐个字符地从左到右比较的。Python 比较`'1'`和`'4'`，因为`'1'`较小，所以`<`运算符返回`True`。确保你的值具有你认为它们应该有的类型！

一个对字符串有效但对数字无效的关系运算符是`in`。如果第一个字符串至少出现在第二个字符串中一次，它返回`True`，否则返回`False`：

```py
>>> 'ppl' in 'apple'

True

>>> 'ale' in 'apple'

False
```

**概念检查**

以下代码的输出是什么？

```py
a = 3

b = (a != 3)

print(b)
```

A. `True`

B. `False`

C. `3`

D. 这段代码会产生语法错误

答案：B. 表达式`a != 3`的值为`False`；然后`b`被赋值为这个`False`值。

### `if`语句

现在我们来探讨 Python 的`if`语句的几种变体。

#### 单独使用`if`

假设我们有两个变量`apple_total`和`banana_total`存储最终分数，我们希望如果`apple_total`大于`banana_total`时输出`A`。下面是实现方法：

```py
>>> apple_total = 20

>>> banana_total = 6

>>> if apple_total > banana_total:

...     print('A')

...

A
```

Python 输出`A`，正如我们所预期的那样。

`if`语句以关键字`if`开始。*关键字*是 Python 中特别有意义的单词，不能作为变量名使用。关键字`if`后跟布尔表达式，接着是冒号，然后是一个或多个缩进的语句。缩进的语句通常被称为`if`语句的*代码块*。当布尔表达式为`True`时，代码块执行；当布尔表达式为`False`时，代码块被跳过。

注意到提示符从`>>>`变成了`...`。这是一个提醒，表示我们在`if`语句的代码块内部，必须缩进代码。我选择了使用四个空格进行缩进，因此按空格键四次来缩进代码。某些 Python 程序员会按 TAB 键来缩进，但在本书中我们将仅使用空格。

一旦你输入`print('A')`并按下 ENTER 键，你应该看到另一个`...`提示符。由于我们在这个`if`语句中没有其他内容需要写，再按一次 ENTER 键来取消此提示符并返回到`>>>`提示符。这个额外的 ENTER 按键是 Python Shell 的一个特点；当我们在文件中编写 Python 程序时，不需要这些空白行。

让我们看一个例子，在`if`语句的代码块中放入两个语句：

```py
>>> apple_total = 20

>>> banana_total = 6

>>> if apple_total > banana_total:

...     print('A')

...     print('Apples win!')

...

A

Apples win!
```

两个`print`调用都执行，输出两行内容。

让我们试试另一个`if`语句，这次使用一个布尔表达式，其值为`False`：

```py
>>> apple_total = 6

>>> banana_total = 20

 >>> if apple_total > banana_total:

...     print('A')

...
```

这次没有调用`print`函数：`apple_total > banana_total`为`False`，所以`if`语句的代码块被跳过。

#### 使用`elif`的`if`语句

让我们使用三个连续的`if`语句来打印`A`（如果苹果获胜），`B`（如果香蕉获胜），以及`T`（如果是平局）：

```py
>>> apple_total = 6

>>> banana_total = 6

>>> if apple_total > banana_total:

...     print('A')

...

>>> if banana_total > apple_total:

...     print('B')

...

>>> if apple_total == banana_total:

...     print('T')

...

T
```

第一个和第二个`if`语句的代码块被跳过，因为它们的布尔表达式是`False`。但是第三个`if`语句的代码块执行了，输出了`T`。

当你将一个`if`语句放在另一个后面时，它们是独立的。每个布尔表达式都会被评估，无论前面的布尔表达式是`True`还是`False`。

对于任何给定的`apple_total`和`banana_total`的值，只有一个`if`语句能够运行。例如，如果`apple_total > banana_total`为`True`，那么第一个`if`语句将会运行，而其他两个则不会。可以编写代码突出显示只有一个代码块被允许执行。以下是我们可以如何实现：

```py
❶ >>> if apple_total > banana_total:

   ...     print('A')

❷ ... elif banana_total > apple_total:

   ...     print('B')

   ... elif apple_total == banana_total:

   ...     print('T')

   ...

   T
```

这现在是一个单独的`if`语句，而不是三个独立的`if`语句。因此，不要在`...`提示符下按回车键；而是直接输入`elif`行。

为了执行这个`if`语句，Python 首先评估第一个布尔表达式 ❶。如果它为`True`，则输出`A`，并跳过其余的`elif`语句。如果它为`False`，Python 会继续，评估第二个布尔表达式 ❷。如果它为`True`，则输出`B`，并跳过剩下的`elif`语句。如果它为`False`，Python 会继续，评估第三个布尔表达式 ❸。如果它为`True`，则输出`T`。

关键字`elif`代表“else-if”。可以用它来提醒自己，`elif`表达式只有在之前的`if`语句没有执行时才会被检查。

这版代码等同于我们之前使用了三个独立的`if`语句的版本。如果我们希望允许执行多个代码块，就必须使用三个独立的`if`语句，而不是一个带有`elif`块的单个`if`语句。

#### 带有`else`的`if`

我们可以使用`else`关键字来在`if`语句中的所有布尔表达式为`False`时执行代码。以下是一个示例：

```py
>>> if apple_total > banana_total:

...     print('A')

... elif banana_total > apple_total:

...     print('B')

... else:

...     print('T')

...

T
```

Python 会从上到下评估布尔表达式。如果其中任何一个为`True`，Python 会执行相关的代码块并跳过其余的`if`语句。如果所有布尔表达式都为`False`，Python 会执行`else`块。

请注意，代码中不再测试`apple_total == banana_total`。只有当`apple_total > banana_total`为`False`且`banana_total > apple_total`为`False`时，才能进入`else`部分，即当两个值相等时。

是否应该使用独立的`if`语句？使用带有`elif`的`if`语句？还是使用带有`else`的`if`语句？这通常取决于个人偏好。如果你希望最多只有一个代码块执行，可以使用一系列的`elif`语句。`else`可以帮助使代码更清晰，并且去除了编写兜底布尔表达式的需求。比起`if`语句的具体写法，编写正确的逻辑才是最重要的！

**概念检查**

以下代码执行后，`x`的值是多少？

```py
x = 5

if x > 2:

    x = -3

if x > 1:

    x = 1

else:

    x = 3
```

A. `-3`

B. `1`

C. `2`

D. `3`

E. `5`

答案：D。因为`x > 2`为`True`，所以第一个`if`语句的代码块会执行。赋值`x = -3`使得`x`指向`-3`。接下来是第二个`if`语句。这里，`x > 1`为`False`，因此执行`else`代码块，`x = 3`使得`x`指向`3`。我建议将`if x > 1`改为`elif x > 1`并观察程序行为如何变化！

**概念检查**

这两个代码片段执行的是否完全相同？假设`temperature`已经是一个数字。

代码片段 1：

```py
if temperature > 0:

    print('warm')

elif temperature == 0:

    print('zero')

else:

    print('cold')
```

代码片段 2：

```py
if temperature > 0:

    print('warm')

elif temperature == 0:

    print('zero')

print('cold')
```

A. 是的

B. 不是

答案：B。代码片段 2*始终*将`cold`作为最终输出行打印，因为`print('cold')`没有缩进！它不与任何`if`语句相关联。

### 解题步骤

现在是时候解决“胜利团队”问题了。在本书中，我通常会先展示完整代码，然后进行讨论。但由于我们的解决方案比第一章的要长，我决定先分三部分展示代码，再将其合并。

首先，我们需要读取输入。这需要进行六次`input`调用，因为我们有两个队，每个队有三项信息。我们还需要将每项输入转换为整数。以下是代码：

```py
apple_three = int(input())

apple_two = int(input())

apple_one = int(input())

banana_three = int(input())

banana_two = int(input())

banana_one = int(input())
```

第二，我们需要确定“苹果队”和“香蕉队”各自的得分。对于每个队，我们将三分、两分和一分的得分相加。可以按以下方式进行：

```py
apple_total = apple_three * 3 + apple_two * 2 + apple_one

banana_total = banana_three * 3 + banana_two * 2 + banana_one
```

第三，我们生成输出。如果“苹果队”获胜，则输出`A`；如果“香蕉队”获胜，则输出`B`；否则，我们知道比赛是平局，因此输出`T`。我们使用`if`语句来实现这一点，如下所示：

```py
if apple_total > banana_total:

    print('A')

 elif banana_total > apple_total:

    print('B')

else:

    print('T')
```

这就是我们需要的全部代码。请参见代码清单 2-1 获取完整解决方案。

```py
apple_three = int(input())

apple_two = int(input())

apple_one = int(input())

banana_three = int(input())

banana_two = int(input())

banana_one = int(input())

apple_total = apple_three * 3 + apple_two * 2 + apple_one

banana_total = banana_three * 3 + banana_two * 2 + banana_one

if apple_total > banana_total:

    print('A')

elif banana_total > apple_total:

    print('B')

else:

    print('T')
```

*代码清单 2-1：解决胜利团队问题*

如果您将我们的代码提交给评测系统，您应该会看到所有测试用例都通过了。

**概念检查**

以下版本的代码是否正确解决了问题？

```py
apple_three = int(input())

apple_two = int(input())

apple_one = int(input())

banana_three = int(input())

banana_two = int(input())

banana_one = int(input())

apple_total = apple_three * 3 + apple_two * 2 + apple_one

banana_total = banana_three * 3 + banana_two * 2 + banana_one

if apple_total < banana_total:

    print('B')

elif apple_total > banana_total:

    print('A')

else:

    print('T')
```

A. 是的

B. 不是

答案：A。操作符和代码的顺序不同，但代码仍然是正确的。如果“苹果队”输掉了比赛，则输出`B`（因为“香蕉队”获胜）；如果“苹果队”获胜，则输出`A`；否则，我们知道比赛是平局，因此输出`T`。

在继续之前，您可能想尝试解决“章节练习”中的第 1 题，见第 45 页。

### 问题 #4：电话推销员

有时我们需要编码比我们目前看到的更复杂的布尔表达式。在这个问题中，我们将学习有助于此的布尔运算符。

这是 DMOJ 问题`ccc18j1`。

#### 挑战

在这个问题中，我们假设电话号码是四位数。如果一个电话号码的四个数字满足以下三项条件之一，那么它就属于电话推销员：

+   第一个数字是`8`或`9`。

+   第四位数字是`8`或`9`。

+   第二和第三位数字相同。

例如，一个电话号码`8119`属于电话推销员。

确定一个电话号码是否属于电话推销员，并指示我们是否应该接电话或忽略它。

#### 输入

输入有四行。这些行分别给出了电话号码的第一位、第二位、第三位和第四位数字。每个数字都是介于 0 和 9 之间的整数。

#### 输出

如果电话号码属于电话推销员，输出`ignore`；否则，输出`answer`。

### 布尔运算符

一个电话号码如果属于电话推销员，必须满足什么条件？它的第一位数字必须是`8` *或* `9`。*并且*，它的第四位数字也必须是`8` *或* `9`。*并且*，第二位和第三位数字必须相同。我们可以使用 Python 的*布尔运算符*来编码这个“或”和“与”的逻辑。

#### or 运算符

`or`运算符接受两个布尔表达式作为操作数。如果至少有一个操作数为`True`，则返回`True`，否则返回`False`：

```py
>>> True or True

True

>>> True or False

True

>>> False or True

True

>>> False or False

False
```

唯一能让`or`运算符返回`False`的情况是它的两个操作数都为`False`。

我们可以使用`or`来判断一个数字是`8`还是`9`：

```py
>>> digit = 8

>>> digit == 8 or digit == 9

True

>>> digit = 3

>>> digit == 8 or digit == 9

False
```

请记住，在第一章的“整数和浮点数”中，Python 使用运算符优先级来决定运算符应用的顺序。`or`的优先级低于关系运算符的优先级，这意味着我们通常不需要在操作数周围加上括号。例如，在`digit == 8 or digit == 9`中，`or`的两个操作数是`digit == 8`和`digit == 9`。这与我们写成`(digit == 8) or (digit == 9)`是一样的。

用英语表达，“如果数字是 8 或 9”是合理的。但这样写在 Python 中不起作用：

```py
>>> digit = 3

>>> if digit == 8 or 9:

 ...     print('yes!')

...

yes!
```

注意我（错误地！）将第二个操作数写成了`9`，而不是`digit == 9`。Python 输出了`yes!`，这显然不是我们希望的结果，因为`digit`指的是`3`。原因是 Python 将非零数字视为`True`。由于`9`被视为`True`，这使得整个`or`表达式为`True`。在将自然语言翻译成 Python 时，请仔细检查你的布尔表达式，以避免这类错误。

#### and 运算符

`and`运算符返回`True`，当它的两个操作数都为`True`时，否则返回`False`：

```py
>>> True and True

True

>>> True and False

False

>>> False and True

False

>>> False and False

False
```

唯一能让`And`运算符返回`True`的情况是它的两个操作数都为`True`。

`and`的优先级高于`or`。以下是为什么这很重要的一个示例：

```py
>>> True or True and False

True
```

Python 会这样解析该表达式，首先执行`and`：

```py
>>> True or (True and False)

True
```

结果为`True`，因为`or`的第一个操作数为`True`。

我们可以通过括号强制让`or`先发生：

```py
>>> (True or True) and False

False
```

结果为`False`，因为`and`的第二个操作数为`False`。

#### not 运算符

另一个重要的布尔运算符是`not`。与`or`和`and`不同，`not`只接受一个操作数（而不是两个）。如果其操作数为`True`，则`not`返回`False`，反之亦然：

```py
>>> not True

False

>>> not False

True
```

`not`的优先级高于`or`和`and`。

**概念检查**

这是一个表达式及其带括号的不同版本。哪个版本的值为 `True`？

A. `not True and False`

B. `(not True) and False`

C. `not (True and False)`

D. 以上都不是

答案：C。表达式 `(True and False)` 的值为 `False`；因此，`not` 会使整个表达式的值为 `True`。

**概念检查**

考虑表达式 `not a or b`。

以下哪项使得表达式的值为 `False`？

A. `a False`，`b False`

B. `a False`，`b True`

C. `a True`，`b False`

D. `a True`，`b True`

E. 以上多个选项

答案：C。如果 `a` 为 `True`，则 `not a` 为 `False`。由于 `b` 也为 `False`，所以 `or` 运算符的两个操作数都是 `False`，因此整个表达式的值为 `False`。

### 解决问题

使用布尔运算符，我们可以解决电话推销员问题。我们的解决方案在 清单 2-2 中。

```py
   num1 = int(input())

   num2 = int(input())

   num3 = int(input())

   num4 = int(input())

❶ if ((num1 == 8 or num1 == 9) and

           (num4 == 8 or num4 == 9) and

           (num2 == num3)):

       print('ignore')

   else:

       print('answer')
```

*清单 2-2：解决电话推销员问题*

如同“获胜团队”章节一样，我们首先读取输入并将其转换为整数。

我们的 `if` 语句的高级结构 ❶ 由三个用 `and` 运算符连接的表达式组成；它们每一个都必须为 `True`，整个表达式才为 `True`。我们要求第一个数字是 `8` 或 `9`，第四个数字是 `8` 或 `9`，第二个和第三个数字相等。如果这三个条件都满足，那么我们知道该电话号码属于电话推销员，我们输出 `ignore`。否则，电话号码不属于电话推销员，我们输出 `answer`。

我将布尔表达式拆分为三行。这要求将整个表达式用一对额外的括号括起来，正如我所做的那样。（如果没有这些括号，你会遇到语法错误，因为 Python 不知道该表达式将在下一行继续。）

Python 风格指南建议一行代码长度不超过 79 个字符。带有完整布尔表达式的一行代码长度为 76 个字符，正好符合要求。但我认为三行版本更清晰，将每个条件单独列出。

我们这里有一个很好的解决方案。为了进一步探索，让我们讨论一些其他的方法。

我们的代码使用布尔表达式来检测电话号码是否属于电话推销员。我们也可以选择编写代码来检测电话号码是否*不*属于电话推销员。如果电话号码不属于电话推销员，我们应该输出 `answer`；否则，我们应该输出 `ignore`。

如果第一个数字不是 `8` 且不是 `9`，则电话号码不属于电话推销员。或者，如果第四个数字不是 `8` 且不是 `9`，则电话号码不属于电话推销员。或者，如果第二和第三个数字不相等，则电话号码不属于电话推销员。如果这些表达式中有任何一个为 `True`，则电话号码不属于电话推销员。

请参见 清单 2-3 了解捕获此逻辑的代码版本。

```py
num1 = int(input())

num2 = int(input())

num3 = int(input())

num4 = int(input())

if ((num1 != 8 and num1 != 9) or

        (num4 != 8 and num4 != 9) or

        (num2 != num3)):

    print('answer')

else:

    print('ignore')
```

*清单 2-3：解决推销员问题，替代方法*

要正确使用所有这些`!=`、`or`和`and`运算符可不容易！例如，注意我们已经将所有的`==`运算符改为`!=`，所有的`or`运算符改为`and`，所有的`and`运算符改为`or`。

另一种方法是使用`not`运算符来一次性否定“是推销员”的表达式。可以查看清单 2-4 中的代码。

```py
num1 = int(input())

num2 = int(input())

num3 = int(input())

num4 = int(input())

if not ((num1 == 8 or num1 == 9) and

        (num4 == 8 or num4 == 9) and

        (num2 == num3)):

    print('answer')

else:

    print('ignore')
```

*清单 2-4：解决推销员问题，使用非运算符*

你认为哪一种解决方案最直观？通常有不止一种方式来构建`if`语句的逻辑，我们应该选择最容易正确实现的方式。对我来说，清单 2-2 是最自然的，但你可能有不同的看法！

选择你最喜欢的版本并提交给评测系统。你应该看到所有的测试用例都通过了。

### 注释

我们应该始终努力使我们的程序尽可能清晰。这有助于避免在编程时引入错误，并使在错误发生时更容易修复代码。具有意义的变量名、运算符周围的空格、分割程序逻辑部分的空行、简单的`if`语句逻辑：所有这些做法都能提高我们编写代码的质量。另一个好习惯是为我们的代码添加*注释*。

注释是通过`#`字符引入的，并且会一直持续到行末。Python 会忽略注释，因此它们对程序的执行没有任何影响。我们添加注释是为了提醒自己或他人关于我们所做的设计决策。假设阅读代码的人懂 Python，所以避免写那些只是简单重复代码功能的注释。下面是一个带有不必要注释的代码：

```py
>>> x = 5

>>> x = x + 1  # Increase x by 1
```

这个注释除了我们已经知道的赋值语句之外，并没有提供任何额外的信息。

可以查看清单 2-5 中的版本，那里是清单 2-2 的注释版。

```py
❶ # ccc18j1, Telemarketers

   num1 = int(input())

   num2 = int(input())

   num3 = int(input())

   num4 = int(input())

❷ # Telemarketer number: first digit 8 or 9, fourth digit 8 or 9,

   # second digit and third digit are same

   if ((num1 == 8 or num1 == 9) and

           (num4 == 8 or num4 == 9) and

           (num2 == num3)):

       print('ignore')

   else:

       print('answer')
```

*清单 2-5：解决推销员问题，已添加注释*

我添加了三行注释：顶部的那一行❶提醒我们问题代码和名称，而`if`语句前的两行❷提醒我们如何识别推销员的电话号码。

不要过度使用注释。尽可能编写不需要注释的代码。如果代码比较复杂，或者需要记录你为何以某种方式编写代码，那么现在添加一个适当的注释将能为以后节省时间和减少挫败感。

### 输入和输出重定向

当你将 Python 代码提交给评测系统时，它会运行许多测试用例来确定代码是否正确。难道有人在那里，忠实地等待新代码，并且疯狂地从键盘上敲下测试用例？

不可能！这一切都是自动化的。没有人在键盘上输入测试用例。那么，如果我们通过键盘输入某些内容来满足`input`的调用，评测系统是如何测试我们的代码的呢？

事实上，`input`不一定是从键盘读取输入。它是从一个名为*标准输入*的输入源读取，默认情况下，标准输入就是键盘。

可以更改标准输入，使其指向文件而不是键盘。这种技术称为*输入重定向*，它是评测系统用来提供输入的方式。

我们也可以自己尝试输入重定向。对于输入较小的程序——比如一行文本或几个整数——输入重定向可能不会节省太多时间。但对于那些测试用例可能有几十行甚至上百行的程序，输入重定向能大大简化测试工作。我们可以将测试用例保存在文件中，然后多次运行程序，而不需要一遍遍地手动输入。

让我们尝试在电话营销程序上使用输入重定向。进入你的*programming*文件夹，创建一个名为*telemarketers_input.txt*的新文件。在该文件中输入以下内容：

```py
8

1

1

9
```

该问题要求我们每行提供一个整数，所以我们在这里按行写下它们。

保存文件后，输入`python telemarketers.py < telemarketers_input.txt`来使用输入重定向运行程序。你的程序应该输出`ignore`，就像你从键盘输入测试用例时一样。

`<`符号指示操作系统使用文件而不是键盘提供输入。`<`符号后面是包含输入的文件名。

要在不同的测试用例上尝试你的程序，只需修改*telemarketers_input.txt*文件并重新运行程序。

我们也可以改变输出的去向，尽管在本书中我们不需要这样做。`print`函数默认输出到*标准输出*，即屏幕。我们可以改变标准输出，使其指向文件。通过使用*输出重定向*，它是一个`>`符号后跟一个文件名。

输入`python telemarketers.py > telemarketers_output.txt`来使用输出重定向运行程序。输入四个整数后，你应该回到操作系统的提示符。但你不应该看到来自电话营销程序的任何输出！这是因为我们将输出重定向到了文件`telemarketers_output.txt`。如果你在文本编辑器中打开`telemarketers_output.txt`，应该能在那里看到输出。

小心输出重定向。如果你使用已经存在的文件名，旧的文件将被覆盖！请始终仔细检查你使用的文件名是否是你预期的。

### 总结

在本章中，我们学习了如何使用`if`语句来控制程序的行为。`if`语句的关键部分是布尔表达式，它是一个值为`True`或`False`的表达式。为了构建布尔表达式，我们使用关系运算符，如`==`和`>=`，以及布尔运算符，如`and`和`or`。

根据 `True` 和 `False` 来决定做什么，使我们的程序更加灵活，能够根据实际情况做出调整。但我们的程序仍然局限于处理少量的输入和输出——无论是使用单独的 `input` 和 `print` 调用能做到什么。下一章，我们将开始学习循环，它让我们能够重复代码，从而处理任意多的输入和输出。

想要处理 100 个值吗？那 1,000 个怎么样？而且只需要一点点 Python 代码？我知道现在挑衅你有点早，因为你还需要完成以下练习。但当你准备好时，继续往下读吧！

### 章节练习

这里有一些练习供你尝试。

1.  DMOJ 问题 `ccc06j1`，加拿大卡路里计算

1.  DMOJ 问题 `ccc15j1`，特别的日子

1.  DMOJ 问题 `ccc15j2`，快乐还是悲伤

1.  DMOJ 问题 `dmopc16c1p0`，C.C. 和 Cheese-kun

1.  DMOJ 问题 `ccc07j1`，谁在中间

### 备注

《获胜团队》原本来自 2019 年加拿大计算机竞赛，初级水平。《电话推销员》原本来自 2018 年加拿大计算机竞赛，初级水平。
