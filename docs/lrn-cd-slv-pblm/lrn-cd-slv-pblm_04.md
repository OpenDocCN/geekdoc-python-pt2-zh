## 重复代码：无限循环

![image](img/common.jpg)

在第三章中你学到的`for`循环和范围`for`循环对于循环遍历字符串或索引范围非常方便。但如果我们没有字符串，或者索引不遵循固定的模式，该怎么办？我们使用`while`循环，这是本章的主题。`while`循环比`for`循环更通用，能够处理`for`循环无法处理的情况。

我们将解决三个`for`循环不适用的问题：确定老虎机可以玩多少次，组织一个歌曲播放列表直到用户想停止，以及解码一个编码消息。

### 问题 #8：老虎机

老虎机最多能玩多少次，直到我们没有钱了？这是一个微妙的问题，它不仅取决于我们最初的资金，还取决于我们玩游戏时的中奖模式。我们会看到，在这种情况下，我们需要使用`while`循环，而不是`for`循环。

这是 DMOJ 题目`ccc00s1`。

#### 挑战

玛莎去赌场并带了*n*个硬币。赌场有三台老虎机，她按顺序玩它们，直到她没有硬币为止。也就是说，她先玩第一台老虎机，然后是第二台，再是第三台，然后回到第一台，接着是第二台，依此类推。每次游戏消耗一个硬币。

老虎机的规则如下：

+   第一台老虎机每玩第 35 次就会支付 30 个币。

+   第二台老虎机每玩第 100 次就会支付 60 个币。

+   第三台老虎机每玩第 10 次就会支付 9 个币。

+   没有其他的游戏会支付任何奖金。

确定玛莎在没有硬币之前玩了多少次。

#### 输入

输入由四行组成。

+   第一行包含一个整数*n*，表示玛莎带到赌场的硬币数量。*n*在 1 和 1000 之间。

+   第二行包含一个整数，表示第一台老虎机自上次支付以来已经被玩了多少次。这些游戏发生在玛莎到达之前，玛莎的游戏从那里开始。例如，假设第一台老虎机自上次支付以来已经被玩了 34 次。那么玛莎第一次玩时将获得 30 个币。

+   第三行包含一个整数，表示第二台老虎机自上次支付以来已经被玩了多少次。

+   第四行包含一个整数，表示自上次支付以来第三台老虎机已经被玩了多少次。

#### 输出

输出以下句子，其中 x 是玛莎在没有硬币之前玩了多少次：

```py
Martha plays x times before going broke.
```

### 探索测试用例

让我们通过一个例子来确保这个问题中的所有内容都清楚。以下是我们将使用的测试用例：

```py
7

28

 0

8
```

为了仔细追踪玛莎的游戏，我们需要记录六个信息。使用表格来做这件事非常方便，因为每一行都可以告诉我们每次游戏后的状态。下面是我们的列：

**游戏次数** 是指玛莎已经玩过多少台老虎机

**硬币数量** 是指玛莎拥有的硬币数

**下一次游戏** 是玛莎将要玩的老虎机

**第一次游戏** 是指自上次支付以来，第一台老虎机被玩了多少次

**第二次游戏** 是指自上次支付以来，第二台老虎机被玩了多少次

**第三次游戏** 是指自上次支付以来，第三台老虎机被玩了多少次

一开始，玛莎没有玩过任何老虎机，她有七枚硬币，接下来她将玩第一台老虎机。第一台老虎机自上次支付以来已经被玩了 28 次，第二台已经被玩了 0 次，第三台已经被玩了 8 次。我们的状态如下：

| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |
| --- | --- | --- | --- | --- | --- |
| 0 | 7 | first | 28 | 0 | 8 |

玛莎开始玩第一台老虎机，花费一枚硬币。因为这是自上次支付以来，这台机器已经被玩了 29 次，而不是第 35 次，所以下这台老虎机并不会给玛莎任何奖励。接下来，玛莎将玩第二台老虎机。这是我们的新状态：

| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |
| --- | --- | --- | --- | --- | --- |
| 1 | 6 | second | 29 | 0 | 8 |

玩第二台老虎机需要花费一枚硬币。因为这是自上次支付以来，这台机器第一次被玩，而不是第 100 次，所以下这台老虎机并不会给玛莎任何奖励。接下来，玛莎将玩第三台老虎机。这是我们的新状态：

| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |
| --- | --- | --- | --- | --- | --- |
| 2 | 5 | third | 29 | 1 | 8 |

玩第三台老虎机需要花费一枚硬币。因为这是自上次支付以来，这台机器已经被玩了 9 次，而不是第 10 次，所以下这台老虎机并不会给玛莎任何奖励。接下来，玛莎将返回到第一台老虎机。 这是我们的新状态：

| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |
| --- | --- | --- | --- | --- | --- |
| 3 | 4 | first | 29 | 1 | 9 |

现在玛莎玩第一台老虎机：

| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |
| --- | --- | --- | --- | --- | --- |
| 4 | 3 | second | 30 | 1 | 9 |

然后玛莎玩第二台老虎机：

| **游戏次数** | **硬币数量** | **下一次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |
| --- | --- | --- | --- | --- | --- |
| 5 | 2 | third | 30 | 2 | 9 |

玛莎快没硬币了！但好消息来了，因为她接下来要玩第三个老虎机。自从上次支付以来，这台机器已经被玩了九次。因此，下次游戏是它的第十次，这次会支付玛莎九个硬币。她原本有两个硬币，支付一个硬币来玩这台机器，然后获得九个硬币，所以这次游戏后她将有 2 – 1 + 9 = 10 个硬币：

| **游戏次数** | **投币次数** | **下次游戏** | **第一次游戏** | **第二次游戏** | **第三次游戏** |
| --- | --- | --- | --- | --- | --- |
| 6 | 10 | 第一次 | 30 | 2 | 0 |

注意，第三台老虎机自上次支付以来，已经玩了零次。

到目前为止已经进行了六次游戏。我鼓励你继续追踪。你应该能看到玛莎再也没有拿到任何报酬，而且在再进行 10 次游戏（共 16 次）后，玛莎破产了。

### `for` 循环的局限性

在 第三章中，我们学习了 `for` 循环。标准的 `for` 循环是遍历一个序列，比如字符串。但在老虎机问题中，我们显然没有字符串。

Range `for` 循环遍历一系列整数，并且可以用于循环指定次数。但我们应该为老虎机循环多少次呢？十次？五十次？谁知道呢。这取决于玛莎在破产前能玩多少次。

我们没有字符串，也不知道需要多少次迭代。如果我们只有 `for` 循环，那就会卡住。

进入 *while 循环*，Python 提供的最通用的循环结构。我们可以编写与字符串或整数序列无关的 `while` 循环。为了获得这种灵活性，我们需要更加小心，并且在编写循环时承担更多责任。让我们深入了解吧！

### while 循环

要编写一个 `while` 循环，我们使用 Python 的 `while` 语句。`while` 循环由一个布尔表达式控制。如果布尔表达式为 `True`，Python 就会执行一次 `while` 循环。如果该表达式仍然为 `True`，Python 将执行另一次循环，以此类推，直到布尔表达式为 `False`。如果一开始布尔表达式为 `False`，则循环根本不会执行。

`while` 循环是 *不定次循环*：循环的次数可能事先无法知道。

#### 使用 while 循环

让我们从以下 `while` 循环的例子开始：

```py
❶ >>> num = 0

❷ >>> while num < 5:

  ...      print(num)

❸ ...     num = num + 1

  ...

  0

  1

  2

  3

  4
```

在 `for` 循环中，循环变量是由 Python 自动创建的；我们不需要在循环之前使用赋值语句来创建变量。但在 `while` 循环中，我们什么也得不到。如果我们需要一个变量来遍历 `while` 循环中的值，那么我们必须自己创建这个变量。我们通过在循环之前让 `num` 指向 `0` 来做到这一点 ❶。

`while` 循环本身由布尔表达式 `num < 5` ❷ 控制。如果 `num < 5` 为 `True`，那么循环体中的代码将执行。现在，`num` 为 `0`，所以布尔表达式为 `True`。因此，我们运行循环体，输出 `0`，然后将 `num` 增加到 `1` ❸。

我们跳回循环的顶部，再次评估`num < 5`的布尔表达式。由于`num`为`1`，表达式为`True`。因此我们再次执行循环块，输出`1`，并将`num`增加到`2`。

回到循环的开始：`num < 5`还为`True`吗？是的，因为`num`现在是`2`。这会启动循环的另一次迭代，输出`2`，并将`num`增加到`3`。

这种模式会继续下去，循环还有两次迭代：一次当`num`为`3`时，一次当`num`为`4`时。当`num`为`5`时，`num < 5`的布尔表达式最终为`False`，循环结束。

我们必须记得增加`num` ❸。`for`循环会自动将我们的循环变量推进到适当的值。然而，在`while`循环中，我们没有免费的“进展”，必须自己更新变量，以便逐渐接近循环终止。如果忘记增加`num`，会发生如下情况：

```py
>>> num = 0

>>> while num < 5:

...     print(num)

...

0

0

0

0

0

0

0

0

... forever
```

如果你在电脑上运行这段代码，屏幕将被零填满，程序会一直运行下去，直到你终止它。你可以按 CTRL-C 或关闭 Python 窗口来终止程序。

问题是`num < 5`永远为`True`；循环中的任何东西都无法让它变为`False`。这种循环永不终止的情况叫做*无限循环*。意外地产生无限`while`循环其实非常容易。如果你看到相同的值不断重复，或者程序似乎什么都没做，那可能是你陷入了一个无限循环。仔细检查`while`循环的布尔表达式，确保循环块正在朝着终止的方向推进。

我们可以对`num`变量进行任何操作。以下是一个`while`循环，每次增加三：

```py
>>> num = 0

>>> while num < 10:

...     print(num)

...     num = num + 3

...

0

3

6

9
```

这里是一个`while`循环，从`4`倒数到`0`：

```py
   >>> num = 4

❶ >>> while num >= 0:

   ...     print(num)

   ...     num = num - 1

   ...

   4

   3

   2

   1

   0
```

请注意，我在这里使用了`>=`而不是`>` ❶。这样，`while`循环会在`num`为`0`时执行，正是我们想要的效果。

**概念检查**

以下代码的输出是什么？

```py
n = 3

while n > 0:

    if n == 5:

        n = -100

    print(n)

    n = n + 1
```

A.

3

4

B.

3

4

5

C.

3

4

-100

D.

3

4

5

-100

答案：C。`while`循环的布尔表达式只在每次迭代开始时检查。即使在迭代过程中某个时刻它变为`False`，迭代的剩余部分仍会完成。

由于`3`大于`0`，循环执行一次。`if`语句块被跳过（因为它的布尔表达式为`False`），所以这次迭代输出`3`，并将`n`设为`4`。由于`4`大于`0`，我们再次执行循环，这次输出`4`并将`n`设为`5`。由于`5`大于`0`，我们再次执行循环。这时，`if`语句块执行，将`n`设为`-100`。接下来，输出`-100`，并将`n`设为`-99`。我们在这里停止，因为`n > 0`为`False`。

**概念检查**

以下代码的输出是什么？

```py
x = 6

while x > 4:

    x = x - 1

    print(x)
```

A.

6

5

B.

6

5

4

C.

5

4

D.

5

4

3

E.

6

5

4

3

答案：C. 许多`while`循环会执行一些操作然后更新循环变量，但这个循环不是这样。这个循环首先递减循环变量`x`，*然后*输出它。由于`6`大于`4`，循环执行了一次，`x`被赋值为`5`并输出`5`。接着，`5`大于`4`，所以我们又进行了一次迭代，这次将`x`赋值为`4`并输出`4`。就这样：`4`不大于`4`，所以循环终止。

#### 循环中的嵌套循环

我们可以在`while`循环中嵌套循环，就像我们可以在`for`循环中嵌套循环一样。在第三章的“嵌套”中，我提到过，内部`for`循环在外部循环的下一次迭代开始之前完成所有的迭代。`while`循环也一样。这里有一个例子：

```py
>>> i = 0

>>> while i < 3:

...     j = 8

...     while j < 11:

...         print(i, j)

...         j = j + 1

...     i = i + 1

...

0 8

0 9

0 10

1 8

1 9

1 10

2 8

2 9

2 10
```

每个`i`值涉及到三行输出，每行对应内部`j`循环的一次迭代。

**概念检查**

以下嵌套循环会输出多少行？

```py
x = 0

y = 1

while x < 3:

    while y < 3:

        print(x, y)

        y = y + 1

    x = x + 1
```

A. 2

B. 3

C. 6

D. 8

E. 9

答案：A. 外部循环的布尔表达式`x < 3`为`True`，所以我们执行一次外部循环的迭代。这导致内部循环进行了两次迭代：一次当`y`为`1`时，另一次当`y`为`2`时，每次都会打印一行输出。所以到目前为止，输出了两行。

但代码中没有任何内容重置`y`的值！因此，`y < 3`将再也不会为`True`，也不会有更多的内部循环迭代。

忘记重置循环变量是处理嵌套`while`循环时常见的错误。

#### 添加布尔运算符

为了解决老虎机问题，我们希望在玛莎至少有一枚硬币的情况下继续循环。像这样：

```py
while quarters >= 1:
```

这个简单的布尔表达式足以解决这个问题。但就像`if`语句一样，跟在`while`后面的布尔表达式可以包含关系运算符或布尔运算符。这里有一个例子：

```py
>>> x = 4

>>> y = 10

>>> while x <= 10 and y <= 13:

...     print(x, y)

...     x = x + 1

...     y = y + 1

 ...

4 10

5 11

6 12

7 13
```

`while`循环由布尔表达式`x <= 10 and y <= 13`控制。与任何`and`运算符一样，只有当两个操作数都为`True`时，整个表达式才为`True`。当`x`为`8`，`y`为`14`时，循环终止，因为`y <= 13`的操作数为`False`。

### 解决问题

为了解决老虎机问题，我们知道我们需要一个`while`循环，而不是`for`循环，因为我们无法预先预测迭代次数。每次循环将玩当前的老虎机。当循环终止时，玛莎将没有任何硬币，我们将输出她玩过的次数。

我们需要在每次迭代中执行以下操作：

+   将玛莎的硬币减去一个（因为玩老虎机需要一个硬币）。

+   如果玛莎当前在第一个老虎机上，玩这个机器。这涉及到增加该机器的游戏次数。如果这是第 35 次游戏，那么支付玛莎并将该机器的游戏次数重置为 0。

+   如果玛莎当前在第二个老虎机上，玩这个机器（与我们玩第一个机器的方式类似）。

+   如果玛莎目前在第三个老虎机上，就玩这个机器（类似于我们玩第一个机器的方式）。

+   增加玛莎的游戏次数（因为我们刚刚玩了一个机器）。

+   转到下一个机器。如果玛莎刚刚玩了第一个老虎机，我们要转到第二个；如果她刚刚玩了第二个，我们要转到第三个；如果她刚刚玩了第三个，我们要重新回到第一个。

我们的程序现在变得更长了，所以像我刚才那样列出计划是一个有用的技巧，可以帮助我们保持复杂性可控，并引导我们编写正确的代码。我们可以使用这个大纲来确保我们遵循计划，并没有遗漏任何步骤。

我们的代码在清单 4-1 中。

```py
   quarters = int(input())

   first = int(input())

   second = int(input())

   third = int(input())

 plays = 0

❶ machine = 0

❷ while quarters >= 1:

    ❸ quarters = quarters - 1

    ❹ if machine == 0:

           first = first + 1

        ❺ if first == 35:

               first = 0

               quarters = quarters + 30

       elif machine == 1:

           second = second + 1

           if second == 100:

               second = 0

               quarters = quarters + 60

       elif machine == 2:

           third = third + 1

           if third == 10:

               third = 0

               quarters = quarters + 9

    ❻ plays = plays + 1

    ❼ machine = machine + 1

    ❽ if machine == 3:

           machine = 0

   print('Martha plays', plays, 'times before going broke.')
```

*清单 4-1：解决老虎机问题*

`quarters`变量跟踪玛莎拥有的硬币数量。`first`、`second`和`third`变量分别跟踪第一个、第二个和第三个老虎机自上次支付以来的游戏次数。

`machine`变量跟踪玛莎接下来将玩的老虎机。第一个老虎机用数字`0`表示，第二个用数字`1`表示，第三个用数字`2`表示。因此，将`machine`设置为`0`意味着接下来会玩第一个老虎机 ❶。

我们本可以用`1`、`2`和`3`来表示老虎机，而不是`0`、`1`和`2`。或者我们可以使用字符串：`'first'`、`'second'`和`'third'`。但是从零开始编号是惯例，因此我这里使用的是这种方式。

本程序中的最后一个变量是`plays`，它跟踪玛莎玩过的老虎机数量。当玛莎的硬币用完后，我们将输出这个变量。

程序的主体部分是一个`while`循环，循环条件是玛莎还有硬币 ❷。

循环的每次迭代都会玩一个老虎机。因此，首先我们要做的事情是减少玛莎的硬币数量 ❸。接下来，我们玩当前的老虎机。

我们是在老虎机 0 上吗？老虎机 1？老虎机 2？我们需要一个`if`语句来回答这个问题。

我们首先检查是否在老虎机 0 上 ❹。如果是，那么我们增加这个老虎机的游戏次数，因为它已经支付给玛莎。接着，我们检查这个机器自上次支付以来是否已经玩了恰好 35 次 ❺。如果是，那么我们将该机器的游戏次数重置为`0`，并增加玛莎的硬币数量 30。

这里有好几层嵌套，所以请花些时间确保代码的逻辑是正确的。特别是要注意，每次我们玩第一个老虎机时，我们都会将其游戏次数增加 1。但我们只有在每玩 35 次后才会支付玛莎——这就是为什么我们有内层的`if`语句 ❺！

我们处理第二和第三个老虎机的方式与处理第一个老虎机相同。唯一的区别是每个老虎机在其自有的游戏次数后支付给玛莎，并支付给她相应的硬币数量。

玩过老虎机后，我们将玛莎的游戏次数增加 1 ❻。现在只剩下移动到下一个机器，以确保如果循环有下一次迭代，我们能在正确的机器上。

要移动到下一个机器，我们将 `machine` 增加 1 ❼。如果我们在机器 `0` 上，这将使我们移到机器 `1`。如果我们在机器 `1` 上，这将使我们移到机器 `2`。如果我们在机器 `2` 上，这将使我们移到机器 `3`。

*...* 机器 3？没有机器 3！如果我们刚玩过机器 2，那么我们希望从机器 0 开始重新开始。为此，我们添加了一个检查：如果我们刚移到机器 `3` ❽，那么我们知道我们刚玩过机器 `2`，所以我们将 `machine` 重置为机器 `0`。

当循环终止时，我们知道玛莎已经没有硬币了。最后一步，我们输出所需的句子，包括玛莎玩了多少次。

这段代码包含了很多内容：在玛莎没有硬币时停止，跟踪当前机器，适时支付玛莎，并计算玛莎的游戏次数。现在可以提交这段代码，但也可以考虑是否有其他方式编写部分代码。如果你将 `plays` 在循环顶部增加 1，而不是底部，会发生什么？将 `quarters` 在循环顶部或底部减 1 有区别吗？你是否会使用新变量来跟踪玛莎玩过每台老虎机的次数，而不是修改 `first`、`second` 和 `third`？我强烈建议你尝试不同的变体。如果你做了修改，代码不再通过测试，太好了！现在你有了一个新的学习机会来修复代码，并了解为什么你的修改导致了不期望的行为。

接下来的两节将进一步完善代码。我们将使用 `%` 运算符来减少需要的变量数量，并学习 f-string 以简化字符串构建。

### 模运算符

在第一章的“整数与浮点数”中，我介绍了用于计算整数除法余数的模运算符（`%`）。例如，16 除以 5 的余数是 1：

```py
>>> 16 % 5

1
```

15 除以 5 的余数是 0（因为 5 恰好能整除 15）：

```py
>>> 15 % 5

0
```

第二个操作数决定了 `%` 操作符可能返回的值的范围。可能返回的值是从 0 到但不包括第二个操作数。例如，如果第二个操作数是 `3`，那么 `%` 只能返回 0、1 和 2。此外，当我们增加第一个操作数时，我们会依次循环所有可能的返回值。这里有一个例子：

```py
>>> 0 % 3

0

>>> 1 % 3

1

>>> 2 % 3

2

>>> 3 % 3

0

>>> 4 % 3

1

>>> 5 % 3

2

>>> 6 % 3

0

>>> 7 % 3

1
```

注意这个模式：0, 1, 2, 0, 1, 2，以此类推。

这种行为对于计算到指定次数并且然后循环回 0 非常有用。这正是我们玩老虎机时所需的行为：我们先玩老虎机 0，然后是 1，然后是 2，然后是 0，再是 1，再是 2，然后是 0，再是 1，依此类推。（这也是为什么我使用 `0`、`1` 和 `2` 来表示老虎机，而不是其他值的原因。）

假设变量 `plays` 表示玛莎已玩游戏的次数。为了确定下一个要玩的机器（`0`、`1`或`2`），我们可以使用`%`运算符。例如，假设玛莎至今已经玩了一个老虎机，我们想知道她接下来会玩哪个。她将接着玩老虎机 `1`，而`%`运算符告诉我们：

```py
>>> plays = 1

>>> plays % 3

1
```

如果玛莎迄今为止玩了六次，那么她玩了老虎机 0、1、2、0、1、2。接下来她要玩的老虎机是机器 0。而且，由于她已经玩了三台机器两次，并且没有其他额外的游戏，`%` 运算符给我们带来了 `0`：

```py
>>> plays = 6

>>> plays % 3

0
```

作为最后一个例子，假设玛莎已经玩了 11 次。她完成了三次完整的循环：0、1、2、0、1、2、0、1、2。那是九次游戏。剩下的两次游戏使得玛莎接下来的游戏是老虎机 2：

```py
>>> plays = 11

>>> plays % 3

2
```

也就是说，我们可以在不显式维护 `machine` 变量的情况下确定要玩的老虎机。

我们还可以使用`%`来简化逻辑，判断当前老虎机的下一次游戏是否支付玛莎。考虑第一个老虎机。在清单 4-1 中，我们计算了自上次老虎机支付以来的游戏次数。如果这个数字是 35，那么我们就支付玛莎并将计数重置为 0。但是，如果我们使用`%`运算符，就不需要重置计数。我们只需检查老虎机是否已经玩了 35 的倍数次，如果是，就支付玛莎。为了测试一个数字是否是 35 的倍数，我们可以使用`%`运算符。如果一个数字能被 35 除尽，且没有余数，那么它就是 35 的倍数：

```py
>>> first = 35

>>> first % 35

0

>>> first = 48

>>> first % 35

13

>>> first = 70

>>> first % 35

0

>>> first = 175

>>> first % 35

0
```

我们只需检查`first % 35 == 0`来确定是否支付玛莎。

我已经更新了清单 4-1，使用了`%`运算符。新代码见清单 4-2。

```py
  quarters = int(input())

  first = int(input())

  second = int(input())

  third = int(input())

  plays = 0

  while quarters >= 1:

   ❶ machine = plays % 3

     quarters = quarters - 1

     if machine == 0:

         first = first + 1

      ❷ if first % 35 == 0:

             quarters = quarters + 30

    elif machine == 1:

        second = second + 1

        if second % 100 == 0:

            quarters = quarters + 60

    elif machine == 2:

        third = third + 1

        if third % 10 == 0:

            quarters = quarters + 9

    plays = plays + 1

print('Martha plays', plays, 'times before going broke.')
```

*清单 4-2：使用* % *解决老虎机问题*

我已经在本节中以两种方式使用了`%`：一种是根据已玩次数确定当前机器❶，另一种是确定玛莎是否在某次游戏中获得奖励（例如，在❷处）。

将`%`与返回除法余数的功能联系起来掩盖了它的灵活性。每当你需要按周期计数（0, 1, 2, 0, 1, 2）时，可以考虑是否可以使用`%`来简化代码。

### F-字符串

我们在解决老虎机问题时的最后一步是输出所需的句子，如下所示：

```py
print('Martha plays', plays, 'times before going broke.')
```

我们必须记得结束第一个字符串，这样我们就可以输出播放次数，然后开始新的字符串来表示句子的后半部分。此外，我们使用多个参数来调用`print`，以避免将`plays`转换为字符串。如果我们是存储结果字符串而不是直接打印出来，我们将需要进行`str`转换：

```py
>>> plays = 6

>>> result = 'Martha plays ' + str(plays) + ' times before going broke.'

>>> result

'Martha plays 6 times before going broke.'
```

将字符串和整数拼接在一起对于像这样的简单句子是可以的，但它不能扩展。当我们尝试嵌入三个整数而不是一个时，它会变成这样：

```py
>>> num1 = 7

>>> num2 = 82

>>> num3 = 11

>>> 'We have ' + str(num1) + ', ' + str(num2) + ', and ' + str(num3) + '.'

'We have 7, 82, and 11.'
```

我们不想一直跟踪那些引号、加号和空格。

构建包含字符串和数字的字符串最灵活的方式是使用*f-string*。以下是使用 f-string 的前一个示例：

```py
>>> num1 = 7

>>> num2 = 82

>>> num3 = 11

>>> f'We have {num1}, {num2}, and {num3}.'

'We have 7, 82, and 11.'
```

注意字符串开头的`f`。`f`代表格式化，因为 f-strings 允许你格式化字符串的内容。在 f-string 内部，我们可以将表达式放在大括号中。随着字符串的构建，每个表达式都会被其值替换并插入到字符串中。结果仍然是一个普通的字符串——这里没有新的类型：

```py
>>> type(f'hello')

<class 'str'>

>>> type(f'{num1} days')

<class 'str'>
```

大括号中的表达式可以比单纯的变量名更复杂：

```py
>>> f'The sum is {num1 + num2 + num3}'

'The sum is 100'
```

我们可以在“老虎机”问题的最后一行中使用 f-strings。以下是它的表现方式：

```py
print(f'Martha plays {plays} times before going broke.')
```

即使在这个最简单的字符串格式化上下文中，我认为 f-strings 也能增加清晰度。随时记住它们，当你发现自己在从小块拼接字符串时，可以使用它们。

关于 f-strings 的一个警告：它们是在 Python 3.6 中添加的，而在写作时，Python 3.6 仍然是一个相对较新的版本。在旧版本的 Python 中，f-strings 会导致语法错误。

如果你使用 f-strings，请确保检查你提交的评测系统是否使用 Python 3.6 或更高版本来测试你的代码。

在继续之前，你可能想尝试解决“章节练习”中的练习 1，位于第 99 页。

### 问题#9：歌曲播放列表

有时候我们无法预先知道会提供多少输入。我们将在这个问题中看到，`while`循环正是我们在这种情况下需要的。

这是 DMOJ 问题`ccc08j2`。

#### 挑战

我们有五首最喜欢的歌曲，分别是 A、B、C、D 和 E。我们已经创建了一个包含这些歌曲的播放列表，并使用一个应用程序来管理这个播放列表。歌曲的顺序是 A、B、C、D、E。这个应用程序有四个按钮：

+   按钮 1：将播放列表中的第一首歌移动到播放列表的末尾。例如，如果当前的播放列表是 A、B、C、D、E，那么它将变为 B、C、D、E、A。

+   按钮 2：将播放列表中的最后一首歌移动到播放列表的开头。例如，如果当前的播放列表是 A、B、C、D、E，那么它将变为 E、A、B、C、D。

+   按钮 3：交换播放列表中的前两首歌曲。例如，如果当前的播放列表是 A、B、C、D、E，那么它将变为 B、A、C、D、E。

+   按钮 4：播放播放列表！

我们得到用户的按钮按压信息。当用户按下按钮 4 时，输出播放列表中歌曲的顺序。

#### 输入

输入由成对的行组成，其中每对的第一行给出一个按钮的编号（`1`、`2`、`3`或`4`），第二行给出用户按下该按钮的次数（介于 1 和 10 之间）。也就是说，第一行是按钮编号，第二行是按下次数，第三行是按钮编号，第四行是按下次数，依此类推。输入以这两行结束：

```py
4

1
```

表示用户按下按钮`4`一次。

#### 输出

输出播放列表中所有按钮按下后的歌曲顺序。输出必须在一行内，歌曲对之间用空格隔开。

### 字符串切片

我们解决“歌曲播放列表”问题的高层次方案将是一个`while`循环，只要我们没有找到按下按钮`4`，循环就会继续进行。每次循环，我们会读取两行输入并处理它们。这导致了如下结构：

```py
❶ button = 0

   while button != 4:

       # Read button

       # Read number of presses

       # Process button presses
```

在`while`循环之前，我们创建变量`button`并将其初始化为数字`0` ❶。没有这个，`button`变量将不存在，我们在`while`循环的布尔表达式中会出现`NameError`。除了`4`以外的任何数字都可以触发循环的第一次迭代。

在这个`while`循环中，我们将使用`for`循环来处理按钮按下的操作。对于每一次按下，我们将使用`if`语句来检查按下的是哪个按钮。我们需要在`if`语句中为四个按钮分别创建四个缩进的语句块。

让我们讨论如何处理每个按钮。按钮`1`将播放列表中的第一首歌移到播放列表的末尾。由于我们知道歌曲的数量很小且固定，我们可以通过字符串索引来连接每个字符。记住，字符串的第一个字符的索引是 0，而不是 1。我们可以像这样将这个字符移到字符串的末尾：

```py
>>> songs = 'ABCDE'

>>> songs = songs[1] + songs[2] + songs[3] + songs[4] + songs[0]

>>> songs

'BCDEA'
```

这种做法比较繁琐，而且仅适用于正好有五首歌的情况。我们可以使用字符串切片来编写更加通用且不易出错的代码。

*切片*是 Python 的一项特性，允许我们引用字符串的子字符串。（实际上，它也适用于任何序列类型，稍后在本书中我们将看到。）切片需要两个索引：开始的索引和结束索引右边的一个位置。如果我们使用索引 4 和 8，举例来说，我们将获得索引 4、5、6 和 7 的字符。切片使用方括号，两个索引之间用冒号分隔：

```py
>>> s = 'abcdefghijk'

>>> s[4:8]

'efgh'
```

切片操作不会改变`s`所指向的内容。我们可以通过赋值语句使`s`指向切片：

```py
>>> s

'abcdefghijk'

>>> s = s[4:8]

>>> s

'efgh'
```

在这里很容易犯下越界错误，以为`s[4:8]`包含了索引 8 处的字符。但实际上并不包括，就像`range(4, 8)`不包含`8`一样。所以虽然这个行为可能有点反直觉，但它在`range`和切片中是一致应用的。

在进行字符串切片时，我们必须始终包括冒号，但起始和结束索引是可选的。如果我们省略起始索引，Python 会从索引 0 开始切片：

```py
>>> s = 'abcdefghijk'

>>> s[:4]

'abcd'
```

如果省略结束索引，Python 会一直切片到字符串的末尾：

```py
>>> s[4:]

'efghijk'
```

如果省略两个索引呢？这会给我们一个包含整个字符串的切片：

```py
>>> s[:]

'abcdefghijk'
```

我们甚至可以在切片中使用负索引。这里有一个示例：

```py
>>> s[-4:]

'hijk'
```

起始索引指的是从右侧数第四个字符，即 `'h'`，并且省略了结束索引。因此，我们得到一个从 `'h'` 到字符串末尾的切片。

与索引不同，切片永远不会引发索引错误。如果我们使用超出字符串范围的索引，Python 会切片到字符串的适当末端：

```py
>>> s[8:20]

'ijk'

>>> s[-50:2]

'ab'
```

我们将使用字符串切片来实现按钮 `1`、`2` 和 `3` 的行为。以下是按钮 `1` 的代码：

```py
>>> songs = 'ABCDE'

>>> songs = songs[1:] + songs[0]

>>> songs

'BCDEA'
```

该切片给我们除了索引 0 处的字符以外的整个字符串。（这里没有特定于长度为 5 的字符串的内容；这段代码适用于任何非空字符串。）如果补上丢失的字符，第一个歌曲就会移到播放列表的末尾。其他按钮的切片类似；你将在下一段代码中看到。

**概念检查**

以下代码的输出是什么？

```py
game = 'Lost Vikings'

print(game[2:-6])
```

A. `st V`

B. `ost V`

C. `iking`

D. `st Vi`

E. `Viking`

答案：A. 索引 `2` 处的字符是 `'Lost'` 中的 `'s'`。索引 `-6` 处的字符是 `'Vikings'` 中的第一个 `'i'`。由于我们从索引 `2` 开始，到但不包括索引 `-6`，所以我们得到切片 `'st V'`。

**概念检查**

哪个密码可以让我们退出以下循环？

```py
valid = False

while not valid:

    s = input()

    valid = len(s) == 5 and s[:2] == 'xy'
```

A. `xyz`

B. `xyabc`

C. `abcxy`

D. 以上多个密码可以让我们退出循环

E. 无；循环从未执行，且没有获得任何密码

答案：B. `while` 循环在 `valid` 为 `True` 时终止（因为此时 `not valid` 为 `False`）。给定的密码中，唯一一个长度为 5 且前两个字符为 `'xy'` 的密码是 `xyabc`。因此，这个密码是唯一一个将 `valid` 设置为 `True` 并结束循环的密码。

### 解决问题

现在我们已经练习了如何使用 `while` 循环来处理多个按钮，并利用切片进行字符串操作，接下来我们准备解决歌曲播放列表问题。请参见 清单 4-3 了解代码。

```py
   songs = 'ABCDE'

   button = 0

❶ while button != 4:

       button = int(input())

       presses = int(input())

    ❷ for i in range(presses):

           if button == 1:

            ❸ songs = songs[1:] + songs[0]

           elif button == 2:

            ❹ songs = songs[-1] + songs[:-1]

           elif button == 3:

            ❺ songs = songs[1] + songs[0] + songs[2:]

❻ output = ''

 for song in songs:

       output = output + song + ' '

❼ print(output[:-1])
```

*清单 4-3：解决歌曲播放列表*

`while` 循环会一直继续，直到按钮 `4` 被按下 ❶。在每次执行 `while` 循环时，我们读取按钮编号，然后读取该按钮被按下的次数。

现在，在外部的 `while` 循环中，我们需要在每次按钮按下时执行一次循环。在选择使用哪种循环时，请记住所有循环类型。这里，使用 `for` 循环范围是最好的选择 ❷，因为它是以我们指定的次数精确循环的最简单方法。

`for` 循环中的行为取决于按下的按钮。我们因此使用 `if` 语句来检查按钮号码并相应地修改播放列表。如果按下的是按钮 `1`，我们使用切片将第一首歌移到播放列表的末尾 ❸。如果按下的是按钮 `2`，我们使用切片将最后一首歌移到播放列表的开头 ❹。为了做到这一点，我们从字符串的右端开始，然后使用切片将所有其他字符追加上去。对于按钮 `3`，我们需要修改播放列表，使得前两首歌交换位置。我们构建一个新的字符串，其中包含索引 `1` 处的字符，然后是索引 `0` 处的字符，再加上从索引 `2` 开始的所有字符 ❺。

一旦我们跳出 `while` 循环，我们需要输出歌曲，每对歌曲之间用一个空格分隔。我们不能仅仅输出 `songs`，因为那没有空格。相反，我们构建一个输出字符串，里面有适当的空格。为了做到这一点，我们从空字符串 ❻ 开始，然后使用 `for` 循环将每首歌和一个空格连接起来。有一个小麻烦是，这会在字符串的末尾添加一个空格，在最后一首歌后面，而我们不想要那个空格。因此，我们使用切片来去掉最后的空格字符 ❼。

你现在准备好提交给评委了。

在继续之前，你可能想试着解决“章节练习”中第 99 页的第 3 题。

### 问题 #10：秘密句子

即使我们有一个字符串，甚至知道将提供多少输入，`while` 循环仍然可能是所需的循环类型。这个问题演示了为什么会是这种情况。

这是 DMOJ 问题`coci08c3p2`。

#### 挑战

卢卡在课堂上写下了一句秘密句子。他不希望老师能读懂它，因此他没有写下原始句子，而是写下了一个编码版本。在句子中的每个元音字母（*a*, *e*, *i*, *o*, 或 *u*）后面，他都会加上字母 *p*，然后再加上那个元音字母。例如，他不会写下句子 *i like you*，而是写成 *ipi lipikepe yopoupu*。

老师获得了卢卡的编码句子。为老师恢复卢卡的原始句子。

#### 输入

输入是一行文本，卢卡的编码句子。它由小写字母和空格组成。每对单词之间有且只有一个空格。该行的最大长度为 100 个字符。

#### 输出

输出卢卡的原始句子。

### `for` 循环的另一个限制

在第三章中，我们学习了如何使用 `for` 循环处理字符串。`for` 循环逐个字符地遍历字符串，从头到尾。在许多情况下，这正是我们想要的。例如，在“三杯”问题中，我们需要从左到右查看每次交换，所以我们在交换字符串上使用了 `for` 循环。

在其他情况下，这样的限制太严苛了，`for` 循环可能会更合适。`for` 循环让我们能够访问索引，而不是字符。它还允许我们根据需要选择步长来跳跃遍历序列。例如，我们可以使用 `for` 循环访问字符串中的每三个字符：

```py
>>> s = 'zephyr'

>>> for i in range(0, len(s), 3):

...     print(s[i])

...

z

h
```

我们还可以使用 `for` 循环从右到左处理字符串，而不是从左到右：

```py
>>> for i in range(len(s) - 1, -1, -1):

...     print(s[i])

...

r

y

h

p

e

z
```

这一切都假设我们希望在每次迭代中步长固定。

如果有时我们希望向右移动一个字符，而其他时候我们希望向右移动三个字符呢？这完全不是不可能的。事实上，如果我们能做到这一点，那么我们就能很接近解决“秘密句子”问题了。

为了说明这一点，考虑以下测试案例：

```py
ipi lipikepe yopoupu
```

假设我们正在通过复制字符来重构 Luka 的原始句子。编码句子的第一个字符是元音字母 `i`。这也是 Luka 原始句子的第一个字符。根据 Luka 编码句子的方式，我们知道接下来的两个字符将是 `p` 和 `i`。我们不希望将它们包含在 Luka 的原始句子中，所以我们需要跳过它们。也就是说，在处理完索引 0 后，我们要跳到索引 3。

索引 3 是一个空格字符。由于它不是元音字母，我们将这个字符原样复制到 Luka 的原始句子中，然后跳到索引 4。索引 4 是 `l`，另一个非元音字母，所以我们也复制它并跳到索引 5。这里在索引 5 是一个元音字母；复制它后，我们要跳到索引 8。

这里的步长是多少？有时我们跳跃三个字符，但并不总是如此。有时我们跳跃一个字符，但也不总是如此。它是三和一的混合。`for` 循环并不适合这种处理方式。

使用 `while` 循环，我们可以随心所欲地跳跃遍历字符串，不受预定义步长的限制。

### `while` 循环遍历索引

写一个 `while` 循环来遍历字符串索引，与写任何其他类型的 `while` 循环没有区别。我们只需要结合字符串的长度。以下是我们如何从左到右遍历字符串的每个字符：

```py
   >>> s = 'zephyr'

   >>> i = 0

❶ >>> while i < len(s):

   ...     print('We have ' + s[i])

   ...     i = i + 1

   ...

   We have z

   We have e

   We have p

   We have h

   We have y

   We have r
```

变量 `i` 允许我们访问字符串的每个字符。它从 `0` 开始，每次循环增加 1。

我在循环的布尔表达式 ❶ 中使用了 `<`，以便在没有达到字符串长度时继续。如果我使用的是 `<=` 而不是 `<`，我们会收到一个 `IndexError` 错误：

```py
>>> i = 0

>>> while i <= len(s):

...     print('We have ' + s[i])

...     i = i + 1

...

We have z

We have e

We have p

We have h

We have y

We have r

Traceback (most recent call last):

  File "<stdin>", line 2, in <module>

IndexError: string index out of range
```

字符串的长度是 6。我们之所以会遇到这个错误，是因为循环试图访问 `s[6]`，而这是一个无效的索引。

想要每次跳跃三个字符而不是一个字符吗？没问题；只需将 `i` 增加 `3` 而不是 `1`：

```py
>>> i = 0

>>> while i < len(s):

...     print('We have ' + s[i])

...     i = i + 3

...

We have z

We have h
```

我们也可以从右往左遍历，而不是从左往右。我们必须从`len(s) - 1`开始，而不是从`0`开始，并且在每次迭代时减少`i`，而不是增加它。我们还必须改变循环的布尔表达式，以便检测到我们到达字符串的开头，而不是结尾。以下是如何从右往左遍历，每次处理一个字符：

```py
>>> i = len(s) - 1

>>> while i >= 0:

...     print('We have ' + s[i])

...     i = i - 1

...

We have r

We have y

We have h

We have p

We have e

We have z
```

在字符串上使用`while`循环的一个最终应用：在满足某些条件时停止在第一个索引处。

该策略是使用布尔`and`运算符，在仍有字符需要检查并且我们还没有满足条件的情况下继续循环。例如，下面是如何找到字符串中第一个`'y'`的索引：

```py
>>> i = 0

>>> while i < len(s) and s[i] != 'y':

...     i = i + 1

...

>>> print(i)

4
```

如果字符串中没有`'y'`，循环会在`i`等于字符串长度时停止：

```py
>>> s = 'breeze'

>>> i = 0

>>> while i < len(s) and s[i] != 'y':

...     i = i + 1

...

>>> print(i)

6
```

当`i`为`6`时，`and`的第一个操作数为`False`，因此循环终止。你可能会想，为什么`and`的第二个操作数不会导致错误，因为索引`6`在字符串中不是一个有效的索引。原因是布尔运算符使用*短路求值*，这意味着它们在结果已经确定时会停止评估其操作数。对于`and`，如果第一个操作数为`False`，我们就知道无论第二个操作数是什么，`and`都会返回`False`；因此，Python 不会评估第二个操作数。同样地，对于`or`，如果第一个操作数为`True`，那么`or`保证返回`True`，因此 Python 不会评估第二个操作数。

### 解决问题

现在我们知道如何使用`while`循环来遍历一个字符串。

对于密句（Secret Sentence），我们需要根据我们查看的是元音（vowel）还是非元音（nonvowel）来采取不同的处理方式。如果我们查看的是元音，那么我们需要复制该字符，并跳过三个字符（跳过`p`和该元音的第二次出现）。如果我们查看的是非元音，那么我们需要复制该字符并移动到下一个字符。因此，我们总是复制当前字符，然后根据当前字符是否为元音，跳过三个字符或一个字符。我们可以在`while`循环中使用`if`语句来为我们看到的每个字符做出决定。

密句的解决方案在清单 4-4 中。

```py
   sentence = input()

❶ result = ''

   i = 0

❷ while i < len(sentence):

       result = result + sentence[i]

    ❸ if sentence[i] in 'aeiou':

           i = i + 3

       else:

           i = i + 1

   print(result)
```

*清单 4-4：解决密句问题*

`result`变量❶用于逐个字符地构建原始句子。

`while`循环的布尔表达式是用于遍历字符串直到到达末尾的标准表达式❷。在这个循环中，我们首先将当前字符连接到结果的末尾。然后，我们检查当前字符是否为元音❸。请回顾第二章中的“关系运算符”部分，`in`运算符可以用来检查第一个字符串是否出现在第二个字符串中。如果当前字符出现在元音的字符串中，我们就跳过三个字符；如果没有，我们就移动到下一个字符。

一旦循环终止，我们已经遍历了整个编码后的句子，并将正确的字符复制到`result`中。因此，最后要做的就是输出这个变量。

你已经准备好将我们的代码提交给评审了。Grepeapat wopork!

### break 和 continue

在这一节中，我将向你展示 Python 支持的另外两个循环关键字：`break`和`continue`。根据我的经验，引入这些关键字会导致学习者过度使用它们，从而影响循环的清晰度，因此我决定在书中的其他部分避免使用它们。尽管如此，它们偶尔还是有用的，你很可能会在其他 Python 代码中看到它们，所以让我们简要讨论一下。

#### break

`break`关键字会立即终止一个循环，不做任何询问。

当我们解决歌曲播放列表问题时，我们使用了一个`while`循环，条件是按钮没有按下`4`。我们也可以使用`break`来解决这个问题；请参见列表 4-5 中的代码。

```py
   songs = 'ABCDE'

❶ while True:

       button = int(input())

    ❷ if button == 4:

        ❸ break

       presses = int(input())

       for i in range(presses):

           if button == 1:

               songs = songs[1:] + songs[0]

           elif button == 2:

               songs = songs[-1] + songs[:-1]

           elif button == 3:

               songs = songs[1] + songs[0] + songs[2:]

   output = ''

   for song in songs:

       output = output + song + ' '

   print(output[:-1])
```

*列表 4-5：使用* break *解决歌曲播放列表问题*

循环的布尔表达式❶看起来很可疑：`True`总是`True`，所以乍一看似乎这个循环永远不会终止。（这就是`break`的弊端。我们不能仅通过布尔表达式来理解循环何时终止。）但是它是可以终止的，因为我们使用了`break`。如果按钮`4`被按下❷，那么我们会遇到一个`break`❸，从而终止循环。

让我们再看一个使用`break`的例子。在本章的“`while`循环通过索引”中，我们编写了代码来查找字符串中第一个`'y'`的索引。以下是使用`break`的实现：

```py
>>> s = 'zephyr'

>>> i = 0

>>> while i < len(s):

...     if s[i] == 'y':

...         break

...     i = i + 1

...

>>> print(i)

4
```

再次注意，循环的布尔表达式具有误导性：它暗示循环总是一直运行直到字符串的末尾，但仔细审查后会发现有一个`break`存在，它可以影响终止条件。

`break`只会终止它自身的循环，而不会影响外部的循环。这里有一个例子：

```py
   >>> i = 0

   >>> while i < 3:

   ...     j = 10

   ...     while j <= 50:

   ...         print(j)

   ...         if j == 30:

❶ ...             break

   ...         j = j + 10

   ...     i = i + 1

   ...

   10

   20

   30

   10

   20

   30

   10

   20

   30
```

注意`break`❶是如何缩短`j`循环的。但它不会影响`i`循环：该循环有三个迭代，正如没有`break`❶时的情况一样。

#### continue

`continue`关键字结束当前的循环迭代，而不会运行更多的代码。与`break`不同，它不会终止整个循环。如果循环条件为`True`，那么循环将继续进行下一次迭代。

这是一个使用`continue`打印每个元音字母及其在字符串中的索引的例子：

```py
   >>> s = 'zephyr'

   >>> i = 0

   >>> while i < len(s):

❶ ...     if not s[i] in 'aeiou':

   ...         i = i + 1

❷ ...         continue

❸ ...     print(s[i], i)

   ...     i = i + 1

   ...

   e 1
```

如果当前字符不是元音字母❶，那么我们不想打印它。因此，我们将`i`增加`1`，跳过这个字符，然后使用`continue`❷结束当前的迭代。如果我们进入`if`语句之后❸，那就意味着我们看到的是元音字母（否则`continue`会阻止我们到达这里）。因此，我们输出这个字符，并将`i`增加`1`，跳过这个字符。

`continue` 关键字具有诱惑力，因为它看似提供了一种方法，让我们退出我们不想参与的迭代。“这不是元音，我走！”但也可以使用 `if` 语句实现相同的行为，并且逻辑通常更清晰：

```py
>>> s = 'zephyr'

>>> i = 0

>>> while i < len(s):

...     if s[i] in 'aeiou':

...         print(s[i], i)

...     i = i + 1

...

e 1
```

当当前字符不是元音时，`if` 语句会在字符 *是* 元音时进行处理，而不是跳过该次迭代。

### 总结

本章问题的共同特点是我们事先不知道循环需要迭代多少次。

**老虎机** 迭代次数取决于初始的硬币数量和老虎机的支付比例。

**歌曲播放列表** 迭代次数取决于按下了多少个按钮。

**秘密句子** 迭代次数及每次迭代要做的操作，取决于元音在字符串中的位置。

当迭代次数未知时，我们使用 `while` 循环，它会根据需要执行。使用 `while` 循环比使用 `for` 循环的代码更容易出错，但它也更灵活，因为我们不再受制于 `for` 循环必须依次遍历序列的限制。

在下一章，我们将学习列表，它可以让我们存储大量的数字或字符串数据。你猜我们如何处理这些数据呢？没错：使用循环！通过做以下练习来锻炼你的循环技能。在用列表解决问题时，你会频繁用到它们。

### 章节练习

现在，你可以使用三种类型的循环：`for` 循环、范围 `for` 循环和 `while` 循环。解决问题时的一个挑战是知道使用哪种循环！在接下来的练习中，试着使用不同类型的循环，找到你最喜欢的解决方案。

1. DMOJ 问题 `ccc20j2`，流行病学

1.  DMOJ 问题 `coci08c1p2`，Ptice

1.  DMOJ 问题 `ccc02j2`，美加之战

1.  DMOJ 问题 `ecoo13r1p1`，取一个数字

1.  DMOJ 问题 `ecoo15r1p1`，当你吃掉你的巧克力豆时

1.  DMOJ 问题 `ccc19j3`，冷敷

### 备注

老虎机最初来自 2000 年加拿大计算机竞赛，初级/高级水平。歌曲播放列表最初来自 2008 年加拿大计算机竞赛，初级水平。秘密句子最初来自 2008/2009 年克罗地亚信息学公开赛，第 3 场比赛。
