## 10

大O和程序效率

![image](Images/common.jpg)

在本书的前七章中，我们主要专注于编写正确的程序：对于任何有效的输入，我们希望程序能够输出期望的结果。然而，除了正确的代码外，我们通常还希望代码是高效的，即使面对大量的输入时也能快速运行。在前七章的学习过程中，或许你曾经偶尔遇到过时间超限错误，但我们真正正式接触程序效率的部分是在[第8章](ch08.xhtml#ch08)，当时我们解决了电子邮件地址问题。我们在那时看到，有时候我们需要让程序更加高效，以便能够在给定的时间限制内完成。

本章中，我们首先将学习程序员如何思考和沟通程序效率。接着，我们将研究两个需要编写高效代码的问题：确定围巾上最受欢迎的部分和绘制一个丝带。

对于每个问题，我们会看到最初的想法会导致一个不够高效的算法。但我们会继续努力，直到为同一个问题设计出一个更快的算法，一个明显更高效的算法。这体现了程序员常见的工作流程：首先，提出一个正确的算法；然后，如果需要，才优化它使其更快。

### 时间测试的难题

本书中我们解决的每个竞赛编程问题都有一个时间限制，规定了我们的程序可以运行的最长时间。（当我们在[第8章](ch08.xhtml#ch08)中开始遇到效率成为严重问题的编程挑战时，我开始在问题描述中加入时间限制。）如果我们的程序超出了时间限制，评测系统将终止程序，并报告时间超限错误。时间限制的设置是为了防止过于缓慢的解法通过测试用例。例如，也许我们提出了一个完整搜索的解法，但问题的作者已经提出了一个更快的解法。这个更快的解法可能是完整搜索的变种，就像我们在[第9章](ch09.xhtml#ch09)解决牛球问题时那样，或者它也可能是完全不同的方法。无论如何，时间限制可能会设置得使得我们的完整搜索解法无法在规定时间内完成。因此，除了正确性外，我们的程序还需要足够的速度。

我们可以运行程序来测试它是否足够高效。例如，回想一下在[第8章](ch08.xhtml#ch08)中我们尝试使用列表解决电子邮件地址问题时的“列表查找效率”部分。我们运行了使用越来越大的列表的代码，以了解列表操作所需的时间。这种测试可以帮助我们理解程序的效率。如果我们的程序运行得太慢，超过了问题的时间限制，那么我们就知道需要优化现有的代码，或者找到一种全新的方法。

程序所需的时间取决于运行程序的计算机。我们不知道评测机使用的是什么计算机，但在我们自己的计算机上运行程序仍然具有参考价值，因为评测机可能使用的计算机至少和我们的同样快速。假设我们在笔记本电脑上运行程序，并且在某个小的测试用例上花费了30秒。如果问题的时间限制是3秒，我们就可以确信程序速度不够快。

然而，单纯关注时间限制是有限制的。想一想我们在[第9章](ch09.xhtml#ch09)中的第一个牛棒球问题的解法。我们不需要运行那段代码来确定它有多慢。这是因为我们能够通过对程序需要执行的工作量进行刻画，来估算程序的表现。例如，在[第253页](ch09.xhtml#ch09lev2sec16)的“程序效率”一节中，我们说对于 *n* 头牛，我们的程序需要处理 *n*³ 个牛三元组。请注意，我们这里关注的不是程序运行所需的秒数，而是程序在处理 *n* 的输入时所做的工作量。

与记录程序执行时间并运行程序相比，这种分析方法有显著的优势。这里有五个优势：

**执行时间取决于计算机** 测量程序的运行时间仅能告诉我们程序在一台计算机上需要多长时间。这是非常具体的信息，对于理解程序在其他计算机上的表现帮助不大。在学习过程中，你可能还注意到，即使是在同一台计算机上，程序的执行时间也会有所不同。例如，你可能在一个测试用例上运行程序，发现它花了三秒钟；然后你再运行一次相同的测试用例，结果可能是两秒半或者三秒半。出现这种差异的原因是操作系统在管理你的计算资源，根据需要将它们分配到不同的任务上。操作系统所做的决策会影响程序的运行时间。

**执行时间取决于测试用例** 对我们的程序进行计时，仅仅告诉我们程序在该测试用例上的执行时间。假设我们的程序在一个小的测试用例上运行需要三秒钟。这看起来可能很快，但关于小测试用例的真相是：每个合理的解决方案都能很快解决这些问题。如果我让你告诉我10个电子邮件地址中的唯一电子邮件地址数量，或者10头牛中有多少组三头牛，你可以用你第一个想到的正确方法快速完成。真正有趣的是大规模的测试用例。它们是算法创意能够展现价值的地方。那么，我们的程序在大测试用例或超大测试用例上的执行时间会是多少？我们不知道。我们也需要在这些测试用例上运行程序。即使我们这么做了，也可能会有特定类型的测试用例触发更差的性能。我们可能会被误导，认为我们的程序比实际情况要快。

**程序需要实现** 我们不能对没有实现的东西进行计时。假设我们正在思考一个问题，并且想到了一个解决方案。这会很快吗？虽然我们可以实现它以找出答案，但如果事先知道这个想法是否能带来一个快速的程序，那将会更好。你不会实施一个你知道一开始就是错误的程序。类似地，如果程序从一开始就知道会太慢，那事先知道这一点也会更好。

**计时无法解释程序慢的原因** 如果我们发现程序运行太慢，那么接下来的任务就是设计一个更快的程序。然而，简单地对程序进行计时并不能为我们提供程序为什么慢的任何线索。它就是慢。进一步说，如果我们想到一个可能的改进方案，我们也需要实施它来查看是否有帮助。

**执行时间难以传达** 由于许多原因，使用执行时间与他人讨论算法的效率是困难的。执行时间过于具体：它取决于计算机、操作系统、测试用例、编程语言和所使用的具体实现。我们必须向其他对我们算法效率感兴趣的人提供所有这些信息。

不用担心：计算机科学家已经设计了一种符号来解决计时的这些不足。它独立于计算机、独立于测试用例，并且不依赖于特定的实现。它能够指出程序慢的原因。它易于传达。它叫做 *大O*，马上就要讲解了。

### 大O

大O表示法是计算机科学家用来简洁描述算法效率的符号。这里的关键概念是*效率类*，它告诉你算法的运行速度，或者说，算法需要做多少工作。算法越快，它的工作量越少；算法越慢，它的工作量越多。每个算法都属于一个效率类；效率类告诉你这个算法在处理输入时相对于输入量需要做多少工作。要理解大O，我们需要理解这些效率类。接下来我们将学习七个最常见的效率类。我们将看到那些做最少工作的算法，也就是你希望你的算法能归入的类别。我们还将看到那些做更多工作的算法，这些算法可能会给你带来超时错误。

#### 常数时间

最理想的算法是那些随着输入量的增加而不会增加额外工作量的算法。无论问题实例如何，这样的算法大致需要相同的步骤数。这些被称为*常数时间*算法。

这难以相信，对吧？一个做差不多相同工作的算法，无论情况如何？确实，使用这样的算法解决问题是很少见的。但当你能做到时，庆祝一下吧：你已经做得最好了。

在本书中，我们已经成功地使用常数时间算法解决了几个问题。回想一下[第2章](ch02.xhtml#ch02)中的推销员问题，我们需要判断提供的电话号码是否属于推销员。我已经在这里重现了来自[清单2-2](ch02.xhtml#ch02ex02)的解决方案：

num1 = int(input())

num2 = int(input())

num3 = int(input())

num4 = int(input())

if ((num1 == 8 或 num1 == 9) 并且

(num4 == 8 或 num4 == 9) 并且

(num2 == num3)):

print('忽略')

否则：

print('答案')

我们的解决方案无论电话号码的四个数字是什么，都做相同数量的工作。代码首先读取输入。然后它与num1、num2、num3和num4做一些比较。如果电话号码属于推销员，我们输出某些内容；如果不属于推销员，我们输出其他内容。没有任何输入能使我们的程序做比这更多的工作。

在[第2章](ch02.xhtml#ch02)中，我们解决了“获胜团队”问题。我们是否也以常数时间解决了这个问题呢？是的！以下是来自[清单2-1](ch02.xhtml#ch02ex01)的解决方案：

apple_three = int(input())

apple_two = int(input())

apple_one = int(input())

banana_three = int(input())

banana_two = int(input())

banana_one = int(input())

apple_total = apple_three * 3 + apple_two * 2 + apple_one

banana_total = banana_three * 3 + banana_two * 2 + banana_one

如果 apple_total > banana_total:

print('A')

elif banana_total > apple_total:

print('B')

否则：

print('T')

我们读取输入，计算苹果队的总分，计算香蕉队的总分，比较这些总分，并输出消息。不管苹果队或香蕉队的得分是多少——我们的程序总是做相同数量的工作。

等一下——如果苹果队得到了成千上万的三分球得分呢？计算机处理巨大的数字肯定比处理像10或50这样的数字要花更长的时间吧？虽然这是对的，但我们在这里不需要担心。题目描述中说明每支队伍每种类型的进球最多为100个。因此，我们处理的是小数字，可以合理地说，计算机可以在常数步数内读取或操作这些数字。一般来说，你可以把几亿以内的数字看作是“较小”的数字。

在大O符号表示法中，我们说常数时间算法是 *O*(1)。这个1并不意味着你只能在常数时间算法中执行一步。如果你执行固定数量的步骤，例如10步甚至10,000步，它仍然是常数时间。但不要写 *O*(10) 或 *O*(10000)——所有常数时间算法都表示为 *O*(1)。

#### 线性时间

大多数算法不是常数时间算法。相反，它们所做的工作量取决于输入量。例如，它们处理1,000个值时的工作量要比处理10个值时多。区分这些算法的关键是输入量与算法所做工作量之间的关系。

A *线性时间*算法是指输入量与工作量之间存在线性关系的算法。假设我们在包含50个值的输入上运行线性时间算法，然后在包含100个值的输入上再次运行它。那么，相对于50个值，算法在100个值上所做的工作大约是两倍。

举个例子，我们来看一下[第3章](ch03.xhtml#ch03)中的“三杯问题”。我们在[清单3-1](ch03.xhtml#ch03ex01)中解决了这个问题，下面是我们的解决方案：

swaps = input()

ball_location = 1

❶ for swap_type in swaps:

if swap_type == 'A' and ball_location == 1:

ball_location = 2

elif swap_type == 'A' and ball_location == 2:

ball_location = 1

elif swap_type == 'B' and ball_location == 2:

ball_location = 3

elif swap_type == 'B' and ball_location == 3:

ball_location = 2

elif swap_type == 'C' and ball_location == 1:

ball_location = 3

elif swap_type == 'C' and ball_location == 3:

ball_location = 1

print(ball_location)

有一个for循环 ❶，它所做的工作量与输入量呈线性关系。如果需要处理5个交换，那么循环就会迭代5次。如果需要处理10个交换，那么循环就会迭代10次。每次循环都执行常数数量的比较，并可能更改ball_location的值。因此，该算法所做的工作量与交换次数直接成正比。

我们通常用 *n* 来表示输入到问题中的数据量。在这里，*n* 是交换的次数。如果需要进行 5 次交换，那么 *n* 就是 5；如果需要进行 10 次交换，那么 *n* 就是 10。

如果有 *n* 次交换，那么我们的程序大约做 *n* 次工作。这是因为 for 循环执行了 *n* 次迭代，每次迭代执行常数数量的步骤。我们不关心每次迭代执行多少步骤，只要它是常数时间的。无论算法执行的是 *n* 步，10*n* 步，还是 10,000*n* 步，它都是线性时间算法。在大 O 表示法中，我们说这个算法是 *O*(*n*)。

使用大 O 表示法时，我们不包括 *n* 前面的数字。例如，一个需要 10*n* 步骤的算法应该写作 *O*(*n*)，而不是 *O*(10*n*)。这有助于我们专注于算法的线性时间性质，而不是线性关系的具体细节。

如果一个算法需要 2*n* + 8 步骤，那么这是什么类型的算法？这仍然是线性时间！原因是线性项（2*n*）会在 *n* 足够大的时候支配常数项（8）。例如，如果 *n* 是 5000，那么 8*n* 就是 40,000。数字 8 相对于 40,000 来说非常小，所以我们可以忽略它。在大 O 表示法中，我们忽略所有除主导项以外的部分。

许多 Python 操作的执行时间是常数时间。例如，向列表中添加元素、向字典中添加键值对，或者索引序列或字典，都需要常数时间。

但是有些 Python 操作是线性时间的。要小心将它们算作线性时间，而不是常数时间。例如，使用 Python 的输入函数读取一长串字符串需要线性时间，因为 Python 必须读取输入行中的每个字符。任何检查字符串或列表中每个字符或值的操作都需要线性时间。

如果一个算法读取 *n* 个值，并且每个值的处理步骤是常数时间，那么它就是一个线性时间算法。

我们不需要走得太远就能看到另一个线性时间算法——我们在[第 3 章](ch03.xhtml#ch03)中对“已占用空间”的解决方案就是另一个例子。我在这里复现了我们在[清单 3-3](ch03.xhtml#ch03ex03)中的解决方案：

n = int(input())

yesterday = input()

today = input()

occupied = 0

for i in range(len(yesterday)):

if yesterday[i] == 'C' and today[i] == 'C':

occupied = occupied + 1

print(occupied)

我们设 *n* 为停车位的数量。模式和“三杯问题”是一样的：我们读取输入，然后对每个停车位执行常数数量的步骤。

**概念检查**

在[清单 1-1](ch01.xhtml#ch01ex01)中，我们解决了词数问题。这里是该解决方案的代码。

line = input()

total_words = line.count(' ') + 1

print(total_words)

我们的算法的大 O 效率是多少？

A. *O*(1)

B. *O*(*n*)

答案：B。人们很容易认为这个算法是 *O*(1)。毕竟，那里没有循环，看起来算法只执行了三步：读取输入、调用计数方法来统计单词数量、输出单词数量。

但这个算法是 *O*(*n*)，其中 *n* 是输入中的字符数量。输入函数读取输入需要线性时间，因为它必须逐字符读取输入。使用计数方法也需要线性时间，因为它必须处理字符串的每个字符以找到匹配项。所以这个算法执行了线性的工作量来读取输入，并且执行了线性的工作量来统计单词。总体上，这是线性的工作量。

**概念检查**

在[示例 1-2](ch01.xhtml#ch01ex02)中，我们解决了圆锥体积问题。我在这里重现了该解决方案：

PI = 3.141592653589793

radius = int(input())

height = int(input())

volume = (PI * radius ** 2 * height) / 3

print(volume)

我们算法的大 O 效率是多少？（回想一下，半径和高度的最大值是100。）

A. *O*(1)

B. *O*(*n*)

答案：A。我们这里处理的是小数字，因此从输入中读取它们需要常数时间。计算体积也需要常数时间，因为只是进行几个数学运算。因此，我们所做的只是几个常数时间的步骤。总体上，这是常数工作量。

**概念检查**

在[示例 3-4](ch03.xhtml#ch03ex04)中，我们解决了数据计划问题。我在这里重现了该解决方案：

monthly_mb = int(input())

n = int(input())

excess = 0

for i in range(n):

used = int(input())

excess = excess + monthly_mb - used

print(excess + monthly_mb)

我们算法的大 O 效率是多少？

A. *O*(1)

B. *O*(*n*)

答案：B。这个算法的模式类似于我们解决“三杯或占据空间”问题的解决方案，不同之处在于它将读取输入与处理输入交替进行。我们设 *n* 为每月兆字节数值的数量。对于这些 *n* 个输入值，程序执行一个常数步数。因此，这是一个 *O*(*n*) 的算法。

#### 二次时间

到目前为止，我们讨论了常数时间算法（即随着输入量的增加，工作量不增加的算法）和线性时间算法（即随着输入量的增加，工作量线性增加的算法）。像线性时间算法一样，*二次时间*算法在输入量增加时会增加工作量；例如，处理1,000个值比处理10个值需要更多的工作。虽然在相对较大的输入量下，我们可以使用线性时间算法，但在二次时间算法上，我们将被限制在更小的输入量上。接下来我们将看到原因。

##### 典型形式

一个典型的线性时间算法看起来是这样的：

for i in range(n):

<以常数步数处理输入 i>

相比之下，一个典型的二次时间算法看起来是这样的：

for i in range(n):

for j in range(n):

<以恒定步数处理输入 i 和 j>

对于一个包含 *n* 个值的输入，每个算法处理多少值？线性时间算法处理 *n* 个值，每次迭代处理一个。相比之下，二次时间算法在外层 for 循环的每次迭代中都处理 *n* 个值。

在外层 for 循环的第一次迭代中，处理 *n* 个值（每次内层 for 循环迭代处理一个）；在外层 for 循环的第二次迭代中，再处理 *n* 个值；以此类推。由于外层 for 循环迭代了 *n* 次，总共处理的值的数量是 *n* * *n*，即 *n*²。两个嵌套循环，每个循环都依赖于 *n*，就形成了一个二次时间算法。在大 O 表示法中，我们说二次时间算法是 *O*(*n*²)。

让我们比较线性时间和二次时间算法所做的工作量。假设我们正在处理一个包含1,000个值的输入，即 *n* 为 1,000。一个线性时间算法需要 *n* 步，因此需要1,000步。一个二次时间算法需要 *n*² 步，因此需要 1,000² = 1,000,000 步。一百万比一千要多得多。但谁在乎呢：计算机真的非常快，对吧？嗯，是的，对于包含1,000个值的输入，如果我们使用一个二次时间算法，可能还是可以的。在《我们程序的效率》一章中，见 [第253页](ch09.xhtml#ch09lev2sec16)，我给出了一个保守的规则，声称我们每秒可以执行大约五百万步。那么，一百万步应该在大多数时间限制下都能完成。

但对于二次时间算法的任何乐观情绪都是短暂的。看看当我们将输入值的数量从1,000增加到10,000时会发生什么。线性时间算法只需要10,000步。二次时间算法需要10,000² = 100,000,000步。嗯……如果我们使用二次时间算法，计算机的速度就没有那么快了。虽然线性时间算法仍然能在毫秒级别运行，但二次时间算法至少需要几秒钟。时间超限，毫无疑问。

**概念检查**

以下算法的大 O 效率是多少？

for i in range(10):

for j in range(n):

<以恒定步数处理输入 i 和 j>

A. *O*(1)

B. *O*(*n*)

C. *O*(*n*^(*2*))

答案：B。这里有两个嵌套循环，所以你可能本能地认为这是一个二次时间算法。然而要小心，因为外层 for 循环只迭代了10次，与 *n* 的值无关。因此，这个算法的总步数是 *10n*。这里没有 *n*^(*2*)，*10n* 是线性的，就像 *n* 一样。所以，这是一个线性时间算法，而不是二次时间算法。我们会将其效率写作 *O*(*n*)。

**概念检查**

以下算法的大 O 效率是多少？

for i in range(n):

<以恒定步数处理输入 i>

for j in range(n):

<以常数步长处理输入 j>

A. *O*(1)

B. *O*(*n*)

C. *O*(*n*^(*2*))

答案：B。我们这里有两个循环，它们都依赖于 *n*。这不就是二次时间复杂度吗？

不！这两个循环是顺序执行的，而不是嵌套的。第一个循环执行 *n* 步，第二个循环也执行 *n* 步，总共执行 *2n* 步。因此，这是一个线性时间算法。

##### 备用形式

当你看到两个嵌套的循环且每个循环都依赖于 *n* 时，可以推测这是一个二次时间复杂度算法。但即使没有嵌套循环，二次时间复杂度算法也有可能出现。我们可以在解决电子邮件地址问题时的第一个解法中找到这样一个例子，[第8-2号列表](ch08.xhtml#ch08ex02)。我在这里重现了该解决方案：

# clean 函数未显示

for dataset in range(10):

n = int(input())

addresses = []

for i in range(n):

address = input()

❶ address = clean(address)

❷ 如果 address 不在 addresses 中：

addresses.append(address)

print(len(addresses))

我们将 *n* 设为我们在 10 个测试用例中看到的最大电子邮件地址数量。外层 for 循环执行 10 次；内层 for 循环最多执行 *n* 次。因此，我们最多处理 10*n* 个电子邮件地址，这在 *n* 上是线性的。

清理一个电子邮件地址 ❶ 需要常数时间的步骤，所以我们不需要担心这一点。但这仍然不是 *线性时间* 算法，因为内层 for 循环的每次迭代都需要超过常数时间的步骤。具体来说，检查一个电子邮件地址是否已经在我们的列表中 ❷ 需要与列表中已有的电子邮件地址数量成比例的工作量，因为 Python 需要遍历列表。这本身就是一个线性时间操作！因此，我们需要处理 10*n* 个电子邮件地址，每个地址需要 *n* 的工作量，总共需要 10*n*²，或者说是二次时间复杂度的工作量。正因为有了这种二次时间复杂度表现，我们才在代码中遇到了超时错误，导致我们使用了集合而不是列表。

#### 三次时间

如果一个循环能导致线性时间，两个嵌套循环能导致二次时间复杂度，那么三个嵌套循环呢？三个嵌套循环，每个都依赖于 *n*，将导致一个 *三次时间复杂度* 算法。在大 O 符号表示法中，我们说一个三次时间复杂度算法是 *O*(*n*³)。

如果你觉得二次时间复杂度的算法已经很慢，等你看到三次时间复杂度的算法有多慢吧。假设 *n* 是 1,000。我们已经知道线性时间算法将花费大约 1,000 步，二次时间算法将花费大约 1,000² = 1,000,000 步。而三次时间复杂度算法将花费 1,000³ = 1,000,000,000 步。十亿步！但更糟糕的是。例如，如果 *n* 是 10,000，这仍然是一个较小的输入量，那么三次时间复杂度的算法将花费 1,000,000,000,000（即一万亿）步。一万亿步将需要数分钟的计算时间。不是开玩笑：三次时间复杂度的算法几乎永远不够好。

当我们尝试使用三次方时间复杂度的算法来解决牛仔棒球问题时，在[清单9-5](ch09.xhtml#ch09ex05)中显然是不够好的。我在这里重新呈现了那个解决方案：

input_file = open('baseball.in', 'r')

output_file = open('baseball.out', 'w')

n = int(input_file.readline())

positions = []

for i in range(n):

positions.append(int(input_file.readline()))

total = 0

❶ for position1 in positions:

❷ for position2 in positions:

first_two_diff = position2 - position1

if first_two_diff > 0:

low = position2 + first_two_diff

high = position2 + first_two_diff * 2

❸ for position3 in positions:

if position3 >= low and position3 <= high:

total = total + 1

output_file.write(str(total) + '\n')

input_file.close()

output_file.close()

你将看到这段代码中的三次方时间复杂度的典型特征：三个嵌套循环 ❶ ❷ ❸，每一个都依赖于输入量。正如你记得的那样，那个问题的时间限制是四秒，而我们最多可以有1000头牛。一个三次方时间复杂度的算法，处理十亿个三元组，速度太慢了。

#### 多个变量

在[第五章](ch05.xhtml#ch05)中，我们解决了贝克奖金问题。我在这里重新呈现了我们在[清单5-6](ch05.xhtml#ch05ex06)中的解决方案：

for dataset in range(10):

lst = input().split()

franchisees = int(lst[0])

days = int(lst[1])

grid = []

❶ for i in range(days):

row = input().split()

for j in range(franchisees):

row[j] = int(row[j])

grid.append(row)

bonuses = 0

❷ for row in grid:

total = sum(row)

if total % 13 == 0:

bonuses = bonuses + total // 13

❸ for col_index in range(franchisees):

total = 0

for row_index in range(days):

total = total + grid[row_index][col_index]

if total % 13 == 0:

bonuses = bonuses + total // 13

print(bonuses)

这个算法的Big O效率是多少？这里有一些嵌套循环，所以初步猜测这个算法的时间复杂度是*O*(*n*²)。但*n*到底是什么呢？

在本章到目前为止讨论的问题中，我们使用单一变量*n*来表示输入的量：*n* 可能是交换的次数、停车位的数量、电子邮件地址的数量或牛的数量。但在贝克奖金问题中，我们处理的是二维输入，因此需要*两个*变量来表示其量。我们将第一个变量称为*d*，即天数；将第二个变量称为*f*，即特许经营商的数量。更正式地说，由于每个输入都有多个测试用例，我们将*d*设为天数的最大值，*f*设为特许经营商的最大数量。我们需要给出*两个d*和*f*的Big O效率。

我们的算法包含三个主要部分：读取输入、从行中计算奖金数量、以及从列中计算奖金数量。让我们逐一查看这些部分。

为了读取输入 ❶，我们执行*d*次外循环。在每次迭代中，我们读取一行并调用split，这需要大约*f*步。我们还需要再执行*f*步来遍历这些值并将它们转换为整数。因此，每次*d*次迭代执行的步骤数与*f*成正比。因此，读取输入需要*O*(*df*)的时间。

现在来看行奖励 ❷。外循环在这里循环*d*次。每次迭代都会调用sum，这需要*f*步，因为它必须加总*f*个值。因此，像读取输入一样，这部分算法是*O*(*df*)。

最后，我们来看列奖励 ❸的代码。外循环循环*f*次。每次迭代都会导致内循环迭代*d*次。总的来说，这也是*O*(*df*)。

该算法的每个组成部分是*O*(*df*)。将三个*O*(*df*)的组件加在一起，得到一个*O*(*df*)的算法。

**概念检查**

以下算法的大O效率是多少？

for i in range(m):

<执行一个需要一步的操作>

for j in range(n):

<执行一个需要一步的操作>

A. *O*(1)

B. *O*(*n*)

C. *O*(*n*^(*2*))

D. *O*(*m*+*n*)

E. *O*(*mn*)

答案：D。第一个循环依赖于*m*，第二个循环依赖于*n*。这些循环是顺序执行的，而不是嵌套的，所以它们的工作是相加的，而不是相乘的。

#### 对数时间

在[第255页](ch09.xhtml#ch09lev2sec18)的“我们的程序效率”部分，我们讨论了线性查找和二分查找之间的区别。线性查找通过从头到尾搜索列表来查找一个值。这是一个*O*(*n*)的算法。无论列表是否排序，它都能工作。相比之下，二分查找仅适用于已排序的列表。但如果你有一个已排序的列表，二分查找的速度非常快。

二分查找的工作原理是将我们要查找的值与列表中间的值进行比较。如果列表中间的值大于我们要查找的值，我们就继续在列表的左半部分查找。如果列表中间的值小于我们要查找的值，我们就继续在列表的右半部分查找。我们一直这么做，每次忽略列表的一半，直到找到我们要查找的值为止。

假设我们使用二分查找在一个包含512个值的列表中查找一个值。需要多少步呢？好吧，经过一步后，我们已经忽略了一半的列表，因此剩下大约512 / 2 = 256个值。（无论我们查找的值是否大于或小于列表中一半的值，在每种情况下，我们都会忽略列表的一半。）经过两步后，剩下256 / 2 = 128个值。经过三步后，剩下128 / 2 = 64个值。继续下去，经过四步后剩下32个值，经过五步后剩下16个值，经过六步后剩下8个值，经过七步后剩下4个值，经过八步后剩下2个值，经过九步后只剩下1个值。

九步——就这么多！比起使用线性查找最多需要 512 步，二分查找要好得多。二分查找的工作量远小于线性时间算法。那么它到底是什么类型的算法呢？它不是常数时间：虽然它只需要很少的步骤，但随着输入量的增加，步骤数会稍微增加。

二分查找是一个 *对数时间* 或 *对数时间* 算法的例子。在大 O 符号中，我们说对数时间算法是 *O*(log *n*)。

对数时间指的是数学中的对数函数。给定一个数字，该函数告诉你需要多少次将这个数字除以一个基数才能得到 1 或更小的数值。我们在计算机科学中通常使用的基数是 2，所以我们要找的是将一个数字除以 2，直到得到 1 或更小的次数。例如，将 512 除以 2 需要 9 次。我们写作 log[2] 512 = 9。

对数函数是指数函数的反函数，后者你可能会更熟悉。计算 log[2] 512 的另一种方法是找到一个指数 *p*，使得 2*^p* = 512。由于 2⁹ = 512，我们确认 log[2] 512 = 9。

令人震惊的是对数函数增长得如此缓慢。例如，考虑一个包含一百万个值的列表。二分查找需要多少步才能查找这个列表？它只需要 log[2] 1,000,000 步，约为 20 步。对数时间比线性时间更接近常数时间。每当你能用对数时间算法替换线性时间算法时，这都是一次巨大的胜利。

#### n log n 时间

在[第 5 章](ch05.xhtml#ch05)中，我们解决了村庄邻里问题。我在这里重现了我们在[列表 5-1](ch05.xhtml#ch05ex01)中的解法：

n = int(input())

positions = []

❶ for i in range(n):

positions.append(int(input()))

❷ positions.sort()

left = (positions[1] - positions[0]) / 2

right = (positions[2] - positions[1]) / 2

min_size = left + right

❸ for i in range(2, n - 1):

left = (positions[i] - positions[i - 1]) / 2

right = (positions[i + 1] - positions[i]) / 2

size = left + right

if size < min_size:

min_size = size

print(min_size)

看起来像是线性时间算法，对吧？我是说，那里有一个线性时间循环用来读取输入 ❶，另一个线性时间循环用来找到最小大小 ❸。那这段代码是 *O*(*n*) 吗？

现在下结论还为时过早！原因是我们还没有考虑到排序位置 ❷ 的因素。我们不能忽视这一点；我们需要了解排序的效率。正如我们将看到的，排序比线性时间慢。所以，由于排序是这里最慢的步骤，排序的效率将决定整体的效率。

程序员和计算机科学家们设计了许多排序算法，这些算法大致可以分为两类。第一类是需要 *O*(*n*²) 时间的算法。这三种最著名的排序算法是冒泡排序、选择排序和插入排序。如果你愿意，可以自己深入了解这些排序算法，但在这里我们不需要了解它们的细节。我们只需要记住的是，*O*(*n*²) 的算法可能非常慢。例如，要对一个包含 10,000 个值的列表进行排序，*O*(*n*²) 排序算法大约需要 10,000² = 100,000,000 步。正如我们所知，这样的排序算法至少需要几秒钟的时间才能完成。这个结果相当令人失望：排序 10,000 个值似乎应该是计算机能够几乎瞬间完成的任务。

进入第二类排序算法。这类算法只需要 *O*(*n* log *n*) 时间。这个类别中有两种著名的排序算法：快速排序和归并排序。同样，如果你愿意，可以查阅它们的相关资料，但在这里我们不需要详细了解。

*O*(*n* log *n*) 是什么意思？别让这个符号搞混了。它只是 *n* 乘以 log *n*。我们来对一个包含 10,000 个值的列表进行尝试。这里，我们有 10,000 * log 10,000 步，这大约是 132,877 步。这是一个非常小的步骤数，尤其是与 *O*(*n*²) 排序算法的 100,000,000 步相比。

现在我们可以问一个我们真正关心的问题：当我们让 Python 对列表进行排序时，它使用的是哪种排序算法？答案是：一种 *O*(*n* log *n*) 的算法！（它被称为 Timsort。如果你想了解更多，可以从归并排序开始，因为 Timsort 是改进版的归并排序。）这里没有慢速的 *O*(*n*²) 排序算法。一般来说，排序非常快速—几乎接近线性时间—因此我们可以使用它而不会对效率产生太大影响。

返回到村庄邻里问题，现在我们看到它的效率不是 *O*(*n*)，而是由于排序的原因，变成了 *O*(*n* log *n*)。实际上，*O*(*n* log *n*) 算法比 *O*(*n*) 算法多做一点工作，而远比 *O*(*n*²) 算法少得多。如果你的目标是设计一个 *O*(*n*) 算法，那么设计一个 *O*(*n* log *n*) 算法可能已经足够好了。

#### 处理函数调用

从 [第六章](ch06.xhtml#ch06) 开始，我们编写了自己的函数，帮助我们设计更大的程序。在我们的大 O 分析中，我们需要小心地包括在调用这些函数时所做的工作。

让我们回顾一下 [第六章](ch06.xhtml#ch06) 中的扑克牌问题。我们在 [清单 6-1](ch06.xhtml#ch06ex01) 中解决了这个问题，解决方案的一部分涉及调用我们的 no_high 函数。我在这里重新呈现了该解决方案：

NUM_CARDS = 52

❶ def no_high(lst):

"""

lst 是一个表示扑克牌的字符串列表。

如果 lst 中没有高牌，则返回 True，否则返回 False。

"""

if 'jack' in lst:

return False

if 'queen' in lst:

return False

if 'king' in lst:

return False

if 'ace' in lst:

return False

return True

deck = []

❷ 对于 i 在 range(NUM_CARDS) 中:

deck.append(input())

score_a = 0

score_b = 0

player = 'A'

❸ 对于 i 在 range(NUM_CARDS) 中:

card = deck[i]

points = 0

remaining = NUM_CARDS - i - 1

if card == 'jack' and remaining >= 1 and no_high(deck[i+1:i+2]):

points = 1

elif card == 'queen' and remaining >= 2 and no_high(deck[i+1:i+3]):

points = 2

elif card == 'king' and remaining >= 3 and no_high(deck[i+1:i+4]):

points = 3

elif card == 'ace' and remaining >= 4 and no_high(deck[i+1:i+5]):

points = 4

if points > 0:

print(f'玩家 {player} 得分 {points} 分。')

if player == 'A':

score_a = score_a + points

player = 'B'

else:

score_b = score_b + points

player = 'A'

print(f'玩家 A: {score_a} 分。')

print(f'玩家 B: {score_b} 分。')

我们将用 *n* 来表示卡片的数量。no_high 函数 ❶ 接收一个列表并对其进行 in 操作，因此我们可能会得出它是 *O*(*n*) 的结论。（in 可能需要遍历整个列表来查找它想要的内容。）然而，我们每次调用 no_high 时，传入的列表大小都是常数——最多四张卡片——因此我们可以将每次调用 no_high 视为 *O*(1) 的时间复杂度。

现在我们理解了 no_high 的效率，我们可以确定整个程序的时间复杂度。我们从一个循环开始，它花费 *O*(*n*) 的时间来读取卡片 ❷。然后我们进入另一个循环，该循环迭代 *n* 次 ❸。每次迭代只需要常数步，可能包括调用 no_high，它也只需要常数步。这个循环因此花费 *O*(*n*) 的时间。所以程序由两个 *O*(*n*) 的部分组成，因此总时间复杂度是 *O*(*n*)。

小心准确判断调用函数时执行的工作量。正如你刚刚看到的，通过 no_high，可能需要同时查看函数本身和它被调用的上下文。

**概念检查**

以下算法的时间复杂度是多少？

def f(lst):

for i in range(len(lst)):

lst[i] = lst[i] + 1

# 假设 lst 指的是一个数字列表

for i in range(len(lst)):

f(lst)

A. *O*(1)

B. *O*(*n*)

C. *O*(*n*^(*2*))

答案: C. 主程序中的循环迭代 *n* 次。每次迭代时，我们调用函数 f，而 f 本身也有一个循环，它迭代 *n* 次。

#### 总结

做最少工作的算法是 *O*(1)，然后是 *O*(log *n*)，接着是 *O*(*n*)，最后是 *O*(*n* log *n*)。你曾用这四种中的某一种解决过问题吗？如果有，说明你已经解决了问题。如果没有，那么根据时间限制，你可能还需要更多的工作。

我们现在将探讨两个问题，在这些问题中，直接的解决方案将无法达到效率要求——它将无法在时间限制内运行。利用我们刚刚学到的大 O，我们甚至能在没有实现代码的情况下预测到这个低效性！然后我们将着手寻找一个更快的解决方案，并实现它，以在时间限制内解决问题。

### 问题 #24: 最长围巾

在这个问题中，我们将通过剪裁初始围巾来确定我们能够制作出多长的亲戚想要的围巾。阅读以下描述后，停下来思考：你会如何解决这个问题？你能提出多个算法，并评估它们的效率吗？

这是DMOJ问题 dmopc20c2p2。

#### 挑战

你有一条长度为 *n* 英尺的围巾，每只脚都有特定的颜色。

你还有 *m* 个亲戚。每个亲戚通过指定第一只脚和最后一只脚的颜色来表示他们想要的围巾。

你的目标是通过剪裁原始围巾来制作出最长的亲戚想要的围巾。

#### 输入

输入包括以下几行：

+   一行包含整数围巾长度 *n* 和亲戚数量 *m*，用空格分隔。*n* 和 *m* 的范围都是1到100,000之间。

+   一行包含以空格分隔的 *n* 个整数。每个整数指定了围巾一只脚的颜色，从第一只脚到最后一只脚依次排列。每个整数的范围是1到1,000,000之间。

+   *m* 行，每行代表一个亲戚，包含两个以空格分隔的整数。这些数字描述了亲戚想要的围巾：第一个整数是第一只脚的颜色，第二个整数是最后一只脚的颜色。

#### 输出

输出通过剪裁原始围巾可以制作出的最长想要的围巾的长度。

解决测试案例的时间限制为0.4秒。

### 探索一个测试案例

让我们通过一个小的测试案例来确保我们准确理解问题。测试案例如下：

6 3

18 4 4 2 1 2

1 2

4 2

18 4

我们有一条长6英尺的围巾和三个亲戚。围巾每只脚的颜色依次为18、4、4、2、1、2。我们能做出多长的亲戚想要的围巾呢？

第一个亲戚想要一条围巾，第一只脚是1号颜色，最后一只脚是2号颜色。我们能给这个亲戚的最好围巾是2英尺长：围巾末端的2只脚（颜色1和2）。

第二个亲戚想要一条围巾，第一只脚是4号颜色，最后一只脚是2号颜色。我们可以给他们一条5英尺的围巾：4、4、2、1、2。

第三个亲戚想要一条围巾，第一只脚是18号颜色，最后一只脚是4号颜色。我们可以给他们一条3英尺的围巾：18、4、4。

我们能够制作出的最大长度的想要围巾是5英尺，因此这是这个测试案例的答案。

### 算法 1

我们刚才处理这个测试用例的方法，可能会立即向你暗示一种算法，帮助我们解决这个问题。也就是说，我们应该能够遍历这些亲戚，找出每个人希望的最长围巾的长度。例如，第一个亲戚的最大长度可能是 2，那么我们就记住这个值。第二个亲戚的最大长度可能是 5。这比 2 长，所以我们记住 5。第三个亲戚的最大长度可能是 3。这没有比 5 长——所以不需要更改。如果这让你想起了一个完整搜索算法（[第 9 章](ch09.xhtml#ch09)）：很好，因为它确实是一个完整搜索算法！

有 *m* 个亲戚。如果我们知道处理每个亲戚需要多长时间，那么我们就能计算出我们所处理的大 O 效率。

这里有一个想法：对于每个亲戚，我们可以找到第一段颜色的最左边索引和最后一段颜色的最右边索引。一旦我们得到了这些索引，无论围巾有多长，我们都可以利用这些索引快速确定这个亲戚希望的最长围巾长度。例如，如果第一段颜色的最左边索引是 100，最后一段颜色的最右边索引是 110，那么他们希望的最长围巾长度是 110 – 100 + 1 = 11。

根据我们尝试寻找这些索引的方式，我们可能会幸运地快速找到它们。例如，我们可以从左扫描第一段颜色的最左边索引，再从右扫描最后一段颜色的最右边索引。然后，如果第一段颜色靠近围巾的开头，最后一段颜色靠近围巾的结尾，我们将非常快地发现这些索引。

然而，我们可能并不那么幸运。找到一个或两个索引可能需要 *n* 步。例如，假设一个亲戚想要一条围巾，其第一段的颜色出现在围巾的最后部分，或者根本没有出现在围巾中。我们需要检查整个 *n* 英尺的围巾，一次检查一段，以弄清楚这一点。

那么，每个亲戚大约需要 *n* 步。这是线性时间，我们知道线性时间是快速的。我们没问题吧？不，因为在这种情况下，线性时间的工作量比看起来更具威胁。记住，对于每个亲戚，我们都要执行 *O*(*n*) 的工作。这样总的时间复杂度就是 *O*(*mn*)。*m* 和 *n* 最大可以达到 100,000。所以，*mn* 最大可以达到 100,000 *** 100,000 = 10,000,000,000。那是 100 亿！考虑到我们每秒可以执行大约五百万次操作，而我们的时间限制是 0.4 秒……是的，我们完全不行。这个算法根本无法实现。我们已经确信它会在大型测试用例中超时。不如直接放弃，去实现其他东西吧。（如果你仍然对代码感兴趣，请参考书本相关的在线资源。只要记住，即使不看代码，我们也早就知道它会太慢。大 O 分析的威力就在于帮助我们在实现之前就能知道一个算法是否注定失败。）

### 算法 2

我们必须以某种方式处理每一个亲戚——这是无法避免的。那么，我们需要优化的就是每个亲戚的处理工作量。不幸的是，像上一节那样处理亲戚，可能会让我们检查围巾的很大一部分。正是这种针对每个亲戚逐一检查围巾的操作，才让我们感到吃力。我们需要控制这个搜索过程。

假设我们只能在一开始就看一次围巾，在我们还不知道亲戚们想要什么之前。我们可以记住每种颜色在围巾中的两个信息：它最左边的索引和最右边的索引。然后，无论每个亲戚想要什么，我们都可以通过我们已存储的左右索引来计算他们所需围巾的最大长度。

比如，假设我们有这样一条围巾：

18 4 4 2 1 2

我们会存储以下信息：

| **颜色** | **最左索引** | **最右索引** |
| --- | --- | --- |
| 1 | 4 | 4 |
| 2 | 3 | 5 |
| 4 | 1 | 2 |
| 18 | 0 | 0 |

假设一个亲戚想要的围巾的第一段是颜色 1，最后一段是颜色 2。我们查找颜色 1 的最左索引是 4，颜色 2 的最右索引是 5。然后，我们计算 5 - 4 + 1 = 2，这就是该亲戚所需围巾的最大长度。

太神奇了：不管围巾多长，我们只需为每个亲戚做一个快速的计算。不再需要一次又一次地跑遍围巾。唯一的难点在于如何计算每种颜色的最左和最右索引，并且只看一次围巾。

代码可以参考 [清单 10-1](ch10.xhtml#ch10ex01)。在继续阅读我的解释之前，试着理解最左索引和最右索引字典是如何构建的。

lst = input().split()

n = int(lst[0])

m = int(lst[1])

scarf = input().split()

for i in range(n):

scarf[i] = int(scarf[i])

❶ leftmost_index = {}

❷ rightmost_index = {}

❸ for i in range(n):

color = scarf[i]

❹ 如果颜色不在最左索引中：

leftmost_index[color] = i

rightmost_index[color] = i

❺ 否则：

rightmost_index[color] = i

max_length = 0

for i in range(m):

relative = input().split()

first = int(relative[0])

last = int(relative[1])

if first in leftmost_index and last in leftmost_index:

❻ length = rightmost_index[last] - leftmost_index[first] + 1

如果长度大于最大长度：

max_length = length

print(max_length)

*清单 10-1：解决最长围巾问题，算法 2*

这个解决方案使用了两个字典：一个用于跟踪每个颜色的最左索引 ❶，另一个用于跟踪每个颜色的最右索引 ❷。

如承诺，我们只检查一次每个围巾的脚 ❸。下面是我们如何保持 leftmost_index 和 rightmost_index 字典的更新：

+   如果当前脚的颜色以前从未出现过 ❹，那么当前索引既是该颜色的最左索引也是最右索引。

+   否则，当前脚的颜色之前已经出现过 ❺。我们不想更新这个颜色的最左索引，因为当前索引在旧索引的右侧。不过，我们*确实*希望更新最右索引，因为我们找到了一个位于旧索引右侧的索引。

现在到了回报的时候：对于每一个相对位置，我们可以简单地从这些字典中查找最左和最右的索引 ❻。所需围巾的最大长度是最后一只脚的颜色的最右索引减去第一只脚的颜色的最左索引，再加一。

正如我现在所要论证的，这个算法比算法1要好得多。读取围巾的过程需要 *O*(*n*) 时间，处理围巾的脚也需要 *O*(*n*) 时间。到目前为止是 *O*(*n*) 时间。然后我们花常数时间来处理每个相对位置（不像之前那样是 *n* 步！），所以是 *O*(*m*) 时间。总的来说，我们有一个 *O*(*m* + *n*) 的算法，而不是 *O*(*mn*) 算法。考虑到 *m* 和 *n* 最大可以是 100,000，我们总共只需大约 100,000 + 100,000 = 200,000 步，完全能够在时间限制内完成。你可以提交我们的代码给裁判以证明这一点！

### 问题 #25：彩带涂色

这是另一个问题，其中我们可能首先想到的算法过于缓慢。然而，我们不会在这个算法上浪费太多时间，因为我们的时间复杂度分析会在我们考虑实现代码之前告诉我们所有需要知道的信息。然后，我们将花时间设计一个更快的算法。

这是DMOJ问题dmopc17c4p1。

#### 挑战

你有一条紫色的彩带，长度为 *n* 单位。第一单位从位置 0 到不包括位置 1，第二单位从位置 1 到不包括位置 2，以此类推。然后你进行 *q* 次涂色操作，每次操作将彩带的一段涂成蓝色。

你的目标是确定仍然是紫色的带子单位数和现在是蓝色的带子单位数。

#### 输入

输入包含以下几行：

+   一行包含整数带子长度*n*和涂料笔触的整数数量*q*，两者之间以空格分隔。*n*和*q*的值都在1到100,000之间。

+   *q*行，每行一个涂料笔触，包含两个整数，用空格分隔。第一个整数给出涂料笔触的起始位置；第二个整数给出涂料笔触的结束位置。起始位置保证小于结束位置；每个整数的值在0到*n*之间。涂料笔触从起始位置涂到结束位置，但不包括结束位置。这里举个简单的例子，如果一笔涂料的起始位置是5，结束位置是12，那么这笔涂料就将带子从位置5涂到12，但不包括12的位置。

#### 输出

输出仍然是紫色的带子单位数，一个空格，再加上现在是蓝色的带子单位数。

解决测试用例的时间限制是2秒。

### 探索一个测试用例

让我们来看一个小的测试用例。这个用例不仅能确保我们正确理解了问题，还能凸显朴素算法的陷阱。这个用例如下：

20 4

18 19

4 16

4 14

5 12

我们的带子长度为20，有四个涂料笔触。那么这些涂料笔触将多少部分带子涂成蓝色呢？

第一笔涂料将一个单位涂成蓝色，涂抹的位置是18。

第二笔涂料涂了从位置4到位置15的带子单位。这次涂了12个单位的蓝色，这样总共有13个蓝色单位。

第三笔涂料将10个单位涂成蓝色。但是，这些单位在第二笔涂料时已经是蓝色的了！如果我们在这次涂料过程中仍然涂抹这些单位，那将是一次巨大的时间浪费！我们设计的算法最好不要陷入这种浪费时间的陷阱。

第四笔涂料涂了7个单位蓝色。但同样：这些单位早已是蓝色的了！

现在我们涂完了，剩下13个蓝色单位。总长度是20 – 13 = 7，剩下7个紫色单位，因此该测试用例的正确输出是：

7 13

### 解决问题

带子的最大长度为100,000，最大涂料笔触数量为100,000。回想一下我们在解决《最长围巾》问题时使用的算法1，我们发现*O*( *mn* )算法在这些约束条件下会太慢。同样地，在这里，*O*( *nq* )算法也不合适，因为在大测试用例上，它无法在时间限制内完成。

这意味着我们不能处理每个被涂料笔触涂上的单位。如果我们能更容易地专注于仅仅那些被新涂成蓝色的*单位*就好了。这样我们就可以遍历每个涂料笔触，计算出它涂上蓝色的单位数量。

说得对，但我们如何确定每个涂抹笔触的贡献呢？这很棘手，因为下一个涂抹笔触的部分区域可能已经被之前的涂抹笔触涂成了蓝色。

然而，如果我们首先对涂抹笔触进行排序，这种情况就变得简单得多。记住在本章早些时候提到的 “n log n 时间” 这一点，排序非常快速，只需 *O*(*n* log *n*) 时间。使用排序不会引起效率问题，因此我们来理解一下排序为何能帮助我们。

对上一节测试用例中的涂抹笔触进行排序，得到以下涂抹笔触列表：

4 14

4 16

5 12

18 19

现在，涂抹笔触已经排序，我们可以高效地处理它们。在此过程中，我们会存储已处理的涂抹笔触的最右位置。我们将最右位置初始为 0，表示我们还没有涂任何颜色。

我们的第一个涂抹笔触涂抹了 14 – 4 = 10 个蓝色单元。现在，我们存储的最右位置是 14。

我们的第二个涂抹笔触涂抹了 12 个蓝色单元，没错，但其中有多少个单元是从紫色变成了蓝色？毕竟，它与之前的涂抹笔触重叠，所以其中的一部分单元已经是蓝色了。我们可以通过从 16（当前涂抹笔触的结束位置）减去 14（我们存储的最右位置），来计算新增的蓝色单元数量。这就是我们忽略之前涂抹笔触已经涂上的蓝色单元的方式。因此，有 16 – 14 = 2 个新的蓝色单元，总共有 12 个蓝色单元。关键是，我们没有逐个处理这个涂抹笔触的单元，就弄清楚了这一点。继续之前，别忘了更新我们存储的最右位置为 16。

我们的第三个涂抹笔触与第二个类似，它的起始位置早于我们存储的最右位置。然而，与第二个涂抹笔触不同的是，它的结束位置完全没有超出我们存储的最右位置。因此，这个涂抹笔触并没有添加新的蓝色单元，我们存储的最右位置仍然是16。再次强调，我们在没有逐个处理这个涂抹笔触位置的情况下就弄清楚了这一点！

小心第四个涂抹笔触。它*并没有*增加 19 – 16 = 3 个新的蓝色单元。我们必须以不同的方式处理这个涂抹笔触，因为它的起始位置在我们存储的最右位置的右侧。在这种情况下，我们根本不使用存储的最右位置，而是计算 19 – 18 = 1 个新的蓝色单元，总共有 13 个蓝色单元。我们还将存储的最右位置更新为 19。

唯一的问题是我们如何在 Python 代码中对涂抹笔触进行排序。我们需要按照它们的起始位置进行排序；如果多个涂抹笔触具有相同的起始位置，那么我们希望按照它们的结束位置进行排序。

也就是说，我们希望像这样处理一个列表：

[[18, 19], [4, 16], [4, 14], [5, 12]]

并且产生这个结果：

[[4, 14], [4, 16], [5, 12], [18, 19]]

幸运的是，正如我们在[第6章](ch06.xhtml#ch06)的“任务4：排序盒子”中发现的那样，列表排序方法正是按这种方式工作的。当给定一个列表的列表时，sort会根据每个列表中的第一个值进行排序；如果这些值相同，则通过第二个值进一步排序。看看这个：

>>> strokes = [[18, 19], [4, 16], [4, 14], [5, 12]]

>>> strokes.sort()

>>> strokes

[[4, 14], [4, 16], [5, 12], [18, 19]]

算法：检查。排序：检查。我们状态很好！在查看代码之前，我们还想知道一件事：它的时间复杂度是什么？我们需要读取*q*个查询；这需要*O*(*q*)时间。然后我们需要对查询进行排序；这需要*O*(*q* log *q*)时间。最后，我们需要处理这些查询；这需要*O*(*q*)时间。最慢的是排序的*O*(*q* log *q*)时间，因此这是我们总体的时间复杂度。

现在我们有了快速解决方案所需的一切。查看[Listing 10-2](ch10.xhtml#ch10ex02)中的内容。

lst = input().split()

n = int(lst[0])

q = int(lst[1])

strokes = []

for i in range(q):

stroke = input().split()

❶ strokes.append([int(stroke[0]), int(stroke[1])])

❷ strokes.sort()

rightmost_position = 0

blue = 0

for stroke in strokes:

stroke_start = stroke[0]

stroke_end = stroke[1]

❸ if stroke_start <= rightmost_position:

if stroke_end > rightmost_position:

❹ blue = blue + stroke_end - rightmost_position

rightmost_position = stroke_end

❺ else:

❻ blue = blue + stroke_end - stroke_start

rightmost_position = stroke_end

print(n - blue, blue)

*Listing 10-2: 解决带状绘画问题*

我们读取每个绘画笔触，将其作为两个值的列表添加到我们的strokes列表中❶。然后我们对所有绘画笔触进行排序❷。

接下来，我们需要从左到右处理每个绘画笔触。有两个关键变量驱动这个处理：变量rightmost_position存储我们目前为止绘制的最右位置，变量blue存储我们目前为止绘制的蓝色区域数量。

要处理一个绘画笔触，我们需要知道它是开始于我们存储的最右位置之前，还是之后。让我们逐一考虑这些情况。

首先：当绘画笔触开始于我们存储的最右位置之前时该怎么办❸？这个绘画笔触可能会给我们一些新的蓝色单位，但前提是它延伸超过我们存储的最右位置。如果确实如此，那么新的蓝色单位就是从存储的最右位置到绘画笔触结束位置之间的那些单位❹。

其次：当绘画笔触开始于我们存储的最右位置之后时该怎么办❺？这时，绘画笔触与我们之前绘制的区域完全分开；这个整个绘画笔触是一个新的蓝色区域。因此，新的蓝色单位就是这个绘画笔触的结束位置和起始位置之间的那些单位❻。

请注意，在每个情况下，我们还会正确更新存储的最右位置，以便我们准备好处理进一步的绘画笔触。

就这样！在大 O 分析的指导下，我们能够摒弃一个我们知道实现会太慢的算法。然后我们思考了第二个算法——在实现之前，我们知道它会非常快速。是时候把我们的代码提交给评审，享受成功的喜悦了。

### 总结

在这一章中，我们学习了大 O 分析。大 O 是算法设计进一步学习的一个重要效率基石。你将在各个地方看到它：在教程中，在书籍中，可能还有你下一次的工作面试中！

我们还解决了两个需要设计非常高效算法的问题。我们不仅能够做到这一点，还能够利用大 O 得到一个令人满意的理解，确切地知道为什么我们的代码如此高效。

### 章节练习

这里有一些练习供你尝试。对于每一个练习，使用大 O 分析来判断你提议的算法是否足够高效，以便在时间限制内解决问题。你也可以实现一些你知道会太慢的算法。这将为你提供额外的练习，巩固你的 Python 知识，并确认你的大 O 分析是否准确！

其中一些问题相当具有挑战性。这里有两个原因。首先，你可能会根据你在全书中的工作发现，提出*任何*算法都可能是艰难的。提出一个更快的算法甚至更难。其次，这是我们共度时光的结束，但只是算法学习的开始。我希望这些问题既能帮助你欣赏自己所取得的成就，又能证明，如果你愿意，书籍之外还有更多的内容等待你去探索。

1.  DMOJ 问题 dmopc17c1p1，Fujo Neko（该问题讨论了如何使用快速输入/输出。不要忽视这一点！）

1.  DMOJ 问题 coci10c1p2，Profesor

1.  DMOJ 问题 coci19c4p1，Pod starim krovovima（提示：为了最大化空玻璃杯的数量，你需要尽可能将液体倒入最大的玻璃杯中。）

1.  DMOJ 问题 dmopc20c1p2，Victor’s Moral Dilemma

1.  DMOJ 问题 avocadotrees，Avocado Trees!

1.  DMOJ 问题 coci11c5p2，Eko（提示：最大树木数量远小于最大高度数量。从最高到最低考虑每棵树。）

1.  DMOJ 问题 wac6p2，Cheap Christmas Lights（提示：不要试图每秒切换一次开关——你怎么知道该切换哪个？相反，先储存开关，尽快在能关掉所有开着的灯时一次性使用它们。）

1.  DMOJ 问题 ioi98p3，Party Lamps（提示：对于每个按钮来说，关键是它被按下的次数是奇数还是偶数。）

### 备注

最长围巾最初来自于 DMOPC ’14 三月比赛。彩带绘画最初来自于 DMOPC ’20 十一月比赛。
