## 第三章：重复代码：确定性循环

![image](img/common.jpg)

计算机在重复执行一个过程时表现得非常出色。它们会不知疲倦地按照我们的要求执行，无论是执行 10 次、100 次，还是 10 亿次。在这一章中，我们将学习循环，它是指示计算机重复执行程序部分代码的语句。

我们将使用循环来解决三个问题：追踪球在杯子下的位置，计算占用的停车位数，以及确定手机套餐上的可用数据量。

### 问题 #5：三只杯子

在这个问题中，我们将追踪球在杯子下的位置，随着杯子移动而变化。但杯子可能会移动多次，因此我们不能为每次移动单独编写代码。相反，我们将学习并使用 `for` 循环，它可以让我们更轻松地为每次移动执行代码。

这是 DMOJ 问题 `coci06c5p1`。

#### 挑战

Borko 有一排三只不透明的杯子：一个在左边（位置 1），一个在中间（位置 2），一个在右边（位置 3）。球在左边的杯子下。我们的任务是随着 Borko 交换杯子的顺序，追踪球的位置。

Borko 可以进行三种类型的交换：

**A** 交换左杯和中杯

**B** 交换中杯和右杯

**C** 交换左杯和右杯

例如，如果 Borko 的第一次交换是 A 类型，那么他交换左杯和中杯；因为球最初在左边，这个交换将球移动到中间。如果他的第一次交换是 B 类型，那么他交换中杯和右杯；左杯保持原位，所以球的位置不变。

#### 输入

输入是一行最多 50 个字符的字符串。每个字符表示 Borko 进行的一种交换类型：`A`、`B` 或 `C`。

#### 输出

输出球的最终位置：

+   `1` 如果球在左边

+   `2` 如果球在中间

+   `3` 如果球在右边

### 为什么要用循环？

考虑以下测试案例：

```py
ACBA
```

这里有四次交换。为了确定球的最终位置，我们需要执行每一次交换。

第一次交换是 A 类型，交换左杯和中杯。因为球最初在左边，这将球移动到中间。第二次交换是 C 类型，交换左杯和右杯。由于球目前在中间，所以这次交换对球的位置没有影响。第三次交换是 B 类型，交换中杯和右杯。这个交换将球从中间移动到右边。第四次交换是 A 类型，交换左杯和中杯。这个交换对球没有影响。因此，正确的输出是 `3`，因为球最终在右边。

请注意，对于每次交换，我们需要做出决策，判断球是否移动，如果移动了，如何正确地移动球。做决策是我们在第二章中学过的内容。例如，如果交换类型是`A`，且球在左侧，则球移动到中间。看起来是这样的：

```py
if swap_type == 'A' and ball_location == 1:

    ball_location = 2
```

我们可以为每个其他球移动的情况添加一个`elif`分支：交换类型`A`且球在中间，交换类型`B`且球在中间，交换类型`B`且球在右侧，等等。这个大的`if`语句可以处理一次交换。但这还不足以解决三杯问题，因为我们可能会有最多 50 次交换的测试案例。我们需要为每次交换重复`if`语句逻辑。而且我们当然不希望复制粘贴相同的代码 50 次。想象一下如果你写错了一个地方，需要修正 50 次。或者如果你突然对最多有百万次交换的测试案例产生兴趣。不会的，我们到目前为止学到的东西还远远不够。我们需要一种方法，能够遍历这些交换，为每个交换执行相同的逻辑。我们需要一个循环。

### for 循环

Python 的`for`语句生成*for 循环*。`for`循环让我们可以处理序列中的每个元素。到目前为止，我们所见的唯一序列类型是字符串。我们将会学习其他类型；`for`循环适用于所有这些类型。

这是我们第一个`for`循环的示例：

```py
>>> secret_word = 'olive'

>>> for char in secret_word:

...     print('Letter: ' + char)

...

Letter: o

Letter: l

Letter: i

Letter: v

Letter: e
```

在关键字`for`后，我们写上一个*循环变量*的名字。循环变量是在循环进行时，引用不同值的变量。在字符串的`for`循环中，循环变量指向字符串中的每个字符。

我选择了变量名`char`（表示“字符”），提醒我们这个变量指代字符串中的一个字符。有时候，如果使用一个有上下文的变量名会更清晰。例如，在“三杯”问题中，我们可以使用`swap_type`这个名字，提醒我们它代表的是一种交换类型。

在变量名后面，我们有关键字`in`，然后是我们想要循环的字符串。在我们的例子中，我们正在循环遍历由`secret_word`表示的字符串，值为`'olive'`。

像`if`、`elif`和`else`语句中的`if`行一样，`for`行以冒号（`:`）结束。而且，和`if`语句类似，`for`语句也有一个缩进的语句块，里面可以包含一个或多个语句。

执行这个缩进语句块的过程称为*迭代*。以下是我们循环在每次迭代时的执行步骤：

+   在第一次迭代时，Python 将`char`设置为指向`'olive'`的第一个字符`'o'`。然后它执行循环块，循环块中只有对`print`的调用。由于`char`指向`'o'`，所以输出结果是`Letter: o`。

+   在第二次迭代时，Python 将`char`设置为指向`'olive'`的第二个字符`'l'`。然后它调用`print`，输出`Letter: l`。

+   这个过程会再重复三次，每次处理`'olive'`中的剩余字符。

+   然后循环终止。我们在循环后没有其他代码，所以程序已经运行完毕。如果循环后有额外的代码，执行将继续进行。

你可以在 `for` 循环的代码块中放入多个语句。这里有一个示例：

```py
>>> secret_word = 'olive'

>>> for char in secret_word:

...     print('Letter: ' + char)

...     print('*')

...

Letter: o

*

Letter: l

*

Letter: i

*

Letter: v

*

Letter: e

*
```

现在我们在每次迭代时有两个语句执行：一个输出字符串的当前字母，另一个输出 `*` 字符。

`for` 循环遍历序列的元素，因此序列的长度告诉我们会有多少次迭代。`len` 函数接受一个字符串并返回其长度：

```py
>>> len('olive')

5
```

我们对 `'olive'` 的 `for` 循环因此会进行五次迭代：

```py
   >>> secret_word = 'olive'

❶ >>> print(len(secret_word), 'iterations, coming right up!')

   >>> for char in secret_word:

 ...     print('Letter: ' + char)

   ...

   5 iterations, coming right up!

   Letter: o

   Letter: l

   Letter: i

   Letter: v

   Letter: e
```

我调用了带有多个参数的 `print` ❶，而不是使用字符串拼接，目的是避免将长度转换为字符串。

`for` 循环是所谓的*确定性循环*，即迭代次数是预定的。还有*不确定性循环*，它们的迭代次数依赖于程序运行时发生的随机情况。我们将在下一章学习这些。

**概念检查**

以下代码的输出是什么？

```py
s = 'garage'

total = 0

for char in s:

    total = total + s.count(char)

print(total)
```

A. `6`

B. `10`

C. `12`

D. `36`

答案：B。对于 `'garage'` 中的每个字符，我们将其计数加到 `total` 中。这里有两个 `g`，两个 `a`，一个 `r`，两个 `a`（再次出现！），两个 `g`（再次出现！），以及一个 `e`。

### 嵌套

`for` 循环块是一个或多个语句。这些语句可以包括一行语句，如函数调用和赋值语句。但它们也可以包含多行语句，如 `if` 语句和循环。

让我们从一个 `for` 循环中的 `if` 语句示例开始。假设我们只想输出字符串中的大写字符。字符串有一个 `isupper` 方法，我们可以用它来判断一个字符是否是大写字母：

```py
>>> 'q'.isupper()

False

>>> 'Q'.isupper()

True
```

我们可以在 `if` 语句中使用 `isupper` 来控制每次 `for` 循环的迭代过程：

```py
>>> title = 'The Escape'

>>> for char in title:

...     if char.isupper():

...         print(char)

...

T

E
```

注意这里的缩进。我们需要一个缩进层级来表示 `for` 循环，另一个额外的缩进层级用来表示嵌套的 `if` 语句。

在第一次迭代时，`char` 表示 `'T'`。由于 `'T'` 是大写字母，`isupper` 测试返回 `True`，于是 `if` 语句块执行。这导致输出 `T`。在第二次迭代时，`char` 表示 `'h'`。这次，`isupper` 测试返回 `False`，所以 `if` 语句块不执行。总体来说，`for` 循环遍历字符串中的每个字符，但嵌套的 `if` 语句只会在两个地方触发：一个是字符串开头的 `'T'`，另一个是 `'Escape'` 开头的 `'E'`。

那么，`for` 循环嵌套在另一个 `for` 循环中怎么办？我们可以这么做！这里有一个示例：

```py
>>> letters = 'ABC'

>>> digits = '123'

>>> for letter in letters:

...     for digit in digits:

...         print(letter + digit)

...

A1

A2

A3

B1

B2

B3

C1

C2

C3
```

这段代码生成所有由两个字符组成的字符串，第一个字符来自 `letters`，第二个字符来自 `digits`。

在外循环（`letters`）的第一次迭代中，`letter` 为 `'A'`。这次迭代完全运行内循环（`digits`）。内循环运行的整个时间，`letter` 都为 `'A'`。在内循环的第一次迭代中，`digit` 为 `1`，这就解释了 `A1` 的输出。在内循环的第二次迭代中，`digit` 为 `2`，并输出 `A2`。在内循环的第三次也是最后一次迭代中，`digit` 为 `3`，并输出 `A3`。

我们还没完成！我们只走了一遍外循环。在外循环的第二次迭代中，`letter` 变为 `'B'`。现在，内循环的三次迭代再次运行，这时 `letter` 指向 `'B'`。这就解释了 `B1`、`B2` 和 `B3` 的输出。最后，在外循环的第三次迭代中，`letter` 指向 `'C'`，内循环产生 `C1`、`C2` 和 `C3`。

**概念检查**

以下代码的输出是什么？

```py
title = 'The Escape'

total = 0

for char1 in title:

    for char2 in title:

        total = total + 1

print(total)
```

A. `10`

B. `20`

C. `100`

D. 这段代码会产生语法错误，因为两个嵌套的循环不能同时使用 `title`。

答案：C. `total` 最初为 `0`，并在每次内循环迭代时增加 1。`'The Escape'` 的长度为 10。因此外循环有 10 次迭代。每次迭代时，内循环都会有 10 次迭代。因此内循环一共会有 10*10 = 100 次迭代。

### 解决问题

回到三杯问题。我们需要的结构是一个 `for` 循环遍历每个交换，并嵌套一个 `if` 语句来跟踪球的位置：

```py
for swap_type in swaps:

    # Big if statement to keep track of the ball
```

有三种类型的交换（A、B 和 C）和三种可能的位置，因此我们可能会得出结论，必须编写一个包含 3 * 3 = 9 个布尔表达式的 `if` 语句（一个在 `if` 后面，另外八个在每个 `elif` 后面）。实际上，我们只需要六个布尔表达式。九个表达式中有三个根本不移动球：当球在右侧时交换类型 A，当球在左侧时交换类型 B，当球在中间时交换类型 C。

列表 3-1 提供了三杯问题的解决方案。

```py
   swaps = input()

   ball_location = 1

❶ for swap_type in swaps:

    ❷ if swap_type == 'A' and ball_location == 1:

        ❸ ball_location = 2

       elif swap_type == 'A' and ball_location == 2:

           ball_location = 1

       elif swap_type == 'B' and ball_location == 2:

           ball_location = 3

       elif swap_type == 'B' and ball_location == 3:

           ball_location = 2

       elif swap_type == 'C' and ball_location == 1:

           ball_location = 3

       elif swap_type == 'C' and ball_location == 3:

           ball_location = 1

   print(ball_location)
```

*列表 3-1：解决三杯问题*

我使用 `input` 将交换字符串赋值给 `swaps` 变量。`for` 循环❶遍历这些交换。每个交换都由嵌套的 `if` 语句 ❷ 处理。`if` 和 `elif` 分支分别编码了给定交换类型和给定球位置时发生的情况，并根据情况移动球。例如，如果交换类型是 `A` 且球的位置是 1 ❷，则球最终会到达位置 2 ❸。

这是一个代码示例，展示了我们使用多个 `elif`（一个大的 `if` 语句）或多个 `if`（多个 `if` 语句）时的区别。如果我们将 `elif` 改为 `if`，那么我们的代码就不再正确了。列表 3-2 显示了错误的代码。

```py
# This code is incorrect

swaps = input()

ball_location = 1

for swap_type in swaps:

 ❶ if swap_type == 'A' and ball_location == 1:

        ball_location = 2

 ❷ if swap_type == 'A' and ball_location == 2:

        ball_location = 1

    if swap_type == 'B' and ball_location == 2:

        ball_location = 3

    if swap_type == 'B' and ball_location == 3:

        ball_location = 2

    if swap_type == 'C' and ball_location == 1:

        ball_location = 3

    if swap_type == 'C' and ball_location == 3:

        ball_location = 1

print(ball_location)
```

*列表 3-2：错误地解决三杯问题*

如果我们说代码不正确，那么我们声称它至少在一个测试用例中失败了。你能找到一个测试用例，其中这个代码输出了错误的答案吗？

这里有一个这样的测试用例：

```py
A
```

我们可能认为球每次交换最多只能移动一次。但 Python 会机械地执行你编写的代码，无论它是否符合我们的预期。在这种情况下，我们只有一次交换，所以球最多应移动一次。在`for`循环的第一次也是唯一一次迭代中，Python 检查表达式❶。它为`True`，因此 Python 将`ball_location`设置为`2`。然后，Python 检查表达式❷。因为我们刚刚将`ball_location`设置为`2`，这个表达式也为`True`！因此，Python 将`ball_location`设置为`1`。程序的输出是`1`，而它应该是`2`。

这是一个*逻辑错误*的例子：导致程序遵循错误逻辑并产生错误答案的错误。逻辑错误的常见术语是*bug*。当程序员修复代码中的 bug 时，这个过程称为*调试*。

通常只需要一个简单的测试用例，就能演示程序何时不正确。当你试图缩小问题范围时，不要从长的测试用例开始。这类测试用例的结果很难手动验证，并且常常会触发复杂的执行路径，我们可能从中学到的东西很少。相反，一个小的测试用例不会让程序做太多事；如果它做的事情是错误的，那么我们查找错误的范围就不大了。设计小而有针对性的测试用例并不总是容易的。这是一个可以通过练习来磨练的技能。

提交我们正确的代码给评测系统，然后继续。

在继续之前，你可以尝试解决“章节练习”中第 1 和第 2 题，见第 67 页。

### 问题 #6：占用的停车位

我们知道如何遍历字符串的字符。但有时我们需要知道在字符串中的位置，而不仅仅是存储在那里字符。这就是一个这样的例子。

这是 DMOJ 问题`ccc18j2`。

#### 挑战

你管理一个有*n*个停车位的停车场。昨天，你记录了每个停车位是否被车占用，或者是空的。今天，你再次记录了每个停车位是否被车占用，或者是空的。请指出在两个日期中都被占用的停车位数量。

#### 输入

输入由三行组成。

+   第一行包含整数*n*，表示停车位的数量。*n*的范围是 1 到 100 之间。

+   第二行包含一个长度为*n*的字符串，表示昨天的信息，每个字符对应一个停车位。`C`表示占用的停车位（C 代表车），`.`表示空的停车位。例如，`CC.`表示前两个停车位被占用，第三个停车位为空。

+   第三行包含一个长度为*n*的字符串，表示今天的信息，格式与第二行相同。

#### 输出

输出两个日期中被占用的停车位数量。

### 一种新的循环方式

我们最多可以有 100 个停车位，所以你可能不会惊讶地发现这里会有一个循环。我们在解决“三杯问题”时学到的那种 `for` 循环当然可以遍历停车位信息的字符串：

```py
>>> yesterday = 'CC.'

>>> for parking_space in yesterday:

...     print('The space is ' + parking_space)

...

The space is C

The space is C

The space is .
```

这告诉我们每个停车位昨天是否被占用。但我们还需要知道每个停车位今天是否也被占用。

考虑这个测试用例：

```py
3

CC.

.C.
```

第一个停车位昨天被占用了。那个停车位在两天都有被占用吗？为了回答这个问题，我们需要查看今天字符串中对应的字符。它是一个 `.`（空的），所以这个停车位并没有在两天都被占用。

那么第二个停车位呢？那个昨天也被占用了。而且，看看今天字符串中的第二个字符，今天它也被占用了。所以这个*确实*是一个在两天都被占用的停车位。（这是唯一一个这样的停车位；该测试用例的正确输出是`1`。）

遍历一个字符串中的字符并不能帮助我们找到另一个字符串中对应的字符。但如果我们能够追踪我们在字符串中的位置——我们在第一个停车位，我们在第二个停车位，依此类推——我们就可以查找每个字符串中的对应字符。到目前为止我们学过的 `for` 循环并不是这种操作的方式。正确的方式是使用索引和一种新的 `for` 循环。

### 索引

字符串中的每个字符都有一个*索引*，它表示字符的位置。第一个字符的索引是 0，第二个字符的索引是 1，以此类推。在自然语言中，我们通常从 1 开始计数。在英语中，没有人会说“*hello* 中位置 0 的字符是 *h*。”但大多数编程语言，包括 Python，都从 0 开始计数。

要使用索引，我们在字符串后面加上方括号中的索引。以下是一些索引的示例：

```py
>>> word = 'splore'

>>> word[0]

's'

 >>> word[3]

'o'

>>> word[5]

'e'
```

如果我们愿意，可以在索引中使用变量：

```py
>>> where = 2

>>> word[where]

'l'

>>> word[where + 2]

'r'
```

我们在非空字符串上可以使用的最高索引是其长度减去 1。（空字符串没有有效的索引。）例如，`'splore'`的长度是 6，因此索引 5 是它的最高索引。再大就会报错：

```py
>>> word[len(word)]

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

IndexError: string index out of range

>>> word[len(word) - 1]

'e'
```

如何访问字符串从右数的第二个字符呢？这样就可以做到：

```py
>>> word[len(word) - 2]

'r'
```

但是有一个更简单的方法。Python 支持负数索引作为访问字符的另一种选项。索引`-1`表示最右边的字符，索引`-2`表示从右数第二个字符，以此类推：

```py
>>> word[-2]

'r'

>>> word[-1]

'e'

>>> word[-5]

'p'

>>> word[-6]

's'

>>> word[-7]

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

IndexError: string index out of range
```

计划是使用索引来访问昨天和今天停车信息的对应位置。我们可以使用每个字符串的索引 0 来访问第一个停车位的信息，索引 1 来访问第二个停车位的信息，依此类推。但在我们可以实施这个计划之前，我们需要学习一种新的 `for` 循环。

**概念检查**

以下代码的输出是什么？

```py
s = 'abcde'

t = s[0] + s[-5] + s[len(s) - 5]

print(t)
```

A. `aaa`

B. `aae`

C. `aee`

D. 这段代码会产生错误

答案：A. 三个索引中的每一个都指向 `'abcde'` 中的第一个字符。首先，`s[0]` 指向 `'a'`，因为 `'a'` 在字符串中的索引是 0。其次，`s[-5]` 指向 `'a'`，因为 `'a'` 是从右数第五个字符。第三，`s[len(s) - 5]` 指向 `'a'`，因为索引计算结果为 0：5（字符串的长度）减去 5。

### 范围循环

Python 的 `range` 函数生成整数范围，我们可以使用这些范围来控制 `for` 循环。与其循环遍历字符串的字符，不如使用范围 `for` 循环来遍历整数。如果我们向 `range` 提供一个参数，我们将得到一个从 0 到比该参数小 1 的范围：

```py
>>> for num in range(5):

...     print(num)

...

0

1

2

3

4
```

注意，`5` 没有被输出。

如果我们向 `range` 提供两个参数，我们将得到一个从第一个参数到但不包括第二个参数的序列：

```py
>>> for num in range(3, 7):

...     print(num)

 ...

3

4

5

6
```

我们可以通过包含第三个参数来按不同的 *步长* 递增。默认的步长是 `1`，即每次递增 1。让我们试试其他几个步长：

```py
>>> for num in range(0, 10, 2):

...     print(num)

...

0

2

4

6

8

>>> for num in range(0, 10, 3):

...     print(num)

...

0

3

6

9
```

我们也可以倒数，但 *不是*这样：

```py
>>> for num in range(6, 2):

...     print(num)

...
```

这样行不通，因为默认情况下，`range` 是递增的。步长为 `-1` 让我们可以逐步递减：

```py
>>> for num in range(6, 2, -1):

...     print(num)

...

6

5

4

3
```

为了从 `6` 递减到 `0`（包括 0），我们需要将第二个参数设置为 `-1`：

```py
>>> for num in range(6, -1, -1):

...     print(num)

...

6

 5

4

3

2

1

0
```

有时快速查看范围中的数字而不编写循环是很有帮助的。不幸的是，`range` 函数并不会直接显示这些数字：

```py
>>> range(3, 7)

range(3, 7)
```

我们可以将该结果传递给 `list` 函数来获取我们想要的结果：

```py
>>> list(range(3, 7))

[3, 4, 5, 6]
```

当与范围一起调用时，`list` 函数会生成一个包含该范围内整数的列表。我们稍后会详细学习列表；现在，请将 `list` 保留在脑海中，作为诊断范围错误的辅助工具。

**概念检查**

以下循环执行了多少次迭代？

```py
for i in range(10, 20):

    # Some code here
```

A. 9

B. 10

C. 11

D. 20

答案：B. 范围遍历了数字 10、11、12、13、14、15、16、17、18 和 19，共有 10 个数字，因此执行了 10 次迭代。

### 通过索引的范围循环

假设我们有表示昨天和今天停车位信息的字符串：

```py
>>> yesterday = 'CC.'

>>> today = '.C.'
```

给定一个索引，我们可以查看昨天和今天的该索引信息：

```py
>>> yesterday[0]

'C'

>>> today[0]

'.'
```

我们可以通过索引使用范围 `for` 循环来处理每一对对应的字符。我们知道 `yesterday` 和 `today` 的长度是相同的。但是这个长度可以是从 1 到 100 之间的任何值，所以我们不能写类似 `range(3)` 的东西。我们想要的迭代索引是 0、1、2，依此类推，一直到字符串长度减去 1。我们可以通过使用其中一个字符串的长度作为 `range` 的参数来实现：

```py
>>> for index in range(len(yesterday)):

...     print(yesterday[index], today[index])

...

C .

C C

. .
```

我已经将循环变量命名为 `index`。其他常用的名称包括 `i`（`index` 的首字母）和 `ind`。从现在起，我将使用 `i`。

不要将这个循环变量命名为 `status` 或 `information`。这些名称暗示它取值 `'C'` 和 `'.'`，而实际上它取值的是整数。

### 解决问题

使用我们的 `for` 循环，我们准备好解决占用空间问题。我们的策略是从字符串的开头循环到结尾。我们可以检查每个索引在昨天和今天的停车位信息中对应的内容。使用嵌套的 `if` 语句，我们将判断该停车位在两天内是否都被占用。

清单 3-3 是我们的解决方案。

```py
   n = int(input())

   yesterday = input()

   today = input()

❶ occupied = 0

❷ for i in range(len(yesterday)):

    ❸ if yesterday[i] == 'C' and today[i] == 'C':

        ❹ occupied = occupied + 1

   print(occupied)
```

*清单 3-3：解决占用空间问题*

程序首先读取三行输入：`n` 表示停车位数量；`yesterday` 和 `today` 分别表示昨天和今天的停车位信息。

注意，我们没有再次提到停车位的数量（`n`）。我们本可以利用它来告诉我们字符串的长度，但我选择忽略它，因为在实际情况中它通常没有提供。

我们使用 `occupied` 变量来统计昨天和今天都被占用的停车位数量。我们将这个变量初始化为 `0` ❶。

现在我们进入 `for` 循环，循环遍历 `yesterday` 和 `today` 的有效索引 ❷。对于每个这样的索引，我们检查该停车位是否在昨天和今天都被占用 ❸。如果是，那么我们通过将 `occupied` 增加 `1` 来把这个停车位计入总数 ❹。

当 `for` 循环结束时，我们将已经遍历了所有停车位。昨天和今天被占用的停车位总数可以通过 `occupied` 变量来访问。剩下的就是输出这个总数。

这就是本题的解决方法。现在是时候将你的代码提交给评测系统了。

### 问题 #7：数据计划

我们已经学会了 `for` 循环对于处理从输入读取的数据非常有用。它们通常也非常适合用于读取数据本身。在这个问题中，我们将处理分布在多行的数据，并使用 `for` 循环帮助我们读取所有数据。

这是 DMOJ 问题 `coci16c1p1`。

#### 挑战

Pero 与他的手机服务商有一个数据计划，每月提供 *x* 兆字节的数据。此外，任何未使用的数据会转到下个月。例如，如果 *x* 是 10 而 Pero 只使用了 4MB，那么剩余的 6MB 将会转到下个月（那时他将有 10 + 6 = 16MB 可用）。

我们给定了 Pero 在前 *n* 个月中每个月使用的兆字节数据。我们的任务是确定下个月可用的数据量。

#### 输入

输入包含以下几行：

+   一行包含整数 *x*，表示 Pero 每月获得的兆字节数。*x* 在 1 到 100 之间。

+   一行包含整数 *n*，表示 Pero 拥有数据计划的月数。*n* 在 1 到 100 之间。

+   *n* 行，每行代表 Pero 在那个月使用的兆字节数。每个数字至少为 0，并且永远不会超过可用的兆字节数。（例如，如果 *x* 是 10，且 Pero 当前有 30MB 可用，那么下一个数字最多为 30。）

#### 输出

输出下个月可用的兆字节数。

### 循环读取输入

在我们至今处理的所有问题中，我们都确切知道需要从输入中读取多少行。例如，在“三个杯子”问题中，我们读取了一行；在“被占用的空间”问题中，我们读取了三行。在数据计划问题中，我们无法提前知道需要读取多少行，因为这取决于我们从第二行读取的数字。

我们可以读取第一行的输入：

```py
monthly_mb = int(input())
```

（我用了变量名 `monthly_mb`，而不是 `x`，以便赋予它一些意义。）

我们可以读取第二行的输入：

```py
n = int(input())
```

但我们不能不使用循环而继续读取。一个 `for` 循环在这里非常合适，因为我们可以用它循环读取恰好 `n` 次：

```py
for i in range(n):

    # Process month
```

### 解题过程

我解决问题的策略是追踪从前几个月结转过来的兆字节数。我称之为 *结转*。

考虑这个测试用例：

```py
10

3

4

12

1
```

每个月，Pero 会得到 10MB 的数据，我们需要处理他在提供的三个月内使用的数据。在第一个月，Pero 得到 10MB 并使用了 4MB，因此结转的剩余数据为 6MB。第二个月，Pero 又得到 10MB，总共有 16MB。他这月使用了 12MB，因此结转的剩余数据为 16 - 12 = 4MB。第三个月，Pero 再得到 10MB，总共有 14MB。他这月使用了 1MB，因此结转的剩余数据为 14 - 1 = 13MB。

我们需要知道 Pero 下个月（即第四个月）可用的兆字节数。他有 13MB 的结转数据，再加上本月常规的 10MB，因此他总共有 13 + 10 = 23MB 可用。

当我根据这个解释编写代码时，我忘记加上最后的 10，所以输出是 13，而不是 23。我专注于结转数据，忘记了我们需要的不是进入下个月的结转数据，而是可用的总兆字节数。总数应该是结转数据加上每个月给予的 10MB。

请参阅 清单 3-4 查看（修正过的！）代码。

```py
   monthly_mb = int(input())

   n = int(input())

   excess = 0

❶ for i in range(n):

       used = int(input())

    ❷ excess = excess + monthly_mb - used

❸ print(excess + monthly_mb)
```

*清单 3-4：解决数据计划*

`excess` 变量初始化为 `0`。在每次 `for` 循环迭代中，我们根据每个月给定的兆字节数和该月使用的兆字节数来更新 `excess`。

`for` 循环会循环 `n` 次，每次对应 Pero 使用数据计划的每个月 ❶。`i` 的值——`0`、`1` 等等——我们并不关心，因为我们不需要关心我们正在处理的是哪个月。因此，我们在程序中并没有使用 `i` 的值。你可以将 `i` 替换成 `_`（下划线），以明确表示该变量的“无关”状态，但为了与其他示例保持一致，我会保留 `i`。

在 `for` 循环中，我们读取本月使用的兆字节数。然后，我们更新剩余的多余兆字节数 ❷：它等于之前的值，再加上 Pero 每月获得的兆字节数，减去 Pero 本月使用的兆字节数。

计算出 `n` 个月后剩余的多余兆字节数，我们报告下个月可用的兆字节数 ❸。

解决问题的方式总是有多种。编程是创造性的，我喜欢观察人们提出的各种解决策略。即使你已经成功解决了问题，你也可以通过 Google 查找该问题，了解其他人是如何解决的。另外，一些在线评测平台，比如 DMOJ，允许你在解决问题后查看其他人的提交。对于通过所有测试用例的提交：那些程序员是否做了不同的处理？对于某些测试用例失败的提交：代码出了什么问题？阅读他人的代码是提高自己编程技能的好方法！

你能想到另一种解决数据计划问题的方法吗？

这里有个提示：你可以先计算 Pero 获得的总兆字节数，然后减去他使用的兆字节数。我鼓励你在继续之前，花点时间想想如何做这道题！

给 Pero 的总兆字节数，包括下个月的，是 *x* * (*n* + 1)，其中 *x* 是每月分配的兆字节数。为了确定下个月可用的兆字节数，我们可以从这个总数开始，减去 Pero 每月使用的兆字节数。这个策略在 列表 3-5 中有代码实现。

```py
monthly_mb = int(input())

n = int(input())

total_mb = monthly_mb * (n + 1)

for i in range(n):

    used = int(input())

    total_mb = total_mb - used

print(total_mb)
```

*列表 3-5：解决数据计划，另一种方法*

选择你最喜欢的解法，并提交给评测系统。

对一个人来说直观的东西，对另一个人可能不直观。你可能会读到某个解释或代码，完全无法理解。这并不意味着你不够聪明，而是意味着你需要一种不同的展示方式，更贴近你当前的思维方式。你还可以标记那些难懂的解释和例子，留待以后复习。一旦你积累了更多的实践，它们可能会出乎意料地变得有用。

### 总结

在本章中，我们学习了 `for` 循环。标准的 `for` 循环用于遍历一个序列中的字符；范围 `for` 循环用于遍历一个范围内的整数。我们解决的每一个问题都需要处理许多输入，如果没有循环，我们是无法完成这些操作的。

`for` 循环是当你需要重复执行指定次数的代码时的首选循环。Python 还有另一种类型的循环，我们将在下一章学习如何使用它。为什么除了 `for` 循环之外，我们还需要其他的循环？`for` 循环做不了什么呢？好问题！现在告诉你的是：练习 `for` 循环是为接下来的内容做准备的一个绝佳方式。

### 章节习题

这里有一些习题供你尝试。

1.  DMOJ 问题 `wc17c3j3`，无法破解

1.  DMOJ 问题 `coci18c3p1`，Magnus

1.  DMOJ 问题 `ccc11s1`，英语或法语

1.  DMOJ 问题 `ccc11s2`，选择题

1.  DMOJ 问题 `coci12c5p1`，Ljestvica

1.  DMOJ 问题 `coci13c3p1`，Rijeci

1.  DMOJ 问题 `coci18c4p1`，Elder

### 注意事项

“三杯”最初出自 2006/2007 年克罗地亚信息学公开赛，第 5 题。占用空间最初出自 2018 年加拿大计算机竞赛，初级组。数据计划最初出自 2016/2017 年克罗地亚信息学公开赛，第 1 题。
