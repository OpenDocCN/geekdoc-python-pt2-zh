## **2**

**模块、库和框架**

![image](img/common01.jpg)

模块是使 Python 可扩展性得以实现的关键部分。没有它们，Python 就只会是一个围绕着单体解释器构建的语言；它也无法在一个巨大的生态系统中蓬勃发展，无法让开发者通过组合扩展迅速且简便地构建应用程序。在这一章中，我将向你介绍一些使 Python 模块如此出色的特性，包括你需要了解的内置模块和外部管理的框架。

### **导入系统**

要在你的程序中使用模块和库，必须使用 import 关键字导入它们。举个例子，示例 2-1 导入了至关重要的 Python 之禅指导原则。

>>> import this

《Python 之禅》，Tim Peters 编写

美丽优于丑陋。

明确优于隐式。

简单优于复杂。

复杂优于复杂化。

扁平优于嵌套。

稀疏优于密集。

可读性很重要。

特殊情况不足以打破规则。

尽管实用性优于纯粹性。

错误永远不应默默地通过。

除非明确地被静默处理。

面对模糊时，拒绝猜测的诱惑。

应该有一种——并且最好只有一种——显而易见的做法。

尽管除非你是荷兰人，否则这种方式一开始可能不太明显。

现在比永远都好。

尽管有时永远比*现在*更好。

如果实现难以解释，那就不是一个好主意。

如果实现容易解释，那么这可能是个好主意。

命名空间是一个极棒的想法——我们应该多做一些！

*示例 2-1：Python 之禅*

导入系统相当复杂，我假设你已经掌握了基础知识，因此在这里我将向你展示该系统的一些内部机制，包括 sys 模块如何工作、如何更改或添加导入路径，以及如何使用自定义导入器。

首先，你需要知道 import 关键字实际上是一个包装函数，名为 __import__。以下是一个导入模块的常见方式：

>>> import itertools

>>> itertools

<module 'itertools' from '/usr/.../>

这与以下方法完全等效：

>>> itertools = __import__("itertools")

>>> itertools

<module 'itertools' from '/usr/.../>

你还可以模仿 import 的 as 关键字，如以下两种等效的导入方式所示：

>>> import itertools as it

>>> it

<module 'itertools' from '/usr/.../>

这是第二个例子：

>>> it = __import__("itertools")

>>> it

<module 'itertools' from '/usr/.../>

虽然 import 是 Python 中的一个关键字，但从内部来看，它是一个通过 __import__ 名称访问的简单函数。__import__ 函数非常有用，因为在某些（特殊）情况下，你可能想导入一个事先不知道名称的模块，像这样：

>>> random = __import__("RANDOM".lower())

>>> random

<module 'random' from '/usr/.../>

不要忘记，模块一旦被导入，本质上就是对象，它的属性（类、函数、变量等）也是对象。

#### ***sys 模块***

sys 模块提供了与 Python 本身及其运行操作系统相关的变量和函数的访问权限。这个模块还包含了关于 Python 导入系统的大量信息。

首先，你可以使用 sys.modules 变量检索当前已导入的模块列表。sys.modules 是一个字典，键是你想检查的模块名，返回的值是模块对象。例如，一旦 os 模块被导入，我们可以通过输入以下内容来获取它：

>>> import sys

>>> import os

>>> sys.modules['os']

<module 'os' from '/usr/lib/python2.7/os.pyc'>

sys.modules 变量是一个标准的 Python 字典，包含所有已加载的模块。这意味着，例如，调用 sys.modules.keys() 将返回已加载模块的完整名称列表。

你还可以使用 sys.builtin_module_names 变量来检索内建模块的列表。根据传递给 Python 构建系统的编译选项，编译到解释器中的内建模块可能会有所不同。

#### ***导入路径***

当导入模块时，Python 依赖于一个路径列表来确定从哪里查找模块。这个列表存储在 sys.path 变量中。要检查解释器将搜索哪些路径，只需输入 sys.path。

你可以更改这个列表，根据需要添加或删除路径，或者甚至修改 PYTHONPATH 环境变量来添加路径，而无需编写任何 Python 代码。如果你想将 Python 模块安装到非标准位置（例如测试环境），将路径添加到 sys.path 变量中会很有用。然而，在正常操作中，通常不需要修改路径变量。以下方法几乎等效——*几乎*因为路径在列表中的位置不会完全相同；这种差异可能不重要，取决于你的使用场景：

>>> import sys

>>> sys.path.append('/foo/bar')

这几乎等同于：

$ PYTHONPATH=/foo/bar python

>>> import sys

>>> '/foo/bar' in sys.path

True

需要注意的是，这个列表会被逐一迭代来查找请求的模块，因此 sys.path 中路径的顺序非常重要。将最有可能包含你正在导入的模块的路径放在列表前面，可以加快搜索速度。这样做还确保如果有两个同名的模块可用，解释器会选择第一个匹配的模块。

这个属性尤其重要，因为一个常见的错误是用你自己的模块覆盖 Python 内建模块。你的当前目录会在 Python 标准库目录之前被搜索。这意味着，如果你决定将某个脚本命名为 *random.py*，然后尝试使用 `import random`，当前目录中的文件将被导入，而不是 Python 的标准模块。

#### ***自定义导入器***

你还可以使用自定义导入器扩展导入机制。这正是 Lisp-Python 方言 Hy 所使用的技术，它教 Python 如何导入标准的*.py*或*.pyc*文件以外的文件。（Hy 是一个基于 Python 的 Lisp 实现，稍后将在“Hy 简介”部分中讨论，参见第 145 页。）

*导入钩子机制*，也就是这种技术，是由 PEP 302 定义的。它允许你扩展标准的导入机制，从而修改 Python 导入模块的方式，并构建你自己的导入系统。例如，你可以编写一个扩展，从网络上的数据库导入模块，或者在导入任何模块之前做一些完整性检查。

Python 提供了两种不同但相关的方式来扩展导入系统：用于 sys.meta_path 的元路径查找器和用于 sys.path_hooks 的路径条目查找器。

#### ***元路径查找器***

*元路径查找器*是一个对象，它允许你加载自定义对象以及标准的*.py*文件。一个元路径查找器对象必须暴露一个 find_module(fullname, path=None)方法，该方法返回一个加载器对象。加载器对象还必须拥有一个 load_module(fullname)方法，负责从源文件加载模块。

举个例子，示例 2-2 展示了 Hy 如何使用自定义元路径查找器，使 Python 能够导入以*.hy*结尾的源文件，而不是*.py*文件。

class MetaImporter(object):

def find_on_path(self, fullname):

fls = ["%s/__init__.hy", "%s.hy"]

dirpath = "/".join(fullname.split("."))

对于 sys.path 中的每个 pth：

pth = os.path.abspath(pth)

对于 fp 中的每个文件：

composed_path = fp % ("%s/%s" % (pth, dirpath))

如果 os.path.exists(composed_path):

返回 composed_path

def find_module(self, fullname, path=None):

path = self.find_on_path(fullname)

如果 path 存在：

返回 MetaLoader(path)

sys.meta_path.append(MetaImporter())

*示例 2-2: 一个 Hy 模块导入器*

一旦 Python 确定路径有效且指向一个模块，就会返回一个 MetaLoader 对象，如示例 2-3 所示。

class MetaLoader(object):

def __init__(self, path):

self.path = path

def is_package(self, fullname):

dirpath = "/".join(fullname.split("."))

对于 sys.path 中的每个 pth：

pth = os.path.abspath(pth)

composed_path = "%s/%s/__init__.hy" % (pth, dirpath)

如果 os.path.exists(composed_path):

返回 True

返回 False

def load_module(self, fullname):

如果 fullname 在 sys.modules 中：返回 sys.modules[fullname]

如果 self.path 为空：

返回

sys.modules[fullname] = None

➊ mod = import_file_to_module(fullname, self.path)

ispkg = self.is_package(fullname)

mod.__file__ = self.path

mod.__loader__ = self

mod.__name__ = fullname

如果是包：

mod.__path__ = []

mod.__package__ = fullname

否则：

mod.__package__ = fullname.rpartition('.')[0]

sys.modules[fullname] = mod

返回 mod

*示例 2-3: 一个 Hy 模块加载器对象*

在 ➊ 处，import_file_to_module 读取一个 *.hy* 源文件，将其编译为 Python 代码，并返回一个 Python 模块对象。

这个加载器相当简单：一旦找到 *.hy* 文件，它会传递给这个加载器，必要时进行编译、注册、设置一些属性，然后返回给 Python 解释器。

uprefix 模块是另一个该功能运作的良好示例。Python 3.0 到 3.2 不支持 Python 2 中用于表示 Unicode 字符串的 u 前缀；uprefix 模块通过在编译前移除字符串中的 u 前缀，确保 Python 2 和 3 之间的兼容性。

### **有用的标准库**

Python 自带一个庞大的标准库，里面包含了几乎任何你能想到的工具和功能。对于那些习惯于自己编写基本任务函数的新手来说，通常会惊讶于 Python 本身已经内建了这么多功能，随时可以使用。

每当你想要编写自己的函数来处理一个简单任务时，首先停下来查看标准库。事实上，在开始使用 Python 之前，至少浏览一遍整个标准库，这样下次需要某个函数时，你就知道它是否已经在标准库中存在。

我们将在后续章节讨论一些这些模块，如 functools 和 itertools，但这里列出的是一些你绝对会觉得有用的标准模块：

+   atexit 允许你注册程序退出时调用的函数。

+   argparse 提供用于解析命令行参数的函数。

+   bisect 提供排序列表的二分查找算法（参见 第十章）。

+   calendar 提供多个与日期相关的函数。

+   codecs 提供用于编码和解码数据的函数。

+   collections 提供多种有用的数据结构。

+   copy 提供用于复制数据的函数。

+   csv 提供用于读取和写入 CSV 文件的函数。

+   datetime 提供处理日期和时间的类。

+   fnmatch 提供用于匹配 Unix 风格文件名模式的函数。

+   concurrent 提供异步计算（Python 3 中是原生支持，Python 2 可通过 PyPI 使用）。

+   glob 提供用于匹配 Unix 风格路径模式的函数。

+   io 提供处理 I/O 流的函数。在 Python 3 中，它还包含 StringIO（在 Python 2 中是同名模块的一部分），允许你将字符串当作文件来处理。

+   json 提供用于读取和写入 JSON 格式数据的函数。

+   logging 提供对 Python 内置日志功能的访问。

+   multiprocessing 允许你从应用程序中运行多个子进程，同时提供一个 API，使它们看起来像线程。

+   operator 提供实现基本 Python 运算符的函数，你可以使用这些函数，而无需编写自己的 lambda 表达式（参见 第十章）。

+   os 提供对基本操作系统功能的访问。

+   random 提供生成伪随机数的功能。

+   re 提供正则表达式功能。

+   sched 提供一个无需多线程的事件调度器。

+   select 提供访问 select() 和 poll() 函数的接口，用于创建事件循环。

+   shutil 提供访问高级文件操作功能的接口。

+   signal 提供处理 POSIX 信号的功能。

+   tempfile 提供创建临时文件和目录的功能。

+   threading 提供访问高级线程功能的接口。

+   urllib（在 Python 2.*x* 中为 urllib2 和 urlparse）提供处理和解析 URL 的功能。

+   uuid 允许你生成全球唯一标识符（UUID）。

将这个列表作为快速参考，了解这些有用的库模块的功能。如果你能记住其中的一部分，那就更好了。你花在查找库模块上的时间越少，你就能花更多时间编写实际需要的代码。

大部分标准库是用 Python 编写的，因此你完全可以查看模块和函数的源代码。当有疑问时，打开代码亲自看看它是如何工作的。即便文档已经提供了你所需的所有信息，仍然有可能从中学到一些有用的东西。

### **外部库**

Python 的“内置电池”理念是，一旦你安装了 Python，你就应该拥有构建任何你想要的项目所需的一切。这是为了避免出现类似于打开一个很棒的礼物，却发现送礼人忘了买电池的情况。

不幸的是，Python 的开发者无法预测你可能想要制作的*所有*东西。即使他们能做到，大多数人也不愿意处理一个多吉字节的下载，特别是当他们只是想写一个简单的脚本来重命名文件时。因此，即使 Python 标准库功能非常丰富，它也不能涵盖所有内容。幸运的是，Python 社区的成员创建了外部库。

Python 标准库是安全且已有充分文档记录的领域：它的模块都有详尽的文档，且有足够多的人定期使用它，因此你可以放心地尝试它，不会在使用时发生混乱——如果发生了不太可能的故障，你也可以相信会有人在短时间内修复它。而外部库则是地图上标注有“这里有龙”的地方：文档可能很稀缺，功能可能存在 bug，更新可能不稳定，甚至没有更新。任何严肃的项目都可能需要外部库才能提供的功能，但你需要意识到使用它们时所涉及的风险。

下面是来自实践中的外部库危险故事。OpenStack 使用 SQLAlchemy，这是一个 Python 数据库工具包。如果你熟悉 SQL，你就知道数据库模式会随着时间变化，因此 OpenStack 还使用了 sqlalchemy-migrate 来处理模式迁移需求。它曾经有效……直到它不再有效。Bug 开始积累，但没有人处理。此时，OpenStack 还希望支持 Python 3，但没有迹象表明 sqlalchemy-migrate 正朝着 Python 3 支持的方向发展。到那时，显然 sqlalchemy-migrate 对我们的需求已经基本上不适用了，我们需要切换到其他方案——我们的需求超出了外部库的能力范围。撰写本文时，OpenStack 项目正迁移到使用 Alembic，这是一个支持 Python 3 的新 SQL 数据库迁移工具。这一过程并非没有努力，但幸运的是，几乎没有痛苦。

#### ***外部库安全检查清单***

所有这些都归结为一个重要的问题：你如何确保不会陷入外部库的陷阱？不幸的是，你无法做到：程序员也是人，无法百分之百确定今天积极维护的库在几个月后是否仍然健康。然而，使用这些库可能值得冒险；关键是要仔细评估你的情况。在 OpenStack，我们在选择是否使用外部库时会使用以下清单，我鼓励你也这么做。

**Python 3 兼容性** 即使你现在并不针对 Python 3 进行开发，未来某个时候你很可能会遇到 Python 3，因此最好检查你选择的库是否已经兼容 Python 3，并且承诺会保持这种兼容性。

**积极开发** GitHub 和 Ohloh 通常提供足够的信息来判断一个库是否在其维护者的积极开发下。

**积极维护** 即使一个库被认为已经完成（即功能已完善），维护者仍应确保其保持无 Bug。检查该项目的跟踪系统，看看维护者响应 Bug 的速度。

**与操作系统发行版捆绑** 如果一个库被包含在主要的 Linux 发行版中，这意味着其他项目也依赖于它——所以如果出现问题，你不会是唯一一个抱怨的人。如果你计划将软件发布给公众，检查这一点也很重要：如果其依赖项已经安装在最终用户的机器上，你的代码会更容易分发。

**API 兼容性承诺** 没有什么比依赖的库突然更改其整个 API 导致软件崩溃更糟糕的了。你可能想检查一下你选择的库是否曾经发生过类似的情况。

**许可证** 你需要确保许可证与你计划编写的软件兼容，并且它允许你根据分发、修改和执行的需求进行任何你打算做的事情。

对依赖项应用此检查清单也是一个好主意，尽管这可能是一个巨大的工作量。作为折中，如果你知道你的应用将严重依赖某个特定库，应该将此检查清单应用到该库的每个依赖项上。

#### ***用 API 包装器保护你的代码***

无论你最终使用什么库，都需要将它们视为有用的工具，但也可能会带来严重的风险。为了安全起见，应该像对待任何物理工具一样对待库：将它们放在工具棚里，远离你的易损贵重物品，但在需要时可以使用。

无论外部库有多么有用，都要小心不要让它深度嵌入到你的源代码中。否则，如果发生错误并且你需要更换库，可能需要重写程序的大部分代码。更好的方法是编写你自己的 API——一个封装外部库的包装器，将它们隔离在源代码之外。你的程序无需知道它正在使用哪些外部库，只需知道你的 API 提供了哪些功能。如果你需要使用不同的库，只需更改你的包装器。只要新库提供相同的功能，你就不需要修改其余的代码库。可能会有例外情况，但应该不多；大多数库设计是为了解决一个特定范围的问题，因此可以轻松隔离。

在第五章中，我们还将探讨如何使用入口点构建驱动系统，从而允许你将项目的某些部分视为可以随时切换的模块。

### **包安装：从 pip 获得更多功能**

pip 项目提供了一种非常简单的方法来处理包和外部库的安装。它在积极开发中，得到良好维护，并且从 Python 3.4 版本开始包含在内。它可以从 *Python 包索引（PyPI）*、tar 包或 Wheel 存档中安装或卸载包（我们将在第五章中讨论这些内容）。

它的使用方法很简单：

$ pip install --user voluptuous

正在下载/解包 voluptuous

正在下载 voluptuous-0.8.3.tar.gz

正在将下载内容存储在缓存中：./.cache/pip/https%3A%2F%2Fpypi.python.org%2Fpa

ckages%2Fsource%2Fv%2Fvoluptuous%2Fvoluptuous-0.8.3.tar.gz

正在为包 voluptuous 运行 setup.py egg_info

要求已满足（使用 --upgrade 来升级）：distribute 在 /usr/

lib/python2.7/dist-packages（来自 voluptuous）

安装已收集的包：voluptuous

正在为 voluptuous 运行 setup.py install

成功安装 voluptuous

正在清理...

通过在 PyPI 分发索引中查找，任何人都可以上传包以供他人分发和安装，pip install 可以安装任何包。

您还可以提供 --user 选项，使 pip 将包安装到您的主目录中。这可以避免将包安装到操作系统的系统范围目录中，避免污染系统目录。

您可以使用 pip freeze 命令列出已经安装的包，如下所示：

$ pip freeze

Babel==1.3

Jinja2==2.7.1

commando=0.3.4

--snip--

pip 还支持卸载包，使用 uninstall 命令：

$ pip uninstall pika-pool

正在卸载 pika-pool-0.1.3：

/usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/

DESCRIPTION.rst

/usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/INSTALLER

/usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/METADATA

--snip--

继续（y/n）？ y

成功卸载 pika-pool-0.1.3

pip 的一个非常有价值的功能是它能够安装包而不复制包的文件。这个功能的典型使用场景是，当你在积极开发一个包时，想避免每次需要测试更改时重新安装的漫长和乏味过程。通过使用 -e <directory> 标志可以实现这一点：

$ pip install -e .

从 file:///Users/jd/Source/daiquiri 获取

正在安装收集的包：daiquiri

正在为 daiquiri 运行 setup.py develop

成功安装 daiquiri

在这里，pip 不会将文件从本地源目录复制，而是将一个名为 egg-link 的特殊文件放置在您的分发路径中。例如：

$ cat /usr/local/lib/python2.7/site-packages/daiquiri.egg-link

/Users/jd/Source/daiquiri

egg-link 文件包含要添加到 sys.path 以查找包的路径。可以通过运行以下命令轻松检查结果：

$ python -c "import sys; print('/Users/jd/Source/daiquiri' in sys.path)"

True

另一个有用的 pip 工具是 pip install 的 -e 选项，它有助于从各种版本控制系统的仓库中部署代码：支持 git、Mercurial、Subversion，甚至 Bazaar。例如，您可以直接从 git 仓库安装任何库，只需将其地址作为 URL 传递给 -e 选项：

$ pip install -e git+https://github.com/jd/daiquiri.git\#egg=daiquiri

从 git+https://github.com/jd/daiquiri.git#egg=daiquiri 获取 daiquiri

克隆 https://github.com/jd/daiquiri.git 到 ./src/daiquiri

正在安装收集的包：daiquiri

正在为 daiquiri 运行 setup.py develop

成功安装 daiquiri

为了正确安装，您需要通过在 URL 末尾添加 #egg= 来提供包的 egg 名称。然后，pip 会使用 git clone 克隆仓库到 src/<eggname> 目录，并创建一个指向该克隆目录的 egg-link 文件。

这种机制在依赖尚未发布的库版本或在持续测试系统中工作时非常方便。然而，由于它没有版本控制，-e 选项也可能非常糟糕。你无法提前知道该远程仓库中的下一个提交是否会破坏一切。

最后，所有其他安装工具都被弃用，转而推荐使用 pip，因此你可以放心地将其作为你所有包管理需求的一站式解决方案。

### **使用和选择框架**

Python 提供了各种框架，适用于各种 Python 应用程序：如果你正在编写一个 web 应用程序，可以选择 Django、Pylons、TurboGears、Tornado、Zope 或 Plone；如果你需要一个事件驱动的框架，可以选择 Twisted 或 Circuits；等等。

框架和外部库的主要区别在于，应用程序是通过在框架之上构建来使用框架的：你的代码会扩展框架，而不是框架扩展你的代码。与库不同，库基本上是你可以引入的附加功能，用来为你的代码增加额外的功能，而框架则构成了你代码的*底盘*：你所做的每件事都在某种程度上依赖于这个底盘。这可能是把双刃剑。使用框架有很多优点，比如快速原型设计和开发，但也有一些值得注意的缺点，比如被框架束缚。你需要在决定是否使用框架时考虑到这些因素。

选择适合 Python 应用程序的框架时需要检查的推荐事项，基本与“外部库安全检查表”中描述的相同，见第 23 页—这也是合乎逻辑的，因为框架通常作为 Python 库的集合发布。有时框架还包含用于创建、运行和部署应用程序的工具，但这并不改变你应该应用的标准。我们已经确定，替换一个外部库在你已经写了依赖它的代码后会很麻烦，但替换框架则更加糟糕，通常需要从头开始完全重写程序。

举个例子，前面提到的 Twisted 框架至今还没有完全支持 Python 3：如果你几年前使用 Twisted 编写了一个程序，并且希望将其更新为支持 Python 3，你会遇到麻烦。要么你必须重写整个程序，换用另一个框架，要么你得等到有人最终为 Twisted 提供完全的 Python 3 支持。

有些框架比其他框架更轻量。例如，Django 有自己的内置 ORM 功能；而 Flask 则没有类似的功能。框架为你做的事情越少，未来遇到的问题就越少。然而，框架缺少的每一个功能，都会变成你需要解决的另一个问题，要么自己编写代码，要么麻烦地挑选另一个库来处理。这完全取决于你愿意处理哪种情况，但要明智选择：当事情出现问题时，迁移离开一个框架可能是一个艰巨的任务，即使它有其他功能，Python 也没有任何东西能帮你解决这个问题。

### **Doug Hellmann，Python 核心开发者，谈 Python 库**

Doug Hellmann 是 DreamHost 的高级开发者，也是 OpenStack 项目的贡献者之一。他创建了网站 Python Module of the Week (*[`www.pymotw.com/`](http://www.pymotw.com/)*), 并且写了一本名为 *《Python 标准库示例》* 的优秀书籍。他也是 Python 核心开发者。我向 Doug 提出了关于标准库以及围绕它设计库和应用程序的一些问题。

**当你从零开始编写一个 Python 应用程序时，你的第一步是什么？**

从零开始编写应用程序的步骤在抽象层面上与破解现有应用程序类似，但细节有所不同。

当我修改现有代码时，我通常会先弄清楚它是如何工作的，以及我的修改需要添加到哪里。我可能会使用一些调试技巧：添加日志或打印语句，或使用 pdb，然后用测试数据运行应用程序，确保我理解它的运行方式。我通常会先手动修改并测试，然后在提交补丁之前添加任何自动化测试。

当我创建一个新应用程序时，我也采用相同的探索性方法——编写一些代码并手动运行，然后一旦基本功能正常工作，我会编写测试来确保涵盖所有边缘情况。创建测试的过程也可能导致一些重构，以便让代码更易于操作。

这在 smiley [一个用于监控你的 Python 程序并记录其活动的工具] 中的确是这样的。我先通过 Python 的 trace API 进行实验，使用一些临时脚本，然后再构建真正的应用程序。最初，我计划有一个部分用于监控并收集另一个正在运行的应用程序的数据，另一个部分用于收集通过网络发送的数据并保存它。在添加了几个报告功能之后，我意识到重播收集到的数据的处理过程与最初收集数据的过程几乎相同。我重构了几个类，并成功创建了一个用于数据收集、数据库访问和报告生成器的基类。使这些类符合相同的 API 允许我轻松创建一个将数据直接写入数据库而不是通过网络发送信息的数据收集应用版本。

在设计应用程序时，我会考虑用户界面的工作方式，但对于库，我更关注开发者如何使用 API。对于将要使用新库的程序，先编写测试可能更容易，然后再编写库代码。我通常会以测试的形式创建一系列示例程序，然后构建库以使其工作。

我还发现，在编写任何代码之前编写库的文档可以帮助我理清功能和工作流程，而不需要纠结于实现细节，并且它可以让我记录下我在设计时做出的选择，这样读者不仅能理解如何使用库，还能理解我在创建过程中所期望的。

**将模块加入 Python 标准库的流程是什么？**

提交模块到标准库的完整过程和指南可以在 Python 开发者指南中的 *[`docs.python.org/devguide/stdlibchanges.html`](https://docs.python.org/devguide/stdlibchanges.html)* 找到。

在模块被添加之前，提交者需要证明它是稳定的且广泛有用的。该模块应该提供一些功能，这些功能要么是自己实现起来很难做到正确，要么是如此有用，以至于许多开发者已经创建了自己的变体。API 应该清晰，且任何模块的依赖应该仅限于标准库内部。

第一步是通过 *python-ideas* 邮件列表将引入模块到标准库的想法提交给社区，非正式地评估兴趣的程度。如果反馈是积极的，下一步是创建一个 Python 增强提案（PEP），其中应包括添加该模块的动机和过渡的实现细节。

由于包管理和发现工具变得如此可靠，特别是 pip 和 PyPI，可能更实际的做法是将一个新的库保持在 Python 标准库之外。单独发布允许更频繁地更新新功能和修复 bug，这对于处理新技术或 API 的库尤其重要。

**你希望人们更多了解标准库中的三个最重要模块是什么？**

标准库中有一个非常有用的工具是 abc 模块。我使用 abc 模块来将动态加载的扩展的 API 定义为抽象基类，以帮助扩展的作者理解哪些方法是必需的，哪些是可选的。抽象基类在一些其他面向对象编程（OOP）语言中是内置的，但我发现许多 Python 程序员并不知道我们也有它们。

bisect 模块中的二分查找算法是一个很好的示例，它是一个有用的功能，但经常被错误地实现，因此非常适合放在标准库中。我尤其喜欢它能够搜索稀疏的列表，在这些列表中搜索值可能并不包含在数据中。

collections 模块中有一些有用的数据结构，但它们的使用频率并不像它们应有的那样高。我喜欢使用 namedtuple 来创建小型、类似类的数据结构，这些结构只需要存储数据，而没有关联的逻辑。如果以后需要添加逻辑，从 namedtuple 转换为普通类是非常容易的，因为 namedtuple 支持按名称访问属性。这个模块中的另一个有趣的数据结构是 ChainMap，它是一个很好的可堆叠命名空间。ChainMap 可以用于创建渲染模板的上下文，或者管理来自不同来源并具有明确优先级的配置设置。

**许多项目，包括 OpenStack 和外部库，都会在标准库之上构建自己的抽象层，比如日期/时间处理。你认为程序员应该坚持使用标准库，自己编写函数，切换到某个外部库，还是开始为 Python 提交补丁？**

以上所有方法！我倾向于避免重复造轮子，因此我强烈主张为可以作为依赖使用的项目贡献修复和增强功能。另一方面，有时创建另一个抽象层并单独维护这段代码是有意义的，可以在应用程序内部或作为一个新的库来实现。

在您的示例中使用的 timeutils 模块，实际上是对 Python datetime 模块的一个相对简洁的封装。大多数函数都很短小简单，但创建一个包含最常用操作的模块，可以确保它们在所有项目中始终如一地处理。因为许多函数具有应用特定性，例如强制决定时间戳格式字符串或“当前时间”的定义，它们并不适合作为 Python 库的补丁或作为通用库发布供其他项目使用。

相反，我一直在努力将 OpenStack 中的 API 服务从项目早期创建的 WSGI [Web Server Gateway Interface] 框架迁移到第三方 Web 开发框架。Python 中有很多用于创建 WSGI 应用程序的选择，尽管我们可能需要对其中一个进行增强，以使其完全适用于 OpenStack 的 API 服务器，但将这些可复用的改动提交给上游项目总比维护一个“私有”框架要好。

**对于犹豫不决的开发者，您有什么建议，特别是在选择 Python 主要版本时？**

支持 Python 3 的第三方库数量已经达到了临界点。现在比以往任何时候都更容易为 Python 3 构建新库和应用程序，得益于 3.3 版本新增的兼容性功能，维护对 Python 2.7 的支持也变得更加容易。主要的 Linux 发行版正在致力于默认安装 Python 3 的发布版本。任何开始新项目的人都应该认真考虑使用 Python 3，除非他们依赖的库尚未移植到该版本。不过，到目前为止，不支持 Python 3 的库几乎可以被视为“未维护”。

**在设计、规划、迁移等方面，将代码从应用程序分支到库的最佳方式是什么？**

应用程序是将库为特定目的结合在一起的“胶水代码”集合。首先将应用程序设计为一个实现该目的的库，再构建应用程序，能确保代码被正确地组织成逻辑单元，从而简化测试。这还意味着应用程序的功能通过库可以访问，并且可以重新组合以创建其他应用程序。如果你不采用这种方法，应用程序的功能可能会与用户界面紧密绑定，这使得它们更难修改和重用。

**对于计划设计自己 Python 库的人，您有什么建议？**

我总是推荐从上到下设计库和 API，在每一层应用设计准则，如单一职责原则（SRP）。考虑调用者希望如何使用库，并创建支持这些功能的 API。思考哪些值可以存储在实例中并被方法使用，而不需要每次都传递给每个方法。最后，思考实现方式，以及底层代码是否应该与公共 API 的代码有所不同。

SQLAlchemy 是应用这些指南的一个优秀例子。声明式 ORM（对象关系映射）、数据映射和表达式生成层都是分开的。开发人员可以根据自己的需求决定进入 API 和使用库的合适抽象层次，而不是受限于库设计所强加的限制。

**在阅读 Python 开发者的代码时，你遇到的最常见编程错误是什么？**

Python 的习惯用法与其他语言在循环和迭代方面有显著的不同。例如，我常看到的一个反模式是使用 `for` 循环来过滤列表，方法是先将项目附加到一个新列表，然后在第二个循环中处理结果（可能是在将列表作为参数传递给函数之后）。我几乎总是建议将这种过滤循环转换为生成器表达式，这样既更高效，又更易于理解。还常见到将多个列表合并，以便以某种方式处理它们的内容，而不是使用 `itertools.chain()`。

在代码审查中，我经常建议一些更细微的事项，比如使用 `dict()` 作为查找表，而不是一个冗长的 if:then:else 块，确保函数总是返回相同类型的对象（例如，返回一个空列表而不是 None），通过将相关的值组合成元组或新类来减少函数所需的参数数量，以及在公共 API 中定义类而不是依赖字典。

**你对框架有什么看法？**

框架就像其他任何工具一样。它们能提供帮助，但在选择时需要小心，以确保它适合手头的工作。

将应用程序的共同部分提取到框架中，可以帮助你将开发工作集中在应用程序的独特方面。框架还提供了大量的启动代码，用于执行诸如在开发模式下运行和编写测试套件等任务，帮助你更快地将应用程序带到有用的状态。它们还鼓励应用程序实现的一致性，这意味着你最终得到的代码更容易理解且更具可重用性。

当然，也存在一些潜在的陷阱。选择使用特定框架通常意味着对应用程序设计的某些假设。选择错误的框架可能会使应用程序的实现更加困难，尤其是当这些设计约束与应用程序的需求不自然契合时。如果你尝试使用与框架推荐的模式或习惯不同的方式，可能会和框架产生冲突。
