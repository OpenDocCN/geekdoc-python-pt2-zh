## **1**

**启动你的项目**

![image](../images/common01.jpg)

在本章中，我们将探讨启动项目的几个方面，以及在开始之前应该考虑的一些事项，比如使用哪个 Python 版本、如何构建模块结构、如何有效地标记软件版本、以及如何通过自动错误检查确保最佳的编码实践。

### **Python 版本**

在开始一个项目之前，你需要决定该项目将支持哪个版本的 Python。这并不是一个看起来那么简单的决定。

Python 支持多个版本这一点早已不是什么秘密。每个小版本的解释器都会获得 18 个月的 bug 修复支持和 5 年的安全支持。例如，Python 3.7 于 2018 年 6 月 27 日发布，将支持到 Python 3.8 发布为止，预计大约在 2019 年 10 月左右。2019 年 12 月左右，Python 3.7 会发布最后一个 bug 修复版本，届时所有人都应切换到 Python 3.8。每个新的 Python 版本都会引入新特性并弃用旧特性。[图 1-1](ch01.xhtml#ch1fig1) 展示了这一时间线。

![image](../images/f01-01.jpg)

*图 1-1：Python 发布时间线*

此外，我们还应该考虑 Python 2 与 Python 3 的问题。使用（非常）老旧平台的人们可能仍然需要 Python 2 的支持，因为这些平台尚未提供 Python 3，但一般的经验法则是，如果可以的话，忘记 Python 2。

这里有一个快速的方法来确定你需要支持哪个版本：

+   版本 2.6 及更早版本现在已经过时，因此我不建议你去担心支持这些版本。如果你确实因为某些原因需要支持这些旧版本，请注意你将很难确保你的程序也支持 Python 3.x。话虽如此，你可能仍然会在一些旧系统上遇到 Python 2.6——如果是这种情况，抱歉！

+   版本 2.7 是 Python 2.x 的最后一个版本，并将保持为最后的版本。如今每个系统基本上都能运行或能够运行 Python 3，因此除非你在做考古学工作，否则不必担心在新程序中支持 Python 2.7。Python 2.7 将在 2020 年后停止支持，所以你最不想做的事就是基于它来构建新的软件。

+   目前，Python 3.7 是 Python 3 分支中最新的版本，也是你应该使用的版本。然而，如果你的操作系统提供的是 3.6（除了 Windows，其他大多数操作系统都提供 3.6 或更高版本），确保你的应用程序也能在 3.6 上正常运行。

支持 Python 2.7 和 3.x 的编程技巧将在[第 13 章](ch13.xhtml#ch13)中讨论。

最后，注意这本书是基于 Python 3 编写的。

### **规划你的项目**

启动一个新项目总是有点复杂。你无法确定项目将如何结构化，因此可能不知道如何组织文件。然而，一旦你对最佳实践有了正确的理解，你就会知道应该从哪种基本结构开始。这里我将提供一些关于项目布局的注意事项。

#### ***应该做的***

首先，考虑你的项目结构，应该相对简单。明智地使用包和层次结构：深层次的层级可能会让导航变得非常困难，而扁平化的层次结构往往会变得臃肿。

然后，避免将单元测试存储在包目录外的常见错误。这些测试应当包含在你的软件的子包中，这样就不会被 setuptools（或其他打包库）误操作成 *tests* 顶级模块。将它们放在子包中，可以确保它们可以被安装，并最终被其他包使用，从而允许用户编写自己的单元测试。

[图1-2](ch01.xhtml#ch1fig2) 展示了标准文件层级应该是什么样的。

![image](../images/f01-02.jpg)

*图1-2：标准包目录*

Python 安装脚本的标准名称是 *setup.py*。它配有 *setup.cfg* 文件，该文件应包含安装脚本的配置详情。当运行 *setup.py* 时，它将使用 Python 分发工具安装你的包。

你还可以通过 *README.rst*（或 *README.txt*，或任何你喜欢的文件名）向用户提供重要信息。最后，*docs* 目录应包含以 *reStructuredText* 格式编写的包文档，Sphinx 将使用它（参见 [第3章](ch03.xhtml#ch03)）。

包通常需要提供额外的数据供软件使用，例如图像、shell 脚本等。不幸的是，对于这些文件应该存放在哪里，并没有一个被普遍接受的标准，因此你应根据它们的功能将它们放在对你的项目最有意义的位置。例如，Web 应用程序的模板可以放在包根目录下的 *templates* 目录中。

以下顶级目录也经常出现：

+   *etc* 用于示例配置文件

+   用于 shell 脚本或相关工具的 *tools*

+   *bin* 用于你编写的二进制脚本，这些脚本将通过 *setup.py* 安装

#### ***什么是禁止做的***

在项目结构中，我经常遇到一个特定的设计问题，尤其是在没有完全考虑清楚的情况下：一些开发者会根据存储代码的类型来创建文件或模块。例如，他们可能会创建 *functions.py* 或 *exceptions.py* 文件。这是一种*糟糕的*做法，并且在开发者浏览代码时没有任何帮助。在阅读代码库时，开发者期望程序的功能区域被限定在特定的文件中。这种代码组织方式并没有带来好处，反而迫使读者在文件间跳来跳去，毫无意义。

根据 *功能* 而不是类型来组织你的代码。

创建一个仅包含 *__init__.py* 文件的模块目录也是一个不好的主意，因为这是不必要的嵌套。例如，你不应该创建一个名为 *hooks* 的目录，里面只有一个名为 *hooks/__init__.py* 的文件，而应该使用 *hooks.py*。如果你创建一个目录，它应该包含多个属于该目录代表的类别的其他 Python 文件。不必要地构建深层次的层级结构会让人困惑。

你还应该非常小心你放入 *__init__.py* 文件中的代码。这个文件会在第一次加载目录中包含的模块时被调用和执行。将错误的内容放入 *__init__.py* 可能会产生不良的副作用。实际上，除非你知道自己在做什么，否则 *__init__.py* 文件应该大多数时候是空的。不过，不要尝试完全删除 *__init__.py* 文件，否则你将无法导入你的 Python 模块：Python 要求目录中存在一个 *__init__.py* 文件，才会将该目录视为子模块。

### **版本号**

软件版本需要进行标记，以便用户知道哪个版本是最新的。对于每个项目，用户必须能够组织代码演变的时间线。

有无数种方式来组织你的版本号。然而，PEP 440 引入了一种版本格式，所有 Python 包，理想情况下每个应用程序，都应该遵循这种格式，以便其他程序和包能够轻松、可靠地识别它们需要的包版本。

PEP 440 定义了以下的版本号格式的正则表达式：

N[.N]+[{a|b|c|rc}N][.postN][.devN]

这允许使用标准的版本编号，如 1.2 或 1.2.3。还有一些细节需要注意：

+   版本 1.2 等同于 1.2.0，版本 1.3.4 等同于 1.3.4.0，以此类推。

+   匹配 N[.N]+ 的版本被认为是 *正式* 版本。

+   基于日期的版本号，例如 2013.06.22，被认为是无效的。设计用来检测 PEP 440 格式版本号的自动化工具，如果检测到版本号大于或等于 1980，将会（或应该）抛出错误。

+   最终组件也可以使用以下格式：

    +   N[.N]+aN（例如，1.2a1）表示 alpha 版本；这是一个可能不稳定且缺少功能的版本。

    +   N[.N]+bN（例如，2.3.1b2）表示 beta 版本，即可能已经完成功能但仍有 bug 的版本。

    +   N[.N]+cN 或 N[.N]+rcN（例如，0.4rc1）表示（发布）候选版本。它是一个可能会作为最终产品发布的版本，除非出现重大 bug。rc 和 c 后缀具有相同含义，但如果两者都使用，rc 发布版本被认为比 c 发布版本更新。

+   还可以使用以下后缀：

    +   后缀 *.postN*（例如，1.4.post2）表示发布后的版本。发布后版本通常用于解决发布过程中出现的小错误，比如发布说明中的错误。当发布一个修复 bug 的版本时，不应该使用 *.postN* 后缀；而是应该增加次版本号。

    +   后缀*.devN*（例如，2.3.4.dev3）表示开发版本。它表示该版本的预发布版：例如，*2.3.4.dev3* 表示 *2.3.4* 发布的第三个开发版本，在任何 alpha、beta、候选版本或最终版本之前。这个后缀不推荐使用，因为它对于人类解析比较困难。

这个方案对于大多数常见的用例应该足够了。

**注意**

*你可能听说过语义版本控制，它为版本号命名提供了自己的指导原则。这个规范与 PEP 440 部分重叠，但不完全兼容。例如，语义版本控制推荐的预发布版本使用类似 1.0.0-alpha+001 的方案，而这与 PEP 440 不兼容。*

许多*分布式版本控制系统（DVCS）*平台，如 Git 和 Mercurial，能够通过标识哈希生成版本号（对于 Git，请参考 git describe）。不幸的是，这个系统与 PEP 440 定义的方案不兼容：其中一个原因是标识哈希无法排序。

### **编码风格和自动化检查**

编码风格是一个敏感的话题，但我们应该在深入讨论 Python 之前先谈论一下。与许多编程语言不同，Python 使用*缩进*来定义代码块。虽然这为解决“我应该在哪里放置大括号？”这一历史性问题提供了简单的解决方案，但也带来了一个新问题：“我应该如何缩进？”

这是社区最早提出的问题之一，因此 Python 开发者们凭借其深厚的智慧，提出了*PEP 8: Python 代码风格指南*（*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*）。

本文档定义了编写 Python 代码的标准风格。指导原则的清单归结为：

+   每个缩进级别使用四个空格。

+   限制所有行的最大字符数为 79。

+   用两个空行分隔顶级函数和类定义。

+   使用 ASCII 或 UTF-8 编码文件。

+   每个导入语句和每行只能导入一个模块。将导入语句放在文件的顶部，位于注释和文档字符串之后，按照顺序首先导入标准库，然后是第三方库，最后是本地库。

+   在圆括号、方括号或大括号之间，以及逗号之前，不要使用多余的空格。

+   类名使用驼峰命名法（例如，CamelCase），异常类以Error结尾（如果适用），函数名使用小写字母，并且单词之间用下划线分隔（例如，separated_by_underscores）。使用前导下划线表示_私有属性或方法。

这些指南真的不难遵循，而且它们非常合理。大多数Python程序员在编写代码时并不难遵守这些规则。

然而，*人非圣贤，孰能无过*，查看你的代码以确保它符合PEP 8指南仍然是件痛苦的事情。幸运的是，有一个pep8工具（可在 *[https://pypi.org/project/pep8/](https://pypi.org/project/pep8/)* 上找到），它可以自动检查你发送的任何Python文件。使用pip安装pep8，然后你可以像下面这样在文件上使用它：

$ pep8 hello.py

hello.py:4:1: E302 期望2个空行，但发现1个 $ echo $?

1

这里我在我的文件*hello.py*上使用pep8，输出结果显示哪些行和列不符合PEP 8，并报告每个问题的代码——这里是第4行和第1列。违反规范中*必须*语句的将被报告为*错误*，错误代码以*E*开头。轻微问题会被报告为*警告*，错误代码以*W*开头。紧跟其后的三位数字代码表示错误或警告的具体类型。

百位数字告诉你错误代码的一般类别：例如，错误代码以E2开头表示空格问题，错误代码以E3开头表示空行问题，警告代码以W6开头表示使用了废弃的特性。这些代码都列在pep8的readthedocs文档中（* [https://pep8.readthedocs.io/](https://pep8.readthedocs.io/)*）。

#### ***捕捉样式错误的工具***

社区仍然在争论是否对不属于标准库的PEP 8代码进行验证是良好的实践。我的建议是定期使用PEP 8验证工具检查源代码。你可以通过将其集成到持续集成系统中来轻松实现。虽然这种方法看起来有点极端，但它是确保长期遵守PEP 8指南的好方法。在“使用virtualenv与tox”中，我们将在[第92页](ch06.xhtml#page_92)讨论如何将pep8与tox集成来自动化这些检查。

大多数开源项目通过自动检查强制执行PEP 8一致性。从项目一开始就使用这些自动检查可能会让新手感到沮丧，但它也确保了代码库在项目的每个部分始终保持一致。这对于有多个开发者参与的大型项目来说尤为重要，因为开发者们可能在空格排序等方面有不同的看法。你懂我的意思。

你也可以通过使用--ignore选项设置让代码忽略某些类型的错误和警告，像这样：

$ pep8 --ignore=E3 hello.py

$ echo $?

0

这将忽略我在*hello.py*文件中的任何代码 E3 错误。--ignore 选项允许你有效地忽略你不想遵循的 PEP 8 规范部分。如果你在现有的代码库上运行 pep8，它还允许你忽略某些类型的问题，这样你就可以一次集中精力修复一个类别的问题。

**注意**

*如果你为 Python 编写 C 代码（例如，模块），PEP 7 标准描述了你应该遵循的编码风格。*

#### ***捕获编码错误的工具***

Python 还提供了一些检查实际编码错误的工具，而非风格错误。以下是一些值得注意的例子：

+   *Pyflakes* (*[https://launchpad.net/pyflakes/](https://launchpad.net/pyflakes/)*): 可通过插件扩展。

+   *Pylint* (*[https://pypi.org/project/pylint/](https://pypi.org/project/pylint/)*): 默认检查 PEP 8 合规性，并进行代码错误检查；可以通过插件扩展。

这些工具都使用静态分析——也就是说，它们解析代码并进行分析，而不是直接运行代码。

如果你选择使用 Pyflakes，请注意它本身不检查 PEP 8 合规性，因此你需要使用第二个 pep8 工具来涵盖两者。

为了简化事情，Python 有一个名为 flake8 的项目 (*[https://pypi.org/project/flake8/](https://pypi.org/project/flake8/)*)，它将 pyflakes 和 pep8 合并为一个命令。它还添加了一些新的功能：例如，它可以跳过包含 # noqa 的行，并且可以通过插件扩展。

有大量的插件可以供 flake8 使用，你可以开箱即用。例如，安装*flake8-import-order*（使用 `pip install flake8-import-order`）将扩展 flake8，使其检查你的导入语句是否在源代码中按字母顺序排序。是的，一些项目确实需要这样做。

在大多数开源项目中，flake8 被广泛用于代码风格验证。一些大型开源项目甚至为 flake8 编写了自己的插件，增加了对一些错误的检查，比如异常使用不当、Python 2/3 兼容性问题、导入风格、危险的字符串格式化、可能的本地化问题等。

如果你正在开始一个新项目，我强烈建议你使用这些工具之一来自动检查代码质量和风格。如果你已经有一个没有实现自动代码检查的代码库，一个好的方法是先用你选择的工具运行，并禁用大部分警告，逐一修复每个类别的问题。

尽管这些工具中没有一个*完美*适合你的项目或偏好，flake8 依然是提高代码质量并使代码更具耐用性的好方法。

**注意**

*许多文本编辑器，包括著名的GNU Emacs和vim，都有插件（如Flycheck），可以直接在代码缓冲区中运行工具，如pep8或flake8，互动式地高亮显示任何不符合PEP 8规范的代码部分。这是一种在写代码时修复大多数风格错误的方便方式。*

我们将在[第9章](ch09.xhtml#ch09)中讨论如何通过自定义插件扩展这个工具集，以验证正确的方法声明。

### **Joshua Harlow谈Python**

约书亚·哈洛（Joshua Harlow）是一位Python开发者。他曾在2012到2016年间担任雅虎OpenStack团队的技术负责人，现在在GoDaddy工作。Josh是多个Python库的作者，如*Taskflow*、*automaton*和*Zake*。

**是什么让你开始使用Python的？**

我大约在2004年左右，在IBM位于纽约州波基普西的实习期间开始编程，使用的是Python 2.3或2.4（我大多数亲戚和家人都来自纽约上州，向他们致敬！）。我忘了当时具体做什么了，但它涉及到wxPython和一些他们用来自动化某些系统的Python代码。

在那次实习之后，我回到学校，继续在罗切斯特理工学院攻读研究生，并最终在雅虎工作。

我最终加入了CTO团队，我和其他几位同事的任务是找出应该使用哪个开源云平台。我们选择了OpenStack，它几乎完全用Python编写。

**你喜欢和讨厌Python语言的哪些方面？**

我喜欢的一些事情（不是一个全面的列表）：

+   它的简洁性——Python对于初学者来说非常容易上手，对有经验的开发者来说也能保持兴趣。

+   风格检查——以后阅读自己写的代码是开发软件的一个重要部分，拥有一致性并通过flake8、pep8和Pylint等工具强制执行，这真的很有帮助。

+   能够选择和混合编程风格，按需组合使用。

我不喜欢的一些事情（不是一个全面的列表）：

+   从Python 2到Python 3的过渡有点痛苦（版本3.6已经解决了大部分问题）。

+   Lambda表达式过于简单，应该让它们更强大。

+   缺乏一个体面的包管理器——我觉得pip需要改进，比如开发一个真正的依赖解决器。

+   全局解释器锁（GIL）及其必要性。它让我感到难过……[更多关于GIL的内容在[第11章](ch11.xhtml#ch11)中]。

+   缺乏对多线程的原生支持——目前你需要额外的显式asyncio模型来实现。

+   Python社区的分裂；这主要是指CPython和PyPy（以及其他变体）之间的分歧。

**你在debtcollector上工作，这是一个用于管理弃用警告的Python模块。启动一个新库的过程是怎样的？**

上述的简洁性使得创建新库并将其发布供他人使用变得非常容易。由于这段代码来自我参与的另一个库（taskflow^([1](footnote.xhtml#foot1)))，所以将这段代码移植并扩展起来相对简单，且无需担心 API 设计不佳。我非常高兴其他人（无论是 OpenStack 社区内外）发现了它的需求/用途，并且我希望这个库能够成长，适应更多其他库（和应用程序？）可能需要的废弃模式。

**你认为 Python 缺少什么？**

Python 在即时编译（JIT）下的性能可能会更好。大多数新兴语言（如 Rust、使用 Chrome V8 JavaScript 引擎的 Node.js 等）具备 Python 的许多功能，但也都支持 JIT 编译。如果默认的 CPython 也能进行 JIT 编译，那就太好了，这样 Python 就能在性能上与这些新兴语言竞争。

Python 也非常需要一套强大的并发模式；不仅仅是低级的 asyncio 和线程模式，而是更高层次的概念，帮助开发出在大规模应用中表现出色的程序。Python 库 goless 移植了一些来自 Go 的概念，Go 提供了内建的并发模型。我认为这些更高层次的模式需要作为一等公民被内建到标准库中并得到维护，以便开发者在需要时使用。没有这些，我看不到 Python 如何与提供这些功能的其他语言竞争。

下次再见，保持编程并保持快乐！
