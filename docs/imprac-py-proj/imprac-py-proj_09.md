## **9**

使用马尔可夫链分析写俳句**

![image](img/common01.jpg)

计算机可以通过重新排列现有的诗歌来写诗。这基本上是人类所做的事。你我并没有发明我们所说的语言——我们是通过学习它来掌握的。要说话或写作，我们只是重新组合现有的词汇——而且很少以真正原创的方式进行。正如 Sting 曾经说过的关于创作音乐的话，“我不认为流行音乐中有创作这种东西。我认为我们在流行音乐中做的是整理……我擅长整理。”

在这一章中，你将编写一个程序，按照俳句的形式将“最好的词放在最好的位置”。但是为了做到这一点，Python 需要优秀的示例，因此你需要提供由日本大师创作的俳句训练语料库。

为了以有意义的方式重新排列这些词语，你将使用*马尔可夫链*，它以俄罗斯数学家 Andrey Markov 的名字命名。*马尔可夫链分析*是概率论中的一个重要部分，它是一个尝试根据当前状态的属性预测后续状态的过程。现代应用包括语音和手写识别、计算机性能评估、垃圾邮件过滤，以及 Google 的 PageRank 算法来搜索网络。

通过马尔可夫链分析、训练语料库和来自第八章的音节计数程序，你将能够生成符合音节规则并且在很大程度上“紧扣主题”的新俳句。你还将学习如何使用 Python 的日志模块，通过简单的开关反馈来帮助监控程序的行为。在第 184 页的“挑战项目”中，你可以邀请社交媒体上的朋友，看看他们能否区分你模拟的俳句和真实的俳句。

### **项目 #16: 马尔可夫链分析**

像第七章中的遗传算法一样，马尔可夫链分析听起来很有影响力，但其实很容易实现。你每天都在做这件事。如果你听到有人说：“Elementary, my dear . . .”，你会自动想：“Watson。”每次你的大脑听到这个短语，它都会进行采样。基于采样的数量，它可以预测出答案。另一方面，如果你听到有人说：“I want to go to . . .”，你可能会想“厕所”或“电影院”，但很可能不会想到“Louisiana 的 Houma”。虽然有很多可能的答案，但有些答案比其他的更可能。

在 20 世纪 40 年代，Claude Shannon 开创了使用马尔可夫链来统计建模文本中的字母序列。例如，在一本英文书籍中，每次出现二元组*th*时，接下来的字母最可能是*e*。

但你不仅想知道最可能的字母是什么；你还想知道得到该字母的实际概率，以及得到每个其他字母的概率，这是一个非常适合计算机解决的问题。为了解决这个问题，你需要将文本中的每个二字母对映射到紧随其后的字母。这是一个经典的字典应用，二字母对是键，字母是值。

当应用到单词中的字母时，*马尔科夫模型*是一个数学模型，通过计算一个字母出现的概率，基于前一个*k*连续的字母，其中*k*是一个整数。*二阶模型*意味着字母出现的概率取决于前面两个字母。*零阶模型*意味着每个字母是独立的。这同样的逻辑适用于单词。考虑以下这两个俳句的例子：

| 在云中休息 | 光辉的月亮 |
| --- | --- |
| 明亮的月亮山顶 | 因此我们的感谢黑暗的云朵来 |
| 遥远而孤高 | 休息我们疲惫的脖子 |

一个将每个俳句单词映射到其后续单词的 Python 字典如下所示：

'a': ['休息', '明亮'],

'aloof': ['光辉的'],

'and': ['孤高的'],

'break': ['在'],

'bright': ['山顶'],

'clouds': ['那个', '来'],

'come': ['到'],

'dark': ['云'],

'distant': ['和'],

'glorious': ['那个'],

'in': ['那个'],

'moon': ['一个', '因此'],

'mountaintop': ['遥远的'],

'our': ['感谢', '疲惫'],

'rest': ['我们的'],

'thanks': ['黑暗'],

'the': ['云', '月亮', '月亮'],

'therefore': ['我们的'],

'tired': ['脖子'],

'to': ['休息']

由于只有两个俳句，大多数词典的键只有一个值。但请看列表底部的*the*，*moon*出现了两次。这是因为马尔科夫模型将每个单词的出现视为单独的重复值。因此，对于键*the*，如果随机选择一个值，选择*moon*与*clouds*的概率是 2:1。相反，模型会自动筛选出极为罕见或不可能的组合。例如，许多单词可以跟在*the*后面，但不可能再跟另一个*the*！

以下字典将每个*词对*映射到紧随其后的单词；这意味着它是一个二阶模型。

'a break': ['在'],

'a bright': ['山顶'],

'aloof glorious': ['那个'],

'and aloof': ['光辉的'],

'break in': ['那个'],

'bright mountaintop': ['遥远的'],

'clouds come': ['到'],

'clouds the': ['月亮'],

'come to': ['休息'],

'dark clouds': ['来'],

'distant and': ['孤高的'],

'glorious the': ['月亮'],

'in the': ['云'],

'moon a': ['明亮的'],

'moon therefore': ['我们的'],

'mountaintop distant': ['和'],

'our thanks': ['黑暗'],

'our tired': ['脖子'],

'rest our': ['疲惫'],

'thanks dark': ['云'],

'the clouds': ['那个'],

'the moon': ['一个', '因此'],

'therefore our': ['感谢'],

'to rest': ['我们的']

请注意，映射从第一个俳句延续到第二个，因此字典包含项目 'and aloof': ['glorious'] 和 'aloof glorious': ['the']。这种行为意味着你的程序可以从一个俳句跳到另一个俳句，而不仅仅局限于单个俳句中的词对。它可以自由地形成新的词对，这些词对可能是大师们从未想到过的。

由于训练语料非常短，*the moon* 是唯一一个有多个值的词对。对于其他所有词对，你都“被锁定”在一个唯一的结果上。在这个例子中，训练语料的大小极大地决定了每个键的值的数量，但如果语料库更大，马尔可夫模型中 *k* 的值将会有更大的影响。

*k* 的大小决定了你生成的内容是胡说八道、剽窃，还是一篇清晰的原创作品。如果 *k* 等于 0，那么你将根据该词在语料库中的整体频率随机选择词语，结果很可能是大量的无意义话语。如果 *k* 很大，结果会受到严格的限制，你将开始逐字复制训练文本。因此，小值的 *k* 促进创造力，而大值的 *k* 则促进重复。挑战在于找到两者之间的适当平衡。

举例来说，如果你使用一个三阶的马尔可夫模型来生成前面的俳句，所有结果键都会只有一个值。与词对 *the moon* 相关的两个值将丢失，因为原先的词对变成了两个键，每个键有一个唯一的值：

'the moon a': ['bright'],

'the moon therefore': ['our']

由于俳句很短——只有 17 个音节——且现有的训练语料库相对较小，使用 *k* 为 2 应该足以在保证*某种*顺序的同时，仍然允许程序中的创造性词汇替换。

**目标**

编写一个程序，通过马尔可夫链分析生成俳句。允许用户通过独立重新生成第二行和第三行来修改俳句。

### **策略**

你模拟俳句的总体策略是，基于人类写作的俳句训练语料库构建一阶和二阶的马尔可夫模型。然后，使用这些模型和 第八章中的 *count_syllables.py* 程序生成符合要求音节结构（5-7-5）的新俳句。

程序应该一次生成一个词来构建俳句，从语料库中随机抽取一个词来启动（或*播种*）俳句；使用一个一阶的马尔可夫模型选择俳句的第二个词；然后使用二阶模型选择每个后续的词。

每个词都来自一个 *前缀*——一个决定将选择哪个词加入俳句的词或词对；在词映射字典中，键代表前缀。因此，前缀决定的词就是 *后缀*。

#### ***选择和丢弃词汇***

当程序选择一个单词时，它首先计算该单词的音节数，如果该单词不合适，它会选择一个新单词。如果根据诗句中的前缀没有可能的单词，程序会采用我称之为*幽灵前缀*的策略，这是一个在俳句中并不存在的前缀。例如，如果俳句中的一个词对是*temple gong*，而在马尔可夫模型中所有后续单词的音节数都太多，无法完成这一行，程序会随机选择一个新词对，并利用它来选择下一个俳句中的单词。新的词对前缀*不应该包含在这一行中*——也就是说，*temple gong*不会被替换。虽然你可以通过多种方式选择一个合适的新单词，但我更喜欢这种技术，因为它允许你通过保持整个程序的一致过程来简化操作。

你可以通过图 9-1 和 9-2 中的函数来完成这些步骤。假设你正在处理一个五音节的诗句，图 9-1 展示了如果所有选择的单词都符合音节目标，程序在高级别上会发生的情况。

![image](img/f0165-01.jpg)

*图 9-1：五音节俳句行的高级图形伪代码*

程序从语料库中随机选择种子词*the*，然后计算它的音节数。接下来，根据前缀*the*，它从一级模型中选择*bright*。然后它计算*bright*的音节数，并将该数字加到行中的音节总数中。由于音节总数不超过五，程序将*bright*加入到行中，继续根据前缀*The bright*从二级模型中选择*autumn*，然后重复音节计数过程。最后，程序根据前缀*bright autumn*选择*moon*，计算音节数，并且——由于该行的音节总数恰好为五——将*moon*加入行中，完成该行。

图 9-2 展示了程序需要利用幽灵前缀来成功完成一个五音节诗句的情况。

![image](img/f0166-01.jpg)

*图 9-2：使用随机选择的幽灵前缀（*full white*）选择新后缀*

假设在马尔可夫模型中，紧跟前缀*temple gong*的唯一单词是*glorious*。这个词的音节数太多，无法满足该行的要求，于是程序随机选择了一个幽灵前缀*full white*。单词*moon*跟随幽灵前缀，并满足了这一行的剩余音节数，因此程序将其添加到这一行中。程序随后丢弃了*full white*前缀，这一行完成了。使用这种幽灵前缀技术，你不能保证新的后缀在语境上完全合适，但同时，这也是将创造性融入过程的一种方式。

#### ***从一行继续到另一行***

马尔科夫模型是“特别酱料”，它使你能够赋予俳句从一行到另一行的上下文和意义。日本的大师们*通常*会写俳句，每一行都是独立的短语，但上下文的脉络会跨越行延续，就像这首来自 Bon Cho 的俳句：

在寂静的午夜

我们的老稻草人倒下了

奇怪的空洞回声

*—Bon Cho*

尽管大师们更喜欢每行俳句代表一个完整的思想，但他们并不严格遵循这一规则。以下是 Buson 俳句中的一个例子：

我的两棵梅树是

如此优雅，看看，它们开花了

一个现在，一个稍后

*—Buson*

Buson 俳句的第一行本身并不符合语法，因此读者必须继续到下一行，而没有停顿。当诗句中的一句话从一行移到下一行时没有停顿或语法中断时，这种现象称为* enjambment*（延续式）。根据《虚拟缪斯》一书的作者 Charles Hartman 的说法，enjambment 是赋予韵律线条柔韧生动的原因之一。这是件好事，因为很难让算法写出一个连贯的诗句，而不借用上一行的语法内容。为了让你的程序通过多行继续一个“思想”，你需要使用上一行结束时的单词对作为当前行的起始前缀。

最后，你应该给用户一个机会，不仅可以构建诗句，还能通过重新生成第二行和第三行来交互式编辑它。写作的许多部分都是重写，如果用户有两行完美的诗句却没有办法对不合作的行重新投掷骰子，那将是不可理喻的。

### **伪代码**

如果你按照我刚才概述的策略进行操作，你的高级伪代码应该如下所示：

导入 count_syllables 模块

加载一个训练语料库文本文件

处理训练语料库中的空格、换行符等

将语料库中的每个单词映射到后面的单词（马尔科夫模型顺序 1）

将语料库中的每一对单词映射到后面的单词（马尔科夫模型顺序 2）

给用户选择生成完整俳句、重新做第 2 行或第 3 行，或退出的选项

如果是第一行：

目标音节数 = 5

从语料库中获取一个随机单词，音节数 ≤ 4（没有单词行）

将单词添加到行中

设置随机单词 = 前缀变量

获取前缀后的映射单词

如果映射的单词音节数过多

随机选择新的前缀词并重复

从映射单词中随机选择新单词

将新单词添加到行中

计算单词中的音节并计算行中的总音节数

如果行中的音节数等于目标音节数

返回行和行中的最后一对单词

否则如果是第二行或第三行：

目标 = 7 或 5

行等于上一行中的最后一对单词

在音节目标未达到时：

前缀 = 行中的最后一对单词

获取单词对前缀后的映射单词

如果映射的单词音节数过多

随机选择新的单词对前缀并重复

从映射单词中随机选择新单词

将新单词添加到行中

计算单词中的音节并计算行中的总音节数

如果总和大于目标

丢弃词语，重置总和，重复

如果总和小于目标

将词语添加到行中，保持总和，并重复

如果总和等于目标

将词语添加到行中

返回行和行中的最后一个词对

显示结果和选择菜单

### **训练语料库**

马尔可夫模型是从语料库构建的，因此它们是该语料库特有的。从埃德加·赖斯·巴勒斯的完整作品构建的模型将与从安妮·赖斯的作品构建的模型不同。我们每个人都有独特的风格或*声音*，只要样本足够大，马尔可夫方法就能生成你风格的统计模型。就像指纹一样，这个模型可以将你与某个文档或手稿联系起来。

要构建马尔可夫模型，你将使用的语料库是一个包含近 300 首古今俳句的文本文件，其中超过 200 首是由大师们写的。理想情况下，你的训练语料库应该包含成千上万的俳句，且全部出自同一作者（以保持一致的声音），但这些很难找到，尤其是许多古老的日本俳句并不遵循音节规则，可能是故意为之，或者是翻译成英文时出现了偏差。

为了增加马尔可夫模型中每个关键字的值的数量，初始语料库中的俳句被复制了 18 次，并随机分布在文件中。这不会影响俳句内部的词汇关联，但会增加俳句之间的互动。

为了说明，假设以下俳句结尾的词对是唯一的，只映射到第二个俳句的起始词；这将导致一个几乎无用的键值对“空心青蛙”：['镜面池塘']：

张开嘴巴，露出

你整个湿漉漉的内部

傻乎乎的**空心青蛙**！

**镜面池塘**的星星

突然的一场夏雨

水面上的涟漪

如果你复制并打乱俳句，可能会引入一个介词，从而大大增加将“空心青蛙”与某些合理内容关联的概率：

张开嘴巴，露出

你整个湿漉漉的内部

傻乎乎的**空心青蛙**！

**在**城市的田野里

沉思樱花树

陌生人像朋友

马尔可夫模型现在将两个值分配给“空心青蛙”：“镜面池塘”和“在”。每次你复制俳句时，俳句结尾的词或词对的每个关键字的值数量都会增加。但这只在某个点上有帮助；一段时间后，收益递减，你开始反复添加相同的值，毫无意义。

### **调试**

调试是寻找和修复计算机硬件和软件中的错误（bug）的过程。当你试图为一个复杂的问题编写解决方案时，你需要紧密控制程序，以便在出现意外情况时找到问题的根源。例如，如果你在俳句的第一行中得到了七个音节，而不是五个，你会想知道是音节计数功能失败了，还是在将单词映射到单词时出现了问题，或者程序认为它在第二行。为了找出哪里出错了，你需要监控程序在每个关键步骤中返回的内容，这就需要使用*脚手架*或*日志记录*。我将在接下来的两个部分中讨论这两种技术。

#### ***构建脚手架***

*脚手架*，在这里定义，是你编写的临时代码，用于帮助开发程序，然后在完成后删除。这个名称暗指建筑中使用的脚手架——必要的，但没有人希望它永远存在。

一种常见的脚手架是一个 print() 语句，用来检查一个函数或计算返回了什么。用户不需要看到输出，因此在确认程序正常工作后，你可以删除它。

有用的脚手架输出包括诸如值或变量的类型、数据集的长度以及增量计算的结果等内容。正如 Allen Downey 在《*Think Python*》中所说：“构建脚手架所花费的时间可以减少你调试所花费的时间。”

使用 print() 语句进行调试的缺点是你需要在稍后回去删除（或注释掉）所有这些语句，而且你有可能不小心删除了对最终用户有用的 print() 语句。幸运的是，有一种替代脚手架的方法，可以让你避免这些问题。它被称为日志记录模块。

#### ***使用日志记录模块***

日志记录模块是 Python 标准库的一部分 (*[`docs.python.org/3/library/logging.html`](https://docs.python.org/3/library/logging.html)*)。通过日志记录，你可以获得关于程序在任何你选择的位置正在做什么的定制报告。你甚至可以将报告写入永久的日志文件。以下交互式命令行示例使用日志记录检查一个音节计数程序是否正常工作：

➊ >>> import logging

➋ >>> logging.basicConfig(level=logging.DEBUG,

format='%(levelname)s - %(message)s')

>>> word = 'scarecrow'

>>> VOWELS = 'aeiouy'

>>> num_vowels = 0

>>> for letter in word:

if letter in VOWELS:

num_vowels += 1

➌ logging.debug('字母 & 计数 = %s-%s', letter, num_vowels)

DEBUG - 字母 & 计数 = s-0

DEBUG - 字母 & 计数 = c-0

DEBUG - 字母 & 计数 = a-1

DEBUG - 字母 & 计数 = r-1

DEBUG - 字母 & 计数 = e-2

DEBUG - 字母 & 计数 = c-2

DEBUG - 字母 & 计数 = r-2

DEBUG - 字母 & 计数 = o-3

DEBUG - 字母 & 计数 = w-3

要使用 logging 模块，首先导入它 ➊。然后设置你想要查看的调试信息及其格式 ➋。DEBUG 级别是最低的消息级别，用于诊断详细信息。请注意，输出使用字符串格式化 %s。你可以包括更多的信息，例如，日期和时间通过 format='%(asctime)s' 显示——但对于这段代码，你只需要检查程序是否正确计数元音即可。

对于每个评估的字母，输入自定义的文本消息以显示变量值。请注意，必须将非字符串对象（如整数和列表）转换为字符串 ➌。以下是 logging 输出。你可以看到累计计数，以及哪些字母实际上改变了计数。

就像脚手架一样，logging 是为开发者准备的，而不是用户。就像 print() 函数一样，logging 也会减慢程序的运行速度。要禁用日志消息，只需在导入模块后插入 logging.disable(logging.CRITICAL) 调用，如下所示：

>>> import logging

>>> logging.disable(logging.CRITICAL)

将禁用调用放在程序顶部附近，可以轻松找到它，并切换消息的开关。logging.disable() 函数会抑制指定级别或更低级别的所有消息。由于 CRITICAL 是最高级别，传递它给 logging.disable() 函数会关闭所有消息。这比手动查找并注释掉 print() 语句要好得多！

### **代码**

本节中的 *markov_haiku.py* 代码将处理名为 *train.txt* 的训练语料库，准备作为字典的马尔可夫模型，并一字一字生成俳句。*count_syllables.py* 程序和 *missing_words.json* 文件来自 第八章，将确保 *markov_haiku.py* 为每行使用正确的音节数。你可以从 *[`www.nostarch.com/impracticalpython/`](https://www.nostarch.com/impracticalpython/)* 下载所有这些文件（第九章 文件夹）。务必将它们保存在同一目录中。

#### ***设置***

清单 9-1 导入所需模块，然后加载并准备外部文件。

*markov_haiku.py*，第一部分

➊ import sys

import logging

import random

from collections import defaultdict

from count_syllables import count_syllables

➋ logging.disable(logging.CRITICAL)  # 注释掉以启用调试消息

logging.basicConfig(level=logging.DEBUG, format='%(message)s')

➌ def load_training_file(file):

"""将文本文件作为字符串返回。"""

with open(file) as f:

➍ raw_haiku = f.read()

return raw_haiku

➎ def prep_training(raw_haiku):

"""加载字符串，去除换行符，按空格分割单词并返回列表。"""

corpus = raw_haiku.replace('\n', ' ').split()

return corpus

*清单 9-1：导入、加载并准备训练语料库*

从单独的行开始列出导入语句 ➊。你需要使用日志记录以接收调试消息，而 defaultdict 会帮助你通过自动创建新键来从列表构建字典，而不是抛出错误。你还需要导入从*count_syllables.py* 程序中编写的 count_syllables 函数，后者在第八章中有介绍。你应该对这些导入语句中的其他内容已经熟悉。

在导入语句之后立即放置禁用日志记录的语句，这样你可以轻松找到它。要查看日志信息，你需要注释掉此语句 ➋。以下语句配置了你将看到的内容，如前一部分所述。我选择从显示中省略了级别标识。

接下来，定义一个函数来加载训练语料库文本文件 ➌。使用内置的 read() 函数将数据作为字符串读取，程序在转换为列表 ➍ 之前会对其进行准备。返回该字符串以供下一个函数使用。

prep_training() 函数 ➎ 将 load_training_file() 函数的输出作为参数。然后，它将换行符替换为空格，并基于空格将单词拆分为列表项。最后，函数返回语料库作为列表。

#### ***构建马尔可夫模型***

马尔可夫模型实际上是 Python 字典，使用单词或单词对作为键，紧随其后的单词作为值。通过重复值列表中的尾随单词来捕捉尾随单词的统计频率——类似于集合，字典不能有重复的*键*，但可以有重复的*值*。

清单 9-2 定义了两个函数。两个函数都以语料库作为参数，并返回一个马尔可夫模型。

*markov_haiku.py,* 第二部分

➊ def map_word_to_word(corpus):

"""加载列表并使用字典将单词映射到其后继单词。"""

➋ limit = len(corpus) - 1

➌ dict1_to_1 = defaultdict(list)

➍ for index, word in enumerate(corpus):

if index < limit:

➎ suffix = corpus[index + 1]

dict1_to_1[word].append(suffix)

➏ logging.debug("map_word_to_word 结果对于 \"sake\" = %s\n",

dict1_to_1['sake'])

➐ return dict1_to_1

➑ def map_2_words_to_word(corpus):

"""加载列表并使用字典将单词对映射到尾随单词。"""

➒ limit = len(corpus) - 2

dict2_to_1 = defaultdict(list)

for index, word in enumerate(corpus):

if index < limit:

➓ key = word + ' ' + corpus[index + 1]

suffix = corpus[index + 2]

dict2_to_1[key].append(suffix)

logging.debug("map_2_words_to_word 结果对于 \"sake jug\" = %s\n",

dict2_to_1['sake jug'])

return dict2_to_1

*清单 9-2：定义构建 1 阶和 2 阶马尔可夫模型的函数*

首先，定义一个函数将每个单词映射到它的尾随单词 ➊。程序将仅使用此函数从种子单词选择俳句的第二个单词。它的唯一参数是 prep_training() 函数返回的语料库列表。

设置一个限制，以防无法选择语料库中的最后一个单词 ➋，因为这样会导致索引错误。然后使用 `defaultdict` 初始化一个字典 ➌。你希望字典的值是一个列表，用来存储你找到的所有后续单词，所以使用 `list` 作为参数。

遍历语料库中的每个单词，使用 `enumerate` 将每个单词的索引转换为一个对象 ➍。使用条件语句和限制变量来防止选择最后一个单词作为关键字。定义一个名为 `suffix` 的变量来表示后续单词 ➎。该值将是当前单词的索引位置加 1——即列表中的下一个单词。将此变量作为当前单词的值添加到字典中。

为了检查一切是否按计划工作，使用 `logging` 来显示 *单个关键字* 的结果 ➏。语料库中有成千上万的单词，因此你不希望打印出所有的单词。选择一个你知道在语料库中的单词，比如 *sake*。注意，你正在使用旧的字符串格式化方法 `%`，因为它适合当前日志记录器的设计。最后返回字典 ➐。

下一个函数 `map_2_words_to_word()` 基本上是相同的函数，只不过它使用两个连续的单词作为键，映射到后续的单个单词 ➑。主要的变化是将限制设置为离语料库末尾两个单词的位置 ➒，使得键由两个单词组成，中间用空格隔开 ➓，并且为后续单词的索引加 2。

#### ***选择一个随机单词***

程序无法在没有键的情况下利用马尔可夫模型，因此用户或程序必须提供模拟俳句中的第一个单词。列表 9-3 定义了一个随机选择第一个单词的函数，便于自动化种子选择。

*markov_haiku.py*，第三部分

➊ def random_word(corpus):

"""从训练语料库中返回随机单词和音节数。"""

➋ word = random.choice(corpus)

➌ num_syls = count_syllables(word)

➍ if num_syls > 4:

random_word(corpus)

else:

➎ logging.debug("random word & syllables = %s %s\n", word, num_syls)

return (word, num_syls)

*列表 9-3：随机选择一个种子单词来启动俳句*

定义函数并传递语料库列表 ➊。然后定义一个 `word` 变量，并使用 `random.choice()` 方法从语料库中随机选择一个单词 ➋。

使用 count_syllables() 函数（来自 count_syllables 模块）计算词语的音节数；将计算结果存储在 num_syls 变量中 ➌。我个人不喜欢在俳句中使用单个词的行，因此不要允许函数选择超过四个音节的词（回想一下，最短的俳句行有五个音节）。如果发生这种情况，请递归调用 random_word() 函数，直到得到一个可接受的词 ➍。请注意，Python 默认的最大递归深度是 1,000，但只要你使用的是适当的俳句训练语料库，基本不会在找到合适的词之前超出这个限制。如果真的超出了，你可以通过使用 while 循环来解决这个问题。

如果词语的音节数少于五个，则使用日志记录功能显示该词和它的音节数 ➎；然后将该词和音节数作为元组返回。

#### ***应用马尔可夫模型***

要选择紧随种子词的单一词语，可以使用一阶马尔可夫模型。之后，程序应使用二阶模型选择所有后续词语，二阶模型使用词对作为键。列表 9-4 为这些操作定义了单独的函数。

*markov_haiku.py*，第四部分

➊ def word_after_single(前缀, suffix_map_1, current_syls, target_syls):

"""返回语料库中跟随单个词的所有可接受词语。"""

➋ accepted_words = []

➌ suffixes = suffix_map_1.get(前缀)

➍ 如果 suffixes 不为 None：

➎ 对于候选词 in suffixes：

num_syls = count_syllables(候选词)

如果 current_syls + num_syls <= target_syls：

➏ accepted_words.append(候选词)

➐ logging.debug("经过 \"%s\" 后的可接受词语 = %s\n",

前缀，设置（accepted_words）

return accepted_words

➑ def word_after_double(前缀, suffix_map_2, current_syls, target_syls):

"""返回在语料库中，跟随词对的所有可接受词语。"""

accepted_words = []

➒ 后缀 = suffix_map_2.get(前缀)

如果 suffixes 不为 None：

对于候选词 in suffixes：

num_syls = count_syllables(候选词)

如果 current_syls + num_syls <= target_syls：

accepted_words.append(候选词)

logging.debug("经过 \"%s\" 后的可接受词语 = %s\n",

前缀，设置（accepted_words）

➓ return accepted_words

*列表 9-4：选择一个给定前缀、马尔可夫模型和音节数的词的两个函数*

定义一个名为 word_after_single() 的函数，根据前面的单一种子词来选择俳句中的下一个词。该函数的参数包括前一个词、一阶马尔可夫模型、当前音节数和目标音节数 ➊。

创建一个空列表来保存可接受的词语，这些词语既跟随前缀，又符合音节数不超过目标音节数的要求 ➋。将这些后缀词语称为 suffixes，并使用字典的 get() 方法将其分配给变量 ➌，该方法根据键返回字典值。如果请求的键不存在，get() 方法不会抛出 KeyError，而是返回 None。

极为罕见的情况是前缀会成为语料库中的最后一个单词，而且它是唯一的。在这种情况下，将没有后缀。使用 if 语句来预见这种情况➍。如果没有后缀，调用 word_after_single()的函数（你将在下一部分定义）将选择一个新的前缀。

每个后缀代表一个*候选*单词，用于俳句，但程序尚未确定这个候选词是否“合适”。因此，使用 for 循环、count_syllables 模块和 if 语句来判断将单词添加到这一行是否会违反每行的目标音节数➎。如果没有超出目标音节数，则将单词添加到可接受单词列表中➏。在日志消息中显示可接受的单词，然后返回它们➐。

下一个函数 word_after_double()与之前的函数类似，不同之处在于你传入的是单词对和马尔可夫顺序 2 模型（suffix_map_2）➑，并从这个字典中获取后缀➒。但就像 word_after_single()函数一样，word_after_double()返回一个可接受的单词列表➓。

#### ***生成俳句行***

准备好所有辅助函数后，你可以定义实际写入俳句行的函数。该函数可以构建整个俳句，或仅更新第二行或第三行。有两条路径可以选择：一条用于程序最多只能处理一个单词后缀的情况，另一条用于其他所有情况。

##### **构建第一行**

列表 9-5 定义了写入俳句行并启动俳句第一行的函数。

*markov_haiku.py,* 第五部分

➊ def haiku_line(suffix_map_1, suffix_map_2, corpus, end_prev_line, target_syls):

"""从训练语料库构建一行俳句并返回"""

➋ line = '2/3'

line_syls = 0

current_line = []

➌ if len(end_prev_line) == 0:  # 构建第一行

➍ line = '1'

➎ word, num_syls = random_word(corpus)

current_line.append(word)

line_syls += num_syls

➏ word_choices = word_after_single(word, suffix_map_1,

line_syls, target_syls)

➐ while len(word_choices) == 0:

prefix = random.choice(corpus)

logging.debug("new random prefix = %s", prefix)

word_choices = word_after_single(prefix, suffix_map_1,

line_syls, target_syls)

➑ word = random.choice(word_choices)

num_syls = count_syllables(word)

logging.debug("word & syllables = %s %s", word, num_syls)

➒ line_syls += num_syls

current_line.append(word)

➓ if line_syls == target_syls:

end_prev_line.extend(current_line[-2:])

return current_line, end_prev_line

*列表 9-5：定义了写入俳句行并启动第一行的函数*

定义一个函数，接受两个马尔科夫模型、训练语料库、前一行结尾的最后一对单词以及当前行目标音节数 ➊ 作为参数。立即使用一个变量指定正在模拟的是哪一行俳句 ➋。大部分处理将会集中在第二行和第三行（以及可能的第一行最后部分），在这些地方你将处理已有的单词对前缀，因此可以将这些行作为基本情况。之后，开始计数当前行音节的总数，并启动一个空列表来存储当前行的单词。

使用 `if` 语句，该语句在条件成立时为 `True`，即 `end_prev_line` 参数的长度——前一行最后两个单词的音节数——为 0，意味着没有前一行，你现在正在处理第一行 ➌。该 `if` 块中的第一个语句将 `line` 变量更改为 1 ➍。

选择初始种子单词并通过调用 `random_word()` 函数 ➎ 获取其音节数。通过将 `word` 和 `num_syls` 变量一起赋值，你实际上是在“解包” `random_word()` 函数返回的 `(word, num_sylls)` 元组。函数通过 `return` 语句结束，所以返回元组是一种非常好的返回多个变量的方法。在这个程序的更高级版本中，你可以使用带有 `yield` 关键字的生成器函数，因为 `yield` 会在不放弃执行控制的情况下返回一个值。

接下来，将单词附加到 `current_line` 中，并将 `num_syls` 加到累计总数中。现在你有了一个种子，使用 `word_after_single()` 函数 ➏ 收集所有种子可能的后缀。

如果没有可接受的单词，启动一个 while 循环来处理这种情况。该循环会继续，直到返回一个非空的可接受单词列表 ➐。程序将使用 `random` 模块的 `choice` 方法选择一个新的前缀——一个“幽灵前缀”。（记住，这个前缀不会成为俳句的一部分，它仅用于重新访问马尔科夫模型。）在 while 循环内部，一条日志消息会告诉你选择了哪个幽灵前缀。然后程序将再次调用 `word_after_single()` 函数。

一旦可接受单词列表构建完成，再次使用 `choice` 从 `word_choices` 列表中选择一个单词 ➑。因为列表可能包含重复的单词，这里就体现了马尔科夫模型的统计影响。接下来，计算该单词的音节数并记录结果。

将音节计数添加到当前行的累计总数中，并将单词附加到 `current_line` 列表中 ➒。

如果前两个单词的音节数等于 5 ➓，定义一个变量 `end_prev_line`，并将其赋值为前一行的最后两个单词；这个变量将作为第二行的前缀。最后，返回整行和 `end_prev_line` 变量。

如果第一行的音节目标数尚未达到，程序将跳转到下一个部分的 while 循环以完成这一行。

##### **构建其余的行**

在列表 9-6 中，haiku_line()函数的最后部分处理了一个情况，即俳句已经包含了程序可以在马尔可夫二阶模型中使用的词对前缀。程序用它来完成第一行——假设前两个词的音节数不已经达到五个——并构建第二行和第三行。用户还可以在完整的俳句生成后重新生成第二行或第三行。

*markov_haiku.py，*第六部分

➊ else: # 构建第二行和第三行

➋ current_line.extend(end_prev_line)

➌ while True:

logging.debug("line = %s\n", line)

➍ prefix = current_line[-2] + ' ' + current_line[-1]

➎ word_choices = word_after_double(prefix, suffix_map_2,

line_syls, target_syls)

➏ while len(word_choices) == 0:

index = random.randint(0, len(corpus) - 2)

prefix = corpus[index] + ' ' + corpus[index + 1]

logging.debug("new random prefix = %s", prefix)

word_choices = word_after_double(prefix, suffix_map_2,

line_syls, target_syls)

word = random.choice(word_choices)

num_syls = count_syllables(word)

logging.debug("word & syllables = %s %s", word, num_syls)

➐ if line_syls + num_syls > target_syls:

continue

elif line_syls + num_syls < target_syls:

current_line.append(word)

line_syls += num_syls

elif line_syls + num_syls == target_syls:

current_line.append(word)

break

➑ end_prev_line = []

end_prev_line.extend(current_line[-2:])

➒ if line == '1':

final_line = current_line[:]

else:

final_line = current_line[2:]

return final_line, end_prev_line

*列表 9-6：使用马尔可夫二阶模型来完成编写俳句行的函数*

如果有后缀➊，从 else 语句开始执行。由于 haiku_line()函数的最后部分必须处理第一行以及第二和第三行，所以使用一个技巧，将在步骤➑外部构建的 end_prev_line 列表添加到 current_line 列表中 ➋。稍后，当将最终行添加到俳句中时，你会丢弃这个前导的词对。

启动一个 while 循环，直到达到目标行音节数为止 ➌。每次迭代的开始会显示一个调试信息，告知你当前循环正在评估的路径：'1'或'2/3'。

在当前行开头添加上一行的最后两个词后，当前行的最后两个词将始终是前缀➍。

使用马尔可夫二阶模型，创建一个可接受的词汇列表➎。如果该列表为空，程序使用幽灵前缀过程➏。

使用音节数➐评估接下来该做什么。如果音节数过多，使用 continue 语句重新开始 while 循环。如果音节数不够，附加该词并将其音节数加到当前行的音节数中。否则，附加该词并结束循环。

将行中的最后两个单词赋值给 end_prev_line 变量，以便程序可以将其用作下一行的前缀 ➑。如果当前路径是第 1 行，将当前行复制到名为 final_line 的变量中；如果路径是第 2/3 行，使用索引切片来排除前两个单词，然后再赋值给 final_line ➒。这就是如何从第二行或第三行中删除初始的 end_prev_line 单词对。

#### ***编写用户界面***

清单 9-7 定义了*markov_haiku.py*程序的 main()函数，该函数运行设置函数和用户界面。界面向用户展示一个选择菜单，并显示生成的俳句。

*markov_haiku.py,* 第七部分

def main():

"""给用户选择构建俳句或修改现有俳句的选项。"""

intro = """\n

一千只猴子在一千台打字机前...

或者一台计算机...有时也能生成俳句。\n"""

print("{}".format(intro))

➊ raw_haiku = load_training_file("train.txt")

corpus = prep_training(raw_haiku)

suffix_map_1 = map_word_to_word(corpus)

suffix_map_2 = map_2_words_to_word(corpus)

final = []

choice = None

➋ while choice != "0":

➌ print(

"""

日本俳句生成器

0 - 退出

1 - 生成俳句

2 - 重新生成第 2 行

3 - 重新生成第 3 行

"""

)

➍ choice = input("选择: ")

print()

# 退出

➎ if choice == "0":

print("再见。")

sys.exit()

# 生成完整的俳句

➏ elif choice == "1":

final = []

end_prev_line = []

first_line, end_prev_line1 = haiku_line(suffix_map_1, suffix_map_2,

corpus, end_prev_line, 5)

final.append(first_line)

line, end_prev_line2 = haiku_line(suffix_map_1, suffix_map_2,

corpus, end_prev_line1, 7)

final.append(line)

line, end_prev_line3 = haiku_line(suffix_map_1, suffix_map_2,

corpus, end_prev_line2, 5)

final.append(line)

# 重新生成第 2 行

➐ elif choice == "2":

if not final:

print("请先生成完整的俳句（选项 1）。")

continue

else:

line, end_prev_line2 = haiku_line(suffix_map_1, suffix_map_2,

corpus, end_prev_line1, 7)

final[1] = line

# 重新生成第 3 行

➑ elif choice == "3":

if not final:

print("请先生成完整的俳句（选项 1）。")

continue

else:

line, end_prev_line3 = haiku_line(suffix_map_1, suffix_map_2,

corpus, end_prev_line2, 5)

final[2] = line

# 一些未知的选择

➒ else:

print("\n 抱歉，但这是无效的选择。", file=sys.stderr)

continue

➓ # 显示结果

print()

print("第一行 = ", end="")

print(' '.join(final[0]), file=sys.stderr)

print("第二行 = ", end="")

print(" ".join(final[1]), file=sys.stderr)

print("第三行 = ", end="")

print(" ".join(final[2]), file=sys.stderr)

print()

input("\n\n 按回车键退出。")

if __name__ == '__main__':

main()

*清单 9-7：启动程序并呈现用户界面*

在介绍信息之后，加载并准备训练语料库，构建两个马尔可夫模型。然后创建一个空列表来存放最终的俳句 ➊。接下来，命名一个`choice`变量并将其设置为`None`。启动一个`while`循环，直到用户选择 0 ➋。输入 0，用户决定退出程序。

使用`print()`语句和三引号来显示菜单 ➌，然后获取用户的选择 ➍。如果用户选择 0，退出并说再见 ➎。如果用户选择 1，他们希望程序生成一首新的俳句，因此重新初始化最终列表和`end_prev_line`变量 ➏。然后为所有三行调用`haiku_line()`函数，并传递正确的参数——包括每行的目标音节数。请注意，`end_prev_line`变量名在每行中都会变化；例如，`end_prev_line2`保存第二行的最后两个词。最后一个变量`end_prev_line3`仅是一个占位符，方便你重复使用该函数；换句话说，它永远不会被使用。每次调用`haiku_line()`函数时，它会返回一个需要附加到最终列表的行。

如果用户选择 2，程序重新生成第二行 ➐。在程序重建一行之前，必须先有完整的俳句，因此使用`if`语句来处理用户提前操作的情况。然后调用`haiku_line()`函数，确保传递`end_prev_line1`变量以将其与前一行连接，并将音节目标设置为七个音节。将重建的行插入最终列表的索引 1 处。

如果用户选择 3，重复这个过程，只需将音节目标设置为 5，并将`end_prev_line2`传递给`haiku_line()`函数 ➑。将该行插入`final`的索引 2 处。

如果用户输入菜单上没有的内容，通知他们并继续循环 ➒。最后显示俳句。使用`join()`方法和`file=sys.stderr`进行一个吸引人的打印输出。

以标准代码结束程序，用于作为模块或独立模式运行程序。

### **结果**

要评估一个写诗程序，你需要一种方法来衡量某些主观的东西——诗歌是否“好”——并使用客观标准。对于*markov_haiku.py*程序，我提出以下基于原创性和人类化这两个标准的类别：

**重复** 训练语料库中某首俳句的逐字复制。

**好** 一首俳句——至少对一些人来说——与人类诗人写的俳句难以区分。它应该代表初步的结果或经过几次重新生成第二行或第三行后的结果。

**种子** 一首有价值的俳句，但许多人会怀疑它是由计算机写的，或者你可以通过更改或重新排列不超过两个词，将其转化为一首好的俳句（稍后会更详细描述）。它可能需要对第二行或第三行进行多次重新生成。

**垃圾** 一首显然是随机拼凑的词语组合，没有作为诗歌的价值。

如果你使用程序生成大量的俳句并将结果分类，你可能最终会得到图 9-3 中的分布。大约 5%的时候，你会复制训练语料库中已有的俳句；10%的时候，你会生成一首优秀的俳句；大约 25%的俳句是可以接受或可以修正的；其余的则是垃圾。

![image](img/f0181-01.jpg)

*图 9-3：使用* markov_haiku.py 生成 500 个俳句的主观结果

考虑到马尔可夫过程的简单性，图 9-3 中的结果令人印象深刻。再次引用查尔斯·哈特曼的话：“这是语言从无到有，从单纯的统计噪声中创造出来的……我们可以看到意义的演变，感觉就像是自己在走向奇迹般的双腿。”

#### ***优秀俳句***

以下是一些被分类为“优秀”的模拟俳句示例。在第一个例子中，程序巧妙地——如果你不知道是算法的功劳的话，你可能会说“熟练地”——改变了我在第八章中的俳句，生成了一个具有相同意义的新俳句。

我放任的云层

我自己假装是远方的

远处的山脉

在下一个例子中，程序成功地复制了传统俳句中的常见主题：图像或思想的并列。

镜子，我凝视着

进入显示我父亲的面容

一池静水

在这种情况下，你会发现镜子其实是一个平静池塘的表面，虽然你可能会把面容本身解读为池塘。

运行程序有点像淘金：有时候你会找到一块金块。左边的俳句是 Ringai 在 300 多年前写的。在右边的俳句中，程序做了微妙的改动，使得这首诗现在唤起了晚春霜冻的画面——季节进程中的一次挫折。

| 在这黑暗的水面从我冰冷的井中提起春天的闪光                    —*Ringai* | 从我的冰井中提起的水春天的闪光静止不动                         —*Python* |
| --- | --- |

以下是几个更多的“优秀”俳句示例。第一个特别值得注意，因为它是由训练语料库中的三首独立的俳句组成的，但在整个过程中仍然保持了清晰的上下文线索。

当我走在这条路上

十一位勇敢的骑士飞奔

通过暴风雨中的树林

一行翻转的

穿越漆黑的深红色天空

在这个冬季的池塘上

这样的东西是活着的

生锈的门吱吱作响打开

甚至物体也会感到疼痛

石桥！坐着

安静地什么也不做

然而春天来了，草在生长

黑暗的天空，哦！秋天

雪花！一颗腐烂的南瓜

崩塌并被覆盖

荒凉的荒原开始破碎

黑色的云层破裂，四散

在松树之间，坟墓

#### ***种子俳句***

计算机帮助人类写诗的概念已经存在一段时间了。诗人们常常通过模仿早期的诗歌来“启发创作”，而没有理由认为计算机不能作为网络合作伙伴提供初稿。即便是较差的计算机创作也有潜力“种下”创作的种子，帮助人类克服创作障碍。

以下是*markov_haiku.py*程序生成的三个种子俳句示例。左侧是计算机生成的略显不准确的俳句，右侧是我调整后的版本。我只在每个版本中改变了一个单词，用粗体标出。

| 我的生命必将像另一朵花一样凋谢，什么饥饿的风**它**是 | 我的生命必将像另一朵花一样凋谢，什么饥饿的风是**死亡** |
| --- | --- |
|  |  |
| 静静漂浮在炎热的夜晚，黎明前的**古老**码头 | 静静漂浮在炎热的夜晚，黎明前的**雨**码头 |
|  |  |
| 坟墓上升起的月亮，和我那陈旧的悲伤，一把锋利的铁铲刺入**星星** | 坟墓上升起的月亮，和我那陈旧的悲伤，一把锋利的铁铲刺入**星辰** |

最后的诗句具有隐晦的意义，但似乎行得通，因为它充满了自然的联想（如月亮与星星、坟墓与铁铲、坟墓与悲伤）。无论如何，你不必过于纠结于意义。借用 T.S.艾略特的话：意义就像小偷扔给狗的肉，用来分散注意力，让诗歌完成它的工作！

### **总结**

花了两章的时间，但你现在拥有一个程序，可以模拟由大师们创作的日本俳句——至少可以为人类诗人提供一个有用的起点。此外，你还应用了日志模块，监控程序在关键步骤时的操作。

### **进一步阅读**

*虚拟缪斯：计算机诗歌实验*（Wesleyan 大学出版社，1996 年）由查尔斯·O·哈特曼撰写，是关于人类与计算机早期合作写诗的引人入胜的书籍。

如果你想了解更多关于克劳德·香农的信息，可以查看吉米·索尼和罗德·古德曼的《游戏中的思想：克劳德·香农如何发明信息时代》（Simon & Schuster，2017）。

你可以在线找到*Japanese Haiku: Two Hundred Twenty Examples of Seventeen-Syllable Poems*（The Peter Pauper Press，1955 年）数字版，译者为彼得·贝伦森，网址在 Global Grey 上（* [`www.globalgreyebooks.com/`](https://www.globalgreyebooks.com/) *）。

在论文《Gaiku：通过词汇联想规范生成俳句》（计算语言学协会，2009 年）中，Yael Netzer 及其合著者探讨了使用词汇联想规范（WANs）来生成俳句的方法。你可以通过向人们提交触发词并记录他们的即时反应（例如，*house* 对 *fly*、*arrest*、*keeper*等）来构建 WAN 语料库。这种方法产生了人类生成的俳句所特有的紧密联系和直观关系。你可以在网上找到这篇论文，链接为 *[`www.cs.brandeis.edu/~marc/misc/proceedings/naacl-hlt-2009/CALC-09/pdf/CALC-0905.pdf`](http://www.cs.brandeis.edu/~marc/misc/proceedings/naacl-hlt-2009/CALC-09/pdf/CALC-0905.pdf)*。

*使用 Python 自动化枯燥的工作*（No Starch Press，2015 年）由 Al Sweigart 编写，书中有一章关于调试技巧的有用概述，包括日志记录。

### **挑战项目**

我在这一节中描述了一些衍生项目的建议。和所有挑战项目一样，你要自己解决——没有提供解决方案。

#### ***新词生成器***

在他 1961 年获奖的科幻小说《异乡异客》中，作者 Robert A. Heinlein 创造了词汇*grok*，表示深刻的直观理解。这个词进入了大众文化——尤其是计算机编程文化——并且现在已经被收录进*牛津英语词典*。

想出一个听起来合法的新词并不容易，部分原因是人类对我们已知的词汇有很强的依赖。但计算机不会受到这种限制。在*虚拟缪斯*中，Charles Hartman 观察到，他的诗歌写作程序有时会创造出引人入胜的字母组合，比如*runkin*或*avatheformitor*，这些词可以轻松地代表新词。

编写一个程序，使用马尔科夫顺序 2、3 和 4 模型重新组合字母，并用该程序生成有趣的新词。给它们定义并开始使用它们。谁知道呢——你可能会创造出下一个*frickin*、*frabjous*、*chortle*或*trill*！

#### ***图灵测试***

根据 Alan Turing 的说法，“如果一台计算机能够欺骗一个人，让他相信它是人类，那么它就应该被称为智能的。”用你的朋友们来测试通过*markov_haiku.py*程序生成的俳句。将计算机生成的俳句与几首由大师或你自己写的俳句混合在一起。由于计算机生成的俳句通常是跨行的，因此要小心选择同样跨行的人类俳句，以免让你的聪明朋友轻松过关。所有俳句使用小写字母和最少的标点符号也有助于此。我提供了一个例子，通过 Facebook，见图 9-4。

![image](img/f0185-01.jpg)

*图 9-4：示例图灵测试实验发布在 Facebook 上*

#### ***不可思议！这简直是不可思议！不可思议！***

特朗普总统以使用“最好的词汇”讲简短、简单的句子而闻名，而简短、简单的句子非常适合俳句。事实上，*华盛顿邮报*曾刊登过在他的一些竞选演讲中无意间出现的俳句。以下是其中的一些：

他是个非常棒的人。

我前几天见过他。

在电视上。

他们想出去。

他们想过上好日子。

他们想努力工作。

我们必须做到。

我们需要合适的人。

所以福特将会回归。

使用唐纳德·特朗普演讲的在线文字记录，为*markov_haiku.py*程序构建一个新的训练语料库。记得你需要重新访问第八章，为*卡内基梅隆大学发音字典*中没有的单词建立一个新的“缺失单词”字典。然后重新运行程序，生成能够捕捉这一历史时刻的俳句。保存最好的作品，并重新回到图灵测试挑战，看看你的朋友是否能将你的俳句与特朗普的真实语录区分开来。

#### ***写俳句，还是不写俳句***

威廉·莎士比亚写下了许多适合俳句音节结构的名句，如“所有的昨日”，“心灵的匕首”和“离别是如此甜美的痛苦”。可以将一部或多部莎士比亚的戏剧作为*markov_haiku.py*程序的训练语料库。这里最大的挑战是为这些古英语单词计算音节。

#### ***马尔可夫音乐***

如果你对音乐有兴趣，可以在线搜索“用马尔可夫链作曲”。你应该能找到大量关于使用马尔可夫链分析来作曲的资料，利用现有歌曲的音符作为训练语料库。生成的“马尔可夫音乐”就像我们的种子俳句——为人类词曲创作者提供灵感。
