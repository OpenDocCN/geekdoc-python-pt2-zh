## **5

编码 英国内战密码**

![image](img/common01.jpg)

1587 年，苏格兰女王玛丽因一张纸丧命。55 年后，另一位被斩首的君主查理一世的支持者约翰·特雷瓦农爵士，因一张纸得以保住性命。这其中的关键是什么？隐写术。

*隐写术*是经过时间考验的技术，能够巧妙地隐藏信息，甚至让人完全没有怀疑其存在的可能。这个名字源自希腊词汇，意思是“隐藏的文字”，一个非常字面上的希腊例子是用蜡覆盖的木板来写字，写完后刮去蜡，再在木板上写字，然后用新的一层光滑蜡覆盖。这种技术的现代例子就是通过微妙地改变图像的色彩成分来嵌入信息。即便是一个简单的 8 位 JPEG 图像，也包含了人眼无法察觉的颜色，因此未经数字处理或滤波，信息基本上是不可见的。

在本章中，你将学习*空密码*，这其实并不是一种真正的密码，而是一种将明文隐藏在其他非密码材料中的隐写术技巧。*Null*意味着“没有”，所以空密码的意思是你选择不对信息进行加密。下面是一个使用每个单词首字母的空密码示例：

**N**ice **u**ncles **l**ive **l**onger. **C**ruel, **i**nsensitive **p**eople **h**ave **e**ternal **r**egrets.

首先，你将编写代码，找出那个救了约翰爵士的隐藏信息，然后你将完成一个更为困难的任务——编写一个空密码。最后，你将有机会编写一个程序，如果玛丽使用了它的输出，或许她的头就能得以保全。

### **项目 #10：特雷瓦农密码**

玛丽女王依赖隐写术和加密技术来保护她的信件。这个策略本身是合理的，但她的应用存在缺陷。她不知情地依赖了一名双重间谍吉尔伯特·吉福德来走私她的信件。吉福德首先将信件交给了伊丽莎白女王的间谍首脑，他破解了密码并用一份伪造的信息取而代之，诱使玛丽自我陷害。后来的事情，正如他们所说，已经成为了历史。

对于约翰·特雷瓦农来说，结果则更加美好。约翰爵士是一位杰出的骑士，他曾在英国内战中支持查理一世对抗奥利弗·克伦威尔，并被俘并囚禁在科尔切斯特城堡。执行死刑的前一天，他收到了一个朋友的信。这封信并不是走私进来的，而是直接交到守卫手中，守卫检查过后并未发现任何异常。在阅读完信件后，约翰爵士请求独自一人到教堂祈祷。当守卫回来寻找他时，他已经消失了。

这是约翰爵士收到的消息：

尊敬的约翰爵士：希望，这是遭遇困境者的最佳安慰，恐怕不能**帮助**您。我要告诉您的是，仅此一件事：如果我有机会回报我欠您的，不要因为请求我而犹豫。“这并不是我能做的很多，但我能做的，您可以放心，我一定会做。我知道，如果死亡降临，普通人都会害怕，但它并不会让您害怕，因为您视此为一种崇高的荣誉，作为您忠诚的回报。祈祷您能避免这杯苦酒。我不担心您会抱怨任何痛苦；只有在您通过忍耐能化解它们时，那才是明智之举。告诉我，如果您能，是否有我能为您做的任何事情。将军星期三回去。恭敬的，您的仆人，R.T.

如您所猜测的，这封看似无害的信件实际上包含了一个隐藏的信息，已在下面以**粗体**显示：

尊敬的约翰爵士：**希望**，这是遭遇困境者的最佳安慰，**不能**做太多，我恐怕**不能**帮助您。我要告诉您的是，仅此一件事：如果我有机会回报我欠您的，我不会因为要求您而犹豫。“这并不是我能做的很多，但我能做的，您可以放心，我一定会做。我知道，如果死亡降临，普通人都会害怕，但它并不会让您害怕，因为您视此为一种崇高的荣誉，作为您忠诚的回报。祈祷您能避免这杯苦酒。我不担心您会抱怨任何痛苦；只有在您通过忍耐能化解它们时，那才是明智之举。告诉我，如果您能，是否有我能为您做的任何事情。将军星期三回去。恭敬的，您的仆人，R.T.

这种空白密码在标点符号后使用每三个字母来通知约翰爵士，“教堂东端的面板滑动。”有传闻称，后来在城堡的墙壁凹处发现了一个狭窄的楼梯遗址。这个通道在发现时被堵住，但它可能是约翰爵士在 1642 年左右的逃脱路线。

这种临时的逃脱在传统的密码系统下是无法实现的。只有通过巧妙地使用隐写术将信息隐藏，作者才能如此迅速地将其交到约翰爵士手中。而空白密码的优点在于，即使约翰爵士不知道密码的模式，但怀疑其中有信息，他也能相当快速地找到它。

如果约翰爵士的朋友更加小心，隐藏的是加密的密文而不是明文，那么约翰爵士可能在剩余的短短时间内无法破译该消息——除非他事先得知密码类型和密钥。

**目标**

编写代码，找出空白密码中标点符号后隐藏的字母，并让用户选择每个标点符号后查找的字母数量，以找到解决方案。

#### ***策略与伪代码***

空白密码依赖于发送者和接收者都知道的重复模式。例如，每第三个单词可能是实际信息的一部分，或者更好的是，每第三个单词的最后一个字母。在特雷瓦尼恩密码中，它是标点符号后的第三个字母。

要找到特雷瓦尼恩密码，假设标点符号是开始计数的信号，然后编写代码，定位标点符号后的每*n*个字母，并将这些字母保存到字符串或列表中。一旦你弄清楚如何做到这一点，你可以轻松编辑代码，以便它适应任何起始点，比如每个大写字母单词、每个单词的第二个字母或每第三个单词的第一个字母。

唯一的争议点涉及标点符号。例如，空白密码的写作者*想要*标点符号包含在明文中吗？如果第二个标点符号出现在期望的计数范围内，应该如何处理？如果两个标点符号连续出现，会发生什么？

如果你仔细观察特雷瓦尼恩密码，你会发现由于重复使用单词*’tis*，导致了双重标点符号。在消息的结尾，还有一堆标点符号，其中写作者提供了他的名字首字母。为了解决这个问题，约翰爵士和他的朋友可能在约翰爵士被囚禁之前就制定了一些规则，或者约翰爵士只是通过反复试探来找出这些规则。

根据消息的结尾，标点符号不包括在字母计数中。如果约翰爵士的朋友本意是将它们包括在内，那么隐藏的消息会以一个大写的*T*结束，因为*T*在标点符号后的第三个*字符*，而不是第三个*字母*。这意味着，如果读者在计数限制内遇到标点符号，他们必须重新开始计数。

所以这些是规则：

+   每当遇到标点符号时，启动一个字母计数。

+   如果遇到标点符号，则重置计数。

+   标点符号不能是明文信息的一部分。

由于你可能不知道字母的计数应该是多少，所以编写代码以检查用户提供的上限值范围内的所有计数。伪代码相当简单明了：

加载文本文件并去除空白字符

获取用户输入，确定要查看的标点符号后要前瞻多少个字母

循环遍历从 1 到此前瞻值的字母数量

启动一个空字符串来保存翻译

开始一个计数器

启动一个 ➊第一个找到标记，并设置为 False

循环遍历文本中的字符

如果字符是标点符号

计数器 = 0

第一个找到 = True

否则，如果 ➋第一个找到为 True

计数器 + 1

如果计数器 = 前瞻值

将字符添加到翻译字符串

显示此前瞻值的翻译

注意，第一个找到的变量 ➊ 会保持为 False，直到遇到标点符号，然后它会被设置为 True ➋。这可以防止程序在找到第一个标点符号之前进行计数。

现在你准备好编写代码了！

#### ***特雷瓦尼翁密码代码***

本节中的代码将找到特雷瓦尼翁类型的空密码，它在每个标点符号后的特定数量的字母中编码。你还需要包含特雷瓦尼翁密码的文本文件。你可以从 *[`www.nostarch.com/impracticalpython/`](https://www.nostarch.com/impracticalpython/)* 下载脚本和文本文件，分别命名为 *null_cipher_finder.py* 和 *trevanion.txt*。请将这些文件保存在同一个文件夹中。

##### **加载文本**

列表 5-1 导入了一些有用的模块，并加载了包含空密码的文本文件。

*null_cipher_finder.py,* 第一部分

➊ import sys

import string

➋ def load_text(file):

"""将文本文件加载为字符串。"""

➌ 使用 open(file) 打开文件：

➍ return f.read().strip()

*列表 5-1：导入模块并加载空密码文本*

首先，导入现在熟悉的 sys 模块，以便在用户输入过程中处理可能出现的异常 ➊。还需要导入 string 模块，以便访问有用的常量集合，如字母和标点符号。

接下来，定义一个函数来加载包含空密码的文本文件 ➋。这个函数类似于你在第二章中用来加载字典文件的那个函数。稍后，它将由 `main()` 函数调用来实际加载文件。

开始 `load_text()` 函数，使用 with 打开文件 ➌。通过使用 with，你可以确保文件在加载后会自动关闭。使用 `read()` 加载内容，并使用 `strip()` 去除前后的空白字符。请注意，你可以在同一行中使用 return 语句 ➍。

##### **查找隐藏的消息**

列表 5-2 定义了一个函数，用于查找隐藏的消息。该函数接受两个参数。第一个是消息，即去除空白字符的原始文本文件作为字符串，第二个是标点符号后的字母检查数量。这个检查值是作为 `main()` 函数的一部分从用户那里获取的。

*null_cipher_finder.py,* 第二部分

def solve_null_cipher(message, lookahead):

"""根据标点符号后的字母数量解决空密码问题。

message = 空密码文本作为去除空白的字符串

lookahead = 检查标点符号后字母范围的终点

"""

➊ for i in range(1, lookahead + 1):

➋ plaintext = ''

count = 0

found_first = False

➌ for char in message:

➍ if char in string.punctuation:

count = 0

found_first = True

➎ elif found_first is True:

count += 1

➏ if count == i:

plaintext += char

➐ print("使用标点符号后的偏移量 {} = {}"。

format(i, plaintext))

print()

*列表 5-2：搜索隐藏字母*

将 lookahead 值视为 for 循环中的一个范围的终点，这样你就可以检查消息中所有介于两者之间的字母，以确定是否存在隐藏的消息。将范围设置为 (1, lookahead + 1) ➊；这样，你就从标点符号后的第一个字母开始，并在评估时包含用户的选择。

现在，给几个变量赋值 ➋。首先，初始化一个空字符串来保存翻译后的明文。然后将计数器设置为 0。最后，将 found_first 变量设置为 False。记住，程序使用这个变量推迟计数，直到遇到第一个标点符号为止。

接下来，开始遍历消息中的字符 ➌。如果遇到标点符号，将计数器重置为 0 并将 found_first 设置为 True ➍。如果已经找到了标点符号并且当前字符不是标点符号，则将计数器加 1 ➎。 如果找到了你要找的字母——即计数器达到了当前的 lookahead 值（i）——则将该字母添加到明文字符串 ➏。

当你检查完消息中所有字符并且当前的 lookahead 值已经处理完后，显示当前的密钥和翻译 ➐。

##### **定义 main() 函数**

列表 5-3 定义了 main() 函数。你可能还记得在第三章中，main() 函数就像是你程序的项目经理：它接收输入，跟踪进度，并告诉其他函数何时开始工作。

*null_cipher_finder.py,* 第三部分

def main():

"""加载文本，解决空白密码问题。"""

# 加载并处理消息：

➊ filename = input("\n 请输入要翻译的消息的完整文件名：")

➋ try:

loaded_message = load_text(filename)

except IOError as e:

print("{}. 正在终止程序.".format(e), file=sys.stderr)

sys.exit(1)

➌ print("\n 原始消息 =")

print("{}".format(loaded_message), "\n")

print("\n 待检查的标点符号列表 = {}".

format(string.punctuation), "\n")

# 移除空白字符：

➍ message = ''.join(loaded_message.split())

# 获取用户输入的可能的密码密钥范围：

➎ while True:

➏ lookahead = input("\n 检查 ' " \

"标点符号：")

➐ 如果 lookahead 是数字：

lookahead = int(lookahead)

break

else:

➑ print("请输入一个数字。", file=sys.stderr)

print()

# 运行函数解密密码

➒ solve_null_cipher(message, lookahead)

*列表 5-3：定义了* main() *函数*

首先，询问用户文件的名称（名称 + 扩展名） ➊，然后尝试调用 load_text() 函数 ➋。如果找不到文件，则打印红色错误信息（对于使用 IDLE 窗口的用户），并使用 sys.exit(1) 终止程序，其中 1 表示发生错误终止。

打印消息，并跟随字符串模块中的标点符号列表 ➌。只有这些字符会被程序识别为标点符号。

接下来，取出加载的消息并移除所有空格➍。你只需要计算字母和标点符号，所以空格会妨碍你。启动一个 while 循环，在用户输入无效值时持续请求输入➎。询问用户每个标点符号后的字母数量➏。这将被当作一个范围，起始为 1，结束为用户选择的数字加 1。如果输入值是数字➐，将其转换为整数，因为输入会返回字符串。然后，使用 break 退出循环。

如果用户输入了无效值，比如“Bob”，使用 print 语句请求输入一个数字，并且对于 shell 用户，使用 sys.stderr 将字体变为红色➑。然后，while 循环会重复请求输入。

将前瞻变量与消息一起传递给 solve_null_cipher 函数➒。现在剩下的就是调用 main()函数了。

##### **运行 main()函数**

回到全局空间，通过调用 main()来完成代码——但只有在程序以独立模式运行，而不是被导入到另一个程序时（清单 5-4）。

*null_cipher_finder.py,* 第四部分

如果 __name__ == '__main__':

main()

*清单 5-4：调用* main() *函数*

以下是使用 Trevanion 密码作为输入的完整程序的示例输出：

输入要翻译的完整文件名：trevanion.txt

原始消息 =

尊敬的约翰先生：希望，这是患难中的最好安慰。

我担心，我现在无法为你提供太多帮助。我要对你说的是，这只是：如果曾经

我也许能够回报我欠你的，不必再问我。‘’这不是

我能做的有限：但我能做的事，你可以很确信我会做。我知道，

如果死亡来临，如果普通人害怕它，它不会吓到你，原因是

为了一个崇高的荣誉，拥有你忠诚的回报。祈祷吧，

你可能会避免这杯苦酒。我不担心你会为此有所怨言

苦难；只有如果通过提交，你才能驱赶它们，这是

智者。告诉我，如果你能的话，做任何你想做的事。

将军将在星期三返回。休息，我的仆人，命令我行。

R.T.

要检查的标点符号列表 = !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~

要检查的标点符号后的字母数：4

使用标点符号后偏移量为 1 = HtcIhTiisTbbIiiiatPcIotTatTRRT

使用标点符号后偏移量为 2 = ohafehsftiuekfftcorufnienohe

使用标点符号后偏移量为 3 = panelateastendofchapelslides

使用标点符号后偏移量为 4 = etnapthvnnwyoerroayaitlfogt

在此输出中，程序已检查了标点符号后的第四个字母，但正如你所见，它使用标点符号后的三个字母找到了答案。

### **项目#11：编写一个空密码**

这是一个非常弱的空密码的未完成示例，基于每个单词的开头。花一点时间试着完成这个句子：

H__________ e__________ l__________ p__________ m__________ e__________。

你可能会觉得很难，因为无论是使用字母还是整个单词，制作一个不显得尴尬并引起怀疑的空白密码需要付出艰苦的努力和时间。问题的核心是上下文。如果密码被封装在通信中，这些通信必须是连贯的，以避免怀疑。这意味着它必须涉及一个相关的话题，并在合理的句数内始终围绕这个话题展开。正如你可能看到的，起草任何话题的一个句子都不是一件容易的事！

关键是可信地避免上下文，做这件事的一个好方法是使用列表。没有人会期望购物清单是严谨组织的或有意义的。列表也可以根据接收者量身定制。例如，通信者可能会讨论书籍或电影，并交换自己最喜欢的列表。囚犯可能开始学习外语，并从导师那里定期收到词汇列表。商人可能每月收到一个仓库的库存清单。通过使用列表，即使单词被打乱，正确的字母也能出现在正确的位置，同时仍保持上下文的完整性。

**目标**

编写代码，在单词列表中隐藏一个空白密码。

#### ***列表密码代码***

*list_cipher.py* 代码（见示例 5-5）将一个空白密码嵌入到一个字典单词列表中，借用词汇训练的伪装。你还需要在第二章和第三章中使用的 *load_dictionary.py* 程序。你可以从 *[`www.nostarch.com/impracticalpython/`](https://www.nostarch.com/impracticalpython/)* 下载这个文件，以及以下脚本。最后，你需要一个在第二章和第三章中使用的字典文件。你可以在表 2-1 中找到适合的在线字典，位于第 20 页。所有上述文件应该保存在同一个文件夹中。

*list_cipher.py*

➊ 从 random 导入 randint

导入 string

导入 load_dictionary

# 编写一条不包含标点符号或数字的简短信息！

input_message = "教堂东端的面板滑动"

message = ''

对于 input_message 中的每个字符：

➋ 如果 char 在 string.ascii_letters 中：

message += char

print(message, "\n")

➌ message = "".join(message.split())

➍ # 打开字典文件

word_list = load_dictionary.load('2of4brif.txt')

# 构建包含隐藏信息的词汇表

➎ vocab_list = []

➏ 对于 message 中的每个字母：

size = randint(6, 10)

➐ 对于 word_list 中的每个单词：

如果 len(word) == size 且 word[2].lower() == letter.lower()\

且 word 不在 vocab_list 中：

vocab_list.append(word)

break

➑ 如果 len(vocab_list) < len(message):

print("词汇表太小了。尝试使用更大的字典或更短的消息！")

否则：

print("单元 1 的词汇：\n", *vocab_list, sep="\n")

*示例 5-5：在列表中隐藏空白密码*

首先导入 random 模块的 randint()函数 ➊。这样可以进行（伪）随机整数选择。然后加载字符串模块，以便访问 ASCII 字母。最后导入你的 load_dictionary 模块。

接下来，写一个简短的秘密消息。请注意，相关评论禁止使用标点符号或数字。尝试使用这些内容与词典文件的内容结合会很有问题。因此，检查是否属于 string.ascii_letters 中的字母，以过滤出除了字母以外的所有内容 ➋：

'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

显示消息后，去除空格 ➌。加载你的词典文件 ➍ 并开始一个空列表，用于存储词汇单词 ➎。

使用 for 循环遍历消息中的每个字母 ➏。定义一个大小变量，并使用 randint()函数为其分配一个介于 6 到 10 之间的随机值。这个变量将确保单词的长度足够长，以便作为词汇单词具有可信度。如果需要，你可以将最大值设置得更高。

嵌套另一个 for 循环，使用它遍历字典中的单词 ➐，检查它们的长度是否与大小变量相符，并将单词的第三个字母（小写）与消息循环中的当前字母（小写）进行比较。你可以更改单词的索引值，但要确保它不超过最小的大小变量减去 1！最后的比较避免了相同的单词被使用两次。如果单词通过测试，将其添加到 vocab_list 中，并继续处理消息中的下一个字母。

一个典型的词典文件应包含足够的单词以加密一条短消息。但是，为了安全起见，使用条件语句检查 vocab_list 的长度是否不小于消息的长度 ➑。 如果它更短，那么你在消息结束之前就用完了单词，必须打印警告给用户。否则，打印单词列表。

#### ***列表密码输出***

下面是代码的输出（我已突出显示每第三个字母以便于阅读，尽管没有任何帮助，消息本身也很容易被发现）：

Panelateastendofchapelslides

第 1 单元的词汇：

字母表

放弃

年鉴

异常

着火的

被遗弃的

演出

协助

屈辱

攀岩

激活的

充分的

异常的

腹部

废除

影响

赞同

厌恶

鲍勃

和号

乙炔

指控

逃逸

副翼

酸化

放弃

精通者

缺席

使用具有一致字符宽度的字体并将单词堆叠在一起，确实会破坏密码的安全性。我们将在“保存玛丽”中讨论如何处理这个问题，第 102 页。

### **总结**

在本章中，你编写了一个程序，揭示了 Trevanion 类型的空白密码中的隐藏信息。然后，你编写了第二个程序，生成一个空白密码并将其隐藏在语言学习者的词汇表中。在接下来的实践项目中，你可以探索如何使这个列表密码更加安全。

### **进一步阅读**

更多关于玛丽·斯图尔特女王和约翰·特雷瓦尼翁爵士的细节可以在*《神秘的信息：密码和密码学的历史》*（企鹅出版集团，2009 年）由加里·布莱克伍德（Gary Blackwood）和*《密码书：从古埃及到量子密码学的秘密科学》*（Anchor，2000 年）由西蒙·辛格（Simon Singh）中找到。

### **实践项目**

现在你已经是空密码的专家了，看看你能否改变玛丽·斯图尔特女王的命运，然后偷偷查看约翰爵士最机密的通信。

#### ***拯救玛丽***

编程最棒的部分是思考问题和如何解决它们。让我们重新审视玛丽·斯图尔特女王的悲剧。以下是我们所知道的：

+   玛丽不允许书信往来，因此信件必须被走私进入。这意味着叛徒吉尔伯特·吉福德无法从这个方程中去除。吉福德是玛丽唯一认识的、有能力投递她信件的人。

+   玛丽和她的通讯者过于信任一种不安全的密码，因此说得太过随便。如果他们少些自信，可能会更加忍耐。

+   玛丽的狱卒们手中有明显的密码，他们认为它包含了有罪的材料，并一直工作，直到他们找到了它。

双重间谍吉福德并未了解玛丽使用的密码的细节。现在，假设玛丽使用了空密码。如果通信内容有些许叛国情节——虽然不至于构成叛国罪——信息可能被她的捕获者忽略。如果进行过初步检查，使用变换模式可能足以让密码分析师无法破解。

正如你所见，将空密码隐藏在列表中比隐藏在信件中更容易。支持玛丽的家族列表可以作为这种用途。这些家族可能是已知的支持者，或者在马基雅维利式的扭曲中，可能是朋友*和*敌人的混合！这个信息不会公开反叛，但会足够接近，以至于没有加密会让人认为根本没有使用任何加密形式。

对于这个实践项目，编写一个程序，将“Give your word and we rise”这句话嵌入姓氏列表中。为了隐藏消息中的字母，从第二个姓氏的第二个字母开始，移动到第三个姓氏的第三个字母，然后在剩下的单词中交替使用第二个和第三个字母。

除了未使用的第一个名字外，还在列表早期包含“斯图尔特”和“雅各布”作为空字词，帮助隐藏密码的存在。不要在这些空名字中嵌入密码的字母，并在选择下一个单词的密码字母位置时完全忽略它们；如果在空名字*之前*的单词中使用了第二个字母，则应在空名字*之后*的单词中使用第三个字母。空密码将占据以下加粗字母（空字词的位置由你决定，但不要让它们影响模式）：

第一 第二 第三 斯图尔特 第四 第五 雅各布 第六 第七 第八

程序可以以垂直或水平的方式打印列表。名字列表应该以简短的消息可信地介绍，但该消息不应成为密码的一部分。

名字列表可以从*[`www.nostarch.com/impracticalpython/`](https://www.nostarch.com/impracticalpython/)*下载，文件名为*supporters.txt*，并作为标准字典文件加载。你可以在附录和在线找到解决方案，文件名为*save_Mary_practice.py*。

#### ***科尔切斯特的捕捉***

不是某个酒醉的傻瓜，*你*被留下来负责囚犯约翰·特雷瓦尼翁的事务，当以下信件到达科尔切斯特城堡时：

约翰爵士：你们这群人奇怪且过于坚硬。然而，我们会团结起来，像你一样坚持到底。还有谁能爱他们的敌人，当所有人都失败时站稳脚跟，仇恨与绝望？只要我们还能够，让我们感受到希望。 -R.T.

它似乎表述笨拙，即使对于 17 世纪来说也是如此，你决定在将它交给囚犯之前仔细检查一下。

编写一个 Python 程序，接受一个输入*n*，并根据每个第*n*个单词的第*n*个字母检查并显示一个空密码。例如，输入 2 会在此消息中找到加粗字母：

所以，t**h**e cold t**e**a didn’t p**l**ease the o**l**d finicky w**o**man.

你可以从*[`nostarch.com/impracticalpython/`](https://nostarch.com/impracticalpython/)*下载消息的文本文件，文件名为*colchester_message.txt*。解决方案可以在附录和在线找到，文件名为*colchester_practice.py*。请将文本和 Python 文件放在同一文件夹中。
