## **7

用遗传算法培育超级大老鼠**

![image](../images/common01.jpg)

*遗传算法*是通用优化程序，旨在解决复杂问题。它们发明于1970年代，属于*进化算法*类，因为它们模拟了达尔文的自然选择过程。遗传算法特别适用于当问题的背景知识较少时，处理非线性问题时，或在大搜索空间中寻找暴力破解型解决方案时。最棒的是，它们是容易理解和实现的算法。

在本章中，你将使用遗传算法培育一群超级大老鼠，让它们横扫世界。之后，你将换个身份，帮助詹姆斯·邦德在几秒钟内破解一个高科技保险箱。这两个项目将让你更好地理解遗传算法的原理和强大功能。

### **找到所有可能解中的最佳解**

遗传算法通过**优化**，意味着它们从一组可选的替代方案中选择最佳解（根据某些标准）。例如，如果你想找出从纽约到洛杉矶的最快驾驶路线，遗传算法绝不会建议你飞行。它只能从你提供的允许条件中做出选择。作为优化器，这些算法比传统方法更快，并能避免过早收敛到一个次优解。换句话说，它们能高效地搜索解空间，同时又足够彻底，避免在有更好的答案时选出一个较好的答案。

与*穷举*搜索引擎不同，后者依靠纯粹的暴力破解，遗传算法并不会尝试所有可能的解决方案。相反，它们会不断地对解决方案进行评分，然后用这些评分来进行“有根据的猜测”。一个简单的例子是“温暖-寒冷”游戏，在这个游戏中，你寻找一个隐藏物品，有人会告诉你根据你的接近程度或搜索方向你是变得更温暖还是更寒冷。遗传算法使用适应度函数，类似于自然选择，用来丢弃“寒冷”的解，并在“温暖”的解上进行改进。基本过程如下：

1.  随机生成一个解决方案群体。

1.  测量每个解决方案的适应度。

1.  选择最佳（最温暖的）解决方案，丢弃其他的。

1.  在最佳解决方案中交叉（重组）元素，生成新解决方案。

1.  通过改变其值来突变解决方案中的少数元素。

1.  返回步骤2并重复。

选择–交叉–变异循环继续进行，直到达到*停止条件*，例如找到已知答案、找到一个“足够好的”答案（根据最低阈值）、完成一定次数的迭代或达到时间限制。因为这些步骤与进化过程非常相似，完全符合“适者生存”的原则，所以在遗传算法中使用的术语往往更具生物学性质，而非计算机科学性质。

### **项目 #13：培育超级大老鼠军团**

这是你成为疯狂科学家的机会，拥有一个充满沸腾烧瓶、冒泡试管和“BZZZTTT”声响的机器的秘密实验室。所以，戴上黑色橡胶手套，开始将灵活的垃圾食腐 scavenger 变成巨大的食人怪物吧。

**目标**

使用遗传算法模拟老鼠繁殖至平均体重110磅。

#### ***策略***

你的梦想是繁殖出一种体型和公牛獒犬差不多的老鼠（我们已经确认你疯了）。你将从*Rattus norvegicus*（褐色老鼠）开始，然后加入一些人造甜味剂、1950年代的辐射、足够的耐心和一点Python代码，但绝不做基因工程——你是老派的，宝贝！这些老鼠会从不到一磅长成令人恐惧的110磅，差不多是母公牛獒犬的体型（见[图 7-1](ch07.xhtml#ch07fig1)）。

![image](../images/f0127-01.jpg)

*图 7-1：褐色老鼠、母公牛獒犬和人类的体型比较*

在你开始这样一个巨大的项目之前，最好先在Python中模拟一下结果。而你做的不仅仅是一个计划——你已经绘制了比计划更好的东西——一些图形化的伪代码（见[图 7-2](ch07.xhtml#ch07fig2)）。

![image](../images/f0128-01.jpg)

*图 7-2：遗传算法在繁殖超级老鼠中的应用*

[图 7-2](ch07.xhtml#ch07fig2)所示的过程概述了遗传算法是如何工作的。你的目标是通过遗传算法从一个体重远低于110磅的初始老鼠种群中，繁殖出一个平均体重为110磅的老鼠种群。之后，每一代（或称*世代*）的老鼠都代表着解决问题的一个候选方案。就像任何动物繁殖者一样，你会淘汰那些不理想的雄性和雌性，并将它们人道地送到——对于你这些*奥斯汀·鲍尔斯*影迷来说——一个邪恶的宠物乐园。然后，你会让剩余的老鼠交配和繁殖，这一过程在遗传编程中被称为*交叉*。

剩余老鼠的后代将基本与它们的父母体型相同，因此你需要进行一些变异。虽然变异较为罕见，通常会导致中性或无益的特征（在这种情况下是低体重），但有时你会成功地繁殖出更大的老鼠。

这个过程会变成一个大重复循环，无论是有机的还是程序化的，这让我不禁想，是否我们真的是外星人模拟中的虚拟生命。无论如何，循环的终点——停止条件——是当老鼠达到所需的体型，或者你再也忍受不了与老鼠打交道时。

对于你的模拟输入，你需要一些统计数据。使用公制系统，因为你是个科学家，无论是否疯狂。你已经知道母公牛獒犬的平均体重是50,000克，而有用的老鼠统计数据可以在[表 7-1](ch07.xhtml#ch07tab1)中找到。

**表 7-1：褐色老鼠的体重与繁殖统计**

| **参数** | **已发布值** |
| --- | --- |
| 最低体重 | 200 克 |
| 平均体重（雌性） | 250 克 |
| 平均体重（雄性） | 300–350 克 |
| 最大体重 | 600 克* |
| 每窝小鼠数量 | 8-12 |
| 每年窝数 | 4-13 |
| 寿命（野生，圈养） | 1-3年，4-6年 |
| *在圈养条件下，特殊个体可能达到 1,000 克。 |

由于家鼠和野生棕色大鼠都存在，因此某些统计数据可能会有较大的差异。圈养大鼠通常得到比野生大鼠更好的照料，因此它们体重大、繁殖多、窝数也多。所以当有范围选择时，可以选择较高的值。对于这个项目，参考[表7-2](ch07.xhtml#ch07tab2)中的假设开始。

**表7-2：** 超级大鼠遗传算法的输入假设

| **变量和数值** | **注释** |
| --- | --- |
| GOAL = 50000 | 目标体重（雌性牛头犬，单位：克） |
| NUM_RATS = 20 | 实验室可支持的成鼠总数 |
| INITIAL_MIN_WT = 200 | 初始种群中成鼠的最小体重（单位：克） |
| INITIAL_MAX_WT = 600 | 初始种群中成鼠的最大体重（单位：克） |
| INITIAL_MODE_WT = 300 | 初始种群中最常见的成鼠体重（单位：克） |
| MUTATE_ODDS = 0.01 | 大鼠发生突变的概率 |
| MUTATE_MIN = 0.5 | 对大鼠体重的最小变异因子 |
| MUTATE_MAX = 1.2 | 对大鼠体重的最大变异因子 |
| LITTER_SIZE = 8 | 每对交配大鼠每窝的小鼠数量 |
| LITTERS_PER_YEAR = 10 | 每对交配大鼠每年的窝数 |
| GENERATION_LIMIT = 500 | 停止繁殖程序的代数上限 |

由于大鼠繁殖频繁，因此不需要考虑寿命。即使你保留上一代的一些父母，它们会随着后代体重的增加而很快被淘汰。

#### ***超级大鼠代码***

*super_rats.py* 代码遵循[图7-2](ch07.xhtml#ch07fig2)中的一般工作流程。你也可以从* [https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)* 下载代码。

##### **输入数据和假设**

[清单 7-1](ch07.xhtml#ch07list1)，在程序开始时的全局空间中，导入模块并将[表7-2](ch07.xhtml#ch07tab2)中的统计信息、标量和假设分配为常量。程序完成并正常工作后，可以尝试更改该表中的数值，并观察它们如何影响结果。

*super_rats.py,* 第1部分

➊ import time

import random

import statistics

➋ # 常量（单位：克）

➌ GOAL = 50000

NUM_RATS = 20

INITIAL_MIN_WT = 200

INITIAL_MAX_WT = 600

INITIAL_MODE_WT = 300

MUTATE_ODDS = 0.01

MUTATE_MIN = 0.5

MUTATE_MAX = 1.2

LITTER_SIZE = 8

LITTERS_PER_YEAR = 10

GENERATION_LIMIT = 500

# 确保繁殖对的数量为偶数：

➍ 如果 NUM_RATS % 2 != 0:

NUM_RATS += 1

*清单 7-1：导入模块并分配常量*

首先导入时间、随机和统计模块 ➊。你将使用时间模块记录你的遗传算法的运行时间。对遗传算法进行计时很有意思，哪怕只是为了惊叹它们能多快找到解决方案。

随机模块将满足算法的随机需求，你将使用统计模块来获取均值。这是统计学的一个简单用法，但我希望你了解这个模块，因为它非常实用。

接下来，分配[表7-2](ch07.xhtml#ch07tab2)中描述的输入变量，并确保注意单位是克 ➋。使用大写字母作为变量名，因为这些表示常量 ➌。

现在，我们假设使用繁殖的*配对*，所以检查用户输入的老鼠数量是否为偶数，如果不是，则添加一只老鼠 ➍。稍后，在“[挑战项目](ch07.xhtml#lev167)”中的[第144页](ch07.xhtml#page_144)，你将可以尝试不同性别分布的实验。

##### **初始化种群**

[列表7-2](ch07.xhtml#ch07list2)是程序的“购物代表”。它去宠物店挑选老鼠，作为初始繁殖种群。因为你需要配对交配，所以它应该选择偶数数量的老鼠。并且由于你不能负担一个空间无限大的火山巢穴，你需要在每一代之间维持恒定数量的成年老鼠——尽管数量可以暂时增加，以容纳一窝窝仔。记住，随着它们长大到像大狗一样大，老鼠需要越来越多的空间！

*super_rats.py,* 第2部分

➊ def populate(num_rats, min_wt, max_wt, mode_wt):

"""使用三角分布初始化体重的种群。"""

➋ return [int(random.triangular(min_wt, max_wt, mode_wt))\

for i in range(num_rats)]

*列表7-2：定义了创建初始老鼠种群的函数*

populate()函数需要知道你想要的成年老鼠数量、老鼠的最小体重和最大体重，以及最常见的体重 ➊。请注意，这些参数将使用在全局空间中找到的常量。你不需要将它们作为参数传递给函数以便访问。但我在这里和后面的函数中这样做了，以便于理解，并且局部变量的访问效率更高。

你将使用上述四个参数与随机模块，这些参数包括不同类型的分布。在这里你会使用三角分布，因为它能让你很好地控制最小值和最大值，并能在统计中模拟偏斜。

由于棕色老鼠既存在于野外，也存在于圈养环境中——如动物园、实验室以及作为宠物——它们的体重大多偏高。野生老鼠通常较小，因为它们的生活环境恶劣且寿命短，尽管实验室里的老鼠可能会对此提出异议！使用列表推导式来遍历老鼠数量，并为每只老鼠分配一个体重。将这一切通过返回语句打包在一起 ➋。

##### **衡量种群的适应度**

测量老鼠的适应度是一个两步过程。首先，通过将所有老鼠的平均体重与公牛獒犬的目标体重进行比较，对整个种群进行评分。然后，单独对每只老鼠进行评分。只有体重排在前*n*百分比的老鼠，按照NUM_RATS变量确定，才能再次繁殖。虽然种群的平均体重是一个有效的适应度测量，但它在这里的主要作用是确定是否该停止循环并宣布成功。

[列表 7-3](ch07.xhtml#ch07list3)定义了fitness()和select()函数，它们一起构成了遗传算法中的测量部分。

*super_rats.py,* 第3部分

➊ def fitness(population, goal):

"""根据属性均值与目标进行种群适应度测量。"""

ave = statistics.mean(population)

return ave / goal

➋ def select(population, to_retain):

"""筛选种群，仅保留指定数量的成员。"""

➌ sorted_population = sorted(population)

➍ to_retain_by_sex = to_retain//2

➎ members_per_sex = len(sorted_population)//2

➏ females = sorted_population[:members_per_sex]

males = sorted_population[members_per_sex:]

➐ selected_females = females[-to_retain_by_sex:]

selected_males = males[-to_retain_by_sex:]

➑ return selected_males, selected_females

*列表 7-3：定义了遗传算法的测量步骤*

定义一个函数来评估当前代的适应度➊。使用statistics模块获取种群的均值，并返回该值除以目标体重。当该值大于或等于1时，你就知道该停止繁殖了。

接下来，定义一个函数，该函数根据体重将老鼠种群筛选，直到达到NUM_RATS的数量，这里由to_retain参数➋表示。该函数还将接受一个种群参数，该参数代表每一代的父母。

现在，对种群进行排序，这样你就可以区分大个和小个的老鼠➌。然后，取你想保留的老鼠数量，并用整除法将其除以2，使结果为整数➍。这样做是为了保留最大的雄性和雌性老鼠。如果你只选择种群中最大的一些老鼠，理论上你只会选择雄性老鼠。你可以通过将sorted_population除以2，再次使用整除法来获得当前种群按性别划分的总成员数➎。

雄性老鼠通常比雌性老鼠大，因此做两个简化假设：首先，假设种群中恰好一半是雌性；其次，假设最大雌性老鼠的体重不超过最小雄性老鼠的体重。这意味着，排序后的种群列表的前一半代表雌性，后一半代表雄性。然后，通过将sorted_population分成两半，分别取下半部分作为雌性老鼠➏，上半部分作为雄性老鼠，创建两个新的列表。接下来要做的就是从这两个列表的末尾取出最大的老鼠➐——使用负切片——并返回它们➑。这两个列表包含下一代的父母。

第一次运行这个函数时，它做的只是按性别对老鼠进行排序，因为初始的老鼠数量已经等于NUM_RATS常量。之后，传入的种群参数将包括父母和子代，它的值将超过NUM_RATS。

##### **繁殖新一代**

[列出 7-4](ch07.xhtml#ch07list4)定义了程序的“交叉”步骤，这意味着它繁殖了下一代。一个关键假设是每个子代的体重将大于或等于母鼠的体重，并且小于或等于父鼠的体重。违反此规则的情况将在“突变”函数中处理。

*super_rats.py,* 第4部分

➊ def breed(males, females, litter_size):

"""在群体成员（体重）之间交叉基因。"""

➋ random.shuffle(males)

random.shuffle(females)

➌ children = []

➍ for male, female in zip(males, females):

➎ for child in range(litter_size):

➏ child = random.randint(female, male)

➐ children.append(child)

➑ return children

*列出 7-4：定义了一个繁殖新一代老鼠的函数*

breed()函数的参数是通过select()函数返回的雄鼠和雌鼠的体重列表，以及窝重的大小 ➊。接下来，随机打乱这两个列表 ➋，因为你已经在select()函数中对它们进行了排序，不打乱它们就直接迭代会导致最小的雄鼠和最小的雌鼠配对，依此类推。你需要考虑到爱情与浪漫；最大的雄鼠可能会被最娇小的雌鼠吸引！

创建一个空列表来保存它们的子代 ➌。现在进入难度较高的部分。使用zip()函数遍历打乱后的列表，将每对雄性和雌性配对 ➍。每对老鼠可以有多个子代，因此开始另一个循环，使用窝重作为范围 ➎。窝重是一个常量，名为LITTER_SIZE，是你在输入参数中提供的，因此如果该值为8，你将得到八只小鼠。

对每个子代，随机选择一个体重，介于母鼠和父鼠的体重之间 ➏。请注意，你不需要使用male + 1，因为randint()会使用所提供范围内的*所有*数字。还需要注意，两个值可以相同，但第一个值（母鼠的体重）永远不能大于第二个值（父鼠的体重）。这也是假设雌鼠体型不大于最小雄鼠的简化假设的另一个原因。结束循环时，将每个子代附加到子代列表中 ➐，然后返回子代 ➑。

##### **突变种群**

一小部分子代应经历突变，其中大多数突变会导致不利的特征。这意味着体重低于预期，包括“弱鼠”，这些鼠无法生存。但偶尔，某些有益的突变会导致较重的老鼠。

[Listing 7-5](ch07.xhtml#ch07list5) 定义了 mutate() 函数，该函数应用了你在常量列表中提供的突变假设。在调用 mutate() 之后，如果目标体重尚未达到，就需要检查新种群的适应度，并重新开始循环。

*super_rats.py,* 第5部分

➊ def mutate(children, mutate_odds, mutate_min, mutate_max):

"""使用输入的几率和变化范围随机改变老鼠体重。"""

➋ for index, rat in enumerate(children):

如果 mutate_odds 大于或等于随机生成的数字，那么该索引处的老鼠（体重）就会发生突变。从最小和最大突变值定义的均匀分布中选择一个突变值；这基本上是从最小值和最大值范围中随机选择一个值。由于这些值偏向最小值，结果更有可能是体重减少而非增加。将当前体重乘以这个突变标量，并将结果四舍五入为整数 ➌。最后返回突变后的子代列表。

➌ children[index] = round(rat * random.uniform(mutate_min,

mutate_max))

return children

*Listing 7-5：定义了突变部分种群的函数*

该函数需要子代列表、突变发生的几率，以及突变的最小和最大影响 ➊。这些影响是标量，你将应用于老鼠的体重。在程序开始时的常量列表中（以及[表7-2](ch07.xhtml#ch07tab2)），它们偏向于最小值，因为大多数突变不会带来有益的特征。

遍历子代列表，使用 enumerate() —— 一个方便的内置函数，充当自动计数器 —— 来获取索引 ➋。然后使用 random() 方法生成一个介于 0 和 1 之间的随机数，并与突变发生的几率进行比较。

如果 mutate_odds 变量大于或等于随机生成的数字，则该索引处的老鼠（体重）会发生突变。从最小和最大突变值定义的均匀分布中选择一个突变值；这基本上是从最小值和最大值范围中随机选择一个值。由于这些值偏向最小值，结果更可能是体重减少而非增加。将当前体重乘以这个突变标量，并四舍五入为整数 ➌。最后返回突变后的子代列表。

**注意**

*关于突变统计的有效性，你可以找到一些研究表明有益突变非常罕见，也有研究表明它们比我们想象的更常见。狗的繁育表明，实现体型的巨大变化（例如，吉娃娃与大丹犬）并不需要数百万年的进化。在20世纪的一项著名研究中，俄罗斯遗传学家德米特里·别利亚耶夫从130只银狐开始，通过40年的时间，通过简单地选择每代最温顺的狐狸，成功实现了显著的生理变化。*

##### **定义 main() 函数**

[Listing 7-6](ch07.xhtml#ch07list6) 定义了 main() 函数，该函数管理其他函数并确定何时满足停止条件。它还将显示所有重要结果。

*super_rats.py,* 第6部分

def main():

"""初始化种群，选择，繁殖和突变，显示结果。"""

➊ generations = 0

➋ parents = populate(NUM_RATS, INITIAL_MIN_WT, INITIAL_MAX_WT,

INITIAL_MODE_WT)

print("初始种群体重 = {}".format(parents))

popl_fitness = fitness(parents, GOAL)

print("initial population fitness = {}".format(popl_fitness))

print("number to retain = {}".format(NUM_RATS))

➌ ave_wt = []

➍ while popl_fitness < 1 and generations < GENERATION_LIMIT:

selected_males, selected_females = select(parents, NUM_RATS)

children = breed(selected_males, selected_females, LITTER_SIZE)

children = mutate(children, MUTATE_ODDS, MUTATE_MIN, MUTATE_MAX)

➎ parents = selected_males + selected_females + children

popl_fitness = fitness(parents, GOAL)

➏ print("Generation {} fitness = {:.4f}".format(generations,

popl_fitness))

➐ ave_wt.append(int(statistics.mean(parents)))

generations += 1

➑ print("average weight per generation = {}".format(ave_wt))

print("\nnumber of generations = {}".format(generations))

print("number of years = {}".format(int(generations / LITTERS_PER_YEAR)))

*清单7-6：定义了* main() *函数*

通过初始化一个空列表来启动函数，用于保存代数。你最终将使用这个列表来计算实现目标所需的年数 ➊。

接下来，调用`populate()`函数➋并立即打印结果。然后，获取初始种群的适应度，并将其与每代保留的老鼠数量一起打印，这个数量是`NUM_RATS`常量。

为了好玩，初始化一个列表来保存每代的平均体重，这样你可以在最后查看它 ➌。如果你将这些体重与年数进行绘图，你会看到它们呈指数增长趋势。

现在，开始大的遗传循环，进行选择-配对-突变。这以`while`循环的形式出现，停止条件是达到目标体重或在没有达到目标体重的情况下经过了大量代数 ➍。请注意，在突变孩子们之后，需要将它们与父母结合，形成新的父母列表 ➎。小鼠大约需要五周才能成熟并开始繁殖，但你可以通过将`LITTERS_PER_YEAR`常量从最大可能值调整下来（见[表7-1](ch07.xhtml#ch07tab1)），就像我们在这里做的一样，来考虑这一点。

在每次循环结束时，显示`fitness()`函数的结果，保留四位小数，以便你可以监控算法并确保它按预期进行 ➏。获取该代的平均体重，将其添加到`ave_wt`列表中 ➐，然后将代数计数加1。

完成main()函数，显示每代的平均体重列表、代数和年数——通过`LITTERS_PER_YEAR`变量计算得出 ➑。

##### 运行main()函数

使用熟悉的条件语句来运行程序，无论是独立运行还是作为模块运行。获取结束时间并打印程序运行所花费的时间。性能信息仅应在模块以独立模式运行时打印，因此务必将其放在`if`语句块内。参见[清单7-7](ch07.xhtml#ch07list7)。

*super_rats.py*，第7部分

if __name__ == '__main__':

start_time = time.time()

main()

end_time = time.time()

duration = end_time - start_time

print("\n此程序的运行时间为 {} 秒。".format(duration))

*清单 7-7：如果程序未被导入，则运行* main() *函数和* time *模块*

#### ***总结***

使用[表 7-2](ch07.xhtml#ch07tab2)中的参数，*super_rats.py* 程序大约需要两秒钟运行。平均来说，老鼠们大约需要 345 代，或者 34.5 年，才能达到 110 磅的目标体重。对一个疯狂的科学家来说，这样的时间实在太长了！不过，借助你的程序，你可以寻找减少目标达成时间的方法。

*敏感性研究*通过对*单个*变量进行多次更改并评估结果来工作。你应该小心，如果一些变量彼此依赖的话。由于结果是随机的（stochastic），你应该在每个参数更改时进行多次运行，以便捕捉可能的结果范围。

在你的繁殖计划中，你可以控制的两个因素是繁殖老鼠的数量（NUM_RATS）和突变发生的概率（MUTATE_ODDS）。突变概率受到饮食和辐射暴露等因素的影响。如果你逐一更改这些变量并重新运行 *super_rats.py*，你就可以评估每个变量对项目时间表的影响。

一个直接的观察是，如果你从每个变量的小值开始，并逐渐增加它们，你会看到初期有显著的效果（参见[图 7-3](ch07.xhtml#ch07fig3)）。之后，两个曲线会迅速下降并趋于平坦，典型的递减回报现象。每个曲线变平的点是优化节省资金和减少工作量的关键。

例如，保留超过 300 只老鼠几乎不会带来太大好处。你只是在喂养和照顾大量不必要的老鼠。同样，将突变概率提高到 0.3 以上也几乎没有收益。

像这样的图表让你轻松规划前进的道路。标记为“基线”的水平虚线表示使用[表 7-2](ch07.xhtml#ch07tab2)中输入的平均结果。你可以通过保留 50 只老鼠而不是 20 只，潜在地将时间缩短超过 10 年。你还应该专注于增加有益突变的数量。这样会更有回报，但也更具风险且更难控制。

![image](../images/f0137-01.jpg)

*图 7-3：两个参数对达到目标体重所需时间的影响*

如果你使用 50 只老鼠并将突变概率提高到 0.05 重新运行模拟，理论上你可以在 14 年内完成项目，相比初始基线提高了 246%。现在，*这才是*优化！

繁殖超级老鼠是理解遗传算法基本原理的一个有趣且简单的方法。但要真正理解它们的强大，你需要尝试一些更难的挑战。你需要一个无法通过蛮力解决的问题，接下来的项目正是这样的难题。

### **项目 #14：破解高科技保险箱**

你是 Q，詹姆斯·邦德有一个问题。他必须参加一个邪恶反派家族的优雅晚宴，偷偷溜进男子的私人办公室，破解他的墙壁保险箱。对于 007 来说，这只是小菜一碟，除了一个问题：这是一个 Humperdink BR549 数字保险箱，需要输入 10 位数字，总共有 100 亿种可能的组合。而且，锁轮只有在输入完所有数字后才会开始转动。你不能通过听诊器慢慢转动拨盘来破解它！

作为 Q，你已经有了一个自动拨号器，可以暴力破解所有可能的解决方案，但邦德根本没有时间使用它。原因如下。

组合锁其实应该叫做*排列*锁，因为它需要*有序*的组合，而排列本身就是*有序*的定义。更具体地说，锁依赖于*带有重复的排列*。例如，一个有效的——尽管不安全——组合可能是 999999999。

在[第3章](ch03.xhtml#ch03)的字谜部分和[第4章](ch04.xhtml#ch04)中 “[练习项目](ch04.xhtml#lev106)” 的[第87页](ch04.xhtml#page_87)，你使用了 itertools 模块的 permutations() 迭代器处理字谜，但这里行不通，因为 permutations() 返回的排列是*无重复*的。为了生成适合锁的排列，你需要使用 itertools 的 product() 迭代器，它会计算多个数字集合的笛卡尔积：

>>> 从 itertools 模块导入 product

>>> combo = (1, 2)

>>> for perm in product(combo, repeat=2):

print(perm)

(1, 1)

(1, 2)

(2, 1)

(2, 2)

可选的 repeat 关键字参数允许你对一个可迭代对象进行重复的笛卡尔积运算，就像在这种情况下需要的那样。请注意，product() 函数会返回所有可能的组合，而 permutations() 函数只会返回 (1, 2) 和 (2, 1)。你可以在 *[https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing](https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing)* 阅读更多关于 product() 的内容。

[列表 7-8](ch07.xhtml#ch07list8) 是一个 Python 程序，叫做 *brute_force_cracker.py*，它使用 product() 函数暴力破解找到正确的组合：

*brute_force_cracker.py*

➊ 导入 time 模块

从 itertools 模块导入 product

start_time = time.time()

➋ combo = (9, 9, 7, 6, 5, 4, 3)

# 使用笛卡尔积生成带有重复的排列

➌ for perm in product([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], repeat=len(combo)):

➍ if perm == combo:

print("破解成功! {} {}".format(combo, perm))

end_time = time.time()

➎ print("\n该程序的运行时间是 {} 秒.".format

(end_time - start_time))

*列表 7-8：使用暴力破解法找到保险箱的组合*

从 itertools 导入时间和产品迭代器 ➊。获取开始时间，然后将保险箱的组合作为元组输入 ➋。接下来使用 product()，它返回给定序列的所有排列（包括重复）元组。该序列包含所有有效的单数字输入（0–9）。你应将 repeat 参数设置为组合中的数字个数 ➌。比较每个结果与组合，如果匹配，则打印“破解！”并显示组合和匹配的排列 ➍。最后，显示运行时间 ➎。

这对于最多八位数的组合效果很好。之后，等待时间变得越来越不舒服。[表 7-3](ch07.xhtml#ch07tab3)记录了程序运行时间与组合中数字个数的关系。

**表 7-3：** 运行时间与组合中数字的关系（2.3 GHz 处理器）

| **数字位数** | **运行时间（秒）** |
| --- | --- |
| 5 | 0.035 |
| 6 | 0.147 |
| 7 | 1.335 |
| 8 | 12.811 |
| 9 | 133.270 |
| 10 | 1396.955 |

请注意，向组合中添加一个数字会使运行时间增加一个数量级。这是一个指数级的增长。对于 9 位数字，你将需要等待超过 2 分钟才能得到答案；对于 10 位数字，则需要超过 20 分钟！对于邦德来说，这是一个长时间的“上厕所”休息。

幸运的是，你是 Q，你了解遗传算法。你需要做的就是找到一种方法来评估每个候选组合的适应度。可选的方式包括监控功耗波动、测量操作中的时间延迟以及监听声音。假设我们使用一种声音放大工具，以及一个防止在输入几个错误组合后被锁定的工具。由于 BR549 保管箱的安全措施，声音工具最初只能告诉你*有多少个*数字是正确的，而不能告诉你*哪个*数字正确，但用不了多少时间，你的算法就能锁定解决方案。

**目标**

使用遗传算法在一个大的搜索空间中快速找到保险箱的组合。

#### ***策略***

这里的策略很简单。你将随机生成一个由 10 个数字组成的序列，并将其与真实的组合进行比较，根据匹配的情况进行评分；在现实中，你可以使用固定在保险箱门上的声音探测器来找到匹配的数量。然后你会改变解中的一个值，再次进行比较。如果找到另一个匹配，你就丢弃旧的序列并继续前进；否则，你保持旧的序列并再试一次。

由于一个解完全替代另一个解，这代表了遗传物质的 100% 交叉，因此你实际上只在使用选择和突变。仅使用选择加突变就能生成一个强大的*爬山*算法。爬山是一种优化技术，它从一个任意的解开始，并在解中更改（突变）一个值。如果结果有所改进，就保留新的解，并重复这个过程。

爬山算法的一个问题是它可能会陷入*局部*最小值或最大值，从而找不到最优的*全局*值。想象一下你正在寻找[图 7-4](ch07.xhtml#ch07fig4)中波动函数的最低值。当前最好的猜测由大黑点标记。如果你所做的变化（变异）幅度太小，无法“逃脱”局部的低谷，算法就无法找到真实的最低点。从算法的角度来看，由于每个方向的结果都比之前更差，它认为自己已经找到了真实答案。因此，算法会过早地收敛到一个解。

![image](../images/f0140-01.jpg)

*图 7-4：爬山算法“卡”在局部最小值的示例*

在遗传算法中使用交叉操作有助于避免过早收敛的问题，允许相对较大的变异也能起到类似作用。因为你这里并不关心生物学的真实性，变异空间可以涵盖组合中的每一个可能值。这样你就不会被困住，而爬山算法是可以接受的方式。

#### ***开锁器代码***

*safe_cracker.py* 代码接受一个由 *n* 位数字组成的组合，并使用爬山算法从一个随机的起点到达该组合。该代码可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)* 下载。

##### **设置和定义 fitness() 函数**

[列表 7-9](ch07.xhtml#ch07list9) 导入必要的模块并定义 fitness() 函数。

*safe_cracker.py，* 第一部分

➊ import time

from random import randint, randrange

➋ def fitness(combo, attempt):

"""比较两个列表中的项目并计算匹配项的数量。"""

grade = 0

➌ for i, j in zip(combo, attempt):

if i == j:

grade += 1

return grade

*列表 7-9：导入模块并定义* fitness() *函数*

导入一些熟悉的模块 ➊ 后，定义一个 fitness() 函数，该函数将真实的组合和尝试的解作为参数 ➋。命名一个变量 grade 并将其初始化为 0。然后使用 zip() 函数遍历组合中的每个元素和你的尝试 ➌。若它们相同，则将 grade 加 1 并返回。注意，这里并没有记录匹配的索引，只是说明该函数发现了匹配。这模拟了声音检测设备的输出。它最初能告诉你有多少个锁轮转动了，而不是它们的位置。

##### **定义并运行 main() 函数**

由于这是一个简短且简单的程序，大部分算法是在 main() 函数中运行的，[列表 7-10](ch07.xhtml#ch07list10)，而不是通过多个函数来完成。

*safe_cracker.py，* 第二部分

def main():

"""使用爬山算法解决锁的组合问题。"""

➊ combination = '6822858902'

print("组合 = {}".format(combination))

# 将 combination 转换为列表：

➋ combo = [int(i) for i in combination]

# 生成猜测并评估适应度：

➌ best_attempt = [0] * len(combo)

best_attempt_grade = fitness(combo, best_attempt)

➍ count = 0

# 进化猜测

➎ while best_attempt != combo:

# 交叉

➏ next_try = best_attempt[:]

# 变异

lock_wheel = randrange(0, len(combo))

➐ next_try[lock_wheel] = randint(0, 9)

# 评分与选择

➑ next_try_grade = fitness(combo, next_try)

if next_try_grade > best_attempt_grade:

best_attempt = next_try[:]

best_attempt_grade = next_try_grade

print(next_try, best_attempt)

count += 1

print()

➒ print("破解成功！{}".format(best_attempt), end=' ')

print("在{}次尝试中完成！".format(count))

if __name__ == '__main__':

start_time = time.time()

main()

end_time = time.time()

duration = end_time - start_time

➓ print("\n该程序的运行时间为{:.5f}秒。".format(duration))

*Listing 7-10: 定义了* main() *函数，并在未被导入的情况下运行和计时程序*

将真实的密码组合作为一个变量 ➊，并使用列表推导式将其转换为一个列表，以便后续使用 ➋。生成一个与密码组合长度相等的零列表，并命名为`best_attempt` ➌。此时，任何组合都与其他组合一样好。你应该保留这个名字—`best_attempt`—因为在爬坡过程中只需要保留最佳的解。一旦生成了初始尝试，使用`fitness()`函数进行评分，然后将该值赋给一个变量，命名为`best_attempt_grade`。

从零开始初始化一个计数变量。程序将使用这个变量记录破解密码所花费的尝试次数 ➍。

现在，启动一个`while`循环，直到找到密码 ➎。将`best_attempt`的*副本*赋给`next_try`变量 ➏。复制它是为了避免别名问题；当你在`next_try`中更改一个元素时，你不希望不小心更改`best_attempt`，因为在`next_try`未通过适应性测试时，可能还会继续使用它。

现在是时候变更密码了。组合中的每个数字都会转动保险箱中的一个锁轮，所以命名一个变量`lock_wheel`并随机设置其值为组合中的一个索引位置。这代表了在这一轮迭代中需要更改的单个元素的位置。接下来，随机选择一个数字，用它替换`lock_wheel`所索引位置的值 ➐。

对`next_try`进行评分，如果它比之前的尝试更适合，则将`best_attempt`和`best_attempt_grade`重置为新值 ➑。否则，`best_attempt`将在下一轮迭代中保持不变。打印`next_try`和`best_attempt`，并排显示，这样你可以在程序结束时滚动查看这些尝试，观察它们的变化。通过递增计数器来结束循环。

当程序找到密码时，显示`best_attempt`的值以及找到密码所需的尝试次数 ➒。记住，`end=' '`参数防止打印行末的换行符，并在当前行末与下一行的开始之间添加空格。

完成程序并添加条件语句，使主函数main()能够独立运行，并将运行时间显示到小数点后五位 ➓。请注意，计时代码位于条件语句之后，因此如果程序作为模块导入时不会执行。

#### ***总结***

以下是*safe_cracker.py*程序的最后几行输出。为了简洁起见，我省略了大部分逐步演化的对比。此次运行是针对一个10位数的组合。

[6, 8, 6, 2, 0, 5, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]

[6, 8, 2, 2, 0, 9, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]

[6, 8, 2, 2, 8, 5, 8, 9, 0, 0] [6, 8, 2, 2, 8, 5, 8, 9, 0, 0]

[6, 8, 2, 2, 8, 5, 8, 9, 0, 2] [6, 8, 2, 2, 8, 5, 8, 9, 0, 2]

破解成功！在78次尝试中成功破解了[6, 8, 2, 2, 8, 5, 8, 9, 0, 2]！

该程序的运行时间为0.69172秒。

十亿种可能的组合，程序只用了78次尝试并且不到一秒的时间就找到了一个解。就连詹姆斯·邦德也会对这个结果印象深刻。

到此为止，基因算法的内容就讲完了。你已经通过一个示例工作流培育出了巨大老鼠，然后通过暴力破解问题迅速完成了爬坡优化。如果你想继续进行数字达尔文实验，探索基因算法的更多应用，Wikipedia上有一长串应用实例可以参考（*[https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications](https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications)*）。一些例子包括：

+   全球气温变化建模

+   集装箱装载优化

+   送货车辆路线优化

+   地下水监测网络

+   学习机器人行为

+   蛋白质折叠

+   稀有事件分析

+   破译密码

+   适合函数的聚类

+   滤波和信号处理

### **进一步阅读**

*使用Python进行基因算法*（Amazon Digital Services LLC，2016年）由Clinton Sheppard编写，是一本关于使用Python进行基因算法的初学者入门书籍。它可以通过*【https://leanpub.com/genetic_algorithms_with_python/](https://leanpub.com/genetic_algorithms_with_python/)*以平装本或便宜的电子书形式购买。

### **挑战项目**

继续利用这些建议的项目来培育超级老鼠，并破解超级保险箱。和往常的挑战项目一样，你必须独立完成；没有提供解决方案。

#### ***建立老鼠后宫***

由于一只雄性老鼠可以与多只雌性老鼠交配，因此不需要雄性和雌性老鼠的数量相等。请重写*super_rats.py*代码，以适应不等数量的雄性和雌性个体。然后使用和之前相同总数的老鼠重新运行程序，但改为使用4只雄性和16只雌性。这样会如何影响达到50,000克目标体重所需的年数？

#### ***创建更高效的保险箱破译工具***

按照当前的写法，当*safe_cracker.py*代码找到一个锁轮匹配时，该匹配并没有被显式保存。只要`while`循环在运行，就没有什么能够阻止正确的匹配被随机覆盖。修改代码，使得正确猜测的索引在未来的更改中被排除。对比两种版本的代码的执行时间，以评估该更改的影响。
