## **4

**解码美国内战密码**

![image](../images/common01.jpg)

密码学是通过使用*代码*和*密码*实现安全通信的科学。代码将整个单词替换为其他单词；密码则是对单词中的字母进行混排或替换（因此，摩尔斯电码实际上就是摩尔斯密码）。密码学的一个目标是使用*密钥*将可读的*明文*加密成不可读的*密文*，然后再*解密*回明文。*密码分析*的目标是解码密码和代码，而不需要知道它们的密钥或加密算法。

本章中，我们将研究美国内战中使用的两种密码：北方使用的路线密码和双方都使用的铁路篱笆密码。我们还将探讨是什么使其中一种密码如此成功，并且我们可以如何借鉴其应用中的经验教训，来更好地为没有经验的用户和那些不熟悉你Python代码的用户编写程序。

### **项目 #8：路线密码**

在美国内战中，联邦几乎在所有领域都比南方联邦占有优势，包括密码学。联邦拥有更好的代码、更好的密码和更训练有素的人员。但或许其最大优势在于领导力和组织能力。

美国军事电报部门的负责人是安森·斯塔杰（[图 4-1](ch04.xhtml#ch04fig1)）。作为西联汇款的共同创始人，斯塔杰通过经验了解到，电报操作员在发送完整单词时犯错较少，而不像大多数密文那样由随机字母和数字组成。他还知道，军事命令只需要保持机密，直到指令执行完毕为止。他的安全解决方案是一种混合加密系统，称为*路线换位密码*，它结合了重排的真实单词和代码单词，成为历史上最成功的军事密码之一。

![image](../images/f0064-01.jpg)

*图 4-1：安森·斯塔杰将军，美国电报队，1865年*

换位密码*打乱*字母或单词的排列方式，不同于替代密码，后者*替换*明文中的字母，用不同的字符或符号。[图 4-2](ch04.xhtml#ch04fig2)展示了一个路线换位密码的示例。消息从左到右书写，在多个预定的列和行上，重要的明文单词被代码词替换，最后一行填充了虚拟占位符单词。读者通过上下遍历这些列来确定重排单词的顺序，如图所示。起始单词是*REST*，然后通过箭头显示加密路线。

![image](../images/f0065-01.jpg)

*图 4-2：使用实际联邦代码词的路线密码*

要完全解码这条消息，你需要知道起点和用来遍历消息并创建最终密文的路线*以及*代码词的含义。

在20世纪初，著名的军事密码分析师威廉·弗里德曼贬低了Stager的路线密码。他认为它过于简单，并认为南方联邦军队不可能从未破解过它。但事实仍然是，战时发送的数十万个路线密码显然从未被解码，且并非因为缺乏尝试。作为众包的早期实例，南方联邦将加密消息刊登在报纸上，希望能得到一些解密帮助，但未果。虽然一些历史学家推测这一密码有时被破解，但Stager的设计教给我们几个重要的教训：

**为人为错误设计。** 军事密码必须简洁，因为一天可能会发送数百条。路线密码中使用的真实单词使其更不容易被电报操作员弄乱。Stager了解他的客户，并为他们量身设计。他认识到自己员工的局限性，并根据这些局限性调整了产品。相比之下，南方联邦军队在解密自己复杂的消息时遇到了很大困难，有时甚至放弃并绕过敌军去面对面交谈！

**创新胜于发明。** 有时你不需要发明新东西；你只需要重新发现旧东西。适用于电报传输的短词换位密码本身太弱，不能单独使用，但通过结合密码名和干扰性虚词，它们使南方联邦难以破解。

**共享学习**。由于电报队中的每个人都使用相同的方法论，因此很容易在现有技术上进行改进并共享经验教训。这使得随着俚语、故意拼写错误的引入，以及越来越多的地点、人物和日期的密码词的出现，路线密码得以随时间演变。

Stager的实用密码可能没有让后来的“纯粹主义者”满意，但它在当时是完美的设计。其背后的概念是永恒的，且易于转化为现代应用。

**目标**

在哈里·特图尔多夫的1992年获奖小说《南方的枪火》中，时间旅行者为南方军队提供现代武器，从而改变了历史的进程。假设你没有携带AK-47，而是带着你的笔记本电脑、几个额外的电池和Python回到了1864年，设计一种基于假设的加密矩阵和路径来解密路线密码的算法。在Stager的精神下，你将编写一个用户友好的程序，减少人为错误。

#### ***策略***

在解决密码时，如果你知道自己面对的是哪种类型的密码，事情就会变得容易得多。在这种情况下，你知道它是一个换位密码，因为它由真实的单词组成并被打乱。你还知道其中有密码词和虚词。你的任务是找出解密*换位*部分的方式，而让别人担心密码词的部分，同时你去好好享受一杯应得的薄荷朱利普。

##### **创建控制消息**

要理解如何做到这一点，创建你自己的消息和路线密码。将其称为你的*控制消息*：

+   列数 = 4

+   行数 = 5

+   起始位置 = 左下角

+   路径 = 交替上下列

+   明文 = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19

+   密文 = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19

+   密钥 = –1 2 –3 4

使用数字递增的明文让你能够立即判断在消息的任何位置，你是否已正确解密了全部或部分内容。

置换矩阵如[图 4-3](ch04.xhtml#ch04fig3)所示。灰色箭头表示加密路径。

![图片](../images/f0067-01.jpg)

*图 4-3：控制消息的置换矩阵，显示了路线密码路径和生成的密文*

密钥追踪了路线的*顺序*和*方向*。路径不需要按顺序穿过列。例如，它可以先沿着第一列向下，再沿着第三列向上，沿着第四列向下，最后沿着第二列向上。负数表示从底部开始读取一列；正数表示相反的方向。对于控制消息，程序中使用的最终密钥将是一个列表：[–1, 2, –3, 4]。这个列表指示程序从第一列的底部开始向上读取，移动到第二列的顶部并向下读取，移动到第三列的底部并向上读取，最后移动到第四列的顶部并向下读取。

请注意，你不应该在密钥中使用 0，因为用户作为人类，习惯从 1 开始计数。当然，Python习惯从 0 开始计数，因此你需要在幕后将密钥值减去 1。大家都能接受！

稍后，在“[路线置换密码：暴力破解攻击](ch04.xhtml#lev111)”中，[第88页](ch04.xhtml#page_88)你可以使用这种紧凑的密钥结构通过暴力破解方式突破一个路线密码，自动尝试数百个密钥直到明文恢复。

##### **设计、填充和去填充矩阵**

你将输入密文作为一个连续的字符串。为了让程序解开这个字符串中的路径，你首先需要构建并填充一个翻译矩阵。密文字符串就是置换矩阵中各列的顺序拼接，正如[图 4-3](ch04.xhtml#ch04fig3)所示。由于置换矩阵有五行，因此密文中的每五个元素表示一个单独的列。你可以用一个列表的列表来表示这个矩阵：

>>> list_of_lists = [['16', '12', '8', '4', '0'], ['1', '5', '9', '13', '17'],

['18', '14', '10', '6', '2'], ['3', '7', '11', '15', '19']]

这个新列表中的项现在代表了列表——每个列表代表一列——而每个列表中的五个元素代表组成该列的行。这一点可能有点难以理解，因此我们将每个嵌套列表打印到单独的一行：

>>> for nested_list in list_of_lists

print(nested_list)

[16, 12, 8, 4, 0]

[1, 5, 9, 13, 17]

[18, 14, 10, 6, 2]

[3, 7, 11, 15, 19]

如果你从上到下、从左到右读取每个列表，你将遵循转置路线，即上下一列交替（参见[图4-3](ch04.xhtml#ch04fig3)）。从Python的角度看，第一个读取的列是list-of-lists[0]，起点是list-of-lists[0][0]。

现在，通过按与起始列相同的方向（向上）读取所有列来规范化路线。这需要反转每个其他列表中的元素顺序，如这里所示的粗体部分：

[16, 12, 8, 4, 0]

[17, 13, 9, 5, 1]

[18, 14, 10, 6, 2]

[19, 15, 11, 7, 3]

一个模式出现了。如果你从右上角开始，沿着每一列向下读取，直到左下角，数字会按顺序排列；你已恢复了明文！

为了实现这一点，脚本可以遍历每个嵌套列表，移除该列表中的最后一个元素并将其添加到新字符串中，直到翻译矩阵被清空。脚本将通过密钥知道需要反转哪些嵌套列表，并按顺序清空矩阵。输出将是恢复后的明文字符串：

'0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19'

你现在应该对策略有了一个非常通用的了解。接下来，让我们更详细地描述并编写伪代码。

#### ***伪代码***

该脚本可以分为三大部分：用户输入、翻译矩阵填充和解密到明文。你应该能够在以下伪代码中看到这些部分：

加载密文字符串。

将密文转换为密文列表，以便拆分出单个单词。

获取列数和行数的输入。

获取密钥的输入。

将密钥转换为列表，以便拆分出单个数字。

为翻译矩阵创建一个新列表。

对密钥中的每个数字进行操作：

创建一个新的列表，并从密文列表中附加每n个元素（n = 行数）。

使用键值的符号来决定是按正向还是反向读取行。

使用选定的方向，将新的列表添加到矩阵中。每个索引的

新列表是基于密钥中使用的列号。

创建一个新的字符串来保存翻译结果。

对行的范围进行操作：

对翻译矩阵中的嵌套列表进行操作：

移除嵌套列表中的最后一个单词

将单词添加到翻译字符串中。

打印翻译字符串。

循环前的所有操作本质上只是收集和重新格式化密文数据。第一个循环负责构建和填充矩阵，第二个循环则从矩阵中创建翻译字符串。最后，翻译字符串会被打印出来。

#### ***路线密码解密代码***

[Listing 4-1](ch04.xhtml#ch04list1) 获取使用路由密码加密的消息，转置矩阵中的列数和行数，以及密钥，然后显示翻译后的明文。它将解密所有“常见”的路由密码，其中路线从列的顶部或底部开始，并在列中向上或向下继续。

这是原型版本；一旦你确认它工作正常，就可以将它打包供其他人使用。你可以在 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)* 下载这段代码。

*route_cipher_decrypt_prototype.py*

➊ ciphertext = "16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19"

# 将元素拆分为单词，而不是字母

➋ cipherlist = list(ciphertext.split())

➌ # 初始化变量

COLS = 4

ROWS = 5

key = '-1 2 -3 4'  # 负数表示从上到下读取列

translation_matrix = [None] * COLS

plaintext = ''

start = 0

stop = ROWS

# 将 key_int 转换为整数列表：

➍ key_int = [int(i) for i in key.split()]

# 将列转换为列表中的项目：

➎ for k in key_int:

➏ if k < 0:  # 从列的底部到顶部读取

col_items = cipherlist[start:stop]

elif k > 0:  # 从列的顶部到底部读取

col_items = list((reversed(cipherlist[start:stop])))

translation_matrix[abs(k) - 1] = col_items

start += ROWS

stop += ROWS

print("\n密文 = {}".format(ciphertext))

print("\n翻译矩阵 =", *translation_matrix, sep="\n")

print("\n密钥长度 = {}".format(len(key_int)))

# 遍历嵌套列表，将最后一个项目弹出到新列表：

➐ for i in range(ROWS):

for col_items in translation_matrix:

➑ word = str(col_items.pop())

➒ plaintext += word + ' '

print("\n明文 = {}".format(plaintext))

*Listing 4-1: 路由密码解密原型.py 的代码*

首先加载密文 ➊ 作为字符串。你需要处理的是单词，而不是字母，因此使用 split() 字符串方法根据空格将字符串拆分，创建一个新的列表名为 cipherlist ➋。split() 方法是 join() 方法的逆操作，你以前见过。你可以基于任何字符串进行拆分；该方法默认基于连续的空白字符进行拆分，并在进入下一个拆分之前删除每个空白字符。

现在是时候输入你对密码的了解了 ➌：列和行，它们形成矩阵，以及包含路线的密钥。将列和行的数字初始化为常量。然后创建一个名为 translation_matrix 的空列表来保存每一列的内容，作为一个（嵌套）列表。通过将 None 的值乘以列数来分配占位符。你可以使用这些空项目的索引，将列按正确的顺序放回，适用于那些密钥不是按数字顺序排列的情况。

一个名为 plaintext 的空字符串将保存解密后的消息。接下来是一些切片参数。请注意，其中一些是从行数派生出来的，行数等于每列的项数。

现在，使用*列表推导*将 key 变量（一个字符串）转换为整数列表——这是一种对列表进行操作的简便方法 ➍。稍后你将使用 key 中的数字作为索引，因此它们需要是整数。

下一个代码块是一个 for 循环，用于填充 translation_matrix，它只是一个列表的列表 ➎。由于每一列变成一个嵌套列表，而 key_int 列表的长度等于列数，所以循环的范围是 key，它也描述了路径。

在循环内部，使用条件判断检查 key 是正数还是负数 ➏；如果 key 为正，则切片的方向将被反转。根据绝对的 key 值，将切片分配到 translation_matrix 的正确位置，并减去 1（因为密钥不包括 0，但列表索引是从 0 开始的）。通过将切片端点按行数推进并打印一些有用的信息来完成循环。

最后的代码块 ➐ 遍历行数——这等同于嵌套列表中单词的数量——以及每个嵌套列表。前两个循环在[图 4-4](ch04.xhtml#ch04fig4)中展示。当你停留在每个嵌套列表时，你可以使用我最喜欢的 Python 函数之一——列表的 pop() 方法 ➑。pop() 方法会移除并返回列表中的最后一个元素，除非提供了特定的索引。它会销毁嵌套列表，但反正你已经不再需要它了。

![image](../images/f0071-01.jpg)

*图 4-4：第一次和第二次遍历嵌套列表，移除并将每个末尾元素追加到翻译字符串中*

一旦你弹出一个单词，将其连接到明文字符串并添加一个空格 ➒。接下来要做的就是显示解密后的密文。数字测试集的输出看起来像这样：

plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19

看起来是成功了！

#### ***破解路线密码***

上述代码假设你知道加密矩阵的路径，或者已经正确猜测了密钥。如果这些假设不成立，你唯一的解决方法就是尝试每一个可能的密钥和矩阵排列。你将有机会自动化密钥选择过程——针对给定的列数——在 “[路线换位密码：暴力破解](ch04.xhtml#lev111)” 的 [第 88 页](ch04.xhtml#page_88)。但是，正如你将看到的，Union 路线密码对暴力破解攻击有很好的防护。你可以破解它，但你会得到大量的数据，最终会感觉像那只追逐并抓住汽车的狗。

随着消息变得更长，换位密码中的可能加密路径数目变得过大，即使使用现代计算机也无法通过暴力破解解决。例如，如果有八列，并且允许路线跳跃到任何一列，那么组合列的方式就是八的阶乘：8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40,320。这是40,320条路径，*在*你开始选择穿越各列的替代路径之前。如果路线可以向上或向下改变方向，组合数将增加到10,321,920。而如果你考虑从*任何*位置开始——而不是从顶部或底部开始——并允许*任何*路径穿越矩阵（例如螺旋形），事情就真的会变得难以控制！

因此，即使是短小的换位密码也可能有成千上万到百万级的可能路径。即使路径数目对计算机来说是可以管理的，并且暴力破解攻击可能会成功，你仍然需要一种方法来筛选大量的结果，要么通过计算选择一个最优解，要么选择一个小的候选集进行人工检查。

对于更常见的*字母*换位密码，编写一个通过将每个解密尝试与字典文件进行比较来检测英语的函数非常容易。如果解密出来的单词中属于字典的数量超过某个阈值百分比，那么你可能已经破解了密码。同样，如果出现常见字母对（*双字母组合*）的频率很高——例如*er*、*th*、*on*或*an*——你也许找到了破解的线索。不幸的是，这种方法对于像你在这里使用的*单词*换位密码是行不通的。

字典无法帮助你判断单词是否被正确排列。对于单词排列，你可以尝试使用像语法规则和概率语言模型（如*n*-gram）的方式，通过检查数千个解密结果并编程选择候选结果，但Stager在他的路径密码中巧妙地使用了代号和虚假单词，这将大大增加这个过程的复杂性。

密码分析师认为，尽管如上所述存在一些问题，短小的、直接的换位密码仍然相对容易破解，而无需计算机。他们寻找合理的常见单词或字母组合，并利用这些信息猜测换位矩阵中的行数。

为了说明这一点，我们使用由数字组成的控制信息。在[图4-5](ch04.xhtml#ch04fig5)中，您可以看到4×5矩阵的密文结果，每个结果都是通过从网格的四个角之一开始，并沿着交替的顺序路线走出。所有情况包括相邻数字的重复（在[图4-5](ch04.xhtml#ch04fig5)中阴影部分）。这些重复数字指示了你在网格中横向移动的位置，并为矩阵的设计以及路线提供了线索。您可以立即看出有五行，因为每对共同的数字中的第一个是第五个单词。此外，知道消息中有20个单词，您可以推断出列数为四（20 / 5 = 4）。通过合理假设明文消息是从左到右写的，您甚至可以猜测路线。例如，如果您从右下角开始，您首先向上走到3，然后向左走到2，再向下走到18，再向左走到17，再向上走到1并向左走到0。 当然，使用单词时，这样做会更加困难，因为单词之间的联系并不明显，但使用数字确实突出了这一点。

![image](../images/f0073-01.jpg)

*图4-5：可以用来猜测加密路线的按逻辑顺序排列的字符或单词（阴影部分）。*

查看[图4-6](ch04.xhtml#ch04fig6)，它基于[图4-2](ch04.xhtml#ch04fig2)中的信息。结束词和可能的关联词，如“is just”或“heading to”，已被阴影标记。

![image](../images/f0073-02.jpg)

*图4-6：基于[图4-2](ch04.xhtml#ch04fig2)的人类破解路线密码。这里标示了一个五行矩阵。*

总共有20个单词，可能有4行、5行或10行。使用两列矩阵的可能性较小，因此我们实际上在处理一个4×5或5×4的排列。如果路线密码路径像[图4-5](ch04.xhtml#ch04fig5)中的那样，那么我们预计在四行矩阵中会看到两个未阴影的单词，而在五行矩阵中会看到三个未阴影的单词。无论从哪个方向读取密文，想要符合四列模式的词对都更难构造。所以，我们很可能在处理一个五列解决方案，它从矩阵的左侧开始——因为关联单词从左到右读是有意义的。

请注意[图4-6](ch04.xhtml#ch04fig6)中阴影单词如何填充[图4-7](ch04.xhtml#ch04fig7)中的转置矩阵的顶部和底部行。这正是我们所期望的，因为路径在每列的顶部和底部“转弯”了。图形解决方案：上帝给无数人的礼物！

![image](../images/f0074-01.jpg)

*图4-7：[图4-6](ch04.xhtml#ch04fig6)中阴影单词放置在转置矩阵中*

这看起来很简单，但话说回来，我们知道路线密码是如何工作的。南方联邦的密码破译员最终也发现了这一点，但由于使用了密码词，他们无法完全进入系统。为了破解密码，他们需要一本被捕获的密码本，或者一个能够收集和分析大数据的大型组织，而这在19世纪的南方联邦是无法实现的。

#### ***添加用户界面***

这个项目的第二个目标是将代码编写得尽量减少人为错误，尤其是那些经验较少的人（包括技术员、实习生、同事以及1864年的电报文员）。当然，使程序更易于使用的最佳方式是包含一个*图形用户界面（GUI）*，但有时这既不实际也不可能。例如，破解程序会自动循环遍历数千个可能的密钥，自动生成这些密钥比直接从用户那里获得它们要容易。

在这个示例中，你将假设用户会打开程序文件并输入一些内容，甚至可能做一些小的代码更改。以下是一些需要遵循的指南：

1.  从一个有用的文档字符串开始（见[第1章](ch01.xhtml#ch01)）。

1.  将所有必需的用户输入放在顶部。

1.  使用注释来澄清输入要求。

1.  清楚地区分用户输入和其余代码。

1.  将大多数过程封装在函数中。

1.  包括用于捕捉可预见的用户错误的函数。

这种方法的好处是没有人会觉得自己的智商受到侮辱。如果用户*想*向下滚动并查看代码，甚至修改它，没有什么可以阻止他们。如果他们只是想输入一些值并获得一个黑盒解决方案，那么他们也会很高兴。我们通过简化操作并减少错误的机会，尊重了安森·斯塔格的精神。

##### **指导用户并获取输入**

[列表4-2](ch04.xhtml#ch04list2)展示了一个原型代码，重新包装以便与他人共享。你可以在*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*找到这段代码。

*route_cipher_decrypt.py,* 第1部分

➊ """解密通过联邦路线密码的路径。

➋ 设计用于具有可变行和列的全词置换密码。

假设加密从列的顶部或底部开始。

密钥指示读取列的顺序和遍历的方向。

负的列号表示从底部开始并向上读取。

正的列号表示从顶部开始并向下读取。

下面的示例是一个4x4矩阵，密钥为 -1 2 -3 4。

注意，“0”是不允许的。

箭头表示加密路线；对于负密钥值，向上读取。

1   2   3   4

___ ___ ___ ___

| ^ | | | ^ | | | 消息已写入

|_|_|_v_|_|_|_v_|

| ^ | | | ^ | | | 穿越每一行

|_|_|_v_|_|_|_v_|

| ^ | | | ^ | | | 以这种方式

|_|_|_v_|_|_|_v_|

| ^ | | | ^ | | | 最后一行填充了虚拟单词

|_|_|_v_|_|_|_v_|

开始        结束

必需的输入 - 一条文本消息，列数，行数，密钥字符串

打印转换后的明文

"""

➌ import sys

#==============================================================================

➍ # 用户输入：

➎ # 要解密的字符串（在三重引号之间输入或粘贴）：

ciphertext = """16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19

"""

➏ # 转置矩阵中的列数：

COLS = 4

# 转置矩阵中的行数：

ROWS = 5

➐ # 带有数字之间空格的密钥；负数表示向上读取列（例如：-1 2 -3 4）：

key = """ -1 2 -3 4 """

➑ # 用户输入结束 - 请勿编辑以下内容！

#==============================================================================

➒ ________________________________________________________________________________

*列表 4-2：route_cipher_decrypt.py 的文档字符串、导入和用户输入*

从三重引号开始编写多行文档字符串 ➊。文档字符串告诉用户该程序仅解密典型的路径密码——一种从列的顶部或底部开始的密码——以及如何输入密钥信息 ➋。附带的图示有助于说明这一点。

接下来，导入 sys 以访问系统字体和函数 ➌。你需要检查用户输入是否符合接受标准，因此需要在 shell 中用显眼的红色显示消息。将这条导入语句放在这里是一个两难问题。由于战略目标是将工作代码隐藏在用户看不见的地方，因此最好在程序后面再应用它。但 Python 的约定是将所有导入语句放在最上面，这种惯例强大到几乎不能忽视。

现在是输入部分。你有多少次看到或处理过必须*贯穿*整个程序的输入或更改？这会让作者感到困惑，对其他用户来说可能更糟。因此，为了方便、出于礼貌并避免错误，将所有这些重要变量移到顶部。

首先，用一行分隔输入部分，然后用大写注释让用户知道他们已经准备好输入 ➍。所需的输入通过注释进行了明确的定义。可以使用三重引号来处理文本输入，以便更好地容纳长文本。请注意，我已经输入了[图 4-3](ch04.xhtml#ch04fig3) ➎中的数字串。接下来，用户需要添加转置矩阵的列数和行数 ➏，然后是提议的（或已知的）密钥 ➐。

用一个声明性的注释结束用户输入部分，并提醒不要编辑以下内容 ➑。然后添加一些额外的空行，以更清楚地将输入部分与程序的其余部分分开 ➒。

##### **定义 main() 函数**

[列表 4-3](ch04.xhtml#ch04list3) 定义了 main() 函数，该函数运行程序并在解密后打印明文。main() 函数可以在它调用的函数之前或之后定义，只要它是最后一个被调用的函数。

*route_cipher_decrypt.py,* 第 2 部分

def main():

"""运行程序并打印解密后的明文。"""

➊ print("\n密文 = {}".format(ciphertext))

print("尝试 {} 列".format(COLS))

print("尝试 {} 行".format(ROWS))

print("尝试密钥 = {}".format(key))

# 将元素拆分为单词，而不是字母

➋ cipherlist = list(ciphertext.split())

➌ validate_col_row(cipherlist)

➍ key_int = key_to_int(key)

➎ translation_matrix = build_matrix(key_int, cipherlist)

➏ plaintext = decrypt(translation_matrix)

➐ print("明文 = {}".format(plaintext))

*列表 4-3：定义了* main() *函数*

开始 main() 函数，首先将用户输入打印到终端 ➊。然后通过空格拆分将密文转换为列表，正如你在原型代码中所做的 ➋。

接下来的几行语句调用了你将很快定义的函数。第一个函数检查输入的行和列是否适合消息长度 ➌。第二个函数将密钥变量从字符串转换为整数列表 ➍。第三个函数构建了翻译矩阵 ➎，第四个函数在矩阵上运行解密算法并返回明文字符串 ➏。通过打印明文 ➐ 完成 main() 函数。

##### **验证数据**

在继续为最终用户打包 *route_cipher_decrypt.py* 时，你需要验证输入是否有效。[列表 4-4](ch04.xhtml#ch04list4)预见了常见的用户错误，并为用户提供了有用的反馈和指导。

*route_cipher_decrypt.py,* 第3部分

➊ def validate_col_row(cipherlist):

"""检查输入的列和行是否与消息长度有效。"""

factors = []

len_cipher = len(cipherlist)

➋ for i in range(2, len_cipher):  # 范围排除了 1 列密码

if len_cipher % i == 0:

factors.append(i)

➌ print("\n密码长度 = {}".format(len_cipher))

print("可接受的列/行值包括: {}".format(factors))

print()

➍ if ROWS * COLS != len_cipher:

print("\n错误 - 输入的列和行不是长度的因子"

"密码的错误。程序终止。", file=sys.stderr)

sys.exit(1)

➎ def key_to_int(key):

"""将密钥转换为整数列表并检查有效性。"""

➏ key_int = [int(i) for i in key.split()]

key_int_lo = min(key_int)

key_int_hi = max(key_int)

➐ if len(key_int) != COLS or key_int_lo < -COLS or key_int_hi > COLS \

或者 0 在 key_int 中：

➑ print("\n错误 - 密钥有问题。程序终止。", file=sys.stderr)

sys.exit(1)

else:

➒ return key_int

*列表 4-4：定义用于检查和准备用户输入的函数*

validate_col_row() 函数检查输入的列和行数字是否适合 cipherlist 的长度，你将其作为参数传递 ➊。换位矩阵的大小始终与消息中的单词数量相同，因此列数和行数必须是消息大小的因子。要确定所有允许的因子，首先创建一个空列表来保存因子，然后获取 cipherlist 的长度。使用 *cipherlist*，而不是输入的 *ciphertext*，因为密文中的元素是 *字母*，而不是单词。

通常，为了得到一个数的因数，你会使用范围 (1, number + 1)，但你不希望这些端点出现在因数列表中，因为具有这些维度的翻译矩阵将只是明文。所以将这些值从范围中排除 ➋。由于一个数的因数能够整除该数，因此使用取模运算符 (%) 查找因数，然后将它们添加到因数列表中。

接下来，显示一些对用户有用的信息：cipherlist 的长度，以及行和列的可选选择 ➌。最后，将用户的两个选择相乘，并将结果与 cipherlist 的长度进行比较。如果不匹配，在 shell 中打印红色警告信息（使用我们以前的 file=sys.stderr 技巧），并终止程序 ➍。使用 sys.exit(1)，因为 1 表示异常退出。

现在定义一个函数来检查密钥并将其从字符串转换为列表 ➎。将密钥变量作为参数传递给它。将密钥中的每个项目拆分并转换为整数；命名列表为 key_int，以区分用户输入的密钥变量 ➏。接下来，确定 key_int 列表中的最小值和最大值。然后使用 if 语句确保列表中包含与列数相同的项目，且密钥中的项目不太大、不太小或等于 0 ➐。如果任何条件未通过，则终止程序并显示错误信息 ➑。否则，返回 key_int 列表 ➒。

##### **构建和解码翻译矩阵**

[清单 4-5](ch04.xhtml#ch04list5) 定义了两个函数，一个用于构建翻译矩阵，另一个用于解码翻译矩阵，并将 main() 函数作为模块或独立模式调用。

*route_cipher_decrypt.py，* 第 4 部分

➊ def build_matrix(key_int, cipherlist):

"""将列表中的每 n 项转换为一个新项目，形成一个列表的列表。"""

translation_matrix = [None] * COLS

start = 0

stop = ROWS

for k in key_int:

if k < 0:  # 从列的底部到顶部读取

col_items = cipherlist[start:stop]

elif k > 0:  # 从列的顶部到底部读取

col_items = list((reversed(cipherlist[start:stop])))

translation_matrix[abs(k) - 1] = col_items

start += ROWS

stop += ROWS

return translation_matrix

➋ def decrypt(translation_matrix):

"""遍历嵌套列表，将最后一个项目弹出为字符串。"""

plaintext = ''

for i in range(ROWS):

for matrix_col in translation_matrix:

word = str(matrix_col.pop())

plaintext += word + ' '

return plaintext

➌ if __name__ == '__main__':

main()

*清单 4-5：定义了构建和解码翻译矩阵的函数*

这两个函数代表了 *route_cipher_decrypt_prototype.py* 程序中代码的封装。详细描述请参见 [清单 4-1](ch04.xhtml#ch04list1)。

首先，定义一个函数来构建翻译矩阵；将 key_int 和 cipherlist 变量作为参数传递给它 ➊。让该函数返回列表的列表。

接下来，将解密代码捆绑起来，弹出每个嵌套列表的末尾，作为一个函数，该函数使用 translation_matrix 列表作为参数 ➋。返回明文，主函数将打印出该明文。

以条件语句结束，让程序可以作为模块或独立模式运行 ➌。

如果你是这个代码的偶尔使用者或一次性用户，你会很欣赏它的简洁和易于接触。如果你计划为了自己的目的修改代码，你也会欣赏密钥变量的可访问性以及主要任务的模块化。你无需深入程序查找关键信息，或者去理解像 list1 和 list2 这样的晦涩变量之间的区别。

以下是程序的输出，使用来自[图 4-3](ch04.xhtml#ch04fig3)的密文：

密文 = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19

尝试 4 列

尝试 5 行

尝试密钥 = -1 2 -3 4

密码长度 = 20

可接受的列/行值包括：[2, 4, 5, 10]

明文 = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19

现在，你应该能够轻松解密已知密钥的路线换位密码，或者通过使用脚本的清晰和易于访问的界面调整密钥来测试怀疑的路径。你将有机会真正破解这些密码，通过自动尝试每个可能的密钥，在“[路线换位密码：暴力破解攻击](ch04.xhtml#lev111)”中，位于[第88页](ch06.xhtml#page_88)。

### **项目 #9：Rail Fence 密码**

南方邦联的军官和间谍在密码学方面几乎是独立的，这导致了不复杂的解决方案，其中最受欢迎的就是 rail fence 密码，之所以这样命名，是因为它与分裂的栅栏的锯齿形图案相似（见[图 4-8](ch04.xhtml#ch04fig8)）。

![image](../images/f0080-01.jpg)

*图 4-8：一个 rail fence*

Rail fence 是一种简单易用的换位密码，就像联邦军的路线密码一样，但与路线密码不同的是，它对字母进行换位，而不是单词，这使得它更容易出错。而且，由于可能的密钥数量远比路线密码中的路径数量要有限，因此 rail fence 密码更容易被“破解”。

联邦军和南方邦联都使用了 rail fence 作为场地密码，而间谍们可能并不经常使用密码词。出于显而易见的原因，密码本需要严格控制，更有可能保存在军事电报局，而不是被易于泄露的卧底特工随身携带。

有时，联邦军使用更复杂的维吉尼亚密码（见“[项目 #12：隐藏维吉尼亚密码](ch06.xhtml#lev130)”在[第106页](ch06.xhtml#page_106)）来传递重要信息——以及一些不重要的消息来误导敌人——但这是一项繁琐的解密工作，同样加密也非常繁琐，不适合快速的战场通信。

尽管缺乏密码学的训练，但南方邦联和南方人普遍来说都非常聪明和创新。在秘密信息艺术方面，他们更令人印象深刻的成就之一是使用微摄影，比冷战期间广泛应用早了100年。

**目标**

编写Python程序，帮助间谍加密和解密“二轨”（两行）栅栏密码。你应该以一种减少缺乏经验的用户可能犯错的方式编写程序。

#### ***策略***

要使用栅栏密码加密消息，请按照[图 4-9](ch04.xhtml#ch04fig9)中的步骤操作。

![image](../images/f0081-01.jpg)

*图 4-9: “两轨”栅栏密码的加密过程*

明文写好后，去除空格，所有字母转换为大写（步骤 2）。在密码学中使用大写字母是常见的惯例，因为它掩盖了专有名词和句子开头的存在，从而给密码分析师提供了更少的解密线索。

然后，消息以堆叠的方式写出，每个字母位于前一个字母的下方，并偏移一个位置（步骤 3）。这就是“栅栏”类比变得明显的地方。

第一行写完后，紧接着在同一行写下第二行（步骤 4），然后将字母分成五个一组，以制造出不同单词的错觉，并进一步迷惑密码分析师（步骤 5）。

要解密栅栏密码，只需反转过程。只需去掉空格，将消息分成两部分，将第二部分堆叠在第一部分下方，偏移一个字母，并使用之字形模式读取消息。如果密文中的字母数是奇数，则将额外的字母放在第一（上）部分。

为了方便那些想使用栅栏密码的人，请按照前面的步骤编写两个程序，一个用于加密，另一个用于解密。[图 4-9](ch04.xhtml#ch04fig9)本质上是你的伪代码，所以让我们开始吧。既然你现在知道如何为缺乏经验的用户打包代码，就从一开始就采用这种方法。

#### ***栅栏密码加密代码***

本节中的代码允许用户输入明文消息，并在解释器窗口中打印加密结果。此代码可以通过本书资源下载，地址为*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。

##### **指导用户并获取输入**

[清单 4-6](ch04.xhtml#ch04list6)位于*rail_fence_cipher_encrypt.py*的顶部，提供了程序的说明，并将明文赋值给一个变量。

*rail_fence_cipher_encrypt.py,* 第1部分

➊ r"""加密一个内战时期的‘栅栏’类型密码。

这是针对短消息的“2轨”栅栏密码。

加密示例文本：‘购买更多的缅因土豆’

栅栏密码样式： B Y O E A N P T T E

U M R M I E O A O S

按照之字形读： \/\/\/\/\/\/\/\/\/

加密结果： BYOEA NPTTE UMRMI EOSOS

"""

#------------------------------------------------------------------------------

➋ # 用户输入：

# 要加密的字符串（粘贴在引号之间）：

➌ plaintext = """让我们跨过这条河流，休息在树荫下

"""

➍ # 用户输入结束 - 请勿编辑以下内容！

#------------------------------------------------------------------------------

*列表4-6：rail_fence_cipher_encrypt.py的文档字符串和用户输入部分*

从多行文档字符串开始，在第一组三重引号之前加上r前缀（表示“原始”） ➊。没有这个前缀，Pylint会强烈抱怨下文中使用的\/\斜杠。幸运的是，pydocstyle会指出这一点，这样你就能修复它（阅读[第1章](ch01.xhtml#ch01)来了解有关Pylint和pydocstyle的所有信息）。如果你想了解更多关于*原始字符串*的信息，请参阅Python文档中的第2.4.1节（* [https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals](https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals) *）。

接下来，使用一行分隔程序的文档字符串和导入语句，并通过全大写注释让用户知道他们即将进入输入部分 ➋。清楚地定义输入要求，并将明文放在三重引号内，以便更好地容纳长文本字符串 ➌。

最后，用声明标明用户输入部分的结束，并提醒不要编辑以下内容 ➍。

##### **加密消息**

将[列表4-7](ch04.xhtml#ch04list7)添加到 *rail_fence_cipher_encrypt.py* 以处理加密过程。

*rail_fence_cipher_encrypt.py,* 第二部分

➊ def main():

"""运行程序，使用2轨道栅栏密码加密消息。"""

message = prep_plaintext(plaintext)

rails = build_rails(message)

encrypt(rails)

➋ def prep_plaintext(plaintext):

"""去除空格和前后空白字符。"""

➌ message = "".join(plaintext.split())

➍ message = message.upper()  # 密文的惯例是大写字母

print("\nplaintext = {}".format(plaintext))

return message

➎ def build_rails(message):

"""用消息中的每个其他字母构建字符串。"""

evens = message[::2]

odds = message[1::2]

➏ rails = evens + odds

return rails

➐ def encrypt(rails):

"""将密文中的字母拆分为5个一组，并连接成字符串。"""

➑ ciphertext = ' '.join([rails[i:i+5] for i in range(0, len(rails), 5)])

print("ciphertext = {}".format(ciphertext))

➒ if __name__ == '__main__':

main()

*列表4-7：定义函数以加密明文消息*

首先，定义一个main()函数来运行程序 ➊。拥有一个main()函数可以在以后需要时，使你有灵活性将这个程序作为模块用于另一个程序。这个函数调用了三个其他函数：一个用来准备输入的明文，一个用来构建密码使用的“轨道”，以及一个用来将加密文本分成五个字母一组。

接下来，定义一个函数来处理输入字符串并准备进行加密 ➋。这个过程包括去除空格 ➌ 并将字母转换为大写（如[图 4-9](ch04.xhtml#ch04fig9)中的步骤 2所示） ➍。然后，在换行后，将明文打印到屏幕上并返回。

现在，定义一个函数，通过对消息进行切片来创建两个字符串，如[图 4-9](ch04.xhtml#ch04fig9)中的步骤 3所示，分别获取偶数索引（从 0 开始，步长为 2）和奇数索引（从 1 开始，步长为 2） ➎。然后，将这两个字符串连接成一个新的字符串，命名为 rails ➏，并返回。

定义一个加密函数，将 rails 字符串作为参数 ➐。使用列表推导式将密文拆分为五个字符一组（如[图 4-9](ch04.xhtml#ch04fig9)中的步骤 5所示） ➑。然后将加密文本打印到屏幕上。最后，编写代码以作为模块或独立模式运行程序 ➒。

这是该程序的输出：

明文 = 让我们跨过河流，在树荫下休息

密文 = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES

#### ***栅栏密码解密代码***

本节中的代码允许用户输入用栅栏密码加密的信息，并在解释器窗口中打印明文。此代码可与本书的其他资源一起下载，链接地址为 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。

##### **导入模块、指导用户并获取输入**

[清单 4-8](ch04.xhtml#ch04list8)开始时有类似于*rail_fence_cipher_encrypt.py*程序中的指令（[清单 4-6](ch04.xhtml#ch04list6)），导入了两个模块，并获取了用户输入。

*rail_fence_cipher_decrypt.py*，第一部分

r"""解密美国内战时期的“栅栏密码”。

这是用于短信息的2轨栅栏密码。

示例明文：  ‘购买更多缅因州土豆’

栅栏风格：  B Y O E A N P T T E

U M R M I E O A O S

按之字形读取：   \/\/\/\/\/\/\/\/\/\/

密文：  BYOEA NPTTE UMRMI EOSOS

"""

➊ import math

import itertools

#------------------------------------------------------------------------------

# 用户输入：

# 要解密的字符串（请在引号之间粘贴）：

➋ 密文 = """LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES

"""

# 用户输入结束 - 请勿编辑以下内容！

#------------------------------------------------------------------------------

*清单 4-8：导入模块、指导用户并获取用户输入*

这里的一个区别是，你需要导入 math 和 itertools 模块 ➊。你将使用 math 进行四舍五入。itertools 模块是 Python 标准库中的一组函数，用于创建高效循环的迭代器。在解密过程中，你将使用 itertools 的 zip_longest() 函数。

唯一的其他更改是，用户应输入密文，而不是明文 ➋。

##### **解密一条信息**

[清单 4-9](ch04.xhtml#ch04list9)定义了用于准备和解码密文的函数，并完成了*rail_fence_cipher_decrypt.py*。

*rail_fence_cipher_decrypt.py,* 第二部分

➊ def main():

"""运行程序以解密2轨铁丝栅加密。"""

message = prep_ciphertext(ciphertext)

row1, row2 = split_rails(message)

decrypt(row1, row2)

➋ def prep_ciphertext(ciphertext):

"""去除空格。"""

message = "".join(ciphertext.split())

print("\nciphertext = {}".format(ciphertext))

return message

➌ def split_rails(message):

"""将消息分成两部分，总是对第一行进行向上取整。"""

➍ row_1_len = math.ceil(len(message)/2)

➎ row1 = (message[:row_1_len]).lower()

row2 = (message[row_1_len:]).lower()

return row1, row2

➏ def decrypt(row1, row2):

"""构建列表，将两个字符串中的每隔一个字母拼接并打印。"""

➐ plaintext = []

➑ for r1, r2 in itertools.zip_longest(row1, row2):

plaintext.append(r1)

plaintext.append(r2)

➒ if None in plaintext:

plaintext.pop()

print("rail 1 = {}".format(row1))

print("rail 2 = {}".format(row2))

print("\nplaintext = {}".format(''.join(plaintext)))

➓ if __name__ == '__main__':

main()

*清单 4-9：准备、解码并打印消息*

这里的main()函数 ➊ 与[清单 4-7](ch04.xhtml#ch04list7)中的加密程序相似。调用了三个函数：一个准备输入字符串，一个用于“分割铁丝栅”，一个将两行重新拼接成可读的明文。

从一个函数开始，该函数重复加密过程中使用的预处理步骤 ➋。去除五个字母块之间的空格以及在粘贴密文时产生的其他任何空格，然后打印并返回密文。

接下来，你需要将消息分成两半，以便逆转加密过程 ➌。正如我在“[策略](ch04.xhtml#lev97)”中提到的，[第81页](ch04.xhtml#page_81)中，字符数为奇数的消息中的额外字母被分配到第一行。为了处理奇数情况，使用math.ceil()方法 ➍。“Ceil”代表“天花板”，所以当你除以2时，答案总是四舍五入到最接近的整数。将这个数字分配给row_1_len变量。一旦你知道第一行的长度，就可以使用该值和切片将消息变量分成两串，表示两行 ➎。通过返回这两个行变量来结束函数。

现在，只需要选择并连接每行的其他字母，将明文拼接起来。定义一个 decrypt() 函数，并传入轨道 1 和轨道 2 的字符串 ➏。通过创建一个空列表来保存结果，开始翻译过程 ➐。接下来，你需要一种简便的方法来处理密文中包含奇数个字母的情况——这会导致两行的长度不同——因为 Python 不允许你循环遍历两个长度不等的序列，会引发超出索引范围的错误。这就是为什么我们导入了 itertools 模块——它的函数可以帮助循环处理这个问题。

itertools.zip_longest() 函数接受两个字符串作为参数，并在遍历它们时不会报错。当遍历到较短字符串的末尾时，它会将一个空值（None）附加到明文列表中 ➑。你不希望打印这个空值，因此如果它存在，可以使用你在路线密码代码中应用的 pop() 方法将其删除 ➒。通过打印两行（轨道）到屏幕，接着输出解密后的密文，完成解密过程。

以标准代码结束程序，使其能够作为模块或独立模式运行 ➓。程序的输出如下：

密文 = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES

轨道 1 = LTSRSOETEIEADETNETEHDOTERE

轨道 2 = EUCOSVRHRVRNRSUDRHSAEFHTES

明文 = letuscrossovertheriverandrestundertheshadeofthetrees

请注意，单词之间没有空格，但这没关系——你不想让密码分析师完全感到无用！

### **总结**

这就完成了我们对南北战争密码的探讨。你编写了一个帮助用户解密路线密码的程序，并且获得了关于其工作原理以及如何破解它的宝贵见解。你可以在接下来的练习项目中实现对该密码的自动化攻击，但请记住，由于其多种可能的路径和使用密码词，联邦路线密码仍然是一个难以完全破解的难题。

接下来，你编写了程序来加密和解密二轨栅栏密码。考虑到手动加密和解密过程既繁琐又容易出错，有一个自动化的方法来完成大部分工作对战争双方来说都非常有价值。为了进一步解决这些问题，你编写了一个用户友好的代码，方便那些没有经验的密码分析师或间谍使用。

### **进一步阅读**

更多适合初学者的 Python 程序用于处理换位密码，可以参考*《用 Python 破解密码》*（No Starch Press，2018年）作者 Al Sweigart。

关于密码学的优秀且图文并茂的概述可以在*《神秘信息：密码和暗号的历史》*（企鹅出版集团，2009年）作者 Gary Blackwood 和*《密码书：从古埃及到量子密码学的秘密科学》*（Anchor，2000年）作者 Simon Singh 中找到。

网站 *[http://www.civilwarsignals.org/pages/crypto/crypto.html](http://www.civilwarsignals.org/pages/crypto/crypto.html)* 和 *[http://www.mathaware.org/mam/06/Sauerberg_route-essay.html](http://www.mathaware.org/mam/06/Sauerberg_route-essay.html)* 包含了爱德华·波特·亚历山大尝试解密路线密码的描述。亚历山大是南方联盟军信号兵团的创始人，也是一个杰出的军事创新者，拥有许多令人印象深刻的成就。

### **实践项目**

通过这些项目来磨练你的密码学技巧。解决方案可以在附录和在线找到。

#### ***破解林肯的密码***

在他的书《神秘信息：密码与密码的历史》中，Gary Blackwood 复制了一条由亚伯拉罕·林肯发送并用路线密码加密的实际信息：

**这个方法在为什么和是否填充它时，你得到它们的海王星，论坛请他们可以提高**

使用 *route_cipher_decrypt.py* 程序来解密这个密码。列数和行数必须是消息长度的因数，并且路线从一个角落开始，不跳过列，并且每次列改变时都会交替方向。代码词定义和明文解答可以在附录中找到。

#### ***识别密码类型***

你越早知道你正在处理哪种类型的密码，就越能快速破解它。单词置换密码容易识别，但字母置换密码可能看起来像字母-*替换*密码。幸运的是，你可以通过使用密文中字母的出现频率来区分这两者。由于字母在置换密码中只是被打乱，而不是被替换，它们的频率分布将与明文所用语言的分布相同。然而，军用信息是一个例外，因为它们使用行话并省略了许多常见的词汇。对于这些，你需要从其他军事信息中构建一个频率表。

编写一个 Python 程序，接受一串密文作为输入，并确定它更可能是置换密码还是替换密码。用 *cipher_a.txt* 和 *cipher_b.txt* 文件进行测试，这些文件可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)* 下载。解决方案可以在附录中找到，也可以在书籍网站上的 *identify_cipher_type_practice.py* 文件中找到。

#### ***将密钥存储为字典***

编写一个简短的脚本，将一个路线密码密钥分为两部分：一部分记录列的顺序，另一部分记录在列中读取行的方向（向上或向下）。将列号作为字典的键，将读取方向作为字典的值。让程序与用户交互，逐个请求每一列的密钥值。解决方案可以在附录和在线文件 *key_dictionary_practice.py* 中找到。

#### ***自动化可能的密钥***

要尝试解密路径密码并使用路径中的任何列组合，你需要知道这些组合是什么，以便你可以将它们作为参数传递给解密函数。编写一个接受整数（例如列数）的 Python 程序，并返回一个元组集合。每个元组应包含列号的唯一排列，例如 (1, 2, 3, 4)。包括负值——例如 (2, -3, 4, -1)——以捕捉向上与向下的加密路径。附录中提供了一个解决方案，并且在本书的官方网站上提供了一个可下载的版本，文件名为 *permutations_practice.py*。

#### ***路径置换密码：暴力破解***

复制并修改 *route_cipher_decrypt.py* 程序来破解 [图 4-2](ch04.xhtml#ch04fig2) 中的路径密码。不要输入单一的密钥，而是循环遍历所有可能的密钥——假设列数已知——并打印结果（使用之前的排列代码生成四列密码的密钥）。[图 4-10](ch04.xhtml#ch04fig10) 清楚地展示了交换列的顺序和允许上下路径通过置换矩阵的影响。虚线表示列数的阶乘；实线表示通过列向上和向下读取的效果（通过在密钥中包含负值来捕捉）。如果你只需要处理4的阶乘，那么作为密码分析员的工作会很简单。但随着密码变得更长，可能的密钥数量急剧增加。实际上，一些联邦的路径密码包含10列或更多列！

![image](../images/f0089-01.jpg)

*图 4-10：路径密码中可能的密钥数与列数的关系*

这是从 [图 4-2](ch04.xhtml#ch04fig2) 中的密文产生的384种翻译中的四种：

使用密钥 = [-4, -1, -2, -3]

翻译结果 = IS HEADING FILLER VILLAGE YOUR SNOW SOUTH GODWIN ARE FREE TO YOU

WITH SUPPLIES GONE TRANSPORT ROANOKE JUST TO REST

使用密钥 = [1, 2, -3, 4]

翻译结果 = REST ROANOKE HEADING TO TRANSPORT WITH SNOW GONE YOU ARE FREE TO

GODWIN YOUR SUPPLIES SOUTH VILLAGE IS JUST FILLER

使用密钥 = [-1, 2, -3, 4]

翻译结果 = VILLAGE ROANOKE HEADING TO GODWIN WITH SNOW GONE YOU ARE FREE TO

TRANSPORT YOUR SUPPLIES SOUTH REST IS JUST FILLER

使用密钥 = [4, -1, 2, -3]

翻译结果 = IS JUST FILLER REST YOUR SUPPLIES SOUTH TRANSPORT ARE FREE TO YOU

WITH SNOW GONE GODWIN ROANOKE HEADING TO VILLAGE

正确答案已经出现，但你可以理解，在使用密码词和虚拟词的情况下，快速挑选出正确答案是多么困难。尽管如此，你已经完成了你的任务。去喝一杯薄荷朱勒普或些许甜茶吧。

这个项目的解决方案可以在附录中找到，也可以在 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)* 上找到，文件名为 *route_cipher_hacker.py*。你还需要 *perms.py* 程序，它基于之前的实践项目。

### **挑战项目**

挑战项目没有提供解决方案。

#### ***路线密码编码器***

一名菜鸟联邦电报员需要加密以下信息，且需使用密码词（[表格 4-1](ch04.xhtml#ch04tab1)）。帮助他们编写一个程序，输入消息后自动替换密码词，填充底行的虚拟词，并使用密钥 [-1, 3, -2, 6, 5, -4] 转置词汇。使用 6×7 的矩阵，并自创虚拟词。

我们将在 4 月 16 日晚上在维克斯堡部署电池，随后前往格兰德峡湾，在那里我们将削弱堡垒。请准备在 4 月 25 日或 29 日过河。海军上将波特。

**表格 4-1:** 密码词

| 电池 | 猎犬 |
| --- | --- |
| 维克斯堡 | 气味 |
| 四月 | CLAYTON |
| 16 | 甜美 |
| 格兰德 | 树 |
| 海湾 | 猫头鹰 |
| 堡垒 | 贝利 |
| 河流 | 山核桃 |
| 25 | 乘法 |
| 29 | 加法 |
| 海军上将 | HERMES |
| 波特 | LANGFORD |

考虑使用 Python 字典来表示此表中的密码词词汇表。

#### ***三排栅栏密码***

编写一个使用三排（行）而不是两排的铁路栅栏密码版本。你可以在 *[https://en.wikipedia.org/wiki/Rail_fence_cipher](https://en.wikipedia.org/wiki/Rail_fence_cipher)* 找到提示。
