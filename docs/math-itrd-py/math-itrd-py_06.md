## 4

用代数变换和存储数字

*“数学可以定义为我们永远不知道自己在谈论什么，也不知道我们说的是否真实的学科。”*

—伯特兰·罗素*

![image](img/fintro-01.jpg)

如果你在学校学过代数，你可能对用字母替代数字的概念很熟悉。例如，你可以写 2*x*，其中*x*是一个占位符，可以代表任何数字。所以 2*x*表示将 2 乘以某个未知数字的概念。在数学中

在课堂上，变量变成了“神秘数字”，你需要找到字母所代表的数字。Figure 4-1 展示了一个学生对“找到*x*”问题的顽皮回答。

![image](img/f053-01.jpg)

*Figure 4-1: 定位*x*变量，而不是求解其值*

正如你所看到的，这位学生在图中定位了变量*x*，而不是*求解*它的值。代数课的重点是解决像这样的方程：解 2*x* + 5 = 13。在这个上下文中，“求解”意味着找出哪个数字，当你把*x*替换成这个数字时，方程就成立。你可以通过平衡方程来解代数问题，这需要大量你必须记住并遵循的规则。

以这种方式使用字母作为占位符就像在 Python 中使用变量一样。事实上，你已经学会了如何在前几章中使用变量来存储和计算数值。数学学生应该学习的重要技能不是解变量的值，而是*使用*变量。事实上，手工解方程的价值是有限的。在本章中，你将使用变量编写程序，快速而自动地找到未知值，而不需要平衡方程！你还将学习使用名为 Processing 的编程环境，来绘制函数图像，帮助你以视觉方式探索代数。

### 解一元一次方程

解决像 2*x* + 5 = 13 这样的简单方程的一种方法是使用*暴力破解*（即随机代入数字直到找到正确的数字）。对于这个特定的方程，我们需要找出一个数字，*x*，当我们将其乘以 2 并加上 5 时，结果是 13。我将做一个有根据的猜测，认为*x*是介于−100 和 100 之间的数字，因为我们主要处理的是两位数或更小的数字。

这意味着我们可以编写一个程序，将介于−100 和 100 之间的所有整数代入方程，检查输出，并打印出使方程成立的数字。在 IDLE 中打开一个新文件，保存为*plug.py*，并输入 Listing 4-1 中的代码，来看到这个程序的实际运行效果。

def plug():

➊ x = -100 #从-100 开始

当 x < 100 时: #直到 100

➋ 如果 2*x + 5 == 13: #如果它使方程成立

print("x =",x) #输出结果

➌ x += 1 #让 x 增加 1 以测试下一个数字

plug() #运行 plug 函数

*Listing 4-1: 使用暴力破解的程序，通过代入数字查看哪个数字满足方程*

这里，我们定义了 plug()函数，并将 x 变量初始化为-100 ➊。在下一行，我们开始一个 while 循环，直到 x 等于 100，这是我们设定的范围的上限。然后我们将 x 乘以 2 并加上 5 ➋。如果输出等于 13，我们告诉程序打印这个数字，因为那就是解。如果输出不等于 13，我们告诉程序继续执行代码。

然后循环重新开始，程序测试下一个数字，我们通过将 x 增加 1 来得到这个数字 ➌。我们继续循环，直到找到匹配项。一定要包括最后一行，它会让程序运行我们刚才定义的 plug()函数；如果你不包括这一行，程序就不会做任何事情！输出应该是这样的：

x = 4

使用猜测和检验法是解决这个问题的完全有效的方法。手动插入所有数字可能很费力，但使用 Python 就轻松多了！如果你怀疑解不是整数，你可能需要通过更小的数字增量来调整，把 ➌行改为 x += .25 或其他小数值。

#### 求解一阶方程的公式

另一种解决像 2*x* + 5 = 13 这样的方程的方法是找到这种类型方程的通用公式。然后我们可以使用这个公式写一个 Python 程序。你可能还记得在数学课上，方程 2*x* + 5 = 13 是一个*一阶方程*的例子，因为在这个方程中变量的最高指数是 1。而且你可能知道，任何数的 1 次方等于它本身。

事实上，所有一阶方程都符合这个通用公式：a*x* + b = c*x* + d，其中 a、b、c 和 d 代表不同的数字。这里有一些其他一阶方程的例子：

![image](img/e055-01.jpg)

在等号的两边，你可以看到一个*x*项和一个*常数*，常数是没有*x*的数字。前面跟在*x*变量前面的数字叫做*系数*。例如，3*x*的系数是 3。

但有时候方程的一边根本没有*x*项，这意味着该*x*的系数为零。你可以在第一个例子中看到这一点，3*x* − 5 = 22，其中 22 是等号右侧唯一的项：

![image](img/e055-02.jpg)

使用通用公式，你可以看到 a = 3, b = −5, 和 d = 22。唯一缺失的似乎是 c 的值。但实际上它并不缺失。事实上，什么都没有意味着 c*x* = 0，这意味着 c 必须等于零。

现在让我们使用一些代数来解这个方程 a*x* + b = c*x* + d，求解*x*。如果我们能找到*x*的值，我们就可以用它来解所有这种形式的方程。

为了解这个方程，我们首先通过从方程两边减去 c*x*和 b，将所有*x*移到等号的一边，像这样：

a*x* − c*x* = d − b

然后我们可以将*x*从 a*x*和 c*x*中提取出来：

*x*(a − c) = d − b

最后，将两边同时除以 a − c 来孤立 *x*，这就得到了 *x* 关于 a、b、c 和 d 的值：

![image](img/e056-01.jpg)

现在，你可以使用这个一般方程在已知方程是一次方程且所有系数（a、b、c 和 d）已知的情况下，解出任何变量 *x*。我们来写一个 Python 程序，帮助我们解一次代数方程。

#### 编写 `equation()` 函数

要编写一个程序，接受一般方程的四个系数并输出 *x* 的解，首先在 IDLE 中打开一个新的 Python 文件，保存为 *algebra.py*。我们将编写一个函数，接受四个数字 a、b、c 和 d 作为参数，并将它们代入公式中（参见示例 4-2）。

def equation(a,b,c,d):

''''解方程的

形式 ax + b = cx + d''''

return (d - b)/(a - c)

*示例 4-2：使用编程求解 x*

记住，一次方程的一般公式是这样的：

![image](img/e056-02.jpg)

这意味着，对于任何形式为 a*x* + b = c*x* + d 的方程，如果我们将系数代入这个公式，就可以计算出 *x* 的值。首先，我们设置 `equation()` 函数来接收四个系数作为参数。然后我们使用表达式 (d - b)/(a − c) 来表示一般方程。

现在让我们用你已经看到的方程进行测试：2*x* + 5 = 13。打开 Python shell，在 >>> 提示符下输入以下代码，然后按回车键：

>>> equation(2,5,0,13)

4.0

如果你将这个方程的系数输入到函数中，你会得到 4 作为解。你可以通过将 4 代入 *x* 来确认它是正确的。它能工作！

练习 4-1：解更多关于 x 的方程

使用你在示例 4-2 中编写的程序解方程 12x + 18 = –34x + 67。

#### 使用 `print()` 代替 `return`

在示例 4-2 中，我们使用了 `return` 而不是 `print()` 来显示结果。因为 `return` 会给我们一个数字结果，可以将其赋值给变量并再次使用。示例 4-3 展示了如果我们使用 `print()` 而不是 `return` 来求解 *x* 时会发生什么：

def equation(a,b,c,d):

''''解方程的

形式 ax + b = cx + d''''

print((d - b)/(a − c))

*示例 4-3：使用 `print()` 无法保存输出*

当你运行这个时，你会得到相同的输出：

>>> x = equation(2,5,0,13)

4.0

>>> print(x)

无

但是，当你尝试使用 `print()` 调用 x 值时，程序无法识别你的命令，因为它没有保存结果。正如你所看到的，`return` 在编程中更有用，因为它允许你保存函数的输出结果，这样你就可以在其他地方使用它。这就是我们在示例 4-2 中使用 `return` 的原因。

要查看如何使用返回的输出，使用练习 4-1 中的方程 12*x* + 18 = −34*x* + 67，并将结果赋值给 x 变量，如下所示：

>>> x = equation(12,18,-34,67)

>>> x

1.065217391304348

首先，我们将方程的系数和常数传递给`equation()`函数，使其为我们求解方程并将解赋值给变量 x。然后我们只需输入 x 就能看到其值。现在，变量 x 已经存储了解，我们可以将其代回方程中检查它是否是正确的答案。

输入以下内容，看看 12*x* + 18，即方程左侧的值，是多少：

>>> 12*x + 18

30.782608695652176

我们得到 30.782608695652176。现在输入以下内容，做同样的操作来求解−34*x* + 67，即方程右侧的值：

>>> -34*x + 67

30.782608695652172

除了在第 15 位小数处有轻微的四舍五入差异，你可以看到方程的两边都约等于 30.782608。所以我们可以确信，1.065217391304348 确实是*x*的正确解！幸好我们返回了解并保存了这个值，而不是仅仅打印出来一次。毕竟，谁愿意一遍又一遍地输入像 1.065217391304348 这样的数字呢？

练习 4-2：系数为分数的方程

使用`equation()`函数来解你在第 55 页看到的最后一个看起来最棘手的方程：

![image](img/e058-01.jpg)

### 求解高次方程

现在你知道如何编写程序来解一元一次方程中的未知数，让我们来试试更复杂的内容。例如，当方程中有二次项时，事情就变得有些复杂，比如*x*² + 3*x* − 10 = 0。这些被称为*二次方程*，它们的一般形式是 a*x*² + b*x* + c = 0，其中 a、b 和 c 可以是任意数字：正数或负数、整数、分数或小数。唯一的例外是 a 不能为 0，因为这会使得方程变成一元一次方程。与只有一个解的一元一次方程不同，二次方程有两个可能的解。

为了解带有平方项的方程，你可以使用*二次公式*，这是通过将方程 a*x*² + b*x* + c = 0 中的*x*孤立出来得到的：

![image](img/e058-02.jpg)

二次公式是一个非常强大的解方程工具，因为无论 a、b 和 c 在 a*x*² + b*x* + c = 0 中是什么值，你都可以将它们代入公式，并使用基本的算术运算来找到解。

我们知道，方程*x*² + 3*x* − 10 = 0 的系数分别是 1、3 和−10。当我们将这些值代入公式时，得到：

![image](img/e059-01.jpg)

将*x*孤立，简化为：

![image](img/e059-02.jpg)

有两个解：

![image](img/e059-03.jpg)

其值为 2，并且

![image](img/e059-04.jpg)

其值为−5。

我们可以看到，将二次方程式中的*x*替换为这些解中的任意一个，可以使方程成立：

(*2*)² + 3(*2*) − 10 = 4 + 6 − 10 = 0

(*−5*)² + 3(*−5*) − 10 = 25 − 15 − 10 = 0

接下来，我们将编写一个函数，使用这个公式返回任何二次方程的两个解。

#### 使用 QUAD() 求解二次方程

假设我们想用 Python 求解以下二次方程：

2*x*² + 7*x* − 15 = 0

为了实现这一点，我们将编写一个名为 quad() 的函数，该函数接受三个系数（a、b 和 c）并返回两个解。但在开始之前，我们需要导入 math 模块中的 sqrt 方法。sqrt 方法可以帮助我们在 Python 中计算平方根，就像计算器上的平方根按钮一样。它对正数很好用，但如果你尝试对负数求平方根，就会出现如下错误：

>>> from math import sqrt

>>> sqrt(-4)

Traceback (most recent call last):

文件 "<pyshell#11>"，第 1 行，在 <module> 中：

sqrt(-4)

ValueError: 数学域错误

在 IDLE 中打开一个新的 Python 文件，并命名为 *polynomials.py*。在文件顶部添加以下行以导入 math 模块中的 sqrt 函数：

from math import sqrt

然后在 清单 4-4 中输入代码，创建 quad() 函数。

def quad(a,b,c):

''''返回方程的解

形式为 a*x**2 + b*x + c = 0''''

x1 = (-b + sqrt(b**2 - 4*a*c))/(2*a)

x2 = (-b - sqrt(b**2 - 4*a*c))/(2*a)

return x1,x2

*清单 4-4：使用二次公式求解方程*

quad() 函数接受 a、b 和 c 这三个数字作为参数，并将它们代入二次公式中。我们使用 x1 来存储第一个解的结果，x2 将存储第二个解的值。

现在，让我们测试这个程序来求解 2*x*² + 7*x* − 15 = 0 中的 *x*。将 2、7 和 −15 代入 a、b 和 c 应该返回以下输出：

>>> quad(2, 7, -15)

(1.5, -5.0)

如你所见，*x* 的两个解是 1.5 和 −5，这意味着这两个值应该都满足方程 2*x*² + 7*x* − 15 = 0。为了验证这一点，先将第一个解 1.5 代入原方程 2*x*² + 7*x* − 15 = 0，再将第二个解 −5 代入，结果如下所示：

>>> 2*1.5**2 + 7*1.5 - 15

0.0

>>> 2*(-5)**2 + 7*(-5) - 15

0

成功！这确认了这两个值在原方程中都成立。以后你可以随时使用 equation() 和 quad() 函数。现在你已经学会了如何写函数来求解一阶和二阶方程，接下来我们来讨论如何求解更高阶的方程！

#### 使用 PLUG() 求解三次方程

在代数课上，学生们常常被要求求解像 6*x*³ + 31*x*² + 3*x* − 10 = 0 这样的 *三次方程*，它包含了一个三次项。我们可以修改在 清单 4-1 中编写的 plug() 函数，使用暴力法来求解这个三次方程。在 IDLE 中输入 清单 4-5 中的代码，看看实际效果。

*plug.py*

def g(x):

return 6*x**3 + 31*x**2 + 3*x − 10

def plug():

x = -100

while x < 100:

如果 g(x) == 0：

print("x =", x)

x += 1

print("done.")

*清单 4-5：使用 plug() 求解三次方程*

首先，我们定义 g(x)为一个函数，计算表达式 6*x**3 + 31*x**2 + 3*x − 10，即我们的三次方程的左边。然后我们告诉程序将所有−100 到 100 之间的数字代入我们刚定义的 g(x)函数中。如果程序找到一个使得 g(x)等于零的数字，那么它就找到了一个解，并将其打印出来。

当你调用 plug()时，你应该看到以下输出：

>>> plug()

x = −5

完成。

这给出的解是−5，但正如你之前处理二次方程时可能猜到的那样，*x*³项意味着这个方程可能有多达三个解。正如你所看到的，你可以通过暴力破解的方式找到解，但你无法确定是否存在其他解，或者它们是什么。幸运的是，有一种方法可以查看函数的所有可能输入及其对应的输出；这叫做*图形化*。

### 通过图形化解决方程

在本节中，我们将使用一个叫做 Processing 的巧妙工具来图形化处理高次方程。这个工具将帮助我们以有趣且直观的方式找到高次方程的解！如果你还没有安装 Processing，请按照第 xxiii 页中的“安装 Processing”说明进行安装。

#### 开始使用 Processing

Processing 是一个编程环境和图形库，它使得可视化代码变得非常容易。你可以在* [`processing.org/examples/`](https://processing.org/examples/)*的示例页面上看到你可以用 Processing 制作的炫酷、动态、互动艺术。你可以把 Processing 看作是一个程序设计创意的草图本。事实上，每个你创建的 Processing 程序都叫做*草图*。图 4-2 展示了 Python 模式下一个简短 Processing 草图的样子。

![image](img/f062-01.jpg)

*图 4-2：Processing 草图示例*

如你所见，这是一个编程环境，你在其中输入代码，另有一个*显示窗口*用于展示代码的可视化效果。这是一个简单程序的草图，创建了一个小圆圈。我们将要创建的每一个 Processing 草图都会包含两个 Processing 的内置函数：setup()和 draw()。我们在 setup()函数中写的代码会在你点击播放按钮后运行一次，播放按钮位于界面左上角。我们在 draw()中写的代码会无限循环执行，直到你点击播放按钮旁边的停止按钮。

在图 4-2 中，你可以看到在 setup()函数中我们使用 size()函数声明了显示屏的大小为 600 像素×600 像素。在 draw()函数中，我们告诉程序使用 ellipse()函数绘制一个圆圈。在哪里绘制？多大？我们需要告诉 ellipse()函数四个数字：椭圆的 x 坐标、y 坐标、宽度和高度。

注意，圆形出现在屏幕的中央，在数学课上这就是*原点*（0,0）。但在 Processing 和许多其他图形库中，（0,0）位于屏幕的左上角。因此，要将圆形放在中间，我必须将窗口的长度（600）和宽度（600）各除以 2。所以它的位置是（300,300），而不是（0,0）。

Processing 有许多函数，如 ellipse()，可以方便地绘制形状。要查看完整的函数列表，可以访问* [`processing.org/reference/`](https://processing.org/reference/)*，在那里你可以找到用于绘制椭圆、三角形、矩形、弧形等形状的函数。在下一章中，我们将详细探讨如何使用 Processing 绘制形状。

**注意**

*Processing 中的代码颜色与 IDLE 中的颜色有所不同。例如，你可以看到在图 4-2 中，def 在 Processing 中显示为绿色，而在 IDLE 中则为橙色*。

#### 创建你自己的绘图工具

现在你已经下载了 Processing，让我们用它创建一个绘图工具，让我们能够看到一个方程有多少解。首先，我们创建一个蓝色线条的网格，看起来像绘图纸。然后，我们用黑线创建 x 轴和 y 轴。

##### 设置图表尺寸

为了制作我们的绘图工具网格，首先需要设置显示窗口的尺寸。在 Processing 中，可以使用 size()函数来指定屏幕的宽度和高度（以像素为单位）。默认的屏幕尺寸为 600 像素乘 600 像素，但为了我们的绘图工具，我们将创建一个 x 值和 y 值范围从−10 到 10 的图表。

打开 Processing 中的新文件，并将其保存为*grid.pyde*。确保你处于 Python 模式。输入清单 4-6 中的代码，声明我们希望在图表中显示的 x 值和 y 值的范围。

*grid.pyde*

#设置 x 值的范围

xmin = -10

xmax = 10

#y 值的范围

ymin = -10

ymax = 10

#计算范围

rangex = xmax - xmin

rangey = ymax - ymin

def setup():

size(600,600)

*清单 4-6：设置图表的 x 值和 y 值范围*

在清单 4-6 中，我们创建了两个变量 xmin 和 xmax，分别表示网格中的最小和最大 x 值，然后对 y 值执行相同的操作。接着，我们声明 rangex 作为 x 值范围，rangey 作为 y 值范围。我们通过从 xmax 中减去 xmin 来计算 rangex 的值，对 y 值也执行同样的操作。

因为我们不需要一个 600 单位乘 600 单位的图表，所以我们需要通过将 x 和 y 坐标乘以比例因子来缩放坐标。在绘图时，我们必须记得将所有的 x 坐标和 y 坐标乘以这些比例因子，否则它们将无法正确显示在屏幕上。为此，请在 setup()函数中更新现有代码，使用清单 4-7 中的代码行。

*grid.pyde*

def setup()

global xscl, yscl

size(600,600)

xscl = width / rangex

yscl = -height / rangey

*Listing 4-7: 使用缩放因子缩放坐标*

首先，我们声明全局变量 xscl 和 yscl，稍后我们将用它们来缩放我们的屏幕。xscl 和 yscl 分别表示 x 缩放因子和 y 缩放因子。例如，如果我们希望 x 范围是 600 像素，或屏幕的完整宽度，那么 x 缩放因子就是 1。但如果我们希望屏幕范围在−300 到 300 之间，那么 x 缩放因子将是 2，这是通过将宽度（600）除以范围 x（300）得到的。

在我们的例子中，我们可以通过将 600 除以 x 范围（20，范围是从−10 到 10）来计算缩放因子。所以，缩放因子必须是 30。从现在开始，我们需要将所有的 x 和 y 坐标按 30 的比例缩放，以便它们能在屏幕上显示。好消息是，计算机会为我们做所有的除法和缩放。我们只需要记得在绘图时使用 xscl 和 yscl！

##### 绘制网格

现在我们已经为图形设置了合适的尺寸，可以像绘制图纸上的网格线一样绘制网格线。setup()函数中的所有内容都会被执行一次。然后，我们创建一个无限循环，使用一个名为 draw()的函数。setup()和 draw()是 Processing 的内置函数，如果你希望草图能够运行，不能更改它们的名称。添加 Listing 4-8 中的代码来创建 draw()函数。

*grid.pyde*

#设置 x 值的范围

xmin = -10

xmax = 10

#y 值的范围

ymin = -10

ymax = 10

#计算范围

rangex = xmax - xmin

rangey = ymax - ymin

def setup():

global xscl, yscl

size(600,600)

xscl = width / rangex

yscl = height / rangey

def draw():

global xscl, yscl

background(255) #白色

translate(width/2,height/2)

#青色线条

strokeWeight(1)

stroke(0,255,255)

for i in range(xmin, xmax + 1):

line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)

line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)

*Listing 4-8: 创建图形的蓝色网格线*

首先，我们使用全局的 xscl、yscl 告诉 Python 我们不是创建新的变量，而是使用我们已经创建的全局变量。然后，我们使用值 255 将背景颜色设置为白色。我们使用 Processing 的 translate()函数来移动图形，可以上下移动，也可以左右移动。代码 translate(width/2,height/2)将原点（x 和 y 都是 0）从左上角移到屏幕中心。接着，我们用 strokeWeight 设置线条的粗细，1 是最细的。如果你想要更粗的线条，可以使用更高的数字。你也可以通过使用 stroke 改变线条的颜色。在这里，我们使用的是青色（“天蓝色”），其 RGB 值为(0,255,255)，这意味着没有红色值，最大绿色和最大蓝色。

然后，我们使用 for 循环来避免键入 40 行代码来绘制 40 条蓝色线条。我们希望蓝色线条从 xmin 延伸到 xmax，包括 xmax，因为这就是我们图形应该的宽度。

RGB 值

RGB 值是红、绿、蓝的混合，顺序为红、绿、蓝。它们的值范围是 0 到 255。例如，（255,0,0）表示“最大红色，没有绿色，没有蓝色。”黄色是红色和绿色的混合，青色（“天蓝色”）是绿色和蓝色的混合。

![image](img/f065-01.jpg)

其他颜色是不同等级的红、绿、蓝的混合：

![image](img/f065-02.jpg)

你可以通过网上搜索“RGB Tables”来获取更多颜色的 RGB 值！

在 Processing 中，你可以通过声明四个数字来绘制一条线：线的起点和终点的 x 和 y 坐标。竖直的线会像这样：

line(-10,-10, -10,10)

line(-9,-10, -9,10)

line(-8,-10, -8,10)

但是因为 range(x)不包括 x（正如你之前学到的），我们的 for 循环需要从 xmin 到 xmax + 1，以包括 xmax。

同样，水平线会像这样：

line(-10,-10, 10,-10)

line(-10,-9, 10,-9)

line(-10,-8, 10,-8)

这次，你可以看到 y 值是−10，−9，−8，以此类推，而 x 值保持不变，分别是−10 和 10，它们是 xmin 和 xmax。让我们再添加一个循环，从 ymin 到 ymax：

for i in range(xmin,xmax+1):

line(i,ymin,i,ymax)

for i in range(ymin,ymax+1):

line(xmin,i,xmax,i)

如果你正确地绘制了这个图形，你现在应该能在屏幕中央看到一个小的斑点，因为 x 轴和 y 轴的坐标范围是从−10 到 10，而屏幕的默认显示范围是从 0 到 600。这是因为我们还没有将所有的 x 轴和 y 轴坐标乘以它们的缩放因子！为了正确显示网格，请按照以下步骤更新代码：

for i in range(xmin,xmax+1):

line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)

for i in range(ymin,ymax+1):

line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)

现在你准备好创建 x 轴和 y 轴了。

##### 创建 X 轴和 Y 轴

为了添加 x 轴和 y 轴的两条黑色线条，我们首先通过调用 stroke()函数将描边颜色设置为黑色（0 为黑色，255 为白色）。然后我们从(0,−10)到(0,10)画一条垂直线，从(−10,0)到(10,0)画一条水平线。别忘了将这些值乘以它们各自的缩放因子，除非它们是 0，这样乘上去也不会改变。

清单 4-9 显示了创建网格的完整代码。

*grid.pyde*

#青色线条

strokeWeight(1)

stroke(0,255,255)

for i in range(xmin,xmax+1):

line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)

for i in range(ymin,ymax+1):

line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)

stroke(0) #黑色坐标轴

line(0,ymin*yscl,0,ymax*yscl)

line(xmin*xscl,0,xmax*xscl,0)

*清单 4-9：创建网格线条*

当你点击**运行**时，你应该能看到一个漂亮的网格，像图 4-3 一样。

![image](img/f067-01.jpg)

*图 4-3：你已经创建了一个用于绘制图表的网格—而且只需要做一次！*

这看起来已经完成了，但如果我们尝试在(3,6)处放置一个点（实际上是一个小椭圆），我们会看到一个问题。将以下代码添加到 draw()函数的末尾：

*grid.pyde*

#test with a circle

fill(0)

ellipse(3*xscl,6*yscl,10,10)

运行时，你将在 图 4-4 中看到输出。

![图片](img/f067-02.jpg)

*图 4-4：检查我们的绘图程序。快到了！*

正如您所见，点位于 (3,−6) 而不是 (3,6)。我们的图形是颠倒的！为了修正这个问题，我们可以在 setup() 函数中的 y 轴比例因子前面加一个负号来翻转它：

yscl = -height/rangey

现在，您应该能看到正确位置的点，就像在 图 4-5 中一样。

![图片](img/f068-01.jpg)

*图 4-5：绘图器正常工作！*

现在我们已经编写了绘图工具，让我们将其放入一个函数中，这样我们可以在需要绘制方程时重复使用它。

##### 编写 grid() 函数

为保持代码的整洁，我们将所有创建网格的代码放入一个名为 grid() 的单独函数中，并在 draw() 函数中调用 grid() 函数，就像在 代码清单 4-10 中一样。

*grid.pyde*

def draw():

全局 xscl, yscl

background(255)

translate(width/2,height/2)

grid(xscl,yscl) #绘制网格

def grid(xscl,yscl):

#为绘图绘制网格

#青色线

strokeWeight(1)

stroke(0,255,255)

for i in range(xmin,xmax+1):

line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)

for i in range(ymin,ymax+1):

line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)

stroke(0) #黑色轴线

line(0,ymin*yscl,0,ymax*yscl)

line(xmin*xscl,0,xmax*xscl,0)

*代码清单 4-10：将所有网格代码移至单独的函数中*

在编程中，我们经常将代码组织成函数。请注意在 代码清单 4-10 中，我们可以轻松看到我们在 draw() 函数中执行的内容。现在我们准备解决我们的三次方程，6*x*³ + 31*x*² + 3*x* − 10 = 0。

#### 绘制方程图

绘制图形是一种有趣且视觉化的方法，用于找出具有多个潜在解的多项式方程的解 *x*。但在我们尝试绘制像 6*x*³ + 31*x*² + 3*x* − 10 = 0 这样复杂的方程之前，让我们先绘制一个简单的抛物线。

##### 绘制点

在 代码清单 4-10 的 draw() 函数之后添加此函数：

*grid.pyde*

def f(x):

return x**2

这定义了我们正在调用的函数 f(x)。我们告诉 Python 如何处理数字 *x* 以生成函数的输出。在这种情况下，我们告诉它对数字 *x* 进行平方运算并返回输出。数学课程传统上称函数为 f(x)、g(x)、h(x) 等。使用编程语言，您可以根据需要命名函数！我们本可以为这个函数取一个描述性的名字，比如 parabola(x)，但由于 f(x) 常用，我们现在就坚持使用这个名字。

这是一个简单的抛物线，我们将在深入研究更复杂的函数之前绘制它。曲线上的所有点只是 x 值及其对应的 y 值。我们可以使用循环在所有整数 x 值的点上绘制小椭圆，但那样看起来会像是一组不连贯的点，如同图 4-6 所示。

![image](img/f069-01.jpg)

*图 4-6：不连贯点的图形*。

使用不同种类的循环，我们可以将点绘得更紧凑，如同图 4-7 所示。

![image](img/f070-01.jpg)

*图 4-7：点之间更靠近，但仍然不像一个有说服力的曲线*。

绘制连接曲线的最佳方法是从一个点绘制到下一个点。如果点之间足够接近，它们看起来会是弯曲的。首先，我们将在 f(x)之后创建一个 graphFunction()函数。

##### 连接点

在 graphFunction()函数中，像这样从 xmin 开始 x 值：

*grid.pyde*

def graphFunction():

x = xmin

为了让图形覆盖整个网格，我们将不断增加 x 值，直到它等于 xmax。这意味着我们将持续这个循环，“只要 x 小于或等于 xmax”，如这里所示：

def graphFunction():

x = xmin

while x <= xmax:

为了绘制曲线本身，我们将从每个点绘制到下一个点，每次上升十分之一单位。即使我们的函数生成了曲线，你可能也不会注意到我们在绘制两个非常接近的点之间的直线。例如，(2, f(2))到(2.1, f(2.1))的距离非常小，所以最终的输出看起来是弯曲的。

def graphFunction():

x = xmin

while x <= xmax:

fill(0)

line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)

x += 0.1

这段代码定义了一个函数，通过从 xmin 开始一直到 xmax 来绘制 f(x)的图形。当 x 值小于或等于 xmax 时，我们将绘制一条从(x, f(x))到((x + 0.1), f(x + 0.1))的线。我们不能忘记在循环结束时将 x 增加 0.1。

列表 4-11 展示了*grid.pyde*的完整代码。

*grid.pyde*

#设定 x 值范围

xmin = -10

xmax = 10

#y 值范围

ymin = -10

ymax = 10

#计算范围

rangex = xmax - xmin

rangey = ymax - ymin

def setup():

global xscl, yscl

size(600,600)

xscl = width / rangex

yscl = -height / rangey

def draw():

global xscl, yscl

background(255) #白色

translate(width/2,height/2)

grid(xscl,yscl)

graphFunction()

def f(x):

return x**2

def graphFunction():

x = xmin

while x <= xmax:

fill(0)

line(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)

x += 0.1

def grid(xscl, yscl):

#为绘制图形绘制网格

#青色线条

strokeWeight(1)

stroke(0,255,255)

for i in range(xmin,xmax+1):

line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)

for i in range(ymin,ymax+1):

line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)

stroke(0) #黑色坐标轴

line(0,ymin*yscl,0,ymax*yscl)

line(xmin*xscl,0,xmax*xscl,0)

*列表 4-11：绘制抛物线的完整代码*

这为我们提供了所需的曲线，如图 4-8 所示。

![image](img/f072-01.jpg)

*图 4-8：漂亮的连续抛物线图！*

现在我们可以将函数改成更复杂的形式，绘图程序会轻松绘制出来：

*grid.pyde*

def f(x):

return 6*x**3 + 31*x**2 + 3*x − 10

通过这个简单的修改，你会看到图 4-9 中的输出，不过函数将显示为黑色。如果你更喜欢红色曲线，只需将 graphFunction() 中的 stroke(0) 行改为 stroke(255,0,0)，你就会看到红色曲线。

![image](img/f072-02.jpg)

*图 4-9：绘制多项式函数*

只需修改 f() 函数中的一行，就能让程序自动绘制不同的函数，真是太棒了！方程的解（称为 *根*）是图像与 x 轴交点的位置。我们可以看到三个位置：一个是在 *x* = −5，另一个是在 −1 和 0 之间，第三个是在 0 和 1 之间。

#### 使用猜测和检查方法来寻找根

我们已经在第三章中看到，猜测和检查方法在猜数字时是多么有效。现在，我们可以用它来近似方程 6*x³ + 31*x² + 3*x − 10 = 0 的根或解。让我们从 0 和 1 之间的根开始。它是 0.5 还是别的什么？为了测试这个，我们可以轻松地将 0.5 代入方程中。创建一个新的 IDLE 文件，将其命名为 *guess.py*，并输入以下代码：

*guess.py*

def f(x):

return 6*x**3 + 31*x**2 + 3*x − 10

>>> f(0.5)

0.0

正如你所看到的，当 *x* 等于 0.5 时，它使得函数的值等于 0，因此我们的方程的另一个解是 *x* = 0.5。

接下来，让我们尝试找到 −1 和 0 之间的根。我们将先尝试 −1 和 0 的平均值：

>>> f(-0.5)

-4.5

在 *x* = −0.5 时，函数值为负数，而不是零。通过观察图像，我们可以看出我们的猜测太高了，因此根必须位于 −1 和 −0.5 之间。我们将这两个端点取平均值，再试一次：

>>> f(-0.75)

2.65625

我们得到一个正数，所以我们的猜测太低了。因此，解必须在 −0.75 和 −0.5 之间：

>>> f(-0.625)

-1.23046875

仍然太高了。这个过程有点乏味。让我们看看如何利用 Python 来完成这些步骤。

#### 编写 guess() 函数

让我们创建一个函数，通过平均较低和较高的值并相应调整下一次猜测来找到方程的根。这对于我们当前的任务是有效的，在此任务中，函数从正值过渡到负值。对于一个上升的函数，从负值到正值，我们需要稍微调整一下。列表 4-12 展示了这个函数的完整代码。

'''猜测方法'''

def f(x):

return 6*x**3 + 31*x**2 + 3*x - 10

def average(a,b):

return (a + b)/2.0

def guess():

lower = -1

upper = 0

➊ for i in range(20):

midpt = average(lower,upper)

if f(midpt) == 0:

return midpt

elif f(midpt) < 0:

upper = midpt

否则：

lower = midpt

return midpt

x = guess()

print(x,f(x))

*列表 4-12：解方程的猜测方法*

首先，我们声明我们尝试求解的方程的函数 f(x)。然后我们创建 average()函数来找到两个数字的平均值，这将在每一步中使用。最后，我们编写一个 guess()函数，初始的下限为−1，上限为 0，因为这是我们的图形与 x 轴交叉的地方。

然后我们使用 for i in range(20): ➊来创建一个循环，将范围每次减半 20 次。我们的猜测将是上下限的平均值，或中点。我们将这个中点代入 f(x)，如果输出为 0，我们知道这就是我们的根。如果输出为负数，我们知道猜得太高了。然后中点将替代我们的上限，我们会再猜一次。否则，如果我们猜得太低，中点将成为我们的下限，我们会再次猜测。

如果我们在 20 次猜测内没有找到解，我们就返回最新的中点及该中点的函数值。

当我们运行这个时，我们应该得到两个值作为输出：

-0.6666669845581055 9.642708896251406e-06

第一个输出是 x 值，它非常接近−2/3。第二个输出是当我们将−2/3 代入 x 值时 f(x)的值。结尾的 e-06 是科学计数法，表示将 9.64 的小数点向左移动六位。因此，f(x)的值是 0.00000964，接近于零。通过这个猜测与检查的程序，并在不到一秒钟的时间内获得这个解，或者说是一个精确到实际解的百万分之一的近似值，依然让我感到惊讶和欣喜！你能感受到使用像 Python 和 Processing 这样的免费软件来探索数学问题的强大吗？

如果我们将迭代次数从 20 次增加到 40 次，我们会得到一个更接近 0 的数字：

-0.6666666666669698 9.196199357575097e-12

让我们检查 f(-0.6666666666669698)，即 f(-2/3)：

>>> f(-2/3)

0.0

这是正确的，所以 6*x*³ + 31*x*² + 3*x* − 10 = 0 的三个解是*x* = −5, −2/3 和 1/2。

练习 4-3：寻找更多的根

使用你刚刚创建的图形工具来找出 2x² + 7x − 15 = 0 的根。记住，根是图形与 x 轴交叉的地方，或者说是函数等于 0 的地方。用你的 quad()函数来检查答案。

### 总结

数学课曾经是关于学习如何解高次方程，花费了许多年。 在这一章，你学会了使用我们的猜测与检查方法，在程序中并不难做到这一点。你还编写了使用其他方法解方程的程序，比如使用二次方程公式和图形法。事实上，你已经学会了解方程的解决方法，不论它有多复杂，只需要绘制它的图形并估算它在哪里与 x 轴交叉。通过迭代并不断缩小有效值的范围，我们可以得到任何我们想要的精度。

在编程中，我们使用代数来创建变量，表示会变化的值，例如对象的大小或坐标。用户可以在一个地方修改变量的值，程序会自动在整个程序中更新该变量的值。用户还可以通过循环改变这些变量，或者在函数调用中声明变量的值。在后续章节中，我们将模拟现实生活中的情境，在这些情境中，我们需要使用变量来表示模型中的参数和约束条件，例如能量含量和重力。使用变量使我们能够轻松地改变值，从而改变模型的不同方面。

在下一章，你将使用 Processing 来创建交互式图形，比如旋转的三角形和多彩的网格！
