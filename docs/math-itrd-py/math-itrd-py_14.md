## 11

元胞自动机

*我喜欢把加湿器和除湿器放在同一个房间里，让它们互相“争斗”。*

—史蒂文·赖特*

![image](img/fintro-01.jpg)

数学方程式是建模我们可以测量的事物的强大工具；毕竟，方程式还让我们登上了月球。但尽管它们很强大，在生物学和社会科学中，它们的应用是有限的，因为生物体的生长并不是根据方程式来进行的。

生物体在许多其他生物体的环境中生长，并在一天内进行无数次互动。这些互动的网络决定了事物将如何生长，而方程式往往无法捕捉这种复杂的关系。方程式可以帮助我们计算单一互动或反应所转换的能量或质量，但要模拟一个生物系统，比如说，你必须重复计算数百次甚至上千次。

幸运的是，有一个工具可以模拟细胞、生物体和其他生物系统如何根据环境生长和变化。由于它们与独立的生物体相似，这些模型被称为*元胞自动机 (CAs)*。术语*自动机*指的是能够自主运行的东西。图 11-1 展示了使用计算机生成的两个元胞自动机的例子。

![image](img/f226-01.jpg)

*图 11-1：一个基础元胞自动机的例子，屏幕上充满了虚拟生物*

本章中我们将创建的元胞自动机是由*细胞*组成的网格。每个元胞自动机中的细胞都有若干*状态*（例如，开/关、存活/死亡或有色/空白）。细胞根据其邻居的状态变化，从而像活的生物一样生长和变化！

元胞自动机自 1940 年代以来就成为了研究的主题，但它们真正兴起是在计算机变得更加普及之后。事实上，元胞自动机实际上只能通过计算机来研究，因为尽管它们遵循非常简单的规则，例如“如果一个生物体没有足够的邻居，它就会死亡”，这些规则只有在创建了数百或数千个这些生物体并让它们运行数百或数千代时，才能产生有用的结果。

由于数学是模式的研究，元胞自动机这一数学主题充满了有趣的思想、编程挑战，以及无尽的美丽输出可能！

### 创建一个元胞自动机

打开一个新的 Processing 草图，并命名为*cellularAutomata.pyde*。我们从一个方格网格开始，在其中放置我们的细胞。我们可以轻松绘制一个 10×10 的 20 大小的正方形网格，如示例 11-1 所示。

*cellular Automata.pyde*

def setup():

size(600,600)

def draw():

for x in range(10):

for y in range(10):

rect(20*x,20*y,20,20)

*示例 11-1：创建一个正方形网格*

保存并运行这个草图，你应该能看到像图 11-2 中显示的网格。

![image](img/f227-01.jpg)

*图 11-2：一个 10 × 10 的网格*

然而，每次我们想要更大的单元格（例如）或一个不同尺寸的网格时，我们都需要更改一堆数字。因此，如果我们使用变量，稍后更改起来就会容易得多。因为图形窗口已经存在关键字 height、width 和 size，所以我们必须使用不同的变量名。清单 11-2 通过创建一个易于调整大小的网格来改进清单 11-1，而且这些网格的单元格也很容易调整大小——这一切都是通过使用变量实现的。

*cellular Automata.pyde*

GRID_W = 15

GRID_H = 15

#单元格大小

SZ = 18

def setup():

size(600,600)

def draw():

for c in range(GRID_W): #列

for r in range(GRID_H): #行

rect(SZ*c,SZ*r,SZ,SZ)

*清单 11-2：使用变量改进的网格程序*

我们为网格的高度（GRID_H）和宽度（GRID_W）创建了变量，使用全大写字母表示这些是常量，并且它们的值不会改变。单元格的大小也是常量（目前如此），因此在声明其初始值时，我们也将其大写（SZ）。现在，当你运行这段代码时，应该会看到一个更大的网格，就像图 11-3 中显示的那样。

![image](img/f228-01.jpg)

*图 11-3：使用变量创建的更大网格*

#### 编写单元格类

我们需要编写一个类，因为我们创建的每个单元格都需要有自己的位置、状态（“开”或“关”）、邻居（它旁边的单元格）等等。我们通过添加在清单 11-3 中显示的代码来创建 Cell 类。

*cellular Automata.pyde*

#单元格大小

SZ = 18

class Cell:

def __init__(self,c,r,state=0):

self.c = c

self.r = r

self.state = state

def display(self):

如果 self.state == 1:

fill(0) #黑色

else:

fill(255) #白色

rect(SZ*self.r,SZ*self.c,SZ,SZ)

*清单 11-3：创建 Cell 类*

单元格的初始状态属性是 0（或关闭）。在 __init__ 方法的参数中，state=0 表示如果我们没有指定状态，则默认状态为 0。display()方法只是告诉 Cell 对象如何在屏幕上显示自己。如果状态为“开”，单元格为黑色；否则，它为白色。此外，每个单元格都是正方形的，我们需要通过将它们的列和行号乘以它们的大小（self.SZ）来分散这些单元格。

在 draw()函数之后，我们需要编写一个函数，创建一个空列表来存放我们的 Cell 对象，并使用嵌套循环将这些 Cell 对象添加到列表中，而不是像之前一样逐一绘制它们，这在清单 11-4 中有展示。

*cellular Automata.pyde*

def createCellList():

'''创建一个包含关闭状态单元格的大列表

中心的单元格状态为开启'''

➊ newList=[]#用于存储单元格的空列表

#填充初始单元格列表

for j in range(GRID_H):

➋ newList.append([]) #添加空行

for i in range(GRID_W):

➌ newList [j].append(Cell(i,j,0)) #添加关闭状态的单元格或零

#中心单元格设置为开启

➍ newList [GRID_H//2][GRID_W//2].state = 1

return newList

*清单 11-4：创建单元格列表的函数*

首先，我们创建一个空列表，命名为 newList ➊，并添加一个空列表作为行 ➋，待填充 Cell 对象 ➌。然后，我们通过将行数和列数各自除以 2（双斜杠表示整数除法）来获取中心单元格的索引，并将该单元格的状态属性设置为 1（或“开启”） ➍。

在 setup()中，我们将使用 createCellList()函数，并声明 cellList 为全局变量，这样它就可以在 draw()函数中使用。最后，在 draw()中，我们将遍历 cellList 中的每一行并进行更新。新的 setup()和 draw()函数如示例 11-5 所示。

def setup():

global cellList

size(600,600)

cellList = createCellList()

def draw():

for row in cellList:

for cell in row:

cell.display()

*示例 11-5: 用于创建网格的新的 setup()和 draw()函数*

然而，当我们运行这段代码时，我们会得到一个显示窗口角落中较小单元格的网格，如图 11-4 所示。

![image](img/f230-01.jpg)

*图 11-4: 还没有居中的单元格网格*

现在，通过改变我们的 15x15 网格的大小，我们可以创建任何大小的单元格列表。

#### 调整每个单元格的大小

为了调整单元格的大小，我们可以让 SZ 自动根据窗口的宽度进行调整。目前窗口宽度是 600，所以让我们使用示例 11-6 中的代码来更改 setup()。

*cellular Automata.pyde*

def setup():

global SZ,cellList

size(600,600)

SZ = width // GRID_W + 1

cellList = createCellList()

*示例 11-6: 调整单元格大小以自动适应显示窗口*

双斜杠（//）表示*整数除法*，只返回商的整数部分。现在，当你运行程序时，它应该会生成一个网格，除了中央的一个有颜色的单元格外，其余单元格都是空的，如图 11-5 所示。

![image](img/f231-01.jpg)

*图 11-5: 中心单元格“开启”的网格*

请注意，当你像示例 11-16 中那样将 1 加到 SZ（单元格大小）时，代码会表现得更好，因为否则网格有时不会填满整个显示窗口。但如果你不加这一步也可以。

#### 让细胞自动机生长

现在，我们希望根据每个单元格的邻居状态来改变它们的状态。如果邻居中有状态为“开启”的单元格，就改变当前单元格的状态。这一部分的灵感来自于 Stephen Wolfram 的*《新科学》*中的二维 CA。你可以在图 11-6 中看到这种细胞自动机如何生长。

![image](img/f231-02.jpg)

*图 11-6: 一个细胞自动机的生长阶段*

在这个设计中，如果一个单元格有*一个或四个*邻居是开启的，我们就让它开启（并保持开启）。

#### 将单元格放入矩阵

直接找到列表中紧挨着某个单元格的前后单元格是很容易的，这样我们就可以找到它左右的邻居。但是，如何找到单元格上下的邻居呢？为了更方便地做这个，我们可以将单元格放入一个二维*数组*或*矩阵*中，这就是一个包含行的列表。这样，如果一个单元格在第 5 列，我们就知道它的“上方”和“下方”邻居也会在第 5 列。

在 `Cell` 类中，我们添加了一个名为 `checkNeighbors()` 的方法，使得每个单元格能够计算它有多少个邻居是开启的，如果邻居数是 1 或 4，那么该单元格就会返回 1 表示“开启”。否则，它返回 0 表示“关闭”。我们首先检查上方的邻居：

定义 `checkNeighbors(self)`：

如果 `self.state == 1`：返回 1  # 开启的单元格保持开启

`neighbs = 0`

# 检查上方的邻居

如果 `cellList[self.r-1][self.c].state == 1`：

`neighbs += 1`

这段代码检查 `cellList` 中与当前单元格在同一列（`self.c`）但位于上一行（`self.r - 1`）的项。如果该项的状态属性为 1，那么它是开启的，我们将 `neighbs` 变量增加 1。然后，我们需要对单元格下方的邻居做相同的检查，再检查左右邻居。你看到这里有一个简单的模式吗？

`cellList[self.r - 1][self.c + 0]`  # 上方

`cellList[self.r + 1][self.c + 0]`  # 下方

`cellList[self.r + 0][self.c - 1]`  # 左边

`cellList[self.r + 0][self.c + 1]`  # 右边

我们只需要跟踪行号和列号的变化。我们只需要检查四个方向的邻居，即“左边一个，右边一个”等等：[-1,0]，[1,0]，[0,-1] 和 [0,1]。如果我们将它们称为 `dr` 和 `dc`（*d* 或希腊字母 *delta* 是表示变化的传统数学符号），这样就可以避免重复：

*cellular Automata.pyde*

定义 `checkNeighbors(self)`：

如果 `self.state == 1`：返回 1  # 开启的单元格保持开启

`neighbs = 0`  # 检查邻居

对于 `dr, dc` 在 [[-1,0],[1,0],[0,-1],[0,1]] 中：

如果 `cellList[self.r + dr][self.c + dc].state == 1`：

`neighbs += 1`

如果 `neighbs in [1,4]`：

返回 1

否则：

返回 0

最后，如果邻居计数为 1 或 4，状态属性将设置为 1。在 Python 中，`if neighbs in [1,4]` 等价于 `if neighbs == 1 or neighbs == 4:`。

#### 创建单元格列表

到目前为止，我们通过在 `setup()` 中运行 `createCellList()` 函数并将输出赋值给 `cellList`，已经创建了单元格列表，并且我们遍历了 `cellList` 中的每一行并更新了每个单元格。现在我们需要检查规则是否有效。围绕中心单元格的四个方格应在下一步中改变状态。这意味着我们必须运行 `checkNeighbors()` 方法，然后显示结果。更新你的 `draw()` 函数如下：

定义 `draw()`：

对于 `cellList` 中的每一行：

对于每一行中的 `cell`：

➊ `cell.state = cell.checkNeighbors()`

`cell.display()`

更新后的第 ➊ 行执行所有 `checkNeighbors()` 代码，并根据结果设置单元格的状态为开启或关闭。运行它，你应该会得到以下错误：

IndexError: 索引超出范围：15

错误出现在检查右侧邻居的那一行。果然，由于每行只有 15 个单元格，因此第 15 个单元格右侧没有邻居是合理的。

如果一个单元格右侧没有邻居（即它的列号是 GRID_W 减去 1），显然我们不需要检查那个邻居，可以继续检查下一个单元格。对于检查第 0 行的单元格上方的邻居也是一样，因为它们上方没有单元格。类似地，第 0 列的单元格左侧没有邻居，第 14 行（GRID_H 减去 1）的单元格下方没有单元格。在 Listing 11-7 中，我们向 checkNeighbors() 方法添加了一个有用的 Python 技巧，称为 *异常处理*，它使用了 try 和 except 关键字。

*cellular Automata.pyde*

def checkNeighbors(self, cellList):

如果 self.state == 1: 返回 1 #单元格保持开启

neighbs = 0

#检查邻居

for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:

➊ 尝试:

如果 cellList[self.r + dr][self.c + dc].state == 1:

neighbs += 1

➋ 除了 IndexError：

继续

如果邻居数在 [1, 4] 之间：

返回 1

否则：

返回 0

*Listing 11-7: 向 checkNeighbors() 添加条件判断*

try 关键字 ➊ 字面意思是“尝试运行下一行代码”。在之前的错误信息中，我们遇到了一个 IndexError。我们使用 except 关键字 ➋ 来表示“如果你遇到这个错误，就做这个”。因此，如果我们遇到 IndexError，我们会继续执行下一个循环。运行此代码后，你会看到一些有趣的结果，如 Figure 11-7 所示。这绝对不是我们在 Figure 11-6 中看到的结果。

![image](img/f234-01.jpg)

*Figure 11-7: 不是我们预期的！*

问题在于我们正在检查邻居并更改当前单元格的状态。然后，单元格的邻居开始检查它们的邻居，但它们正在检查新状态的邻居。我们希望所有单元格检查它们的邻居，并将信息保存在一个新的列表中；然后，当所有单元格都完成时，我们可以一次性更新网格。这就需要另一个列表来存储我们的单元格，newList，它将在循环结束时替代 cellList。

所以我们只需要做的是声明 newList 等于 cellList，对吧？

cellList = newList  #?

尽管这似乎是有道理的，Python 并没有将 newList 的内容复制到 cellList 的原内容中，这是你可能预期的行为。它实际上是引用了 newList，但当你更改 newList 时，cellList 也会被更改。

### PYTHON 列表是奇怪的

Python 列表有个奇怪的行为。假设你声明了一个列表并将另一个列表设置为与其相等，然后你更改第一个列表。你不会期望第二个列表也会变化，但实际情况正是如此，正如这里所展示的那样：

>>> a = [1, 2, 3]

>>> b = a

>>> b

[1, 2, 3]

>>> a.append(4)

>>> a

[1, 2, 3, 4]

>>> b

[1, 2, 3, 4]

如你所见，我们创建了列表 a，然后将列表 a 的值赋给了列表 b。当我们更改列表 a 时，如果没有更新列表 b，Python 也会更改列表 b！

#### 列表索引表示法

一种确保我们在更新一个列表时不会不小心更新另一个列表的方法是使用索引表示法。将列表 b 赋值为列表 a 的所有内容应该能避免这种情况：

>>> a = [1,2,3]

>>> b = a[::]

>>> b

[1, 2, 3]

>>> a.append(4)

>>> a

[1, 2, 3, 4]

>>> b

[1, 2, 3]

在这里，我们使用 b = a[::] 来表示“将列表 a 中的所有内容赋值给变量 b”，而不是简单地声明列表 a 等于列表 b。这样，两个列表就不会互相关联。

在我们声明 SZ 后，我们需要添加以下代码行来声明 generation 变量的初始值，它将跟踪我们正在查看的代数：

generation = 0

我们将通过在更新代码的末尾使用索引表示法来避免列表引用问题。让我们在 draw() 后创建一个新的 update() 函数，这样所有的更新就会在那个独立的函数中完成。清单 11-8 显示了你的 setup() 和 draw() 函数应该是什么样子。

*cellular Automata.pyde*

def setup():

global SZ, cellList

size(600,600)

SZ = width // GRID_W + 1

cellList = createCellList()

def draw():

global generation,cellList

cellList = update(cellList)

for row in cellList:

for cell in row:

cell.display()

generation += 1

if generation == 3:

noLoop()

def update(cellList):

newList = []

for r,row in enumerate(cellList):

newList.append([])

for c,cell in enumerate(row):

newList[r].append(Cell(c,r,cell.checkNeighbors()))

return newList[::]

*清单 11-8：检查更新是否正常工作，并在三代后停止*

我们在 setup() 函数中创建第一个 cellList，然后将其声明为全局变量，以便在其他函数中使用。在 draw() 函数中，我们使用 generation 变量来表示我们想检查的代数（在本例中为三代）；然后我们调用 update 函数来更新 cellList。我们像之前一样使用 display() 方法绘制单元格，然后增加代数，并检查是否已达到我们想要的代数。如果达到了，内置的 Processing 函数 noLoop() 将停止循环。

我们使用 noLoop() 来关闭无限循环，因为我们只希望绘制指定数量的代数。如果你将其注释掉，程序将继续运行！图 11-8 显示了元胞自动机在三代后的样子。

![image](img/f236-01.jpg)

*图 11-8：一个正在工作的元胞自动机！*

使用变量来表示网格大小的好处是，我们只需修改 GRID_W 和 GRID_H 变量，就可以大幅度改变元胞自动机，例如：

GRID_W = 41

GRID_H = 41

如果我们将代数增加到 13（在当前读取 if generation == 3 的那行），输出应该像 图 11-9 所示。

![image](img/f237-01.jpg)

*图 11-9：我们的元胞自动机在更高层次上的表现，带有网格（左）和没有网格（右）*

要移除元胞自动机中空单元格周围的网格，只需在 setup() 函数中添加这一行：

noStroke()

这应该会关闭方格的轮廓，但填充颜色仍会显示，就像图 11-9 所示。

到目前为止，我们做了很多工作！我们创建了二维列表，填充了细胞，并根据一个简单的规则开启了某些细胞。然后我们更新了这些细胞并展示出来。CA 就这样不断生长！

练习 11-1：手动生成 CA

使用你在第十章中学到的 keyPressed()函数手动生成 CA。

#### 让你的 CA 自动生长

如果你希望 CA 从第 0 级周期到最大代数（你可以根据窗口选择合适的数值），只需将 draw()函数修改为清单 11-9 中所示的样子。

*cellular Automata.pyde*

def draw():

global generation, cellList

➊ frameRate(10)

cellList = update(cellList)

for row in cellList:

for cell in row:

cell.display()

generation += 1

➋ if generation == 30:

generation = 1

cellList = createCellList()

*清单 11-9：让 CA 自动生长与再生*

为了减慢动画速度，我们使用了 Processing 内建的 frameRate()函数➊。默认速度是每秒 60 帧，所以在这里我们将其减慢到了 10。接着我们告诉程序，如果 generation 变量达到 30 ➋（你可以将这个数字改为其他值），则重置 generation 为 1，并创建一个新的 cellList。现在你应该可以根据需要观察 CA 的生长速度了。改变规则，看看会如何影响 CA。你也可以改变颜色！

我们刚刚写了一个程序，应用一个简单的规则（如果一个细胞有 1 个或 4 个邻居，它是“开启”的），并且一次性对成千上万的细胞进行应用！结果看起来像一个活着的、不断生长的有机体。现在我们将把代码扩展成一个著名的 CA 模型，在这个模型中，虚拟的有机体可以四处移动、成长和死亡！

### 玩生命游戏

在 1970 年《科学美国人》的一期中，数学普及者马丁·加德纳（Martin Gardner）提到了一个奇怪且神奇的游戏，细胞根据它们的邻居数来决定生死。这个游戏是由英国数学家约翰·康威（John Conway）创作的，拥有三条简单的规则：

1.  如果一个活细胞有少于两个活邻居，它会死亡。

1.  如果一个活细胞有超过三个活邻居，它会死亡。

1.  如果一个死细胞有恰好三个活邻居，它会复活。

以这样的简单规则来讲，游戏竟然变得如此复杂。1970 年，大多数人只能使用棋盘上的跳棋来可视化游戏，而且一代的计算可能需要很长时间。幸运的是，我们有计算机，而我们刚刚写的 CA 代码已经包含了用 Python 创建这个游戏所需的大部分代码。保存我们迄今为止编写的 CA 文件，然后另存为不同的名称，如*GameOfLife*。

在这个游戏中，我们的细胞也有对角线邻居。这意味着我们必须在 dr, dc 行中添加四个额外的值。清单 11-10 显示了你需要对 checkNeighbors()代码进行的更改。

*GameOfLife.pyde*

定义 checkNeighbors(self):

neighbs = 0  # 检查邻居

➊ 对于 dr,dc 在 [[-1,-1],[-1,0],[-1,1],[1,0],[1,-1],[1,1],[0,-1],[0,1]] 中：

尝试：

如果 cellList[self.r + dr][self.c + dc].state == 1：

neighbs += 1

除了 IndexError：

继续

➋ 如果 self.state == 1：

如果邻居数在 [2,3] 中：

返回 1

返回 0

如果邻居数为 3：

返回 1

返回 0

*列表 11-10：修改后的 checkNeighbors() 代码以包括对角线邻居*

首先，我们添加四个值 ➊ 来检查对角线邻居：[-1,-1] 为左上邻居，[1,1] 为右下邻居，依此类推。然后我们告诉程序，如果单元格处于 ➋ 状态，检查是否有两个或三个邻居也处于开启状态。如果是这样，我们告诉程序返回 1，否则返回 0。否则，如果单元格关闭，我们告诉它检查是否有三个邻居是开启的。如果有，返回 1；如果没有，返回 0。

然后我们随机地在网格周围放置活跃的单元格，因此我们需要从 Python 的 random 模块导入 choice() 函数。将这行代码添加到程序的顶部：

来自 random 的 choice 函数

然后我们使用 choice() 函数随机选择一个新的单元格是开启还是关闭。所以，我们只需将 createCellList() 函数中的 append 行修改为以下内容：

newList [j].append(Cell(i,j,choice([0,1])))

现在我们不再需要前一个文件中的代代码。draw() 函数中的其余代码如下：

定义 draw():

全局变量 cellList

frameRate(10)

cellList = update(cellList)

对于 cellList 中的每一行：

对于行中的每个单元格：

cell.display()

运行这段代码，你会看到一场充满活力的动态游戏展现出来，生物在其中移动、变形、分裂，并与其他生物互动，正如在图 11-10 中所示。

![image](img/f240-01.jpg)

*图 11-10：生命游戏的实际操作！*

很有趣的是，这些单元格的“云”是如何变形、移动并与其他“云”（家庭？群体？）碰撞的。一些生物在屏幕上游荡，直到最终网格会趋于某种平衡状态。图 11-11 显示了这种平衡的示例。

![image](img/f240-02.jpg)

*图 11-11：进入稳定状态的生命游戏示例*

在这种平衡状态的示例中，一些形状看起来稳定且不动，而其他形状则陷入了重复的模式。

### 初级元胞自动机

最后这个 CA 非常酷，涉及一些更复杂的数学，但它仍然是一个简单的模式，只不过是扩展的，尽管只是扩展到一维（这就是它被称为“初级 CA”的原因）。我们从一行单元格开始，将中间的单元格状态设置为 1，如图 11-12 所示。

![image](img/f241-01.jpg)

*图 11-12：一个初级 CA 的第一行*

这段代码很容易编写。创建一个新的 Processing 草图并命名为*elementaryCA.pyde*。绘制第一行细胞的代码见于 Listing 11-11。

*elementaryCA.pyde*

➊ #CA 变量

w = 50

rows = 1

cols = 11

def setup():

global cells

size(600,600)

#第一行：

➋ cells = []

for r in range(rows):

cells.append([])

for c in range(cols):

cells[r].append(0)

➌ cells[0][cols//2] = 1

def draw():

background(255) #白色

#绘制 CA

for i, cell in enumerate(cells): #行

for j, v in enumerate(cell): #列

➍ if v == 1:

fill(0)

else: fill(255)

➎ rect(j*w-(cols*w-width)/2,w*i,w,w)

*Listing 11-11：绘制基础 CA 的第一行（世代）*

首先，我们声明一些重要的变量 ➊，例如每个细胞的大小以及 CA 中的行数和列数。接下来，我们开始创建 cells 列表 ➋。我们创建行数为 rows 的行，并在每个列表中附加列数为 cols 的 0。我们将行中的中间细胞设置为 1（或开启） ➌。在 draw()函数中，我们使用 enumerate 遍历行（很快会有不止一行！）和列。我们检查元素是否为 1，如果是，就将其涂黑 ➍。否则，我们将其涂白。最后，我们绘制细胞的正方形 ➎。x 值看起来有点复杂，但这只是为了确保 CA 始终居中。

当你运行这段代码时，你应该看到图 11-12 所示的效果：一行细胞，中间有一个“开启”的细胞。CA 中下一行细胞的状态将取决于我们为一个细胞及其两个邻居设置的规则。有多少种可能性？每个细胞有两种可能的状态（1 或 0，或“开启”或“关闭”），所以左邻居有两种状态，中间细胞有两种状态，右邻居也有两种状态。这就是 2 × 2 × 2 = 8 种可能性。所有组合见于图 11-13。

![image](img/f242-01.jpg)

*图 11-13：细胞及其两个邻居的所有可能组合*

第一种可能性是中心细胞开启，且两个邻居都开启。接下来的可能性是中心细胞开启，左邻居开启，右邻居关闭，依此类推。这个顺序非常重要。（你看出规律了吗？）我们怎么将这些可能性描述给计算机程序呢？我们可以写出类似这样的八个条件语句：

if left == 1 and me == 1 and right == 1:

但还有一种更简单的方法。在《*新科学的本质*》中，斯蒂芬·沃尔夫拉姆根据三个细胞所代表的二进制数字给这些可能性分配了数字。记住，1 代表开，0 代表关，你可以看到 111 在二进制中是 7，110 是 6，以此类推，正如图 11-14 所示。

![image](img/f242-02.jpg)

*图 11-14：八种可能性的编号方法*

现在我们已经为每个可能性编号，我们可以创建一个规则集——即一个包含在下一代中如何处理每个可能性的规则的列表。注意，这些数字像列表的索引，只是反向排列。我们可以轻松地解决这个问题。我们可以随机或根据某些计划为每个可能性分配一个结果。图 11-15 展示了一组结果。

![image](img/f242-03.jpg)

*图 11-15：分配给 CA 中每个可能性的结果集*

每个可能性下方的框表示结果，或该细胞在 CA 下一代中的状态。左侧“可能性 7”下方的白色框表示“如果该细胞开启且其两个邻居都开启，它将在下一代中关闭。” 接下来的两个可能性（在我们的 CA 中尚未出现）：结果是“关闭”。如之前在 图 11-12 中所示，我们有许多“关闭”细胞被“关闭”细胞包围，这正是 图 11-14 最右侧所示的可能性：三个白色方块。在这种情况下，中间的细胞将在下一代中关闭。我们还看到一个“开启”的细胞被两个“关闭”的细胞包围（可能性 5）。在下一代中，这个细胞将保持开启。我们将使用 0 和 1 来表示我们的规则集，如 图 11-16 中所示。

![image](img/f243-01.jpg)

*图 11-16：将生成下一行的规则放入列表中*

我们将把所有这些数字收集到一个名为 ruleset 的列表中，并将在 setup() 函数之前添加它：

ruleset = [0,0,0,1,1,1,1,0]

可能性的重要性在于，这组规则被称为“规则 30”（00011110 在二进制中是 30）。我们的任务是根据这些规则创建下一行。让我们创建一个 generate() 函数，它查看第一行并生成第二行，然后查看第二行并生成第三行，以此类推。添加 列表 11-12 中显示的代码。

*elementaryCA.pyde*

#CA 变量

w = 50

➊ rows = 10

cols = 100

--省略--

ruleset = [0,0,0,1,1,1,1,0] #规则 30

➋ def rules(a,b,c):

return ruleset[7 - (4*a + 2*b + c)]

def generate():

for i, row in enumerate(cells): #查看第一行

for j in range(1,len(row)-1):

left = row[j-1]

me = row[j]

right = row[j+1]

if i < len(cells) - 1:

cells[i+1][j] = rules(left,me,right)

return cells

*列表 11-12：编写 generate() 函数来生成 CA 中的新行*

首先，我们通过更新行数和列数 ➊ 来增大 CA 的大小。接下来，我们创建 rules() 函数 ➋，该函数接受三个参数：左邻居的值、当前细胞的值和右邻居的值。该函数检查规则集，并返回下一代中该细胞的值。我们利用二进制数字，行 4*a + 2*b + c 将“1,1,1”转换为 7，将“1,1,0”转换为 6，依此类推。然而，正如你从图 11-15 中回忆起的那样，索引的顺序是反的，所以我们从 7 中减去总值，以获得规则集中的正确索引。

在 setup() 函数的末尾添加以下代码：

cells = generate()

这将生成完整的 CA，而不仅仅是第一行。当你运行这段代码时，你应该能看到使用“规则 30”生成的 CA 的前 10 行，如图 11-17 所示。

![image](img/f244-01.jpg)

*图 11-17：规则 30 的前 10 行*

![image](img/f244-02.jpg)

*图 11-18：更多的规则 30*

程序正在逐行生成，从上到下，并根据我们在规则集中提供的规则生成下一行。如果我们继续进行呢？将行数和列数更改为 1000，将每个细胞的宽度（w）更改为 3。将 noStroke() 添加到 setup() 函数中以去掉细胞的轮廓，然后运行草图。你应该看到图 11-18 中的内容。

规则 30 是一个非常有趣的设计，因为它既不完全是随机的，也不完全是规则的。规则 73 也很酷；事实上，一位名叫 Fabienne Serriere 的女性将这个规则编程到一台编织机上，创造出带有这种图案的围巾，正如在图 11-19 所示。你可以从 *[`knityak.com/`](https://knityak.com/)* 订购带有这种以及其他算法生成规则的围巾。

![image](img/f245-01.jpg)

*图 11-19：一条围巾，图案为细胞自动机：规则 73！*

练习 11-2：更改规则集

将规则集更改为数字 90 的二进制形式。生成的 CA 看起来怎么样？提示：它是一个分形。

练习 11-3：放大和缩小

使用你在第十章中学到的 keyPressed() 函数，通过上下箭头键来改变变量 w 的值。这应该能让你在 CA 中进行放大和缩小！

### 小结

在这一章中，你学习了如何使用 Python 创建细胞自动机，或者说是根据特定规则独立行动的细胞。我们编写程序，使这些细胞形成一个巨大的网格，遵循特定规则并自我更新，一代又一代，我们创造了出乎意料的美丽图案和惊人地像生命一样的行为。

在下一章中，我们将创建能够为我们解决问题的虚拟生物！这些生物将能够通过不断进化更好的解决方案来猜测一个秘密短语，并找到通过一堆城市的最短路线。
