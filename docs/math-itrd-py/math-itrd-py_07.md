## 5

用几何学变换形状

*有一天，在茶馆里，纳斯鲁丁宣布他要卖掉自己的房子。当其他顾客问他如何描述房子时，他拿出了一个砖块。“它只是这些的集合。”——伊德里斯·沙阿*

![image](../images/fintro-01.jpg)

在几何课上，你学到的所有内容都涉及通过形状来表示空间中的维度。通常你会从一维的线条和二维的圆、方形或三角形开始，然后转向三维物体，如球体和立方体。现在，借助技术和免费的软件，创建几何形状变得简单，但操控和改变这些形状可能会更具挑战性。

在本章中，你将学习如何使用Processing图形包操作和变换几何形状。你将从基本形状如圆形和三角形开始，这将为你在后续章节中处理更复杂的形状如分形和细胞自动机奠定基础。你还将学会如何将一些看似复杂的设计分解为简单的组件。

### 绘制一个圆

我们从一个简单的二维圆开始。在Processing中打开一个新草图并保存为*geometry.pyde*。然后输入[Listing 5-1](ch05.xhtml#ch05list1)中的代码，在屏幕上绘制一个圆。

*geometry.pyde*

def setup():

size(600,600)

def draw():

ellipse(200,100,20,20)

*Listing 5-1: 绘制一个圆*

在绘制形状之前，我们首先定义草图本的大小，也就是*坐标平面*。在这个例子中，我们使用size()函数来表示我们的网格将是600像素宽，600像素高。

在设置好坐标平面后，我们使用绘图函数ellipse()在平面上创建一个圆。前两个参数200和100表示圆心的位置。这里，200是x坐标，第二个数字100是圆心的y坐标，将圆心定位在平面上的(200,100)。

最后两个参数决定了形状的宽度和高度，以像素为单位。在这个例子中，形状的宽度和高度都是20像素。因为这两个参数相同，意味着圆周上的点到圆心的距离是相等的，从而形成了一个完美的圆形。

点击**运行**按钮（它看起来像一个播放符号），一个带有小圆的新窗口应该会打开，就像在[图 5-1](ch05.xhtml#ch05fig1)中一样。

![image](../images/f078-01.jpg)

*图 5-1: [Listing 5-1](ch05.xhtml#ch05list1) 显示的小圆的输出*

Processing提供了多个可以用来绘制形状的函数。请查看完整列表：[*https://processing.org/reference/*](https://processing.org/reference/)，探索其他形状函数。

现在你已经知道如何在Processing中绘制圆形，接下来，你几乎准备好利用这些简单的形状来创建动态的、交互式的图形了。为了做到这一点，你首先需要了解位置和变换。我们先从位置开始。

### 使用坐标指定位置

在[代码清单 5-1](ch05.xhtml#ch05list1)中，我们使用ellipse()函数的前两个参数指定了圆形在网格上的位置。同样，每个我们使用 Processing 创建的形状也需要一个位置，我们通过坐标系统指定，在该系统中，图上的每个点由两个数字表示：(x,y)。在传统的数学图形中，原点（即x=0且y=0的位置）位于图形的中心，如[图 5-2](ch05.xhtml#ch05fig2)所示。

![image](../images/f079-01.jpg)

*图 5-2：传统坐标系，原点位于中心*

然而，在计算机图形学中，坐标系稍有不同。它的原点位于屏幕的左上角，因此 x 和 y 分别在向右和向下移动时增加，正如在[图 5-3](ch05.xhtml#ch05fig3)中所示。

![image](../images/f079-02.jpg)

*图 5-3：计算机图形学的坐标系统，原点位于左上角*

该平面上的每个坐标表示屏幕上的一个像素。如你所见，这意味着你无需处理负坐标。我们将使用函数在这个坐标系统中变换和移动越来越复杂的形状。

绘制一个单一的圆形相当简单，但绘制多个形状则很快变得复杂。例如，想象一下绘制如[图 5-4](ch05.xhtml#ch05fig4)所示的设计。

![image](../images/f080-01.jpg)

*图 5-4：由圆形构成的圆*

指定每个圆形的大小和位置，并将它们均匀地间隔开来，将涉及输入许多相似的代码行。幸运的是，你其实不需要知道每个圆形的绝对 x 和 y 坐标就可以做到这一点。使用 Processing，你可以轻松地将物体放置在网格上的任意位置。

让我们用一个简单的例子来看看如何开始做这个。

### 变换函数

你可能还记得在几何课上用铅笔和纸做过变换，你需要对一组点进行操作，费力地移动一个形状。让计算机来进行变换则有趣得多。事实上，没有变换，就不会有任何值得一看的计算机图形！像平移和旋转这样的几何变换让你在不改变物体本身的情况下，改变物体的出现位置和方式。例如，你可以使用变换将三角形移动到不同的位置，或者旋转它而不改变其形状。Processing 提供了许多内建的变换函数，方便你平移和旋转物体。

#### 使用TRANSLATE()平移对象

*平移*意味着在网格上移动一个形状，使形状的所有点都沿相同方向和相同距离移动。换句话说，平移让你在不改变形状本身，也不倾斜形状的情况下，移动形状。

在数学课上，平移一个物体需要手动更改物体中所有点的坐标。但在 Processing 中，你通过移动 *网格* 本身来平移物体，而物体的坐标保持不变！为了演示这一点，让我们在屏幕上放一个矩形。请根据 [列表 5-2](ch05.xhtml#ch05list2) 中的代码修改你现有的 *geometry.pyde* 代码。

*geometry.pyde*

def setup():

size(600,600)

def draw():

rect(20,40,50,30)

*列表 5-2：绘制一个矩形以进行平移*

这里，我们使用 rect() 函数来绘制矩形。前两个参数是 x 和 y 坐标，告诉 Processing 矩形的左上角应该在哪里。第三个和第四个参数分别表示矩形的宽度和高度。

运行此代码，你应该看到 [图 5-5](ch05.xhtml#ch05fig5) 中显示的矩形。

![image](../images/f081-01.jpg)

*图 5-5：原点位于左上角的默认坐标设置*

**注意**

在这些示例中，我显示了网格以供参考，但你在屏幕上是看不到它的。

现在，让我们告诉 Processing 使用 [列表 5-3](ch05.xhtml#ch05list3) 中的代码来平移矩形。注意，我们并没有改变矩形的坐标。

*geometry.pyde*

def setup():

size(600,600)

def draw():

translate(50,80);

rect(50,100,100,60)

*列表 5-3：平移矩形*

在这里，我们使用 translate() 来移动矩形。我们提供两个参数：第一个告诉 Processing 网格水平（x）方向上应该移动多少距离，第二个参数表示网格在垂直（y）方向上应该移动的距离。所以 translate(50,80) 应该将整个网格向右移动 50 像素并向下移动 80 像素，如 [图 5-6](ch05.xhtml#ch05fig6) 所示。

![image](../images/f082-01.jpg)

*图 5-6：通过将网格右移 50 像素并向下移动 80 像素来平移矩形*

很多时候，将原点（0,0）放在画布中心是很有用的（而且更简单！）。你可以使用 translate() 函数轻松地将原点移动到网格的中心。你也可以用它来改变画布的宽度和高度，如果你希望它更大或更小的话。接下来，我们来探索 Processing 内置的宽度和高度变量，它们可以让你在不手动更改数值的情况下更新画布的大小。为了看到效果，更新 [列表 5-3](ch05.xhtml#ch05list3) 中的现有代码，使其看起来像 [列表 5-4](ch05.xhtml#ch05list4)。

*geometry.pyde*

def setup():

size(600,600)

def draw():

translate(width/2, height/2)

rect(50,100,100,60)

*列表 5-4：使用宽度和高度变量来平移矩形*

在setup()函数中的size声明里输入的任何数字都会变成画布的“宽度”和“高度”。在这个例子中，因为我使用了size(600,600)，它们都是600像素。当我们将translate()这一行更改为translate(width/2, height/2)，使用变量而不是具体数字时，我们告诉Processing将位置(0,0)移到显示窗口的中心，不管窗口大小如何。这意味着如果你改变窗口的大小，Processing会自动更新宽度和高度，你就不需要去修改所有代码中的数字了。

运行更新后的代码，你应该能看到类似于[图 5-7](ch05.xhtml#ch05fig7)的效果。

![image](../images/f083-01.jpg)

*图 5-7：网格被平移到屏幕中央*。

注意，原点仍然标记为(0,0)，这表明我们实际上并没有移动原点，而是移动了整个坐标平面，使得原点位于画布的中央。

#### 使用ROTATE()旋转物体

在几何学中，*旋转*是一种变换，它将物体围绕一个中心点旋转，就像绕轴旋转一样。Processing中的rotate()函数会绕原点(0,0)旋转网格。它接受一个数字作为参数，指定你希望围绕点(0,0)旋转的角度。旋转角度的单位是弧度，你可以在预备数学课程中学习到这一点。我们可以使用2π（约为6.28）弧度来完成一次旋转，而不是使用360度。如果你像我一样习惯使用度数，可以使用radians()函数轻松地将度数转换为弧度，这样你就不必自己做数学计算了。

要查看rotate()函数是如何工作的，将[图 5-8](ch05.xhtml#ch05fig8)中显示的代码输入到现有的草图中，通过用这些示例替换draw()函数中的translate()代码，然后运行它们。[图 5-8](ch05.xhtml#ch05fig8)展示了结果。

![image](../images/f084-01.jpg)

*图 5-8：网格总是围绕(0,0)旋转*

在[图 5-8](ch05.xhtml#ch05fig8)的左侧，网格围绕(0,0)旋转了20度，而(0,0)位于屏幕的左上角。在右侧的示例中，原点首先被平移到右边200个单位并向下平移200个单位，*然后*网格才开始旋转。

rotate()函数使得绘制像[图 5-4](ch05.xhtml#ch05fig4)中的物体圆圈变得简单，可以按照以下步骤进行：

1.  平移到你想要设置圆心的位置。

1.  旋转网格并将物体放置在圆的周长上。

现在你已经知道了如何使用变换函数来操作画布上不同物体的位置，接下来让我们在Processing中重新创建[图 5-4](ch05.xhtml#ch05fig4)。

#### 绘制一个圆形的圆圈

为了创建[图 5-4](ch05.xhtml#ch05fig4)中排列成圆形的圆圈，我们将使用 for i in range() 循环来重复绘制圆形，并确保圆形均匀间隔。首先，让我们思考圆形之间的角度间隔应该是多少，以完成一个完整的圆，记住圆的总角度是 360 度。

输入[列表 5-5](ch05.xhtml#ch05list5)中显示的代码来创建这个设计。

*geometry.pyde*

def setup():

size(600,600)

def draw():

translate(width/2,height/2)

for i in range(12):

ellipse(200,0,50,50)

rotate(radians(360/12))

*列表 5-5：绘制圆形设计*

请注意，draw() 函数中的 translate(width/2,height/2) 将网格平移到屏幕中心。接下来，我们启动一个 for 循环，在网格上的某个点创建一个椭圆，从 (200,0) 开始，如函数的前两个参数所示。然后，我们通过设置椭圆的宽度和高度都为 50 来设定每个小圆的大小。最后，我们在创建下一个椭圆之前将网格旋转 360/12 或 30 度。请注意，我们在 rotate() 函数中使用 radians() 将 30 度转换为弧度。这意味着每个圆形与下一个圆形的角度间隔为 30 度。

当你运行这个代码时，你应该能看到[图 5-9](ch05.xhtml#ch05fig9)中显示的内容。

![image](../images/f085-01.jpg)

*图 5-9：使用变换创建圆形设计*

我们已经成功地将一堆圆形排列成了一个圆形！

#### 绘制方形圆圈

修改你在[列表 5-5](ch05.xhtml#ch05list5)中写的程序，将圆形改为方形。要做到这一点，只需将现有代码中的 ellipse 改为 rect，将圆形变成方形，如下所示：

*geometry.pyde*

def setup():

size(600,600)

def draw():

translate(width/2,height/2)

for i in range(12):

rect(200,0,50,50)

rotate(radians(360/12))

很简单！

### 动画对象

Processing 非常适合用来为你的对象创建动画，以制作动态图形。在你的第一个动画中，你将使用 rotate() 函数。通常，rotate() 发生得非常迅速，因此你不会看到旋转过程——只会看到旋转后的结果。但这次，我们将使用时间变量 t，允许我们实时看到旋转的展开过程！

#### 创建 t 变量

让我们用方形圆圈来写一个动画程序。首先，创建 t 变量，并将其初始化为 0，方法是在 setup() 函数之前添加 t = 0。然后，在 for 循环之前插入[列表 5-6](ch05.xhtml#ch05list6)中的代码。

*geometry.pyde*

t = 0

def setup():

size(600,600)

def draw():

translate(width/2,height/2)

rotate(radians(t))

for i in range(12):

rect(200,0,50,50)

rotate(radians(360/12))

*列表 5-6：添加 t 变量*

然而，如果你尝试运行这个代码，你会收到以下错误信息：

UnboundLocalError: 本地变量 't' 在赋值前被引用

这是因为 Python 不知道我们是否在函数内部创建了一个与全局变量 t 无关的局部变量 t，还是仅仅在调用全局变量 t。因为我们想使用全局变量，所以在 draw() 函数的开始处添加 global t，这样程序就知道我们指的是哪个变量。

输入完整的代码如下：

*geometry.pyde*

t = 0

def setup():

size(600,600)

def draw():

global t

#将背景设置为白色

background(255)

translate(width/2,height/2)

rotate(radians(t))

for i in range(12):

rect(200,0,50,50)

rotate(radians(360/12))

t += 1

这段代码将 t 初始化为 0，将网格旋转指定角度，t 增加 1，然后重复此过程。运行它，你应该会看到方块开始以圆形的模式旋转，正如[图 5-10](ch05.xhtml#ch05fig10)所示。

![image](../images/f087-01.jpg)

*图 5-10：让方块围绕圆形旋转*

太酷了！现在让我们尝试让每个单独的方块旋转。

#### 旋转单个方块

因为在 Processing 中旋转是围绕 (0,0) 进行的，所以在循环内我们首先需要将位置平移到每个方块应在的位置，然后进行旋转，最后绘制方块。请将代码中的循环修改为类似于[列表 5-7](ch05.xhtml#ch05list7)的样子。

*geometry.pyde*

for i in range(12):

translate(200,0)

rotate(radians(t))

rect(0,0,50,50)

rotate(radians(360/12))

*列表 5-7：旋转每个方块*

这将把网格平移到方块的位置，旋转网格使得方块旋转，然后使用 rect() 函数绘制方块。

#### 使用 PUSHMATRIX() 和 POPMATRIX() 保存方向

当你运行[列表 5-7](ch05.xhtml#ch05list7)时，你应该会看到它产生了一些奇怪的行为。方块不是围绕中心旋转，而是持续在屏幕上移动，正如[图 5-11](ch05.xhtml#ch05fig11)所示。

![image](../images/f088-01.jpg)

*图 5-11：方块飞得四处乱飘！*

这是因为改变了中心和网格的方向。将方块的位置平移后，我们需要旋转回圆心，再平移到下一个方块的位置。我们本可以使用另一个 translate() 函数来撤销第一个平移，但可能还需要撤销更多的变换，这样会变得比较混乱。幸运的是，有一种更简单的方法。

Processing 有两个内置函数，pushMatrix() 和 popMatrix()，它们可以保存当前网格的方向，并且在之后恢复到该方向。在这里，我们希望在屏幕中心保存方向。为了做到这一点，请修改循环，使其看起来像[列表 5-8](ch05.xhtml#ch05list8)一样。

*geometry.pyde*

for i in range(12):

pushMatrix() #保存当前方向

translate(200,0)

rotate(radians(t))

rect(0,0,50,50)

popMatrix() #返回到保存的方向

rotate(radians(360/12))

*列表 5-8：使用 pushMatrix() 和 popMatrix()*

pushMatrix()函数保存了方格圆圈中心的坐标系位置。然后我们将坐标系统转换到方格位置，旋转网格使方格旋转，然后绘制方格。接着，我们使用popMatrix()立刻返回到方格圆圈的中心，并对所有12个方格重复此过程。

#### 绕中心旋转

上述代码应该可以完美运行，但旋转可能看起来有些奇怪；这是因为Processing默认将矩形定位在其左上角，并围绕左上角进行旋转。这使得方格看起来似乎偏离了大圆的路径。如果你希望方格绕其中心旋转，可以在setup()函数中添加以下这行代码：

rectMode(CENTER)

请注意，rectMode()中的全大写的CENTER很重要。（你还可以尝试其他类型的rectMode()，例如CORNER、CORNERS和RADIUS。）添加rectMode(CENTER)应该使每个方格绕其中心旋转。如果你希望方格旋转得更快，可以修改rotate()行，增加t中的时间，如下所示：

rotate(radians(5*t))

这里，5是旋转的频率。这意味着程序将t的值乘以5并根据乘积进行旋转。因此，方格将比之前旋转五倍远。试着修改它，看看会发生什么！将rotate()行注释掉（在行前加一个井号），让方格在原地旋转，如[Listing 5-9](ch05.xhtml#ch05list9)所示。

translate(width/2,height/2)

#rotate(radians(t))

for i in range(12):

rect(200,0,50,50)

*Listing 5-9: 注释掉一行代码而不是删除它*

能够使用变换函数如translate()和rotate()来创建动态图形是一项非常强大的技巧，但如果操作顺序不对，可能会产生意想不到的结果！

### 创建互动彩虹网格

现在你已经学会了如何使用循环创建设计并以不同的方式旋转它们，我们将创造一些非常酷的东西：一个方格网格，其彩虹色会随着你的鼠标光标移动！第一步是制作一个网格。

#### 绘制对象网格

许多数学任务和像扫雷这样的游戏创建任务都需要一个网格。网格对于一些模型以及我们在后续章节中将要创建的所有元胞自动机来说都是必需的，因此学习如何编写代码来创建一个可重复使用的网格是很值得的。首先，我们将制作一个12 × 12的方格网格，大小均匀且间隔一致。制作如此大小的网格可能看起来是一个耗时的任务，但实际上使用循环就能轻松完成。

打开一个新的Processing草图并保存为*colorGrid.pyde*。真可惜我们之前已经用了“grid”这个名字。我们将在白色背景上制作一个20 × 20的方格网格。这些方格需要是矩形，并且我们需要在一个for循环内再嵌套一个for循环，确保它们的大小相同且间隔均匀。此外，我们需要让每个25 × 25像素的方格按每30像素绘制一次，使用如下代码：

rect(30*x,30*y,25,25)

当 x 和 y 变量增加 1 时，方块将在两个维度上以 50 像素的间隔绘制。我们将像往常一样，从编写 setup() 和 draw() 函数开始，就像之前的草图（参见 [列表 5-10](ch05.xhtml#ch05list10)）中一样。

*colorGrid.pyde*

def setup():

size(600,600)

def draw():

#设置背景为白色

background(255)

*列表 5-10：Processing 草图的标准结构：setup() 和 draw()*

这设置了窗口的大小为 600 × 600 像素，并将背景颜色设置为白色。接下来，我们将创建一个嵌套循环，其中两个变量都将从 0 到 19， 总共 20 个数字，因为我们想要 20 行 20 个方块。[列表 5-11](ch05.xhtml#ch05list11) 显示了创建网格的代码。

def setup():

size(600,600)

def draw():

#设置背景为白色

background(255)

for x in range(20):

for y in range(20):

rect(30*x,30*y,25,25)

*列表 5-11：网格的代码*

这应该会创建一个 20 × 20 的方块网格，正如你在 [图 5-12](ch05.xhtml#ch05fig12) 中看到的那样。现在是时候为我们的网格添加一些颜色了。

![图片](../images/f091-01.jpg)

*图 5-12：一个 20 × 20 的网格！*

#### 向物体添加彩虹色

Processing 的 colorMode() 函数帮助我们为草图添加一些酷炫的颜色！它用于在 RGB 和 HSB 模式之间切换。回想一下，RGB 使用三个数字表示红色、绿色和蓝色的数量。在 HSB 模式中，三个数字表示色相、饱和度和亮度的级别。我们这里唯一需要改变的是第一个数字，即色相。其他两个数字可以使用最大值 255。[图 5-13](ch05.xhtml#ch05fig13) 显示了如何仅通过改变第一个值——色相来制作彩虹色。在这里，10 个方块的色相值如图所示，饱和度为 255，亮度为 255。

![图片](../images/f091-02.jpg)

*图 5-13：使用 HSB 模式并改变色相值绘制彩虹色*

由于我们在 [列表 5-11](ch05.xhtml#ch05list11) 中将矩形定位在 (30*x,30*y) 处，我们将创建一个变量来测量鼠标与该位置的距离：

d = dist(30*x,30*y,mouseX,mouseY)

Processing 有一个 dist() 函数，可以计算两点之间的距离，在这种情况下，它是方块和鼠标之间的距离。它将距离保存到一个名为 d 的变量中，我们将色相与该变量关联。[列表 5-12](ch05.xhtml#ch05list12) 显示了代码的更改。

*colorGrid.pyde*

def setup():

size(600,600)

rectMode(CENTER)

➊ colorMode(HSB)

def draw():

#设置背景为黑色

➋ background(0)

translate(20,20)

for x in range(30):

for y in range(30):

➌ d = dist(30*x,30*y,mouseX,mouseY)

fill(0.5*d,255,255)

rect(30*x,30*y,25,25)

*列表 5-12：使用 dist() 函数*

我们插入 colorMode() 函数并将 HSB 传递给它 ➊。在 draw() 函数中，我们首先将背景设置为黑色 ➋。然后，我们计算鼠标与位于 (30*x,30*y) 的方块之间的距离 ➌。接下来的一行，我们使用 HSB 数值设置填充颜色。色调值是距离的一半，而饱和度和亮度的数值都为 255，即最大值。

颜色的色调是我们唯一改变的部分：我们根据矩形与鼠标的距离更新色调。我们通过 dist() 函数来实现，这个函数有四个参数：两个点的 x 和 y 坐标。它返回这两个点之间的距离。

运行这段代码，你应该会看到一个非常多彩的设计，它会根据鼠标的位置改变颜色，如[图 5-14](ch05.xhtml#ch05fig14)所示。

现在你已经学会如何为对象添加颜色，接下来让我们探索如何创建更复杂的形状。

![image](../images/f092-01.jpg)

*图 5-14：为你的网格添加颜色*

### 使用三角形绘制复杂图案

![image](../images/f093-01.jpg)

*图 5-15：由罗杰·安顿森（Roger Antonsen）绘制的90个旋转的等边三角形草图。可以在* [https://rantonse.no/en/art/2016-11-30](https://rantonse.no/en/art/2016-11-30) *查看动画。*

在本节中，我们将使用三角形创建更复杂的、类似圆规图案的设计。例如，看看由奥斯陆大学的罗杰·安顿森（Roger Antonsen）制作的旋转三角形草图，见[图 5-15](ch05.xhtml#ch05fig15)。

原始设计会动，但在这本书里你得想象所有三角形都在旋转。这幅草图让我震撼！虽然这个设计看起来很复杂，但制作起来并不难。还记得章节开头纳斯鲁丁关于砖块的笑话吗？就像纳斯鲁丁的房子一样，这个复杂的设计其实就是一堆相同形状的集合。但是什么形状呢？安顿森在命名这幅草图为“90个旋转的等边三角形”时给了我们一个有用的线索。这告诉我们，我们所要做的就是弄清楚如何绘制一个等边三角形，旋转它，然后重复这个过程，直到有90个三角形。首先，让我们讨论如何使用 triangle() 函数绘制等边三角形。首先，打开一个新的 Processing 草图并命名为 *triangles.pyde*。[列表 5-13](ch05.xhtml#ch05list13) 中的代码展示了创建一个旋转的三角形的其中一种方法，但它不是等边三角形。

*triangles.pyde*

def setup():

size(600,600)

rectMode(CENTER)

t = 0

def draw():

global t

translate(width/2,height/2)

rotate(radians(t))

triangle(0,0,100,100,200,-200)

t += 0.5

*列表 5-13：绘制旋转三角形，但不是正确的类型*

列表 5-13 使用了你之前学到的知识：它创建了一个 t 变量（用于时间），将坐标平移到我们想要放置三角形的位置，旋转网格，然后绘制三角形。最后，它递增 t。当你运行这段代码时，你应该会看到类似于[图 5-16](ch05.xhtml#ch05fig16)的效果。

![image](../images/f094-01.jpg)

*图 5-16：围绕一个顶点旋转三角形*

正如你在[图 5-16](ch05.xhtml#ch05fig16)中看到的，三角形围绕其一个*顶点*，或点旋转，从而形成一个以外部点为圆周的圆。你还会注意到，这是一个直角三角形（包含 90 度角的三角形），而不是等边三角形。

为了重新创建 Antonsen 的草图，我们需要绘制一个等边三角形，它是一个各边相等的三角形。我们还需要找到等边三角形的中心，以便围绕其中心旋转它。为此，我们需要找到三角形三个顶点的位置。让我们讨论如何通过确定其中心并指定顶点位置来绘制等边三角形。

#### 一个 30-60-90 三角形

![image](../images/f094-02.jpg)

*图 5-17：将等边三角形分成三等份*

为了找到我们等边三角形三个顶点的位置，我们将回顾一种你在几何课上可能见过的特定类型的三角形：*30-60-90 三角形*，这是一种特殊的*直角三角形*。首先，我们需要一个等边三角形，如[图 5-17](ch05.xhtml#ch05fig17)所示。

这个等边三角形由三等分组成。中间的点是三角形的中心，三条分割线在 120 度角处相交。为了在 Processing 中绘制三角形，我们给 triangle() 函数传入六个数字：三个顶点的 x 和 y 坐标。为了找到[图 5-17](ch05.xhtml#ch05fig17)中所示等边三角形的顶点坐标，我们将底部三角形对半分割，如[图 5-18](ch05.xhtml#ch05fig18)所示。

![image](../images/f095-01.jpg)

*图 5-18：将等边三角形分割成特殊的三角形*

将底部三角形对半分割，得到两个直角三角形，这些是经典的 30-60-90 三角形。你可能还记得，30-60-90 三角形各边的比率可以如[图 5-19](ch05.xhtml#ch05fig19)所示表示。

![image](../images/f095-02.jpg)

*图 5-19：30-60-90 三角形中各边的比率，来自 SAT 测试中的图例*

如果我们将较小的直角边长度称为 *x*，则斜边的长度是该长度的两倍，或者 2*x*，而较长的直角边是 *x* 乘以 3 的平方根，大约是 1.732*x*。我们将使用从[图 5-18](ch05.xhtml#ch05fig18)中大等边三角形的中心到其一个顶点的长度来创建我们的函数，这个顶点恰好是 30-60-90 三角形的斜边。意味着我们可以用这个长度来测量所有内容。例如，如果我们将斜边长度称为 `length`，那么较小的直角边将是该长度的一半，或者 `length/2`。最后，较长的直角边将是 `length` 除以 2 乘以 3 的平方根。[图 5-20](ch05.xhtml#ch05fig20)对 30-60-90 三角形进行了放大展示。

![image](../images/f095-03.jpg)

*图 5-20：近距离查看 30-60-90 三角形*

如你所见，30-60-90三角形的内部角度为30度、60度和90度，并且其边长具有已知比例。你可能熟悉这个比例，它与勾股定理有关，稍后我们会再次用到它。

我们将从大等边三角形的中心到其顶点的距离称为“长度”，它也是30-60-90三角形的*斜边*。你需要知道这个特殊三角形各边长度之间的比例，才能找到等边三角形相对于中心的三个顶点——你可以通过指定三角形的每个点的位置来绘制它（我们要绘制的大等边三角形）。

这个直角三角形中，30度角对面的短腿总是斜边的一半，长腿则是短腿长度乘以3的平方根。因此，如果我们使用中心点来绘制大等边三角形，则三个顶点的坐标将如[图 5-21](ch05.xhtml#ch05fig21)所示。

![image](../images/f096-01.jpg)

*图 5-21：等边三角形的顶点*

如你所见，由于这个三角形由所有边上的30-60-90三角形组成，我们可以利用它们之间的特殊关系来计算等边三角形每个顶点与原点之间的距离。

#### 绘制等边三角形

现在，我们可以利用从30-60-90三角形中推导出的顶点来绘制等边三角形，使用[清单 5-14](ch05.xhtml#ch05list14)中的代码。

*triangles.pyde*

def setup():

size(600,600)

rectMode(CENTER)

t = 0

def draw():

global t

translate(width/2,height/2)

rotate(radians(t))

tri(200) #绘制等边三角形

t += 0.5

➊ def tri(length):

'''绘制等边三角形

绕三角形的中心旋转'''

➋ triangle(0,-length,

-length*sqrt(3)/2, length/2,

length*sqrt(3)/2, length/2)

*清单 5-14：绘制旋转等边三角形的完整代码*

首先，我们编写tri()函数，接受变量length ➊，这个值是我们将等边三角形分割成的特殊30-60-90三角形的斜边。然后，我们使用找到的三个顶点绘制一个三角形。在调用triangle()函数 ➋ 时，我们指定三角形三个顶点的位置： (0,-length)、(-length*sqrt(3)/2, length/2) 和 (length*sqrt(3)/2, length/2)。

当你运行代码时，你应该看到类似于[图 5-22](ch05.xhtml#ch05fig22)的内容。

![image](../images/f097-01.jpg)

*图 5-22：旋转的等边三角形！*

现在，我们可以通过在draw()函数的开始处添加这一行来遮盖掉所有在旋转过程中创建的三角形：

background(255) #白色背景

这应该会擦除所有旋转的三角形，除了一个，所以屏幕上只会显示一个等边三角形。我们所要做的，就是像本章前面一样，将90个等边三角形放置在一个圆形中，使用rotate()函数。

练习 5-1：旋转周期

在Processing草图中创建一个等边三角形的圆，并使用rotate()函数旋转它们。

#### 绘制多个旋转的三角形

现在你已经学会了如何旋转单个等边三角形，我们需要找出如何将多个等边三角形排列成一个圆形。这与旋转方形时的做法类似，但这次我们将使用我们的tri()函数。在Processing中将[代码清单 5-15](ch05.xhtml#ch05list15)的代码替换为def draw()部分，然后运行它。

*triangles.pyde*

def setup():

size(600,600)

rectMode(CENTER)

t = 0

def draw():

global t

background(255)#白色

translate(width/2,height/2)

➊ for i in range(90):

#将三角形均匀分布

#在圆周上

rotate(radians(360/90))

➋ pushMatrix() #保存此方向

#移至圆周上的位置

translate(200,0)

#旋转每个三角形

rotate(radians(t))

#绘制三角形

tri(100)

#返回到保存的方向

➌ popMatrix()

t += 0.5

def tri(length):

➍ noFill() #使三角形透明

triangle(0,-length,

-length*sqrt(3)/2, length/2,

length*sqrt(3)/2, length/2)

*代码清单 5-15：创建90个旋转的三角形*

在➊处，我们使用for循环将90个三角形均匀地排列在圆周上，确保它们通过将360除以90来保持均匀间隔。然后在➋处，我们使用pushMatrix()保存当前位置，再移动网格。在循环的最后，在➌处使用popMatrix()返回到保存的位置。在tri()函数的➍处，我们添加了noFill()语句来使三角形透明。

现在我们有90个旋转的透明三角形，但它们的旋转方式完全相同。这看起来很酷，但还没有达到Antonsen草图的效果。接下来，你将学习如何让每个三角形相对于相邻的三角形略微不同地旋转，从而使图案更加有趣。

#### 相位偏移旋转

我们可以通过*相位偏移*改变三角形的旋转模式，这使得每个三角形稍微滞后于它的邻居，给草图带来“波浪”或“级联”的效果。每个三角形在循环中都有一个编号，表示为i。我们需要在rotate(radians(t))函数中将i加到t上，如下所示：

rotate(radians(t+i))

当你运行此代码时，你应该会看到类似于[图 5-23](ch05.xhtml#ch05fig23)的效果。

![image](../images/f099-01.jpg)

*图 5-23：带相位偏移的旋转三角形*

注意，在屏幕的右侧有一个图案中断。这个中断是由于从第一个三角形到最后一个三角形的相位偏移没有对齐造成的。我们希望图案无缝连接，因此我们必须让相位偏移的总和是360度的倍数，从而完成一个圆圈。因为设计中有90个三角形，所以我们将360除以90，然后再乘以i：

rotate(radians(t+i*360/90))

计算360/90很简单，结果是4，然后用这个数字代入代码中，但我还是保留了这个表达式，因为如果以后我们想改变三角形的数量时，我们会用到它。现在，这应该会创建一个像[图5-24](ch05.xhtml#ch05fig24)所示的无缝图案。

![image](../images/f100-01.jpg)

*图5-24：带相位偏移的无缝旋转三角形*

通过使我们的相位偏移量加起来成为360的倍数，我们能够去除图案中的断裂。

#### 完成设计

为了使设计看起来更像[图5-15](ch05.xhtml#ch05fig15)中的设计，我们需要稍微调整相位偏移量。自己动手试试，看看你能如何改变草图的外观！

在这里，我们将通过将i乘以2来改变相位偏移量，这将增加每个三角形与其相邻三角形之间的偏移量。将代码中的rotate()行更改为以下内容：

rotate(radians(t+2*i*360/90))

在做出这个更改后，运行代码。正如你在[图5-25](ch05.xhtml#ch05fig25)中看到的，我们的设计现在看起来非常接近我们想要重建的设计。

![image](../images/f101-01.jpg)

*图5-25：重建Antonsen的“90度旋转等边三角形”来自[图5-15](ch05.xhtml#ch05fig15)*

现在你已经学会了如何重建像这样的复杂设计，试试下一个练习，来测试你的变换技巧吧！

练习 5-2：彩虹三角形

使用stroke()为旋转三角形草图中的每个三角形着色。它应该看起来像这样。

![image](../images/f101-02.jpg)

### 总结

在本章中，你学习了如何绘制圆形、正方形和三角形等形状，并使用Processing内置的变换函数将它们排列成不同的图案。你还学习了如何通过动画化图形和添加颜色使你的形状变得动态。就像Nasrudin的房子只是砖块的集合一样，本章中的复杂代码示例也只是由更简单的形状或函数组成。

在下一章，你将基于本章所学，扩展技能，学习使用三角函数，如正弦和余弦。你将绘制更酷的设计，并编写新的函数，创造出更复杂的行为，例如留下轨迹，并从一堆顶点创建任何形状。
