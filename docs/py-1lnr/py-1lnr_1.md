## **1

PYTHON 复习**

![图片](img/comm-1.jpg)

本章的目的是刷新你对基本 Python 数据结构、关键字、控制流操作及其他基础知识的记忆。我写这本书是为了帮助中级 Python 程序员提升到更高的编程水平。要达到专家级别，你需要彻底学习基础知识。

理解基础知识让你能够退一步看整体——这是无论你想成为谷歌的技术负责人、计算机科学教授，还是成为一名优秀的程序员，都会用到的重要技能。例如，计算机科学教授通常对自己领域的基础知识有非常深刻的理解，这让他们能够从第一原理出发进行论证，并发现研究的空白，而不是被最新的最先进技术所迷惑。本章介绍了最重要的 Python 基础知识，它们为本书后续更高级的主题奠定了基础。

### **基本数据结构**

对数据结构的透彻理解是你作为程序员可以获得的最基本技能之一。无论你是创建机器学习项目、处理大型代码库、搭建和管理网站，还是编写算法，它都能为你提供帮助。

#### ***数值数据类型和结构***

两种最重要的数值数据类型是整数和浮点数。*整数*是没有小数点的正数或负数（例如，3）。*浮点数*是带有浮动小数精度的正数或负数（例如，3.14159265359）。Python 提供了多种内置的数值运算功能，并且可以在这些数值数据类型之间进行转换。请仔细研究列表 1-1 中的示例，以掌握这些非常重要的数值运算。

```py
## Arithmetic Operations

x, y = 3, 2

print(x + y) # = 5

print(x - y) # = 1

print(x * y) # = 6

print(x / y) # = 1.5

print(x // y) # = 1

print(x % y) # = 1

print(-x) # = -3

print(abs(-x)) # = 3

print(int(3.9)) # = 3

print(float(x)) # = 3.0

print(x ** y) # = 9
```

*列表 1-1：数值数据类型*

大多数运算符是显而易见的。请注意，`//`运算符执行整数除法，结果是一个向下取整的整数值（例如，`3 // 2 == 1`）。

#### ***布尔值***

类型为*布尔型*的变量只能取两个值——`False`或`True`。

在 Python 中，布尔类型和整数类型密切相关：布尔类型在内部使用整数值（默认情况下，布尔值`False`由整数`0`表示，布尔值`True`由整数`1`表示）。列表 1-2 给出了这两个布尔关键字的示例。

```py
x = 1 > 2

print(x)

# False

y = 2 > 1

print(y)

# True
```

*列表 1-2：布尔值`False`和`True`*

在评估给定的表达式后，变量`x`表示布尔值`False`，变量`y`表示布尔值`True`。

你可以在 Python 中使用布尔值与三个重要的关键字组合，创建更复杂的表达式。

##### **关键字：and，or，not**

布尔表达式表示基本的逻辑运算符。通过将它们与以下三个关键字结合使用，你可以构造多种可能复杂的表达式：

**`and`** 表达式 `x and y` 会在 `x` 为 `True` *且* `y` 为 `True` 时评估为 `True`。如果其中任何一个为 `False`，整个表达式也会变成 `False`。

**`or`** 表达式 `x or y` 会在 `x` 为 `True` *或者* `y` 为 `True`（或者两者都为 `True`）时评估为 `True`。如果其中任何一个为 `True`，整个表达式也会变成 `True`。

**`not`** 表达式 `not x` 如果 `x` 为 `False` 时评估为 `True`，否则评估为 `False`。

考虑 清单 1-3 中的 Python 代码。

```py
x, y = True, False

print((x or y) == True)

# True

print((x and y) == False)

# True

print((not y) == True)

# True
```

*清单 1-3: 关键字 `and`、`or` 和 `not`*

通过使用这三个关键词，你可以表达所有你需要的逻辑表达式。

##### **布尔运算符优先级**

布尔运算符的应用顺序是理解布尔逻辑的一个重要方面。例如，考虑自然语言中的语句 `"下雨且天气寒冷或刮风"`。我们可以用两种方式来解释这个表达式：

**`"(下雨且天气寒冷)或刮风"`** 在这种情况下，如果是刮风的话，语句会被评估为`True`——即使没有下雨。

**`并且 "下雨且(天气寒冷或刮风)"`** 然而，在这种情况下，如果没有下雨，无论天气是否寒冷或刮风，语句会被评估为`False`。

布尔运算符的顺序很重要。这个语句的正确解释应该是第一个，因为 `and` 运算符优先级高于 `or` 运算符。让我们看一下 清单 1-4 中的代码片段。

```py
## 1\. Boolean Operations

x, y = True, False

print(x and not y)

# True

print(not x and y or x)

# True

## 2\. If condition evaluates to False

if None or 0 or 0.0 or '' or [] or {} or set():

    print("Dead code") # Not reached
```

*清单 1-4: 布尔数据类型*

这段代码展示了两个重要的观点。首先，布尔运算符按优先级排序——`not` 运算符具有最高优先级，其次是 `and` 运算符，然后是 `or` 运算符。其次，以下值会自动评估为 `False`：关键字 `None`、整数值 `0`、浮点值 `0.0`、空字符串或空容器类型。

#### ***字符串***

Python *字符串* 是字符的序列。字符串是不可变的，因此在创建后不能修改。虽然还有其他方式来创建字符串，但以下是五种最常用的方法：

**单引号** `'Yes'`

**双引号** `"Yes"`

**三引号用于多行字符串** `'''Yes'''` 或 `"""Yes"""`

**字符串方法** `str(5) == '5'` 结果为 `True`

**连接** `'Py' + 'thon'` 变成 `'Python'`

经常，你会显式地在字符串中使用 *空白字符*。最常用的空白字符包括换行符 `\n`、空格符 `\s` 和制表符 `\t`。

清单 1-5 展示了最重要的字符串方法。

```py
## Most Important String Methods

y = "    This is lazy\t\n   "

print(y.strip())

# Remove Whitespace: 'This is lazy'

print("DrDre".lower())

# Lowercase: 'drdre'

print("attention".upper())

# Uppercase: 'ATTENTION'

print("smartphone".startswith("smart"))

# Matches the string's prefix against the argument: True

print("smartphone".endswith("phone"))

# Matches the string's suffix against the argument: True

print("another".find("other"))

# Match index: 2

print("cheat".replace("ch", "m"))

# Replaces all occurrences of the first by the second argument: meat

print(','.join(["F", "B", "I"]))

# Glues together all elements in the list using the separator string: F,B,I

print(len("Rumpelstiltskin"))

# String length: 15

print("ear" in "earth")

# Contains: True
```

*清单 1-5: 字符串数据类型*

这个非详尽的字符串方法列表展示了字符串数据类型的强大，你可以通过 Python 内建功能解决许多常见的字符串问题。如果对如何处理字符串问题有疑问，可以查阅在线参考文档，列出了所有内建的字符串方法：[*https://docs.python.org/3/library/string.html#module-string*](https://docs.python.org/3/library/string.html#module-string)。

布尔值、整数、浮点数和字符串是 Python 中最重要的基本数据类型。但通常，你需要*构建*数据项，而不仅仅是创建它们。在这些情况下，容器类型是答案。但是在我们深入容器数据结构之前，先快速了解一个重要的特殊数据类型：`None`。

#### ***关键字 None***

关键字 `None` 是 Python 常量，表示*没有值*。其他编程语言，如 Java，使用 `null` 值来代替。然而，`null` 这个术语常常让初学者感到困惑，他们误以为它等同于整数值 `0`。实际上，Python 使用关键字 `None`，如列表 1-6 所示，用来表明它与任何数字值、空列表或空字符串不同。一个有趣的事实是，`None` 是 `NoneType` 数据类型中唯一的值。

```py
def f():

   x = 2

# The keyword 'is' will be introduced next

print(f() is None)

# True

print("" == None)

# False

print(0 == None)

# False
```

*列表 1-6：使用关键字 `None`*

这段代码展示了几个 `None` 数据值的示例（以及它不代表的东西）。如果你没有为一个函数定义返回值，默认返回值就是 `None`。

### **容器数据结构**

Python 提供了*容器数据类型*，这些数据类型能够高效地处理复杂操作，同时易于使用。

#### ***列表***

*列表*是一种容器数据类型，用于存储一系列元素。与字符串不同，列表是*可变*的——你可以在运行时修改它们。我可以通过一系列示例来最好地描述列表数据类型：

```py
l = [1, 2, 2]

print(len(l))

# 3
```

这段代码展示了如何使用方括号创建一个列表，并如何用三个整数元素填充它。你还可以看到列表可以包含重复元素。`len()` 函数返回列表中的元素数量。

##### **关键字：is**

关键字 `is` 简单地检查两个变量是否引用了内存中的同一个对象。这可能会让 Python 新手感到困惑。列表 1-7 检查两个整数和两个列表是否引用了内存中的同一个对象。

```py
y = x = 3

print(x is y)

# True

print([3] is [3])

# False
```

*列表 1-7：使用关键字 `is`*

如果你创建了两个列表——即使它们包含相同的元素——它们仍然引用内存中两个不同的列表对象。修改其中一个列表对象不会影响另一个列表对象。我们说列表是 *可变的*，因为你可以在创建后修改它们。因此，如果你检查两个列表是否引用内存中的同一个对象，结果会是 `False`。然而，整数值是 *不可变的*，因此不存在一个变量改变对象后会意外地更改所有其他变量的风险。原因在于，你不能改变整数对象 `3`——尝试这么做只会创建一个新的整数对象，而不会修改旧的对象。

##### **添加元素**

Python 提供了三种常见方式来向现有列表添加元素：*append*、*insert* 或 *list concatenation*。

```py
# 1\. Append

l = [1, 2, 2]

l.append(4)

print(l)

# [1, 2, 2, 4]

# 2\. Insert

l = [1, 2, 4]

l.insert(2, 3)

print(l)

# [1, 2, 3, 4]

# 3\. List Concatenation

print([1, 2, 2] + [4])

# [1, 2, 2, 4]
```

所有这三种操作都会生成相同的列表 `[1, 2, 2, 4]`。但是，*append* 操作是最快的，因为它不需要遍历列表来将元素插入到正确的位置（如 *insert* 操作），也不需要从两个子列表创建一个新的列表（如 *list concatenation* 操作）。大致来说，只有当你希望将元素添加到列表中的某个特定位置（而不是最后一个位置）时，才会使用 *insert* 操作。而你会使用 *list concatenation* 操作来连接两个任意长度的列表。请注意，第四种方法 `extend()`，可以高效地将多个元素添加到给定的列表中。

##### **移除元素**

你可以通过使用 `list` 方法 `remove(`*`x`*`)` 来轻松地从列表中移除元素 *`x`*：

```py
l = [1, 2, 2, 4]

l.remove(1)

print(l)

# [2, 2, 4]
```

该方法作用于列表对象本身，而不是创建一个新列表来保存变更。在之前的代码示例中，我们创建了一个名为 `l` 的列表对象，并通过删除元素修改了该对象在内存中的内容。这通过减少冗余的列表数据副本来节省内存开销。

##### **反转列表**

你可以通过使用方法 `list.reverse()` 来反转列表元素的顺序：

```py
l = [1, 2, 2, 4]

l.reverse()

print(l)

# [4, 2, 2, 1]
```

反转列表也会修改原始的列表对象，而不仅仅是创建一个新的列表对象。

##### **排序列表**

你可以通过使用方法 `list.sort()` 来对列表元素进行排序：

```py
l = [2, 1, 4, 2]

l.sort()

print(l)

# [1, 2, 2, 4]
```

同样，排序列表会修改原始的列表对象。结果列表是按升序排序的。包含字符串对象的列表将按升序字典顺序排序（从 `'a'` 到 `'z'`）。通常，排序函数假设两个对象可以进行比较。大致来说，如果你能够计算出 `a > b`，对于任何数据类型的对象 `a` 和 `b`，Python 也可以对列表 `[a, b]` 进行排序。

##### **索引列表元素**

你可以通过使用方法 `list.index(`*`x`*`)` 来查找指定列表元素 *`x`* 的索引：

```py
print([2, 2, 4].index(2))

# 0

print([2, 2, 4].index(2,1))

# 1
```

方法 `index(`*`x`*`)` 查找列表中元素 *`x`* 的第一次出现并返回其索引。像其他主要编程语言一样，Python 将索引 0 分配给第一个序列，索引 *i*–1 分配给第 *i* 个序列。

#### ***栈***

*栈* 数据结构直观地作为一种先进先出（FIFO）的结构工作。可以把它想象成一堆文件：每次新增一张纸时，你会把它放在旧文件堆的最上面，而在处理堆中的文件时，你会一直取出最上面的一张。栈依然是计算机科学中的一种基本数据结构，广泛用于操作系统管理、算法、语法解析和回溯。

Python 列表可以直观地用作栈，通过列表操作 `append()` 向栈中添加元素，通过 `pop()` 删除最近添加的元素：

```py
stack = [3]

stack.append(42) # [3, 42]

stack.pop() # 42 (stack: [3])

stack.pop() # 3 (stack: [])
```

由于列表实现的效率，通常不需要导入外部的栈库。

#### ***集合***

*集合* 数据结构是 Python 以及许多其他编程语言中的一种基础集合数据类型。对于分布式计算的流行语言（例如 MapReduce 或 Apache Spark）来说，它们几乎专注于集合操作作为编程原语。那么，集合到底是什么呢？集合是一个无序的唯一元素集合。我们将这个定义分解为它的几个主要部分。

##### **集合**

集合是一个包含元素的集合，类似于列表或元组。集合中的元素可以是原始元素（整数、浮动数、字符串），也可以是复杂元素（对象、元组）。然而，集合中的所有数据类型必须是 *可哈希的*，这意味着它们有一个与之相关联的哈希值。对象的哈希值永远不会改变，它用于将该对象与其他对象进行比较。我们来看一下 清单 1-8 中的一个例子，它通过检查字符串的哈希值来创建一个由三个字符串组成的集合。你尝试创建一个由列表组成的集合，但由于列表不可哈希，操作失败。

```py
hero = "Harry"

guide = "Dumbledore"

enemy = "Lord V."

print(hash(hero))

# 6175908009919104006

print(hash(guide))

# -5197671124693729851

## Can we create a set of strings?

characters = {hero, guide, enemy}

print(characters)

# {'Lord V.', 'Dumbledore', 'Harry'}

## Can we create a set of lists?

team_1 = [hero, guide]

team_2 = [enemy]

teams = {team_1, team_2}

# TypeError: unhashable type: 'list'
```

*清单 1-8：集合数据类型只允许可哈希元素。*

你可以创建一个字符串集合，因为字符串是 *可哈希的*。但是你不能创建一个由列表组成的集合，因为列表是 *不可哈希的*。原因在于哈希值依赖于项的内容，而列表是 *可变的*；如果你更改列表数据类型，那么哈希值也必须发生变化。由于可变数据类型不可哈希，所以你不能在集合中使用它们。

##### **无序**

与列表不同，集合中的元素没有固定的顺序。无论你以什么顺序将元素放入集合，你永远无法确定集合存储这些元素的顺序。以下是一个例子：

```py
characters = {hero, guide, enemy}

print(characters)

# {'Lord V.', 'Dumbledore', 'Harry'}
```

我先放入英雄，但我的解释器却先打印敌人（显然，Python 解释器站在黑暗面）。请注意，你的解释器可能会以另一种顺序打印集合中的元素。

##### **唯一**

集合中的所有元素必须是唯一的。严格来说，集合中任意两个值 `x, y`，满足 `x!=y` 时，它们的哈希值也应该不同，即 `hash(x)!=hash(y)`。因为集合中的每两个元素 `x` 和 `y` 都是不同的，所以你不能创造一支哈利·波特的克隆军队去对抗伏地魔。

```py
clone_army = {hero, hero, hero, hero, hero, enemy}

print(clone_army)

# {'Lord V.', 'Harry'}
```

无论你多少次将相同的值放入同一个集合，集合只会存储该值的一个实例。原因在于这些值的哈希值相同，集合每个哈希值最多只能包含一个元素。普通集合数据结构的扩展是*多重集合数据结构*，它可以存储相同值的多个实例。然而，它在实际应用中很少被使用。相比之下，几乎在任何非平凡的代码项目中，你都会使用集合——例如，将一组顾客与一组访问过商店的人员进行交集运算，这将返回一个新的包含同时访问过商店的顾客的集合。

#### ***字典***

*字典*是一个用于存储`(`*键, 值*`)`对的有用数据结构：

```py
calories = {'apple' : 52, 'banana' : 89, 'choco' : 546}
```

你可以通过在方括号内指定键来读取和写入元素：

```py
print(calories['apple'] < calories['choco'])

# True

calories['cappu'] = 74

print(calories['banana'] < calories['cappu'])

# False
```

使用`keys()`和`values()`函数访问字典的所有键和值：

```py
print('apple' in calories.keys())

# True

print(52 in calories.values())

# True
```

使用`items()`方法访问字典的`(`*键, 值*`)`对：

```py
for k, v in calories.items():

    print(k) if v > 500 else None

# 'choco'
```

这样，你就可以轻松地遍历字典中的所有键和值，而无需单独访问它们。

#### ***成员资格***

使用关键字`in`来检查集合、列表或字典中是否包含某个元素（参见列表 1-9）。

```py
➊ print(42 in [2, 39, 42]) 

  # True

➋ print("21" in {"2", "39", "42"}) 

  # False

  print("list" in {"list" : [1, 2, 3], "set" : {1,2,3}})

  # True
```

*列表 1-9：使用关键字`in`*

你可以使用关键字`in`来测试整数值`42` ➊ 是否存在于整数值列表中，或者测试字符串值`"21"`是否存在于字符串集合中 ➋。我们说*x*是*y*的*成员*，如果元素*x*出现在集合*y*中。

检查集合成员比检查列表成员要快：要检查元素*x*是否出现在列表*y*中，你需要遍历整个列表，直到找到*x*或者检查完所有元素。然而，集合的实现方式类似于字典：要检查元素*x*是否出现在集合*y*中，Python 会在内部执行一次操作`y`[`hash(x)`]，并检查返回值是否不为`None`。

#### ***列表和集合推导式***

*列表推导式*是 Python 中的一个流行特性，帮助你快速创建和修改列表。其简单公式是`[` *`表达式`* `+` *`上下文`* `]`：

**表达式** 告诉 Python 如何处理列表中的每个元素。

**上下文** 告诉 Python 应该选择列表中的哪些元素。上下文由任意数量的`for`和`if`语句组成。

例如，在列表推导式语句`[x for x in range(3)]`中，第一部分`x`是（标识）表达式，第二部分`for x in range(3)`是上下文。该语句创建了列表`[0, 1, 2]`。`range()`函数返回 0、1 和 2 这三个连续的整数值——当使用一个参数时，如示例中所示。另一个列表推导式的代码示例如下：

```py
# (name, $-income)

customers = [("John", 240000),

             ("Alice", 120000),

             ("Ann", 1100000),

             ("Zach", 44000)]

# your high-value customers earning >$1M

whales = [x for x,y in customers if y>1000000]

print(whales)

# ['Ann']
```

集合推导式类似于列表推导式，但创建的是一个集合而不是列表。

### **控制流**

*控制流*功能让你可以在代码中做出决策。算法常常被比作烹饪食谱，它们由一系列顺序的命令组成：把水倒进锅里，加入盐，加入米，倒掉水，最后把米盛出来。如果没有*条件执行*，这些命令的执行将仅需几秒钟，米饭也肯定不会做好。例如，你可能会先加入水、盐和米，然后立即把水倒掉，而不等水变热、米变软。

你需要根据不同的情况做出不同的反应：只有*当*水已经热了，你才需要把米放进锅里；只有*当*米已经煮软了，你才需要把水从锅里倒掉。几乎不可能用一种方式编写程序，预见现实世界中发生的所有确定性事件。相反，你需要编写能够在满足不同条件时作出不同响应的程序。

#### ***if、else 和 elif***

关键字`if`、`else`和`elif`（见列表 1-10）使你能够对不同的代码分支进行条件执行。

```py
➊ x = int(input("your value: ")) 

➋ if x > 3: 

      print("Big")

➌ elif x == 3: 

      print("Medium")

➍ else: 

      print("Small")
```

*列表 1-10：使用关键字`if`、`else`和`elif`*

这段代码首先获取用户输入，将其转换为整数，并存储在变量`x`中➊。然后测试变量的值是否大于➋、等于➌，或者小于➍值`3`。换句话说，代码以差异化的方式响应现实世界中的*不可预测*输入。

#### ***循环***

为了允许代码片段的重复执行，Python 使用两种类型的循环：`for`循环和`while`循环。通过使用这些循环，你可以轻松地编写一个仅由两行代码组成的程序，且能永远执行下去。否则，这种重复执行会变得很困难（另一个方法是*递归*）。

在列表 1-11 中，你可以看到这两种循环变体的实际应用。

```py
# For loop declaration

for i in [0, 1, 2]:

   print(i)

'''

0

1

2

'''

# While loop - same semantics

j = 0

while j < 3:

   print(j)

   j = j + 1

'''

0

1

2

'''
```

*列表 1-11：使用关键字`for`和`while`*

两种循环变体都会将整数`0`、`1`和`2`打印到终端，但以两种不同的方式完成任务。

`for`循环声明了一个循环变量`i`，它会依次取列表`[0, 1, 2]`中的所有值。循环会一直执行，直到值用尽。

`while`循环会在满足特定条件时执行循环体——在我们的例子中，当`j < 3`时。

终止循环有两种基本方式：你可以定义一个最终评估为`False`的循环条件，或者在循环体的特定位置使用关键字`break`。列表 1-12 展示了后一种方式的示例。

```py
while True:

   break # no infinite loop

print("hello world")

# hello world
```

*列表 1-12：使用关键字`break`*

你创建了一个`while`循环，其循环条件总是评估为`True`。所以乍一看，它似乎会一直运行下去。无限`while`循环是常见做法，例如在开发 web 服务器时，服务器会重复执行以下过程：等待新的网页请求并提供服务。然而，在某些情况下，你仍然希望提前终止循环。在 web 服务器的例子中，当服务器检测到正在受到攻击时，你会停止提供文件以确保安全。在这些情况下，你可以使用关键字`break`来停止循环并立即执行后续代码。在 Listing 1-12 中，循环提前结束后，代码执行`print("hello world")`。

还可以强制 Python 解释器跳过循环中的某些区域，而不提前结束循环。例如，你可能希望跳过恶意的网页请求，而不是完全停止服务器。你可以通过使用`continue`语句来实现这一点，它会结束当前的循环迭代并将执行流返回到循环条件（参见 Listing 1-13）。

```py
while True:

  continue

  print("43") # dead code
```

*Listing 1-13: 使用关键字`continue`*

这段代码会一直执行，但从未执行过`print`语句。原因是`continue`语句结束当前的循环迭代并将其带回到开始，所以执行从未到达`print`语句。永远不会执行的代码被称为*死代码*。因此，`continue`语句（以及`break`语句）通常在某些条件下，通过使用条件 if-else 语句来使用。

### **函数**

*函数*帮助你在需要时重用代码片段：只需编写一次，但可以多次使用它们。你可以使用关键字`def`定义一个函数，接着是函数名称和一组参数来定制函数体的执行。用两组参数调用函数可以极大地改变函数的结果。例如，你可以定义函数`square(`*`x`*`)`，它返回输入参数*`x`*的平方值。调用`square(10)`的结果是*10 × 10 = 100*，而调用`square(100)`的结果是*100 × 100 = 10,000*。

关键字`return`终止函数并将执行流传递给调用该函数的地方。你还可以在`return`关键字后提供一个可选值，以指定函数的返回结果（参见 Listing 1-14）。

```py
def appreciate(x, percentage):

   return x + x * percentage / 100

print(appreciate(10000, 5))

# 10500.0
```

*Listing 1-14: 使用关键字`return`*

你创建了一个函数`appreciate()`，它计算给定投资在指定回报率下的增值情况。在代码中，你计算了当假设利率为 5%时，$10,000 的投资在一年内增值了多少。结果是$10,500。你使用了关键字`return`来指定函数的返回值应该是原始投资和该投资的名义利息之和。函数`appreciate()`的返回值类型为 float。

### **Lambda 表达式**

你可以使用关键字 `lambda` 来定义 Python 中的 lambda 函数。*Lambda 函数* 是匿名函数，它们没有在命名空间中定义。简单来说，lambda 函数就是没有名称的函数，通常用于单次使用。其语法如下：

```py
lambda <arguments> : <return expression>
```

一个 lambda 函数可以有一个或多个参数，用逗号分隔。在冒号（`:`）之后，你定义了返回表达式，该表达式可以（也可以不）使用已定义的参数。返回表达式可以是任何表达式，甚至是另一个函数。

Lambda 函数在 Python 中扮演着重要角色。在实际的代码项目中，你会经常看到它们：例如，用来简化代码或创建各种 Python 函数的参数（如 `map()` 或 `reduce()`）。请看 示例 1-15 中的代码。

```py
print((lambda x: x + 3)(3))

# 6
```

*示例 1-15：使用关键字 `lambda`*

首先，你创建了一个 lambda 函数，它接受一个值 `x` 并返回表达式 `x + 3` 的结果。返回的结果是一个函数对象，可以像其他函数一样被调用。由于其语义的原因，你将这个函数称为 *增量函数*。当用参数 `x=3` 调用这个增量函数时——即 示例 1-15 中 print 语句后的后缀 `(3)`——结果是整数值 `6`。本书大量使用 lambda 函数，因此请确保你正确理解它们（尽管你也将有机会进一步提升对 lambda 函数的直观理解）。

### **总结**

本章为你提供了一个简洁的 Python 快速入门课程，以刷新你对基础 Python 知识的掌握。你学习了最重要的 Python 数据结构，以及如何在代码示例中使用它们。你学会了如何通过使用 if-elif-else 语句以及 `while` 和 `for` 循环来控制程序的执行流程。你复习了 Python 中的基本数据类型——布尔型、整数、浮点型和字符串，并了解了哪些内建操作和函数是常用的。大多数实际代码片段和复杂算法都围绕着更强大的容器类型构建，如列表、栈、集合和字典。通过学习给定的示例，你学会了如何添加、删除、插入和重新排序元素。你还了解了成员操作符和列表推导式：这是一个高效且强大的内建方法，用于在 Python 中以编程方式创建列表。最后，你学会了函数的定义方法（包括匿名的 lambda 函数）。现在，你已经准备好学习 Python 中的前 10 个基础单行代码。
